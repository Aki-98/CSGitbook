# 第一部分 奠定基础

前期准备

- 构建成本可以占到项目成本的65%

- 准备工作不充分的原因：程序员无法抗拒开始编码的冲动/领导催促尽快开始编码

- 前期准备的方向：逻辑、类比、数据

- 如果需求被污染，需求会污染架构，架构又会污染构建

定义开发方式：

- 序列式：预先确定约80%的需求，为以后再确定的额外需求预留时间，然后采用系统化的变更空值，以确保随着项目的进展只接受最有价值的新需求
- 迭代：预先确定最重要的20%需求，并计划以小的增量了开发软件的其他部分。

软件开发过程

- 问题定义
- 需求开发
- 构建规划
- 软件架构
- 概要设计
- 详细设计
- 编码与调试
- 单元测试 
- 集成测试
- 集成
- 系统测试
- 修复性维护

架构元素

- 程序组织结构
- 主要的类
- 数据表设计
- 业务规则
- 用户界面设计
- 资源管理
- 安全性
- 性能
- 可伸缩性
- 互操作性
- 国际化(I18n)/本地化(L10n)
- 输入/输出
- 错误处理
- 容错性
- 架构可行性
- 健壮性（架构考虑的系统要比需求期望的更见状，因为在软件中，链条的强度不是取决于最薄弱的一环，而是等于所有薄弱环节的乘积）
- 处理变更的策略（数据库版本、接口版本）

# 第二部分 高质量的代码

## 第5章 软件构建的设计

**理想的设计特征**

- 最小化的复杂性
- 易于维护
- 松散耦合
- 可扩展性
- 可重用性
- 高扇入：很多类在使用一个特定的类
- 低到中等扇出：一个特定的类使用了低于七个其他类
- 移植性
- 精简性
- 层次性

**程序的设计层级**

- 第一层：软件系统
- 第二层：分解为子系统或包
  - 常见子系统
    - 业务规则
    - 用户界面
    - 数据库访问
    - 系统依赖项
- 第三层：分解为类
- 第四层：分解为子程序
- 第五层：子程序的内部设计

**对对象的设计步骤**

- 确定对象及其属性（方法和数据） 
- 确定可以对每个对象做什么 
- 确定每个对象允许对其他对象做什么
- 确定每个对象的哪些部分对其他对象可见 哪些部分公共，哪些私有 
- 定义每个对象的公共接口

**识别容易变动的区域并将其隔离**

- 业务规则
- 硬件依赖性
- 输入和输出
- 困难的设计和构建区域
- 状态变量

**耦合的标准（理解耦合、保持松散耦合)**

- 规模（模块之间连接的数量），越小越好
  - 子程序的参数数量
  - 类中公共方法的数量
  - ...
- 可见性（模块之间的连接有多显著），越显著越好
  - 比起修改全局变量让程序使用，通过该程序的参数列表，传递数据的可见性更好
    - 全局变量法 int A ; foo(){A=... }
    - 参数法：foo(int para=A){para=...}
    - 全局变量法 int A ; sender(){A=...receiver() # use A}
    - 参数法：sender(){receiver(para=A)}
- 灵活性（多容易改变模块之间的连接），越容易越好 p97

**危险的语义耦合**

- Module1向 Module2 传递一个控制标志，告诉 Module2 要做什 这种方法要求 Modulel 知道 Module2 的内部工作方式，即 Module2 会用控制标志做什么。如果 Module2 为控制标志定义 个特定的数据类型（枚举类型或对象），那么这种用法或 许可行 
- Module2 使用被 Module1 修改之后的全局数据 这种方法要求 Module2 假设 Module1 是按 Module2 需要的方式修改数据，而 Module1 是在正确的时间调用 
- Module1 的接口规定，其 Module1.Initialize()程序 应在 Module1.Routine()之前调用. Module2 知道 Module1.Routine() 无论如何都会调用 Module1.Initialize(），所以它直接实例化 Module1 并调用 Module1.Routine(), 而没有先调用 Module1. Initialize(）
- Module1将 Object 传递给 Module2 由于 Modulel 知道Module2只使用了Object的7个方法中的三个，所以只对Object进行了部分初始化（使用这三个方法需要特定数据）
- Module1将 BaseObject 传给 Module2。 由于 Module2 知道 Module1 真正传给它的是 DerivedObject, 所以将 BaseObject 型为 DerivedObject, 并调用 DerivedObject 特有的方法。

## 第6章 可以工作的类

良好的抽象

- 每个类都只实现一个抽象数据类型(ADT)

- 提供成对的或相反的操作

- 如果类的一半子程序操作一半数据，另一半子程序操作另一半数据，则应该拆成两个类

- 尽可能使接口可编程而不是表达语义

  - 表达语义的接口

    ```java
    class DeviceManager {
        // 语义化的接口，直接提供 "开启 Wi-Fi" 功能
        void enableWifi() { 
            // 内部逻辑
        }
        
        // 语义化的接口，直接提供 "关闭 Wi-Fi" 功能
        void disableWifi() { 
            // 内部逻辑
        }
    }
    ```

  - 可编程的接口

    ```java
    class DeviceManager {
        void setWifiState(boolean enabled) { 
            // 通过参数控制 Wi-Fi 状态
        }
    }
    ```

- 最小化类的成员和可访问性

- 不要公开成员数据

- 避免将私有实现细节放到类的接口中

- 不要对接口的使用方式做出任何预设

- 避免友元类

  - 友元类（Friend Class）是 C++ 中的一种特殊机制，它允许一个类访问另一个类中被声明为私有（private）或受保护（protected）的成员。

- 倾向于读代码方便而不是写代码方便

- 警惕在语义上破坏封装

  - 不调用类A的InitializeOperations()子程序，因为你知道类A的PerformFirstOperation()子程序会自动调用它
  - 调用employee.Retrieve(database)之前不调用database.Connect()子程序，因为你知道employee.Retrieve()函数会在没有建立连接的前提下自动连接数据库
  - 不调用类A的Terminate()子程序，因为你知道类A的PerformFinalOperation()子程序已经调用过它了
  - 即使在ObjectA离开作用域后，也使用由ObjectA创建的到ObjectB的指针或引用，因为你知道ObjectA将ObjectB放在静态存储中，ObjectB依然有效
  - 使用类B的MAXIMUM_ELEMENTS常量，而不是使用ClassA.MAXIMUM_ELEMENTS，因为你知道它们都等于同一个值

良好的继承

- 除非万不得已，不要通过私有继承实现包含关系
- 警惕数据成员超过7个的类
- 如果派生类不打算完全遵守基类所定义的相同接口契约，继承就不是正确的实现技术
- 如果一个类不是为了继承而设计的，就应该定义成final
- （里氏替换原则）子类必须能通过基类的接口使用，使用者无需知道两者的差异
- 确保只继承想要继承的东西
- 不要在派生类中重用不可覆盖的基类子程序名称
- 将通用接口、数据和行为移到继承树中尽可能高的位置，但不要破坏高处对象的抽象性
- 如果一个类仅有一个实例，考虑是否直接创建一个对象，而不是要引入一个不同的类
- 如果一个基类仅有一个派生类，考虑基类的设计是否必要
- 避免继承后去除子程序的行为
  - 比如基类为Cat，子程序为Scratch()，如果有的Cat不能Scratch()，此时不应该继承Cat并重写Scratch()使其不做任何事，应该重写Cat基类，将子程序Scratch()改为一个Claw的数据成员。
- 避免过深的继承树，大多数人在大脑中很难处理超出两到三层的继承关系



选择继承的策略：

- 有共同的数据但没有共同的行为，不选择继承，选择使用同一个数据对象
- 有共同的行为，选择继承
- 由基类控制接口，选择继承
- 由子类控制接口，不选择继承，选择包含



良好的成员函数和数据

- 减少类中子程序的数量
- 减少类调用子程序的数量
- 减少对其他类的间接子程序调用
- 尽量减少一个类与其他类的协作程度



良好的构造函数

- 尽可能在所有构造函数中初始化所有成员数据
- 使用private构造函数强制类只能实例化一个对象（单例）
- 除非论证可行，使用深拷贝而不是浅拷贝
  - 深拷贝：数据成员逐一拷贝
  - 浅拷贝：只拷贝引用（指针）



创建类的理由

- 建模现实世界中的对象
- 建模抽象对象
- 降低复杂性
- 隔离复杂性
- 隐藏实现细节
- 限制变化造成的影响
- 隐藏全局数据
- 简化参数传递
- 建立中心控制点
- 使代码更容易重用
- 为程序家族做计划
- 打包相关操作
- 实现特定重构



需要避免的类：

- 避免创建万能类
- 消除无关的类
- 避免以动词命名的类

## 第7章 高质量的子程序

**1.创建子程序的原则**

创建子程序的正当理由：

- 降低复杂性
- 引入一个中间的、易于理解的抽象概念
- 避免重复代码
- 支持子类化
- 隐藏处理顺序
- <u>隐藏指针操作</u>
- 提高可移植性
- <u>简化复杂的布尔表达式</u>
- <u>提高性能：将对代码的优化集中到子程序中</u>

此外，许多创建类的理由也是创建子程序的理由

- 隔离复杂性
- 隐藏实现细节
- 限制变更的影响
- 隐藏全局数据
- 建立集中的控制点
- 促进代码的重用
- 完成特定的重构

内聚性的层次：

- 功能内聚性
- 顺序内聚性：执行B之前，必须执行A
- 通信内聚性
- 瞬时内聚性
- 过程内聚性：执行A\B\C的顺序是安排的业务流程
- 逻辑内聚性
- 偶发内聚性：程序之间的多项操作并没有任何可识别的关联，低质量程序的代表



**2.子程序命名**

好的子程序命名：

- 描述子程序所作的所有事
- 可描述子程序得到的返回值
- 可使用动词+对象的结构命名
- 相反操作使用成对的反义词命名
- 为常用操作建立命名规范，GetId() ReadId()?
- 避免使用无意义、模糊或空泛的动词
- 不要只使用数字区分子程序
- 选择合适的长度，不要过长不要过短



**3.子程序长度**

子程序的理想长度？50-150/100-200

需要结合多种因素考量



**4.子程序参数**

- 按“输入-修改-输出”的顺序来排列参数
- 可考虑创建自己专属的IN/OUT关键字（p174）
- 将状态或错误变量放在最后
- 不要把子程序参数作为工作变量使用
- 将输入值赋给一个工作变量可以强调该值的来源
- 对有关参数的接口假设进行文档化说明
- 将子程序的参数限制在7个左右
- 接口应该使用来自对象的参数还是使用对象？（p178）



5.函数使用中的注意事项

- 注意使用函数和过程的区别
- 检查所有可能的返回逻辑路径
- 不要返回指向局部数据的引用或指针
- 注意宏子程序和内联子程序的使用（p182）



## 第8章 防御式编程

主要思想：即使向子程序输入错误数据，它也不会受到破坏

**1.断言**

断言可以用于检查如下类型的假设：

- 入参或出参的值在预期范围内
- 子程序开始或结束时，文件或流处于打开或关闭状态
- 子程序开始或结束执行时，文件或流处于开始或结束的位置
- 文件或流以只读、只写或读写的方式打开
- 只读属性的入参没有被子程序修改
- 指针不为空
- 传入子程序的数组或其他容器至少可以容纳X个数据元素
- 表已经使用真实的值进行了初始化
- 子程序开始或结束执行时，容器是空的或者满的
- 一个经过高度优化的复杂子程序的运算结果与一个较慢但条理清晰的子程序的结果是一致的

断言的指导原则：

- 用错误代码来处理预期会发生的情况，用断言处理永远不应该发生的情况
- 避免将要执行的代码放在断言中，避免编译器跳过断言代码

**2.错误处理**

几种遇到错误输入时的处理方式：

- 返回中立值
- 换用下一条有效数据
- 返回与上次相同的答案
- 换用最接近的合法值
- 在文件中记录警告信息
- 返回一个错误代码
- 调用错误处理子程序或对象
- 在遇到错误的地方显示出错消息
- 在最妥当的方式在局部处理错误
- 关闭程序

**正确性与健壮性**

- 正确性意味着永远不会返回不准确的结果，不返回结果好于返回不准确的结果
- 稳健性倾向于让软件继续允许，即使会导致结果不准确
- 强调人身安全第一的应用往往更诸种正确性而非健壮性，比如放疗仪
- 消费类应用下往往更注重健壮性而非正确性，比如输入法软件

**3.异常**

异常是把代码中的错误或异常事件传递给调用方代码的一种特定方式。

异常还可以用于清理一段代码中存在的混乱逻辑，上游其他代码块直接try-catch异常。

异常的使用准则

- 使用异常来通知程序<u>其他部分不应忽略</u>的错误
- 仅在真正异常的情况下才抛出异常
- 不要使用异常来推卸责任
- 除非再同一位置捕获，否则<u>避免在构造函数和析构函数中抛出异常</u>
- 应当再合适的抽象层次抛出异常
- 在异常消息中应包括导致异常的所有信息
- 避免使用空的catch 块
- 了解使用的库会抛出的异常，如果库代码的异常不能捕捉到，会导致程序崩溃
- 考虑创建一个集中式的异常报告程序。其中包括有哪些类型的异常、每个异常该如何处理和异常消息的格式等。

**4.其他措施**

**隔离程序**：使之包容由错误造成的伤害。进行一些数据清洗验证，将输入时将输入数据转换为合适的类型等

**调试辅助代码**：不要自动将生产版本的约束应用于开发版本

**进攻式编程**：

- 确保断言语句可以使程序终止运行，不要让程序员养成遇到已知问题只知道按回车键绕过的习惯
- 完全填充分配到的所有内存，以便可以检测内存分配方面的错误
- 完全填充分配到的所有文件或流，以便可以排查任何文件格式错误
- 确保每个case语句中的default分支或else分支都能产生严重错误，比如让程序终止运行，或者至少让这些错误不会被忽视
- 在删除对象之前使其填满垃圾数据
- 让程序把错误日志文件通过电子邮件发送给你，让你可以看到已发布软件中发生的各种错误

## 第9章 伪代码编造过程 

（Pseudocode Programming Process）

**1.伪代码的指导原则**

- 使用自然语言风格的语句，精确描述具体的操作
- 避免使用目标编程语言的语法元素。
- 在意图层级上写伪代码。描述方法的含义，而不描述方法如何实现。
- 在足够低的层次上写伪代码，目的是几乎能直接转换成代码。如果伪代码层次太高，可能会掩盖代码中的问题细节。用越来越多的细节来完善伪代码，直到最后似乎能直接转换成代码。

**2.使用伪代码构造子程序**

- 检查先决条件：要检查子程序的工作是否已经准确定义并清晰地融入总体设计中
- 定义子程序要解决的问题：
  - 子程序隐藏的信息
  - 子程序的输入
  - 子程序的输出
  - 调用该子程序之前保证成立的前置条件：
    - 输入值在特定范围内
    - 流已初始化
    - 文件已打开或关闭
    - 缓冲区已填充或刷新
    - ...
  - 子程序在将控制权传回调用者之前保证成立的后置条件：
    - 输出值在指定范围内
    - 流已初始化
    - 文件已打开或关闭
    - 缓冲区已填充或刷新
    - ...
  - 决定如何测试子程序
    - 单元测试
  - 研究标准库中的可用功能
    - 不要重复发明轮子去做多余且不必要的工作
  - 考虑错误处理
  - 考虑效率问题
  - 研究算法和数据类型
  - 在伪代码中多尝试一些思路，保留其中最好的
- 开始编写子程序
  - 写子程序声明
  - 将伪代码转换成高层次的注释
  - 在每条注释下填写代码
  - 检查代码是否要进一步分解

- 检查代码
  - 用心检查子程序的错误
  - 编译子程序
  - 在调试器中逐行执行代码
  - 消除子程序中的错误


# 第三部分 变量

## 第10章 变量使用中的常规问题

隐式声明：

- 关闭隐式声明
- 声明所有变量的类型
- 遵循命名规范
- 利用编译器查看程序的变量列表进行检查

变量初始化：

- 在声明时初始化每个变量
- 在靠近首次使用的地方初始化变量
- 理想情况下，应在靠近首次使用变量的地方声明和定义每个变量
- 尽可能使用final或const
- 特别注意计数器和累加器，是否忘记重置？
- 在构造函数中初始化该类的成员数据
- 检查是否需要重新初始化
- 使用内存访问检测工具来检查错误的指针（操作系统/专门工具）
- 在程序的开始初始化工作内存（P246）

变量作用域：

- 尽量减少变量的跨度（从初始化到第一次使用）和存活时间（从第一次使用到最后一次使用）
- 在循环之前立即初始化循环中使用的变量，而不是在包含该循环的子程序开头进行初始化
- 在使用变量之前不要为其赋值

变量使用：

- 保证每个变量只限用于单一的用途
- 避免使用具有隐含含义的变量
- 确保使用了所有已声明的变量

## 第11章 变量名称

选择好名称的注意事项

- 变量名称要足够充分而准确地描述变量所代表的实体
- 好的名称倾向于表达”什么(what)“，而不是"如何(how)"
- 名称最优长度 ~ 20
- 对全局命名空间中的命名使用限定符
- 计算值限定符（Total\Average\Max\Min），应放置在变量的最后
- 使用对仗词（Begin/End Old/New）
- 循环变量 i、j、k
- 警惕临时变量，考虑用准确的、具有描述性的变量名
- 使用肯定的bool变量名，bool变量名称已包含或真活假的含义
- 枚举类型使用组前缀

语言无关的命名规范指导原则

- 标识全局变量
- 标识成员变量
- 标识类型定义
- 表示具名常量
- 标识枚举类型的元素
- 在不强调入参只读的语言中标识只读入参
- 格式化命名以提高可读性 gymnasticsPointsTotal\gymnastics_points_total

特定语言的命名规范指导原则（P281）

混合语言编程的注意事项（P281）

前缀（P283）

使用缩写的注意

- 不要通过从每个单词中删除一个字符来得出缩写词
- 缩写词要保持一致
- 创建的名称要能够读的出来
- 避免误读或容易发音错误的组合
- 代码中使用缩写对照表

变量名称避坑指南

- 避免使用误导性的命名或缩写
- 避免含义相似、命名相似、发音相似
- 避免数字
- 避免拼写错误或容易拼写错误的单词

## 第12章 基本数据类型

**1.浮点型**

- 避免对大小差别很大的数进行加减运算
- 避免浮点数之间的相等判断
- 预测舍入误差
  - 改为具有更高精度的变量类型
  - 改为二进制编码的十进制变量
  - <u>将浮点型变量改为整型变量</u> 自行处理小数部分 控制小数位数的长度（速度更快，精度能保持在一定范围内）

**2.字符串**

- 注意字符串结束标志
- 字符集（p302）
- C语言中的字符串（p303）

**3.枚举**

- 定义枚举的第一项和最后一项可便于循环控制
- 将枚举类型的第一个元素留作无效值，捕捉没有正确初始化的变量

**4.数组**

- 考虑使用容器（set、stack、queue）而不是数组，或将数组视为顺序结构（表是危险的，数组永远不可随机访问）

**5.自定义类型（p316）**

## 第13章 不常见的数据类型

**1.结构体(p323)**

**2.指针(p327)**

**3.全局数据**

 全局数据的常见问题

- 无意间修改了全局数据
- 全局数据中怪异和令人惊讶的别名问题
- 全局数据的可重入代码问题
  - 当代码中使用全局变量时，如果该代码在多个线程或在递归调用中被同时执行，就可能出现多个执行上下文同时访问和修改同一个全局数据，导致数据状态混乱或错误。也就是说，依赖全局数据的代码难以实现可重入性，即同一代码在不同调用环境下安全、正确地运行。


- 全局数据阻碍代码复用
  - 如果代码依赖于全局数据，就会与具体的全局状态耦合，难以在其他项目或模块中独立使用。这样的代码移植性和独立性较差，因为在新的环境中需要确保相同的全局数据存在和正确配置，增加了复用和维护的复杂性。
- 全局数据使情况变得复杂
- 不确定的全局数据初始化顺序问题
- 全局数据破坏了模块化和智力的可管理性
- 全局数据会给模块化能力带来漏洞

使用全局数据的理由

- 保存全局值
- 模拟具名常量
- 模拟枚举类型
- 简化对极其常用数据的使用
- 消除流浪数据

非必要，不用全局数据

- 所有变量开始都声明为局部变量，若非必要，不要设为全局变量
- 区分全局变量和类变量
- 使用访问器子程序

使用访问器子程序来替代全局数据

- 访问器子程序的优势

  - 可以集中控制数据

  - 可以确保所有对变量的引用都被隔离了

  - 可以自动获得信息隐藏的大部分好处

  - 访问器子程序很容易转换为抽象数据类型

- 如何使用访问器子程序

- 要求所有的代码通过访问器子程序来操作数据

- 不要将所有的全局数据都放到一起

- 使用上锁来控制对全局变量的访问

- 在访问器子程序中构建一个抽象层

- 将对数据的所有访问保持在同一抽象层

如何降低使用全局数据的风险

- 制定一种命名规范，使全局变量一目了然
- 为所有全局变量创建一份注释良好的列表
- 不要使用全局变量保存中间结果
- 不要把所有数据都放在一个庞大的对象中到处传递，假装没有使用全局数据



# 第四部分 语句

## 第14章 直线型代码的组织

顺序攸关的语句

- 组织代码，使依赖关系显而易见，比如将初始化变量的方法从业务代码中提取出来。
- 子程序的命名要揭示依赖关系
- 使用子程序参数揭示依赖关系
- 用注释记录不明确的依赖关系（p356）

顺序无关的语句

- 使用”就近原则“，把相关的行动放在一起
- 把相关的语句分为一组

## 第15章 使用条件语句

if语句

- 保证正常路径始终写在前面，所有出错情况都写在后面
- 使用 > 而不是 > = 使用 < 而不是 <=
- 可以仅仅写上else语句表明已考虑到else情况
- 测试else语句的正确性，检查if-else子句是否颠倒

if-then-else 测试链

- 用布尔函数调用简化复杂测试
- 最常见的情况放在最前面
- 确保覆盖所有情况
- 若语言支持，就用其他结构来替换if-then-else链

case语句

- 可以选择多种方式组织case语句针对的不同情况

  - 将正常情况放在最前面
  - 按频率排列情况
  - 按字母或数组顺序排列各种情况

  - 每个case的动作要简单，可以写一个子程序，从case中调用它
  - case语句应该用于容易归类的简单数据，如果数据不简单，可以使用if-then-else链来代替
  - default语句只用于检测错误，不要用于最后一种情况
  - 注意break的使用

## 第16章 控制循环

进入循环

- 只从一个位置进入循环
- 将初始化代码直接放在循环之前

退出条件

- 将所有退出条件都放在一个地方

## 第17章 不常见的控制结构

**return结束子方法**

**递归**

- 确保递归可以停止
- 使用安全计数器来防止无限递归
- 将递归限制在一个子程序中
- 留意栈以防溢出
- 计算阶乘和斐波那契数列时，不要用递归

**goto语句（p402）**

## 第18章 表驱动法

**表驱动法（Table-Driven Method）**是一种编程技巧，通过将逻辑或规则存储在表（如数组、字典、映射等）中，根据表中的数据来驱动程序的行为，而不是使用大量的条件语句（如 `if-else` 或 `switch-case`）。这种方法可以使代码更简洁、灵活和易于维护。

**表驱动法的核心思想**

- **逻辑映射到表**：将复杂的决策逻辑抽象为表的数据结构。
- **表驱动执行**：程序通过查找表中的数据来执行对应的操作，而不是直接编写复杂的条件分支。

**表驱动法的优点**

1. **代码简洁**：减少 `if-else` 或 `switch-case` 的嵌套，使代码结构更清晰。
2. **易于扩展**：添加新的逻辑或规则时，只需更新表而无需修改核心逻辑代码。
3. **维护性好**：逻辑集中在表中，修改需求时不需要修改大量代码。
4. **高效性**：直接查表通常比多层条件判断更高效，尤其是在规则较多时。

**常见应用场景**

1. **状态机（State Machine）**
   使用表来定义状态之间的转换关系。

   ```python
   # 状态机转移表
   state_transition_table = {
       ("idle", "start"): "running",
       ("running", "pause"): "paused",
       ("paused", "resume"): "running",
       ("running", "stop"): "idle",
   }
   
   # 根据当前状态和事件查表获取下一状态
   def get_next_state(current_state, event):
       return state_transition_table.get((current_state, event), "invalid")
   ```

2. **命令分发（Command Dispatcher）**
   使用表将命令映射到对应的处理函数。

   ```python
   # 命令与处理函数映射表
   command_table = {
       "start": lambda: print("Starting..."),
       "stop": lambda: print("Stopping..."),
       "pause": lambda: print("Pausing..."),
   }
   
   # 根据输入执行对应命令
   def execute_command(command):
       action = command_table.get(command, lambda: print("Invalid command"))
       action()
   ```

3. **数据解析**
   使用表来定义字段映射或解析规则。

   ```
   python复制代码# 数据解析规则表
   parse_table = {
       "name": lambda x: x.strip(),
       "age": lambda x: int(x),
       "active": lambda x: x.lower() == "true",
   }
   
   # 解析输入数据
   def parse_data(data):
       return {key: parse_table[key](value) for key, value in data.items()}
   
   raw_data = {"name": " Alice ", "age": "30", "active": "True"}
   parsed_data = parse_data(raw_data)
   print(parsed_data)  # {'name': 'Alice', 'age': 30, 'active': True}
   ```

4. **游戏开发**
   表驱动法常用于定义游戏中的规则、事件、技能效果等。

5. **配置驱动的程序**
   使用表来定义系统配置或行为规则，比如自动化脚本中的步骤和条件。

**表驱动法的示例**

假设需要根据天气条件给出建议，可以用表驱动法实现：

#### **传统写法**

```
python复制代码def suggest_activity(weather):
    if weather == "sunny":
        return "Go for a walk."
    elif weather == "rainy":
        return "Stay indoors."
    elif weather == "snowy":
        return "Build a snowman."
    else:
        return "Unknown weather."
```

**表驱动法**

```
python复制代码# 定义建议表
activity_table = {
    "sunny": "Go for a walk.",
    "rainy": "Stay indoors.",
    "snowy": "Build a snowman.",
}

# 根据天气查表获取建议
def suggest_activity(weather):
    return activity_table.get(weather, "Unknown weather.")

# 调用
print(suggest_activity("sunny"))  # 输出：Go for a walk.
```

## 第19章 常规控制问题

按数轴顺序来写数值表达式：MIN_ELEMENTS <=i and i <= MAX_ELEMENTS

显式处理比较逻辑：while(balance!=0) while(*chatPtr != '\0') while(bufferPtr!=NULL)

常量放在比较表达式左侧：MIN_ELEMENTS = i (报错)

减少深层嵌套

- 重复测试条件的一部分
- 转换为if-then-else
- 转换为case语句
- 将深度嵌套的代码转换为子程序
- 使用对象和多态分派
- 重写代码以使用状态变量
- 使用防卫子句退出子程序，使得代码的正常路径更清晰
- 使用异常
- 完全重新设计深层嵌套的代码。

# 第五部分 代码改进

## 第20章 软件质量概述

软件质量特性

- 用户感知到的特性
  - BUG发生情况
  - 学习和使用软件的容易程度
  - 是否尽可能少占用系统资源
  - MBTF：平均故障间隔时间
  - 系统组织未经授权或不正确访问其程序及其数据的能力
  - 为特定应用或环境设计的系统，在不做修改的情况下能够在其他应用或者环境种使用的程序
  - 输出结果的误差程度
  - 系统在接收无效输入或处于压力环境时正常运行的能力
- 代码质量
  - 是否能够很容易对系统进行修改，以改变或添加功能、提高性能或修正缺陷
  - 对于一个为特定用途或环境设计的系统，当该系统被用于其他的目的或环境时，需要对该系统做出修改的程度
  - 为了在原来设计的特定环境之外运行，对系统进行修改的难易程度
  - 系统的某些部分可被应用到其他系统中的程度以及此项工作的难易程度
  - 阅读并理解系统源代码的难易程度
  - 对系统进行单元测试和系统测试的程度
  - 在系统组织和细节语句层次上理解系统的难易程度



特性之间的促进/制约关系（p472）



代码审查比测试成本更低，缺陷检出率更高



提高生产率和改进质量的最佳方法时减少代码返工，不论返工是由于需求变化、设计变更、调试和与此相关的重构引起的。更多的质量保证工作能降低错误率，但不会增加开发的总成本



## 第21章 协同构建

### 结对编程

结对编程好处

- 全程采用结对编程的成本可能比单人开发高出10%~25%，但开发周期大概会缩短45%
- 使用结对编程可以达成与正式审查相当的代码质量水平，代码的可读性和可理解性往往可以提高到团队中最优秀程序员的水平

结对编程原则

- 先统一编码规范再开始结对编程
- 不要让结对编程变成旁观
- 不要强迫在简单的问题上使用结对编程
- 定期对结对人员和分配的工作任务进行轮换
- 鼓励双方跟上对方的步伐
- 确保双方都能看到显示器
- 不要强迫彼此看不顺眼的人结对
- 避免新手组合
- 如果整个团队维护的工程都采用结对编程方式，需要指定一个组长

### 代码审查

代码审查好处

- 独立的审查通常会捕捉到大约60%缺陷
- 审查占项目预算的10%~15%，并且会降低项目的整体成本

审查活动中的人员角色(p490)

- 主持人：负责让审查以一定速度进行
- 作者：次要，代码应该不言而喻
- 审查员：应事先准备找到的部分缺陷，随着审查会议中的讨论找到更多缺陷
- ...

审查的一般步骤（p491）*这里只简述注意点

- 规划：主持人应事先准备检查清单，带有行号，分发给审查人
- 会议：所有讨论在明确其是一个错误时就停止，不要讨论解决方案；每次会议不宜超过两小时；一天不宜开两次会议
- 报告：在审查会议的一天内，主持人制作报告列出每个缺陷，包括其类型和严重程度
- 返工、跟进、讨论解决方案（可选）

审查与自尊心：

- 作者不要视图为接受审查的代码辩护，应该认可每一个疑似的缺陷，哪怕可能其不存在
- 审查员不应发布攻击作者的评论，比如“任何一个java程序员都知道..."

### 走查

任何形式的开发人员之间检查代码

### 代码阅读

## 第22章 开发人员测试

**（开发）单元测试：**对完整的类、子程序、小程序执行的测试

**（开发）组件测试：**对类、包、小程序或其他程序元素执行的测试，独立于完整系统

**（开发）集成测试：**对多个类、包、组件或子系统执行的组合测试

**回归测试：**重复先前执行的测试用例

**系统测试：**将软件配置到最终环境中执行测试，包括与软硬件系统的集成，会查找安全性、性能、资源消耗、时序问题



**黑盒测试：**测试者无法获知所测试程序的内部原理的情况下所执行的测试。

**白盒测试：**测试者在了解所测试程序的内部工作原理情况下所执行的测试。



系统化的测试方法，保证测试不遗漏：

- 测试每个相关的需求，保证需求已经实现
- 对每个相关的设计重点进行测试，确保设计已经实现
- 为这些需求和设计添加详细的测试用例时，先加入一些”基础测试“。在这个基础上再添加数据流测试，然后添加其他测试用例，从而彻底测试代码所需的测试。至少应该保证对每一行代码都进行了测试。
- 列出一个错误检查清单，记录到目前为止在该项目或在以前项目中出现过的错误类型。



先写测试用例，再写代码，会让缺陷的存货时间，即缺陷插入到代码到缺陷被检测和移除之间的时间最小化。



**开发人员测试的局限性：**

- 程序员往往倾向于以验证代码是否工作的方式进行测试（干净测试），而不是想尽办法破坏代码以使其失效（肮脏测试）。
- 开发人员测试往往对测试覆盖率过于乐观
- 开发人员测试往往会跳过更复杂的测试覆盖类型（应该要求100%分支覆盖率而不是100%于是覆盖率）



**非完整测试：**在所有可能的测试原理中，只有少数用例是特别的，能暴露出其他测试用例无法暴露的错误。规划测试活动时应该剔除掉不会产生新信息的错误。



**结构化基础测试：**也即对每条语句和每个条件分支至少进行一次测试

- 构建全部为真、全部为假的测试用例
- 确保每个为”真“的逻辑分支至少有一个测试用例，每个为”假“的分支也至少有一个测试用例



**数据流测试：**

- 已定义 数据已经被初始化，但还没有被使用。 
- 已使用 数据已经被用于计算，或作为一个子程序调用的参 数，或用于其他事情。 
- 已撤销 数据曾经被定义过，但在某种意义上它已经撤销了原 来的定义，使之无效。例如，如果数据是一个指针，那么该指 针可能已经被释放 如果它是一个 for 循环中的索引值，可能 程序已经跳出了循环，而 且出了循环，而编程语言不会定义 for 循环索引值在循环之外的值 而如果它是 个指向文件中 记录的指针，可能该文件已经关闭，该记录指针不再有

对某个变量执行某些操作之前或之后立即 或退出一个子程序的即时情况。 

- 已进入 对变量执行操作之前，逻辑控制流刚刚进入该子程序 例如，在子程序的顶部初始化 个工作变量 
- 已退出 对变量执行操作之后，逻辑控制流立即退出该子程序 例如，在子程序结束时，将返回值赋给 个状态变扯

数据状态的正常组合是先定义一个变量，使用一次或多次该变量， 并可 撤销它。因 且看到以下组合模式，就要怀疑其正确性 

- 已定义 - 已定义 如果必须在 个变量有固定的赋值之前对其 进行两次定义，那么这位程序员需要的不是更好的程序，而是 台更好的计算机！这不仅是 种浪费，而且很容易出错，即 使实际上并没有报错 
- 已定义－已退出 如果变量是 个局部变量，那么在定义之后， 没使用它就退出子程序是完全没有意义的行为 但如果它是一个子程序参数或全局变量，或许不会产生问题 
- 已定义－已撤销 先定义 个变量，然后再撤销它，这说明要 么该变址是冗余的，要么就是缺失了原本应该使用该变批的那 段代码
- 已进入－已撤销 如果变量是局部变量，这样就会出问题 果它都没有被定义或使用过，它就不需要被撤销 方面， 如果它是一个子程序参数或全局变量，只要变量在被撤销之前 在其他地方定义过，那么使用这种模式就不会出问题 
- 已进入－已使用 同样，如果变矗是局部变扯，这样也会出问 题。在使用一个变量之前需要先对其进行定义 方面，如 果它是 个子程序参数或全局变最，那么只要变量在被撤销之 前在其他地方进行过定义 使用这种模式就不会出问题 
- 已撤销－已撤销 个变批无需被 销两次 这些变批并不会 死而复生 如果真出现了“复活” 变量只能说明代码写得粗 心大意 两次撤销这种行为对指针来说也是致命的，让计算机 停摆的最好方法之 就是撤销（释放）同一指针两次
- 已撤销 已使用 个变批被撤销之后再次使用它，这肯定 个逻辑错误 如果代码貌似还能继续工作（例如， 个指 针仍然指向已释放的内存），这只能说是一个意外侥幸，而墨 菲定律告诉我们，代码往往会在造成最严重破坏的时候停止 工作 
- 已使用 已定义 先使用 个变量，灾后再对它进行定义，这 可能会产生间题，也可能不会，这取决于变址在被使用之前是 否已经对它进行了定义 当然，如果发现 个这样的”已使用－ 已定义”模式 那么还是有必要再检查一下之前的定义

在开始测试之前，请务必检查这些异常的数据状态组合模式 查过异常模式之后，编写数据流测试用例的关键是对所有可能的”已 定义－已使用“路径进行测试 可以选取不同级别的测试完备性策略进 行测试，请参考如下信息 

- 所有定义 测试每个变址的每个定义，即针对所有变址接收赋 值的每 位置都进行测试 这是 种较弱的策略，因为如果已 经尝试用测试翟盖了每 行代码，默认情况下已经完成了这样 的测试 516 部分代码改进 
- 所有 已定义－已使用 的组合 测试在 个地方定义 个变 量并在另一个地方使用它的每种组合。这是一种比上述测试”所 有定义”更强大的策略，因为只覆盖每一行代码的测试并不能 保证每种“已定义－已使用”的组合都被测试到

等价划分

- 如果两个测试用例产生了完全相同的错误，那么只需要其中一个就够了。

错误猜测

- 利用经验、直觉

边界分析

- 边界条件下的差一错误

复合边界

- 当边界包含多个变最的组合时，会出现一种更隐蔽微妙的边界条 件。例如，如果两个变最相乘，那么当它们都是非常大的正数时，会 怎样？当它们都是非常大的负数呢？或者都是 呢？如果传递给子程 序的所有字符串都非常长怎么办？

不良数据测试用例

- 数据过少（或没有数据） 
- 数据过多
- 错误的数据类型（无效数据） 
- 错误的数据大小
- 未初始化的数据

良好数据的类别

- 标称情况，即不偏不倚的普通情况，正常取值范围 
- 最小正常配置 
- 最大正常配置
- 与旧数据的兼容性



可以使用便于手工检查的测试用例，比如计算薪水，一串复杂的无规律的数字不比一万、三万等简单数字更能检查出错误。



测试脚手架（p529）



系统干扰器（p533）

## 第23章 调试

暴力调试技术

- 对被破坏的代码进行完整的设计或代码评审
- 丢弃部分代码，并进行重新设计或重新编码
- 丢失整个程序，并进行重新设计或重新编码
- 编译带有完整调试信息的代码 
- 以最挑剔的警告级别编译代码，并修复所有挑剔的编译器警告
- 使用单元测试工具并单独测试新代码
- 写一个自动化测试套件，然后通宵运行
- 在调试器中手动单步执行大范围的代码，直到出现错误
- 使用print、display或其他日志语句检测代码
- 使用不同的编译器来编译代码
- 在不同环境中编译和运行程序
- 针对特殊的库或执行环境链接或运行代码，当代码被错误使用时会产生警告
- 复制最终用户的全部机器配置
- 将新代码一小块一小块地集成，并在集成时对每一块进行全面测试



调试建议

- 快而糙的调试方法可能花费比系统调试更多的时间



## 第24章 重构

### 重构的理由

- 代码重复（重复代码需要平行修改）
- 子程序太长
- 循环太长或嵌套太深
- 类的内聚力很差：一个类承担了太多不相关的职责
- 类的接口不能提供一致的抽象层级
- 参数表有太多参数
- 在类中进行的修改各自独立（类有多个职责的信号）
- 必须并行修改多个类
- 必须并行修改集成层次结构（比如每次创建一个类的子类，都必须创建另一个类的子类）
- 必须并行修改case语句
- 一起使用的相关数据项没有被组织成类
- 一个子程序使用了另一个类（而非它自己的类）更多的特性
- 无脑使用基本数据类型
- 类的作用不大
- 传递数据只是为了传递，没有其他意义（如果传递数据与每个子程序的接口呈现的抽象一致则没有意义）
- 中间对象不做任何事情
- 一个类与另一个类过分亲密
- 某个子程序的名字太差劲
- 公共数据成员（推荐将公共数据成员隐藏在访问它的子程序后面）
- 一个子类只是用了其父类一小部分的子程序
- 用注释解释难以理解的代码（好的代码不需要额外的解释）
- 避免超前设计的代码（p607）



### 数据级重构

（只记录有启发的条目）

- 局部的用途的就用局部变量 而不要用参数
- 将数据基元转换为类 
  - 如数据基元需要额外的行为（包括更严格 的类型检查）或额外的数据，就将数据转换为对象并添加你需要的行 。

- 将一组类型代码转换为带有子类的类 
  - 如果与不同类型相关的不 同元素可能有不同的行为，考虑为类型创建 个基类，并为每个类型 代码创建子类 对千 OutputType 基类，可考虑创建像 Screen, Printer ile 样的子类 
- 将数组改为对象 
  - 如果要使用 个数组，其中不同的元素是不同 的类型，就创建 个对象，将之前的每个数组元素改为字段 
- 封装集合 
  - 如类返回集合，同时存在多个集合实例会造成同步困 难。可考虑让类返回 个只读集合，并提供在集合中增删元素的子程序 
- 用数据类替代传统记录 
  - 创建 个类来包含记录的成员 创建类 有利千集中错误检查、持久化和其他涉及记录的操作



### 语句级重构

- 分解布尔表达式 
  - 通过引入命名良好的中间变最来简化布尔表达 式，帮助澄清表达式的含义 
- 将复杂布尔表达式移入一个命名良好的布尔函数 
  - 如果表达式足 够复杂，这样重构就可以改善可读性 如表达式在多个地方使用，重 构后就不需要进行并行修改，并减少了使用该表达式时出错的几率
- 用多态替代条件语句（尤其是重复的 case 语句） 
  - 过去许多在结 构化程序中包含在 case 语句中的逻辑，现在可以被转移到继承层次结 构中，并通过多态的子程序调用来完成 
- 创建和使用空对象，而不是测试空值 
  - 有的时候， 个空对象可 以关联泛型行为或数据，就好像将 个名字不详的居民称为“住户” 在这种情况下，考虑将处理空值的责任从客户代码转移到类中 换言之， Customer 类直接将未知居民定义为“住户”，而不是让 Customer 客户代码反复测试客户的名字是否已知并在未知时用“住户”代替



子程序级重构

- 提取子程序/提取方法
- 内联子程序的代码
- 将长的子程序转换为类
- 用简单酸代替复杂算法
- 添加参数
- 删除参数
- 将查询和修改操作分开
- 通过参数化合并类型的子程序
- 分解行为依赖于传入参数的子程序
- 传递整个对象而不是特定字段
- 传递特定的字段而不是整个对象
- 封装向下转型



类实现重构

- 将值对象修改为引用对象
- 将引用对象修改为值对象
- 用数据初始化替代虚函数
- 改变成员函数或数据的位置
- 将特化代码提取到一个子类中
- 将相似代码合并到超类中



类接口重构

- 将子程序移到另一个类中
- 将一个类转换为两个
- 淘汰类
- 隐藏委托（A调用B，B调用C，有时直接让A调用C更好）
- 去掉中间人
- 用委托代替继承：如某个类需使用另一个类，但有希望对其接口有更多控制，就让超类成为原来子类的字段，然后公开一组子程序来提供一个内聚性的抽象
- 用继承代替委托：如某个类公开了一个委托类（成员类）的所有公共子程序，就从委托类集成，而不要只是使用该类
- 引入外来的子程序：如某个类需要一个额外的子程序，而你不能修改这个类来提供它，可在客户类中创建新建一个子程序来提供该功能
- 引入拓展类：如某个类需要几个额外的子程序，而你不能修改这个类，可新建一个类来合并不可修改的那个类的功能与额外的功能。为此，要么创建原始类的子类并添加新的子程序，要么包装原始类并公开你需要的子程序
- 封装公开的成员变量：如成员数据是公共的，将成员数据修改成私有，改为通过一个子程序来公开成员数据的值
- 删除不可修改的字段的set()子程序：如字段在对象创建时赋值，之后便不可修改，就在对象的工造函数中初始化它，而不是提供一个误导性的set()子程序
- 隐藏不打算在类外使用的子程序：如类的接口没有子程序会更有内聚性，就隐藏此子程序
- 封装未使用的子程序：如发现自己经常只是用类接口的一部分，就为该类创建一个新接口，只公开那些必要的子程序。确保新接口提供一个内聚性的抽象
- 合并实现非常相似的超类和子类：如子类没有提供太多特化，就把它合并到超类中



系统级重构

- 为你无法控制的数据创建一个明确的引用源
- 将单向类关联改为双向类关联，如果有两个类需要使用对方的功能，但使用一个可以知道另一个的情况，就修改这些类，让它们彼此知道对方的情况
- 将双向类关联改为单向类关联
- 提供工厂方法而不是简单构造函数
- 用异常代替错误代码或相反



安全重构

- 保存开始时的代码
- 保持小幅重构
- 一次一个重构
- 列出步骤清单
- ...

## 第25章 代码调优策略

利用短路求值

按频率调整switch-case语句

不同语言的相似逻辑结构性能可能差异巨大，比如java中switch-case的性能远好于if-then-else；而Visual Basic中if-then-else的性能远好于switch-case

最小化循环内部的工作

将复杂的循环放在嵌套循环的内层

将乘法转换为加法

用整数而不是浮点数



# 第六部分 系统化考虑

**增量式集成：**一次性集成一个类而不是一次性集成多个类



**自底向上集成**：在自底向上集成的方法里，系统中层次结构底部的类先编写并集 。一次集成只添加一个类而不是一次性在集成中添加所有的低层类， 这样一来 ，自底向上集成成为 种增量式集成策略 我们可以写测试 驱动程序来让低层类先运行，并随着开发的进行将更多的类添加到测 试驱动程序的脚手架代码中 。当 添加更高层级类时，我们将用真正的 类来替换测试驱动程序中的类



**接口文档生成工具**：有些工具能从源代码文件中提取详细的接口文档 在源文件的代 码中使用＠tag 之类的标记来标识需要提取的文字 然后接口文档生成 工具就提取标记的文本，并生成漂亮的格式 Javadoc 是此类工具中的 优秀代表



**模板**：模板可以帮助简化经常做的键盘输入任务并使这些输入保持一致 假如想在程序前放入 个标准的注释块，可以考虑创建一个正确语法 的注释框架并且在你想要的地方插入 这个框架就是“模板”，可以 存储在文件中或者键盘宏命令中的 创建 个新的程序时，可以更容 易插入模板到源文件中 可以设置大的模板（如类和文件）或者小的（如 循环）



# 第七部分 软件匠艺

类的布局 

1. 头部的注释，对类进行描述并介绍类的总体使用情况。 

2. 构造函数和析构函数 

3. Public 子程序 
4. Protected 子程 
5. Private 子程序和数据成员



征服软件的复杂性

- 在架构层面把一个系统分解成若干个子系统，以便 次只聚焦于系统的一小部分
- 精心定义类的接口，以便能够忽略类的内部工作机制
- 类的接口保持抽象，以便无需记住所有细节
- 避免使用全局变量，因为全局变量会显著增江你需要兼顾的代码
- 避免深层次的继承，因为需要消耗大量的精力
- 避免循环和条件的深度嵌套，因为其实它们能被更简单的控制结构所替代
- 避免使用goto语句
- 小心定义错误处理的方法，不要滥用不同的错误处理技术
- 系统地使用内置的异常机制
- 不要让类过度膨胀，以至于占据整个程序
- 程序不要过长
- 变量命名清楚直观
- 尽可能减少参数的数量
- 
