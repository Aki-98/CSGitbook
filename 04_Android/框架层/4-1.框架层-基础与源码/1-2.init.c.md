# 概念解析

### 1. **`init` 进程**

- **定义**：`init` 是 Android 的第一个用户态进程（PID 为 1），由内核启动。它是系统启动流程的起点，负责初始化系统的基本资源和服务。
- 功能：
  - 挂载必要的文件系统。
  - 解析配置文件（通常是 `init.rc` 文件及其包含的脚本）。
  - 启动必要的守护进程和服务（如 `zygote`、`surfaceflinger` 等）。
  - 设置系统属性和环境变量。
  - 管理系统服务的生命周期。

------

### 2. **`init.c`**

- **定义**：`init.c` 是 Android 中 `init` 进程的实现文件，通常位于 Android 源码的 `system/core/init/` 路径下。
- 作用：
  - 定义了 `init` 进程的主逻辑，包括初始化、解析配置文件、启动服务等核心功能。
  - 包含与设备初始化相关的关键代码，比如：
    - 文件系统挂载。
    - 系统属性设置。
    - 解析 `.rc` 文件（如 `init.rc`）。
  - 通过事件循环机制监控服务状态，并根据需求重启服务或执行其他动作。
- 核心函数：
  - `main()`：`init` 进程的入口函数。
  - `init_parse_config_file()`：解析 `.rc` 文件。
  - `service_start()` 和 `service_stop()`：启动或停止服务。

------

### 3. **`init.rc`**

- **定义**：`init.rc` 是 `init` 进程的配置文件，使用了一种专门的语法，用于定义系统初始化的行为。

- 作用：

  - 指定系统服务的启动顺序、依赖关系和启动条件。
  - 定义环境变量和系统属性。
  - 配置挂载点和文件系统权限。
  - 管理服务生命周期（如 `on`, `service`, `import` 指令）。

- 典型结构：

  ```
  on boot
      # 定义在引导阶段执行的操作
      mount all /fstab.xxx
      start zygote
  
  service zygote /system/bin/app_process
      class main
      user root
      group system
      seclabel u:r:zygote:s0
  
  import /init.xxx.rc
  ```

- 常见指令：

  - `on`: 定义触发条件（如 `on boot`）。
  - `service`: 定义服务，包括服务路径、运行参数、权限等。
  - `import`: 导入其他配置文件。
  - `setprop`: 设置系统属性。

------

### 三者关系

1. **`init.c`** 是 `init` 进程的代码实现，是程序逻辑的核心。
2. **`init`** 进程是由 `init.c` 编译生成的可执行程序，负责执行系统初始化任务。
3. **`init.rc`** 是 `init` 进程的配置文件，定义了初始化流程和服务管理的具体行为。

# init进程分析

## 服务启动机制

1. system/core/init/init.c文件main函数中parse_config_file(init.rc)读取并解析init.rc文件内容。将service信息放置到system/core/init/init_parser.cpp的service_list中
2. system/core/init/init.c文件main函数继续执行restart_service_if_needed(…) -> service_start(…) -> Execve(…)建立service进程；

总体启动框架图：

 ![img](1-2.init.c_imgs\VbbMfMQrf9F.png)

## init进程承担了在用户空间和内核空间建立通讯的初始工作

在Linux系统中，`init`程序是操作系统启动过程中非常重要的一环，承担<u>了在用户空间和内核空间之间建立通讯的初始工作</u>。

> **内核空间（Kernel Space）**
>
> 操作系统核心代码运行的区域，拥有对硬件资源的完全控制权限。
>
> 内核空间包含了操作系统的内核代码，包括管理硬件资源、处理系统调用、管理内存、调度进程、处理中断等。
>
> 权限级别为Ring 0
>
> **用户空间（User Space）**
>
> 用户应用程序运行的区域，用户程序在该区域中执行并访问资源。
>
> 用户空间运行普通应用程序，比如浏览器、文本编辑器、命令行工具等。它隔离于内核空间，用户程序通常不能直接访问硬件资源。
>
> 用户空间的权限级别较低（Ring 3）
>
> 用户空间中的程序需要通过系统调用向内核请求资源（例如文件读写、内存分配、网络访问等）。系统调用是一种接口，用于桥接用户空间和内核空间的交互。

用户空间和内核空间之间的通讯机制多种多样，包括：

- **设备文件**（位于`/dev`目录）：设备驱动程序通过这些文件来与硬件交互。
- **内存文件系统**（如`/proc`和`/sys`）：这些目录下的文件和目录提供系统的内存信息、进程信息、配置参数等，通过这些接口，用户可以读取和修改系统状态。

这些文件都是在用户空间中提供的接口，但背后的数据和逻辑是由内核空间支持的。通过这种设计，用户可以简单地通过读取或写入文件来与内核交互，而不需要直接调用内核函数。

> **一切皆文件的特性**
>
> Linux系统的一个重要设计理念是“一切皆文件”。这意味着系统中的所有资源，包括硬件设备、内存、系统信息等，都通过文件的形式呈现给用户。通过这种设计，用户和应用程序可以通过文件接口与硬件和内核进行交互，提供了高度的抽象和便利。
>
> 例如，设备通常通过文件的形式来访问，比如`/dev/sda`代表一个磁盘设备，`/dev/tty`代表一个终端设备。内存信息、系统状态等也通过`/proc`和`/sys`目录提供给用户。

> ### **终端设备的类型**
>
> 1. **物理终端（硬件终端）**：
>    - 传统上，终端设备是指像键盘、显示器或串行接口设备这样的物理硬件。
>    - 这些设备通过串口（如 `/dev/ttyS0`）或其他接口连接到计算机，用于输入和输出数据。
> 2. **虚拟终端（伪终端）**：
>    - 在现代系统中，大多数终端是虚拟的，运行在软件层之上。
>    - 常见的虚拟终端包括：
>      - **文本控制台**：如通过快捷键 `Ctrl+Alt+F1` 切换到的 TTY（如 `/dev/tty1`, `/dev/tty2`）。
>      - **伪终端（Pseudo Terminal, PTY）**：如通过 SSH、telnet 等远程登录工具建立的终端会话（如 `/dev/pts/0`, `/dev/pts/1`）。
>      - **终端模拟器**：图形界面中的终端，如 GNOME Terminal、xterm 等，它们通过伪终端设备提供终端功能。
> 3. **串行设备终端**：
>    - 通过串行接口（如 RS-232）连接的设备，通常用于调试嵌入式系统或其他硬件（如 `/dev/ttyS0`, `/dev/ttyUSB0`）。



## **`init` 程序的组成和源代码目录**

- `init` 程序是由多组源代码文件编译生成的一个可执行程序，其中的核心文件是 `system/core/init/init.c`。这个文件是 `init` 程序的入口点，定义了启动过程中的关键函数和逻辑，尤其是 `main` 函数。
- `init.c` 文件非常大，包含了服务启动、属性设置、系统调用、文件系统挂载等众多功能模块，因此代码相对复杂。
- 除了 `init.c` 文件外，`init` 程序还依赖多个其他源文件，这些文件在 `system/core/init/` 目录中，处理不同的功能，如属性服务管理、资源管理、进程监控等。
- `init.c` 是 Android `init` 程序的主入口文件，其中的 `main` 函数是 `init` 的启动流程的核心部分。
  - `main` 函数负责从根本上完成系统的初始化工作，包括：
    1. **文件系统的挂载**：根据 `init.rc` 文件的定义，挂载根目录和其他必要的文件系统。
    2. **系统属性的加载和设置**：解析 `init.rc` 文件中的属性设置，并应用到系统中。
    3. **启动关键服务**：如启动 `servicemanager`、`zygote`、`logd` 等，确保系统服务的正常运行。
    4. **进程和资源管理**：初始化进程间通信、创建子进程、管理内存等。

# 启动过程

### **Boot Timing（启动时间）**

`init` 记录了启动过程中的一些重要时间信息，并将其保存在系统属性中。这些信息有助于分析系统启动过程中的不同阶段所消耗的时间。

**系统属性：**

- **`ro.boottime.init`**
  启动后，`init` 程序的第一阶段启动时间（以纳秒为单位，通过 `CLOCK_BOOTTIME` 时钟）。
- **`ro.boottime.init.first_stage`**
  第一步启动（即第一阶段）的持续时间，以纳秒为单位。
- **`ro.boottime.init.selinux`**
  SELinux 阶段的运行时间，以纳秒为单位。该阶段通常涉及加载和配置 SELinux 策略。
- **`ro.boottime.init.modules`**
  加载内核模块的时间，以毫秒为单位。
- **`ro.boottime.init.cold_boot_wait`**
  `init` 等待 `ueventd` 的冷启动阶段完成的时间，以纳秒为单位。
- **`ro.boottime.<service-name>`**
  启动指定服务的时间（以纳秒为单位）。`service-name` 代表服务的名称，启动时间是指从系统启动后到服务首次启动的时间。

这些时间属性帮助开发者和系统管理员了解每个阶段和服务启动的时间，便于优化启动过程。

------

### **Bootcharting（启动图生成）**

**Bootcharting** 是一种记录启动过程的日志工具，能生成启动过程的图表，以便后续分析。

**如何启用 Bootcharting：**

- **在模拟器上**：
  使用 `-bootchart timeout` 选项，在启动时启用启动图生成（`timeout` 是以秒为单位的超时设置）。

- **在设备上**：
  通过以下命令启用 bootcharting：

  ```
  adb shell 'touch /data/bootchart/enabled'
  ```

  启用后，日志文件将会写入 `/data/bootchart/` 目录。启用后记得删除该文件：

  ```
  rm /data/bootchart/enabled
  ```

**如何获取启动图：**

启动图数据会被保存在 `/data/bootchart/`，可以使用提供的脚本来提取数据并创建 `bootchart.tgz` 文件，供 `bootchart` 工具使用：

```
sudo apt-get install pybootchartgui
$ANDROID_BUILD_TOP/system/core/init/grab-bootchart.sh
```

`grab-bootchart.sh` 会使用 `$ANDROID_SERIAL` 环境变量，因此需要确保正确设置。如果没有在启动过程中看到 `init` 从零秒开始运行，需要参考 `dmesg` 输出来确定内核实际启动 `init` 的时间。

------

**比较两个 Bootcharts（比较两个启动图）**

`compare-bootcharts.py` 是一个实用脚本，用于比较两个启动图的时间差。通过该脚本，可以看到在两个不同启动实例之间，进程启动的时间差异。

- 使用方法：

  ```
  system/core/init/compare-bootcharts.py base-bootchart-dir exp-bootchart-dir
  ```

  其中，`base-bootchart-dir` 和 `exp-bootchart-dir` 是存放两个 `bootchart` 文件的目录，脚本会显示每个进程的启动时间差异。

**示例输出：**

```
process: baseline experiment (delta) - Unit is ms (a jiffy is 10 ms on the system)
------------------------------------
/init: 50 40 (-10)
/system/bin/surfaceflinger: 4320 4470 (+150)
...
bootanimation ends at: 33790 31230 (-2560)
```

- 每一行显示了进程的启动时间差异（单位为毫秒）。
- **负数**表示实验版本启动较快，**正数**表示实验版本启动较慢。

通过比较，可以直观地看出哪些进程启动时间有明显变化，这对于优化系统启动过程非常有帮助。

# 调试

### **Systrace (系统追踪)**

Systrace 是一种用于在 Android 设备的启动过程中进行性能分析的工具。它可以生成启动期间的性能报告，并帮助开发者定位系统启动中的瓶颈。Systrace 在 **userdebug** 或 **eng** 构建版本中可用。

**使用方法：**

例如，执行以下命令可以追踪与 **wm**（窗口管理器）和 **am**（活动管理器）相关的事件：

```
$ANDROID_BUILD_TOP/external/chromium-trace/systrace.py wm am --boot
```

- 命令解释：
  - `wm am`：表示追踪窗口管理器 (`wm`) 和活动管理器 (`am`) 事件。
  - `--boot`：表示追踪启动过程中的事件。
  - 执行该命令时，设备会重启。设备重启并完成启动序列后，命令会结束，生成的跟踪报告会以 `trace.html` 格式写入主机，按下 **Ctrl+C** 即可完成。

**限制：**

- **跟踪的开始时间：** 跟踪事件是在持久属性加载之后开始记录的，因此，在此之前触发的事件不会被记录。包括 `vold`、`surfaceflinger` 和 `servicemanager` 等服务的启动，通常会在持久属性加载之前启动，因此它们的事件不会被记录。
- **影响：** 例如，Zygote 初始化和从 Zygote 派生的进程不受此限制影响，因为它们的事件会在持久属性加载后被记录。

------

### **Debugging Init（调试 Init）**

`init` 启动的服务有时可能无法正常执行（`execv()`），这通常意味着在启动新服务时，链接器出现了问题。Android 的链接器会将其日志输出到 `logd` 和标准错误流（`stderr`），这些日志可以通过 `logcat` 访问。如果在访问 `logcat` 之前发生错误，可以使用 `stdio_to_kmsg` 服务选项，将链接器打印的日志转储到 `kmsg`，这样可以通过串口读取。

**调试服务启动：**

- 启动 `init` 服务时，通常不建议绕过 `init` 来启动服务，因为 `init` 会设置重要的环境变量（如用户、组、安全标签、能力等），这些环境变量不容易手动复制。

- 如果确实需要调试某个服务的启动，可以使用 **`sigstop`** 服务选项。这将使 `init` 在调用 `exec` 前向该服务发送 `SIGSTOP` 信号。这样可以给开发者一个机会，在继续执行服务之前，使用调试器（如 `gdb` 或 `strace`）进行调试。

- **示例：**
  调试 `logd` 服务，使用 `sigstop` 标记：

  ```
  stop logd
  setprop ctl.sigstop_on logd
  start logd
  ps -e | grep logd
  ```

  这时可以用 `gdb` 或 `strace` 附加到该进程：

  ```
  gdbclient.py -p 4343
  ```

  或者使用 `strace`：

  ```
  strace -p 4343
  kill -SIGCONT 4343
  ```

通过这种方式，开发者可以在服务启动之前进行详细调试。

------

### **Host Init Script Verification（主机端初始化脚本验证）**

在构建期间，`init` 脚本会经过以下几个方面的检查，以确保其正确性：

1. **格式检查：**
   - 确保每个 `action`、`service` 和 `import` 部分格式正确。例如，`action` 需要在前面有 `on` 行，`import` 语句后不能有额外的行。
2. **命令和参数检查：**
   - 检查命令是否映射到有效的关键字，并且参数数量是否在正确范围内。
3. **服务选项有效性检查：**
   - 需要确保服务选项有效。比如 UID 和 GID 必须能解析。

但以下部分只会在运行时进行检查，因此构建时不会进行验证：

1. 命令参数的有效性检查：
   - 比如不会检查文件路径是否存在、SELinux 是否允许该操作，或者 UID 和 GID 是否能够解析。
2. 服务存在性检查：
   - 不会检查服务是否存在或者是否有有效的 SELinux 域定义。
3. 多次定义检查：
   - 不会检查某个服务是否已经在不同的 `init` 脚本中定义过。

------

# **Early Init Boot Sequence（早期初始化启动序列）**

Android 的启动过程分为三个主要阶段：

1. **第一阶段初始化（First Stage Init）**
   - 负责设置加载其余系统所需的最小环境。具体包括：
     - 挂载 `/dev`、`/proc` 等虚拟文件系统。
     - 挂载“早期挂载”分区（例如包含系统代码的 `system` 和 `vendor` 分区）。
     - 如果设备有 `ramdisk`，则将 `system.img` 挂载到 `/`。
2. **SELinux 设置**
   - 在第一阶段初始化完成后，`init` 执行 SELinux 设置，这一步是可选的，取决于设备是否启用了 SELinux。
3. **第二阶段初始化（Second Stage Init）**
   - 当 SELinux 设置完成后，`init` 会再次执行，进入第二阶段。此时，`init.rc` 脚本开始执行，继续完成启动过程。

#### **设备配置：**

- **System-as-Root 设备：**
  - 这些设备的第一阶段 `init` 是 `/system/bin/init`，并且 `/init` 是指向 `/system/bin/init` 的符号链接。
- **带 `ramdisk` 的设备：**
  - 第一阶段 `init` 是一个静态可执行文件，位于 `/init`，该设备会先挂载 `system.img`，然后执行 `root` 切换操作，将 `/system` 移动到 `/`。
- **使用恢复模式作为 `ramdisk` 的设备：**
  - 第一阶段 `init` 包含在恢复 `ramdisk` 内，设备先切换根目录到 `/firststageramdisk`，然后再按第二阶段的步骤进行启动。

通过这些阶段，`init` 确保了系统能够顺利启动并加载必要的服务和配置。



# init.c源码分析

精炼源码分析（以后在更新的源码上再看一次）：

1. ueventd主要负责设备节点的创建、权限设定等一系列工作；watchdogd用于系统出问题时重启系统

2. 如果参数同时从命令行和DT传过来，DT的优先级总是大于命令行的

> 在 Android 中，"Device Tree"（设备树）通常是指 Android 操作系统的设备树机制。设备树是一种用于描述硬件设备和其连接关系的数据结构，它被广泛用于嵌入式系统中，包括 Android 设备。
>
> Android 设备树的主要目的是为了在 Linux 内核中动态描述和配置硬件设备。设备树通常以一种类似于 XML 的结构进行描述，其中包含了有关系统硬件、设备、中断、总线等信息的详细描述。
>
> 主要的 Android 设备树文件是 `dts`（设备树源）文件，它们编译成 `dtb`（设备树二进制）文件，然后由 Linux 内核加载并解释。设备树的使用允许 Android 操作系统在多种硬件平台上运行，而无需为每个平台定制和编译一个特定的内核。
>
> Android 设备树包括以下方面的信息：
>
> 1. **硬件组件：** 描述了处理器、内存、外设等硬件组件的信息。
> 2. **中断：** 描述了系统中各种中断的分配和连接。
> 3. **总线：** 描述了系统中使用的总线，如 I2C、SPI、PCI 等。
> 4. **设备：** 描述了连接到系统的各种设备，如传感器、摄像头、显示器等。
>
> 通过使用设备树，Android 能够更容易地适应各种硬件配置，使其更加灵活和可移植。