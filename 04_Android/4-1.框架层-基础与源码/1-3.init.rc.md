# init.rc解析

## 服务启动机制

1. system/core/init/init.c文件main函数中parse_config_file(init.rc)读取并解析init.rc文件内容。将service信息放置到system/core/init/init_parser.cpp的service_list中
2. system/core/init/init.c文件main函数继续执行restart_servie_if_needed(…) -> service_start(…) -> Execve(…)建立service进程；

总体启动框架图： ![img](1.3.init.rc_imgs\22.png)

## init.rc 简介

> **内核空间（Kernel Space）**
>
> 操作系统核心代码运行的区域，拥有对硬件资源的完全控制权限。
>
> 内核空间包含了操作系统的内核代码，包括管理硬件资源、处理系统调用、管理内存、调度进程、处理中断等。
>
> 权限级别为Ring 0
>
> **用户空间（User Space）**
>
> 用户应用程序运行的区域，用户程序在该区域中执行并访问资源。
>
> 用户空间运行普通应用程序，比如浏览器、文本编辑器、命令行工具等。它隔离于内核空间，用户程序通常不能直接访问硬件资源。
>
> 用户空间的权限级别较低（Ring 3）
>
> 用户空间中的程序需要通过系统调用向内核请求资源（例如文件读写、内存分配、网络访问等）。系统调用是一种接口，用于桥接用户空间和内核空间的交互。
>
> 

在Linux系统中，`init`程序是操作系统启动过程中非常重要的一环，承担<u>了在用户空间和内核空间之间建立通讯的初始工作</u>。以下是详细的解释：

### 1. **一切皆文件的特性**

- Linux系统的一个重要设计理念是“一切皆文件”。这意味着系统中的所有资源，包括硬件设备、内存、系统信息等，都通过文件的形式呈现给用户。通过这种设计，用户和应用程序可以通过文件接口与硬件和内核进行交互，提供了高度的抽象和便利。
- 例如，设备通常通过文件的形式来访问，比如`/dev/sda`代表一个磁盘设备，`/dev/tty`代表一个终端设备。内存信息、系统状态等也通过`/proc`和`/sys`目录提供给用户。

### 2. **用户空间与内核空间的交互**

- 用户空间和内核空间之间的通讯机制多种多样，包括：
  - **设备文件**（位于`/dev`目录）：设备驱动程序通过这些文件来与硬件交互。
  - **内存文件系统**（如`/proc`和`/sys`）：这些目录下的文件和目录提供系统的内存信息、进程信息、配置参数等，通过这些接口，用户可以读取和修改系统状态。
- 这些文件都是在用户空间中提供的接口，但背后的数据和逻辑是由内核空间支持的。通过这种设计，用户可以简单地通过读取或写入文件来与内核交互，而不需要直接调用内核函数。

### 3. **init 程序的作用**

- `init`程序是用户空间启动的第一个进程，通常由PID为1。它承担了启动时的初始化工作，主要包括：
  - **建立文件系统**：`init`会确保设备文件（如`/dev`）和系统接口（如`/proc`和`/sys`）所在的目录已经建立并挂载，使用户空间可以顺利访问这些内核接口。
  - **启动必要的系统服务**：在完成文件系统初始化后，`init`会启动各种系统服务和守护进程，使系统进入多用户状态。
- 由于`init`是用户空间启动的第一个程序，它标志着内核启动完成，用户空间的操作开始。所有其他用户空间进程都依赖`init`的工作结果，进而完成进一步的操作。

### 4.**`init` 程序的组成和源代码目录**

- `init` 程序是由多组源代码文件编译生成的一个可执行程序，其中的核心文件是 `system/core/init/init.c`。这个文件是 `init` 程序的入口点，定义了启动过程中的关键函数和逻辑，尤其是 `main` 函数。
- `init.c` 文件非常大，包含了服务启动、属性设置、系统调用、文件系统挂载等众多功能模块，因此代码相对复杂。
- 除了 `init.c` 文件外，`init` 程序还依赖多个其他源文件，这些文件在 `system/core/init/` 目录中，处理不同的功能，如属性服务管理、资源管理、进程监控等。

### 5. **`init.c` 文件的作用和 `main` 函数分析**

- `init.rc` 文件是 Android 系统初始化过程中必不可少的配置文件，它并不是程序代码文件，而是一个基于特定语法的配置文件，用于定义系统启动时需要初始化的进程和服务。

- 这些 `.rc` 文件包含了一些系统服务和守护进程的启动命令、系统属性的设定、文件系统的挂载信息等，`init` 程序会解析这些配置文件并根据内容执行相应的操作。
- `init.c` 是 Android `init` 程序的主入口文件，其中的 `main` 函数是 `init` 的启动流程的核心部分。
  - `main` 函数负责从根本上完成系统的初始化工作，包括：
    1. **文件系统的挂载**：根据 `init.rc` 文件的定义，挂载根目录和其他必要的文件系统。
    2. **系统属性的加载和设置**：解析 `init.rc` 文件中的属性设置，并应用到系统中。
    3. **启动关键服务**：如启动 `servicemanager`、`zygote`、`logd` 等，确保系统服务的正常运行。
    4. **进程和资源管理**：初始化进程间通信、创建子进程、管理内存等。

### 6. **不同的 `init.rc` 文件**

在 Android 系统中，存在多个不同的 `init.rc` 文件，每个文件用于不同的启动场景。主要有以下两个关键的 `init.rc` 文件：

- `./system/core/rootdir/init.rc`
  - 这是系统正常启动时使用的主要配置文件。它定义了 Android 系统正常启动时的初始化流程，包括挂载文件系统、启动关键服务（如 `zygote`、`surfaceflinger`）、设置系统属性等。
  - 当系统正常启动时，`init` 程序会读取和解析该文件，按照其中的定义逐步完成系统初始化并进入主界面。
- `./bootable/recovery/etc/init.rc`
  - 这是用于“恢复模式”（Recovery Mode）启动时的配置文件，系统在进入恢复模式时会使用它。恢复模式一般用于系统刷机、数据恢复、工厂重置等操作，因此其中定义的服务和进程相对简单，主要集中在设备初始化和恢复操作相关的服务上。
  - 当用户选择进入恢复模式时，`init` 程序会加载和执行该 `init.rc` 文件中的配置，进入恢复模式环境。



## init.rc语法结构解析

要了解init.rc是怎么解析的，我们需要先看看说明文档，说明文档在，当然也可以看下热心网友的中文对照版本；
init.rc位于/bootable/recovery/etc/init.rc

Android初始化语言包含了四种类型的声明：
Actions（行为）、Commands（命令）、Services（服务）和Options（选项）

所有这些都是以行为单位的，各种记号由空格来隔开。
C语言风格的反斜杠号可用于在记号间插入空格。
双引号也可用于防止字符串被空格分割成多个记号。
行末的反斜杠用于折行，注释行以井号（#）开头（允许以空格开头）。

**需要注意的是，这个只是一个语法文件，就像一个xml文件一样，没有执行顺序的，解析器通过读这个文件获取想要的数据，包括service，action等**

Actions和Services声明一个新的分组Section。所有的命令或选项都属于最近声明的分组。位于第一个分组之前的命令或选项将会被忽略。 Actions和Services有唯一的名字。如果有重名的情况，第二个申明的将会被作为错误忽略。

## Actions

**Actions（行为）是一系列命令的开始**

Actions代表一些Action.Action代表一组命令(Commands),Actions都有一个trigger（触发器）,该触发器决定了何时执行这个Action,即在什么情况下才能执行该Action中的定义命令.当一些条件满足触发器的条件时,该Action中定义的命令会被添加到要执行命令队列的尾部(如果这组命令已经在队列中,则不会再次添加).

队列中的每一个action都被依次提取出，而这个action中的每个command（命令）在一个Action从队列移除时,该Action定义的命令会依次被执行.

Action的格式如下:

```rc
on <trgger> [&& <trigger>]*
   <command1>
   <command2>
   <command3>
   ...
```

on后面跟着一个触发器，当trigger被触发时，command1，command2，command3，会依次执行，直到下一个Action或下一个Service。

简单来说，Actions就是Android在启动时定义的一个启动脚本，当条件满足时，会执行该脚本，脚本里都是一些命令commands，不同的脚本用on来区分。

## Triggers（触发器）

trigger即我们上面所说的触发器,本质上是一个字符串,能够匹配某种包含该字符串的事件.
trigger又被细分为事件触发器(event trigger)和属性触发器(property trigger).
Triggers（触发器）是一个用于匹配特定事件类型的字符串，用于使Actions发生。

事件触发器可由”trigger”命令或初始化过程中通过QueueEventTrigger()触发,通常是一些事先定义的简单字符串, 例如:boot,late-init
属性触发器是当指定属性的变量值变成指定值时触发,其格式为property:=*

一个Action可以有多个属性触发器,但是最多有一个事件触发器.下面我们看两个例子:

```rc
on boot && property:a=b
```

该Action只有在boot事件发生时,并且属性a和b相等的情况下才会被触发.

```rc
on property:a=b && property:c=d
```

该Action会在以下三种情况被触发:

- 在启动时,如果属性a的值等于b并且属性c的值等于d
- 在属性c的值已经是d的情况下,属性a的值被更新为b
- 在属性a的值已经是b的情况下,属性c的值被更新为d

当前AIL中常用的有以下几种事件触发器:

```rc
类型                      说明
-------------------------------------------------
boot                    init.rc被装载后触发
device-added-<path>     指定设备被添加时触发
device-removed-<path>   指定设备被移除时触发
service-exited-<name>   在特定服务(service)退出时触发
early-init              初始化之前触发
late-init               初始化之后触发
init                    初始化时触发（在 /init.conf （启动配置文件）被装载之后）
```

Init的触发是由init.c里的函数action_for_each_trigger来决定的（在main函数中被调用）。

## Services

Services（服务）是一个程序，以 service开头，由init进程启动，一般运行于另外一个init的子进程，所以启动service前需要判断对应的可执行文件是否存在。init生成的子进程，定义在rc文件，其中每一个service，在启动时会通过fork方式生成子进程。Services（服务）的形式如下：

```rc
service <name> <pathname> [ <argument> ]*
    <option>
    <option>
    ...
```

其中：

- name:服务名
- pathname:当前服务对应的程序位置
- option：当前服务设置的选项
- argument 可选参数

## init.rc文件详解

为了方便理解，我把整个init.rc解析一边，便于大家了解整个流程；如果想要了解recovery下的init语法解析，参考这篇文章《recovery下的init.rc语法解析》

```c++
"【import <filename>一个init配置文件，扩展当前配置。】"
import /init.environ.rc
import /init.usb.rc
import /init.${ro.hardware}.rc
import /init.${ro.zygote}.rc
import /init.trace.rc

"【触发条件early-init，在early-init阶段调用以下行】"
on early-init
    # Set init and its forked children's oom_adj.
    write /proc/1/oom_score_adj -1000
    "【打开路径为<path>的一个文件，并写入一个或多个字符串】"
    # Apply strict SELinux checking of PROT_EXEC on mmap/mprotect calls.
    write /sys/fs/selinux/checkreqprot 0

    # Set the security context for the init process.
    # This should occur before anything else (e.g. ueventd) is started.
    "【这段脚本的意思是init进程启动之后就马上调用函数setcon将自己的安全上下文设置为“u:r:init:s0”，即将init进程的domain指定为init。】"
    setcon u:r:init:s0

    # Set the security context of /adb_keys if present.
    "【恢复指定文件到file_contexts配置中指定的安全上线文环境】"
    restorecon /adb_keys

    "【执行start ueventd的命令。ueventd是一个service后面有定义】 "
    start ueventd

    "【mkdir <path> [mode] [owner] [group]   
        //创建一个目录<path>，可以选择性地指定mode、owner以及group。如果没有指定，默认的权限为755，并属于root用户和root组。】"
    # create mountpoints
    mkdir /mnt 0775 root system

on init
    "【设置系统时钟的基准,比如0代表GMT,即以格林尼治时间为准】"
    sysclktz 0

"【设置kernel日志等级】"
loglevel 6 ####
    write /proc/bootprof "INIT: on init start" ####

    "【symlink <target> <path>  
        //创建一个指向<path>的软连接<target>。】"
    # Backward compatibility
    symlink /system/etc /etc
    symlink /sys/kernel/debug /d

    # Right now vendor lives on the same filesystem as system,
    # but someday that may change.
    symlink /system/vendor /vendor

    "【创建一个目录<path>，可以选择性地指定mode、owner以及group。】"
    # Create cgroup mount point for cpu accounting
    mkdir /acct
    mount cgroup none /acct cpuacct
    mkdir /acct/uid

    "【mount <type> <device> <dir> [ <mountoption> ]   
        //在目录<dir>挂载指定的设备。<device> 可以是以 mtd@name 的形式指定一个mtd块设备。<mountoption>包括 ro、rw、remount、noatime、 ...】"
    # Create cgroup mount point for memory
    mount tmpfs none /sys/fs/cgroup mode=0750,uid=0,gid=1000
    mkdir /sys/fs/cgroup/memory 0750 root system
    mount cgroup none /sys/fs/cgroup/memory memory
    write /sys/fs/cgroup/memory/memory.move_charge_at_immigrate 1
    "【chown <owner> <group> <path>   
        //改变文件的所有者和组。】"

    "【后面的一些行因为类似，就省略了】"
    .....

# Healthd can trigger a full boot from charger mode by signaling this
# property when the power button is held.
on property:sys.boot_from_charger_mode=1
    "【停止指定类别服务类下的所有已运行的服务】"
    class_stop charger
    "【触发一个事件,将该action排在某个action之后(用于Action排队)】"
    trigger late-init

# Load properties from /system/ + /factory after fs mount.
on load_all_props_action
    "【从/system，/vendor加载属性。默认包含在init.rc】"
    load_all_props

# Indicate to fw loaders that the relevant mounts are up.
on firmware_mounts_complete
    "【删除指定路径下的文件】"
    rm /dev/.booting

# Mount filesystems and start core system services.
on late-init
    "【触发一个事件。用于将一个action与另一个action排列。】"
    trigger early-fs
    trigger fs
    trigger post-fs
    trigger post-fs-data

    # Load properties from /system/ + /factory after fs mount. Place
    # this in another action so that the load will be scheduled after the prior
    # issued fs triggers have completed.
    trigger load_all_props_action

    # Remove a file to wake up anything waiting for firmware.
    trigger firmware_mounts_complete

    trigger early-boot
    trigger boot


on post-fs
    ...
    "【一些创造目录，建立链接，更改权限的操作，这里省略】"

on post-fs-data
    ...
    "【一些创造目录，建立链接，更改权限的操作，这里省略】"

    "【恢复指定文件到file_contexts配置中指定的安全上线文环境】"
    restorecon /data/mediaserver

    "【将系统属性<name>的值设置为<value>,即以键值对的方式设置系统属性】"
    # Reload policy from /data/security if present.
    setprop selinux.reload_policy 1

    "【以递归的方式恢复指定目录到file_contexts配置中指定的安全上下文中】"
    # Set SELinux security contexts on upgrade or policy update.
    restorecon_recursive /data

    # If there is no fs-post-data action in the init.<device>.rc file, you
    # must uncomment this line, otherwise encrypted filesystems
    # won't work.
    # Set indication (checked by vold) that we have finished this action
    #setprop vold.post_fs_data_done 1

on boot
    "【初始化网络】"
    # basic network init
    ifup lo
    "【设置主机名为localhost】"
    hostname localhost
    "【设置域名localdomain】"
    domainname localdomain

    "【设置资源限制】"
    # set RLIMIT_NICE to allow priorities from 19 to -20
    setrlimit 13 40 40

    "【这里省略了一些chmod,chown,等操作，不多解释】"
   ...


    # Define default initial receive window size in segments.
    setprop net.tcp.default_init_rwnd 60

    "【重启core服务】"
    class_start core

on nonencrypted
    class_start main
    class_start late_start

on property:vold.decrypt=trigger_default_encryption
    start defaultcrypto

on property:vold.decrypt=trigger_encryption
    start surfaceflinger
    start encrypt

on property:sys.init_log_level=*
    loglevel ${sys.init_log_level}

on charger
    class_start charger

on property:vold.decrypt=trigger_reset_main
    class_reset main

on property:vold.decrypt=trigger_load_persist_props
    load_persist_props

on property:vold.decrypt=trigger_post_fs_data
    trigger post-fs-data

on property:vold.decrypt=trigger_restart_min_framework
    class_start main

on property:vold.decrypt=trigger_restart_framework
    class_start main
    class_start late_start

on property:vold.decrypt=trigger_shutdown_framework
    class_reset late_start
    class_reset main

on property:sys.powerctl=*
    powerctl ${sys.powerctl}

# system server cannot write to /proc/sys files,
# and chown/chmod does not work for /proc/sys/ entries.
# So proxy writes through init.
on property:sys.sysctl.extra_free_kbytes=*
    write /proc/sys/vm/extra_free_kbytes ${sys.sysctl.extra_free_kbytes}

# "tcp_default_init_rwnd" Is too long!
on property:sys.sysctl.tcp_def_init_rwnd=*
    write /proc/sys/net/ipv4/tcp_default_init_rwnd ${sys.sysctl.tcp_def_init_rwnd}

"【守护进程】"
## Daemon processes to be run by init.
service ueventd /sbin/ueventd
    class core
    critical
    seclabel u:r:ueventd:s0

"【日志服务进程】"
service logd /system/bin/logd
    class core
    socket logd stream 0666 logd logd
    socket logdr seqpacket 0666 logd logd
    socket logdw dgram 0222 logd logd
    seclabel u:r:logd:s0

"【Healthd是android4.4之后提出来的一种中介模型，该模型向下监听来自底层的电池事件，向上传递电池数据信息给Framework层的BatteryService用以计算电池电量相关状态信息】"
service healthd /sbin/healthd
    class core
    critical
    seclabel u:r:healthd:s0

"【控制台进程】"
service console /system/bin/sh
    "【为当前service设定一个类别.相同类别的服务将会同时启动或者停止,默认类名是default】"
    class core
    "【服务需要一个控制台】"
    console
    "【服务不会自动启动,必须通过服务名显式启动】"
    disabled
    "【在执行此服务之前切换用户名,当前默认的是root.自Android M开始,即使它要求linux capabilities,也应该使用该选项.很明显,为了获得该功能,进程需要以root用户运行】"
    user shell
    seclabel u:r:shell:s0

on property:ro.debuggable=1
    start console

# adbd is controlled via property triggers in init.<platform>.usb.rc
service adbd /sbin/adbd --root_seclabel=u:r:su:s0
    class core
    "【创建一个unix域下的socket,其被命名/dev/socket/<name>. 并将其文件描述符fd返回给服务进程.其中,type必须为dgram,stream或者seqpacke,user和group默认是0.seclabel是该socket的SELLinux的安全上下文环境,默认是当前service的上下文环境,通过seclabel指定】"
    socket adbd stream 660 system system
    disabled
    seclabel u:r:adbd:s0

# adbd on at boot in emulator
on property:ro.kernel.qemu=1
    start adbd

"【内存管理服务，内存不够释放内存】"
service lmkd /system/bin/lmkd
    class core
    critical
    socket lmkd seqpacket 0660 system system

"【ServiceManager是一个守护进程，它维护着系统服务和客户端的binder通信。在Android系统中用到最多的通信机制就是Binder，Binder主要由Client、Server、ServiceManager和Binder驱动程序组成。其中Client、Service和ServiceManager运行在用户空间，而Binder驱动程序运行在内核空间。核心组件就是Binder驱动程序了，而ServiceManager提供辅助管理的功能，无论是Client还是Service进行通信前首先要和ServiceManager取得联系。而ServiceManager是一个守护进程，负责管理Server并向Client提供查询Server的功能。】"
service servicemanager /system/bin/servicemanager
    class core
    user system
    group system
    critical
    onrestart restart healthd
    "【servicemanager 服务启动时会重启zygote服务】"
    onrestart restart zygote
    onrestart restart media
    onrestart restart surfaceflinger
    onrestart restart drm

"【Vold是Volume Daemon的缩写,它是Android平台中外部存储系统的管控中心,是管理和控制Android平台外部存储设备的后台进程】"
service vold /system/bin/vold
    class core
    socket vold stream 0660 root mount
    ioprio be 2

"【Netd是Android系统中专门负责网络管理和控制的后台daemon程序】"
service netd /system/bin/netd
    class main
    socket netd stream 0660 root system
    socket dnsproxyd stream 0660 root inet
    socket mdns stream 0660 root system
    socket fwmarkd stream 0660 root inet

"【debuggerd是一个daemon进程，在系统启动时随着init进程启动。主要负责将进程运行时的信息dump到文件或者控制台中】"
service debuggerd /system/bin/debuggerd
    class main

service debuggerd64 /system/bin/debuggerd64
    class main

"【Android RIL (Radio Interface Layer)提供了Telephony服务和Radio硬件之间的抽象层】"
# for using TK init.modem.rc rild-daemon setting
#service ril-daemon /system/bin/rild
#    class main
#    socket rild stream 660 root radio
#    socket rild-debug stream 660 radio system
#    user root
#    group radio cache inet misc audio log

"【提供系统 范围内的surface composer功能，它能够将各种应用程序的2D、3D surface进行组合。】"
service surfaceflinger /system/bin/surfaceflinger
    class core
    user system
    group graphics drmrpc
    onrestart restart zygote

"【DRM可以直接访问DRM clients的硬件。DRM驱动用来处理DMA，内存管理，资源锁以及安全硬件访问。为了同时支持多个3D应用，3D图形卡硬件必须作为一个共享资源，因此需要锁来提供互斥访问。DMA传输和AGP接口用来发送图形操作的buffers到显卡硬件，因此要防止客户端越权访问显卡硬件。】"
#make sure drm server has rights to read and write sdcard ####
service drm /system/bin/drmserver
    class main
    user drm
    # group drm system inet drmrpc ####
    group drm system inet drmrpc sdcard_r ####

"【媒体服务，无需多说】"
service media /system/bin/mediaserver
    class main
    user root ####
#   google default ####
#   user media    ####
    group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm media sdcard_r system net_bt_stack ####
#   google default ####
#   group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm ####

    ioprio rt 4

"【设备加密相关服务】"
# One shot invocation to deal with encrypted volume.
service defaultcrypto /system/bin/vdc --wait cryptfs mountdefaultencrypted
    disabled
    "【当服务退出时,不重启该服务】"
    oneshot
    # vold will set vold.decrypt to trigger_restart_framework (default
    # encryption) or trigger_restart_min_framework (other encryption)

# One shot invocation to encrypt unencrypted volumes
service encrypt /system/bin/vdc --wait cryptfs enablecrypto inplace default
    disabled
    oneshot
    # vold will set vold.decrypt to trigger_restart_framework (default
    # encryption)

"【开机动画服务】"
service bootanim /system/bin/bootanimation
    class core
    user graphics
#    group graphics audio ####
    group graphics media audio ####
    disabled
    oneshot

"【在Android系统中，PackageManagerService用于管理系统中的所有安装包信息及应用程序的安装卸载，但是应用程序的安装与卸载并非PackageManagerService来完成，而是通过PackageManagerService来访问installd服务来执行程序包的安装与卸载的。】"
service installd /system/bin/installd
    class main
    socket installd stream 600 system system

service flash_recovery /system/bin/install-recovery.sh
    class main
    seclabel u:r:install_recovery:s0
    oneshot

"【vpn相关的服务】"
service racoon /system/bin/racoon
    class main
    socket racoon stream 600 system system
    # IKE uses UDP port 500. Racoon will setuid to vpn after binding the port.
    group vpn net_admin inet
    disabled
    oneshot

"【android中有mtpd命令可以连接vpn】"
service mtpd /system/bin/mtpd
    class main
    socket mtpd stream 600 system system
    user vpn
    group vpn net_admin inet net_raw
    disabled
    oneshot

service keystore /system/bin/keystore /data/misc/keystore
    class main
    user keystore
    group keystore drmrpc

"【可以用dumpstate 获取设备的各种信息】"
service dumpstate /system/bin/dumpstate -s
    class main
    socket dumpstate stream 0660 shell log
    disabled
    oneshot

"【mdnsd 是多播 DNS 和 DNS 服务发现的守护程序。】"
service mdnsd /system/bin/mdnsd
    class main
    user mdnsr
    group inet net_raw
    socket mdnsd stream 0660 mdnsr inet
    disabled
    oneshot

"【触发关机流程继续往下走】"
service pre-recovery /system/bin/uncrypt
    class main
    disabled
    "【当服务退出时,不重启该服务】"
    oneshot
```

