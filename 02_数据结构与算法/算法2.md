```c++
void dfs(int i,int tw,int tv,int rw,int op[]) //求解0/1背包问题
{  //初始调用时rw为所有物品重量和
   int j;
   if (i>n)				//找到一个叶子结点
   {  if (tw==W && tv>maxv) 		//找到一个满足条件的更优解,保存
      {  maxv=tv;
         for (j=1;j<=n;j++)		//复制最优解
            x[j]=op[j];
      }
   }
   else					//尚未找完所有物品
   {  if (tw+w[i]<=W)			//左孩子结点剪枝
      {  op[i]=1;			//选取第i个物品
         dfs(i+1,tw+w[i],tv+v[i],rw-w[i],op);
      }
      op[i]=0;				//不选取第i个物品,回溯
      if (tw+rw>W)			//右孩子结点剪枝
         dfs(i+1,tw,tv,rw-w[i],op);
   }
}
``


```

# C1 概论（填空题）

## 算法时间复杂度分析

### 填空题

![image-20220705053821372](算法2_imgs\CJVvzdyT8hG.png)

![image-20220705054435162](算法2_imgs\ZD9clkznG5i.png)

![image-20220705055112455](算法2_imgs\1Tk8wyWRQjj.png)

![image-20220705055949295](算法2_imgs\uanTLhf5xde.png)

# C3 分治法（填空题、程序填空题）

对于一个规模为n的问题：若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。
这种算法设计策略叫做分治法。

## 寻找一个序列中第k小的元素

【问题描述】对于给定的含有n元素的无序序列，求这个序列中第k（1≤k≤n）小的元素。

【问题求解】假设无序序列存放在a[0..n-1]中，若将a递增排序，则第k小的元素为a[k-1]。
采用类似于快速排序的思想。

对于序列a[s..t]，在其中查找第k小元素的过程如下：

将a[s]作为基准划分，其对应下标为i。3种情况：

若k-1=i，a[i]即为所求，返回a[i]。

若k-1<i，第k小的元素应在a[s..i-1]子序列中，递归在该子序列中求解并返回其结果。

若k-1>i，第k小的元素应在a[i+1..t]子序列中，递归在该子序列中求解并返回其结果。

```cpp
int QuickSelect(int a[]，int s，int t，int k)
//在a[s..t]序列中找第k小的元素
{  int i=s，j=t,tmp;
   if (s<t)
   {  tmp=a[s];
      while (i!=j) 		 //从区间两端交替向中间扫描，直至i=j为止
      {  while (j>i && a[j]>=tmp) j--;
　　　　　a[i]=a[j];		//将a[j]前移到a[i]的位置
　　　　　while (i<j && a[i]<=tmp) i++;
　　　　　a[j]=a[i];		//将a[i]后移到a[j]的位置
      }
      a[i]=tmp;
      if (k-1==i) return a[i];
      else if (k-1<i) return QuickSelect(a，s，i-1，k);	
				//在左区间中递归查找
      else return QuickSelect(a，i+1，t，k);			
				//在右区间中递归查找
   }
   else if (s==t && s==k-1)	//区间内只有一个元素且为a[k-1]
      return a[k-1];
}
```



【算法分析】对于QuickSelect(a，s，t，k)算法，设序列a中含有n个元素，其比较次数的递推式为：
　　T(n)=T(n/2)+O(n)
　　可以推导出T(n)=O(n)，这是最好的情况，即每次划分的基准恰好是中位数，将一个序列划分为长度大致相等的两个子序列。
　　在最坏情况下，每次划分的基准恰好是序列中的最大值或最小值，则处理区间只比上一次减少1个元素，此时比较次数为O(n2)。
　　在平均情况下该算法的时间复杂度为O(n)。

### 填空题

递推式：T(n) = T(n/2)+O(n)

最好情况：T(n) = T(n/2)+O(n)  -- >  O(n)

最坏情况：O(n2)

平均情况：O(n)

### 程序填空题

递归部分：

```cpp
if (k-1==i) return a[i];//要找第k个元素，即下标为k-1的元素，找到返回
else if (k-1<i) return QuickSelect(a，s，i-1，k);//在左区间中递归查找
else return QuickSelect(a，i+1，t，k);	//在右区间中递归查找
//不用找i，因为已经判断过了不是
```

扫描部分

```cpp
//从区间两端交替向中间扫描，直至i=j为止，即碰到为止
while (i!=j){
    //当右边的小了，右边的往前替换
    while (j>i && a[j]>=tmp) j--;
	a[i]=a[j];		//将a[j]前移到a[i]的位置
    //当左边的大了，左边的往后替换
	while (i<j && a[i]<=tmp) i++;
    a[j]=a[i];		//将a[i]后移到a[j]的位置
}
```

## 寻找两个等长有序序列的中位数

【问题描述】对于一个长度为n的有序序列（假设均为升序序列）a[0..n-1]，处于中间位置的元素称为a的中位数。
    设计一个算法求给定的两个有序序列的中位数。 　

【问题求解】对于含有n个元素的有序序列a[s..t]，当n为奇数时，中位数是出现在m=(s+t)/2处；当n为偶数时，中位数下标有m=(s+t)/2（下中位）和m=(s+t)/2+1（上中位）两个。为了简单，仅考虑中位数为m=(s+t)/2处。

采用二分法求含有n个有序元素的序列a、b的中位数的过程如下：

分别求出a、b的中位数a[m1]和b[m2]：

① 若a[m1]=b[m2]，则a[m1]或b[m2]即为所求中位数，算法结束。 　

② 若a[m1]<b[m2]，则舍弃序列a中前半部分（较小的一半），同时舍弃序列b中后半部分（较大的一半）要求舍弃的长度相等。

③ 若a[m1]>b[m2]，则舍弃序列a中后半部分（较大的一半），同时舍弃序列b中前半部分（较小的一半），要求舍弃的长度相等。

画图：舍弃头尾

```cpp
int midnum(int a[]，int s1，int t1，int b[]，int s2，int t2)
{  //求两个有序序列a[s1..t1]和b[s2..t2]的中位数
　　int m1，m2;
　　if (s1==t1 && s2==t2)     //两序列只有一个元素时返回较小者
　　　　return a[s1]<b[s2]?a[s1]:b[s2];
　　else
　　{  m1=(s1+t1)/2;		//求a的中位数
　　   m2=(s2+t2)/2;		//求b的中位数
　　   if (a[m1]==b[m2])	//两中位数相等时返回该中位数
　　　　　　return a[m1];
　　   if (a[m1]<b[m2])	//当a[m1]<b[m2]时
　　   {   postpart(s1，t1);	//a取后半部分
　　　     prepart(s2，t2);	//b取前半部分
　　　　   return midnum(a，s1，t1，b，s2，t2);
　　   }
　     else			//当a[m1]>b[m2]时
　     {  prepart(s1，t1);	//a取前半部分
　　      postpart(s2，t2);	//b取后半部分
　　      return midnum(a，s1，t1，b，s2，t2);
　　   }
　　}
}
```

【算法分析】对于含有n个元素的有序序列a和b，设调用midnum(a，0，n-1，b，0，n-1)求中位数的执行时间为T(n)，显然有以下递归式：

![image-20220705061621314](算法2_imgs\NKhXjpUOFuc.png)

容易推出，T(n)=O(log2n)。

### 填空题

递推式：

![image-20220705061621314](算法2_imgs\NKhXjpUOFuc.png)

复杂度：T(n)=O(log2n)

### 程序填空题

判断逻辑：如果中位数相等则返回，不相等则舍弃头尾

临界条件：两个序列只有一个元素时返回较小者

## 求解连续子序列和问题

   【问题描述】给定一个有n（n≥1）个整数的序列，要求求出其中最大连续子序列的和。
     例如：
     序列（-2，11，-4，13，-5，-2）的最大子序列和为20
     序列（-6，2，4，-7，5，3，2，-1，6，-9，10，-2）的最大子序列和为16。
     规定一个序列最大连续子序列和至少是0，如果小于0，其结果为0。

【问题求解】对于含有n个整数的序列a[0..n-1]，若n=1，表示该序列仅含一个元素，如果该元素大于0，则返回该元素；否则返回0。
 若n>1，采用分治法求解最大连续子序列时，取其中间位置mid=(n-1)/2，该子序列只可能出现3个地方。
（1）该子序列完全落在左半部即a[0..mid]中。采用递归求出其最大连续子序列和maxLeftSum。

   （2）该子序列完全落在右半部即a[mid+1..n-1]中。采用递归求出其最大连续子序列和maxRightSum。

（3）该子序列跨越序列a的中部而占据左右两部分。

```cpp
long maxSubSum(int a[]，int left，int right)	
//求a[left..high]序列中最大连续子序列和
{  int i，j;
   long maxLeftSum，maxRightSum;
   long maxLeftBorderSum，leftBorderSum;
   long maxRightBorderSum，rightBorderSum;
   if (left==right)		//子序列只有一个元素时
   {　　if (a[left]>0) 	//该元素大于0时返回它
　　　　　　return a[left];
　　　　else			//该元素小于或等于0时返回0
　　　　　　　return 0; 
   } 
　　int mid=(left+right)/2;			//求中间位置
　　maxLeftSum=maxSubSum(a，left，mid);	//求左边
　　maxRightSum=maxSubSum(a，mid+1，right);	//求右边
　　maxLeftBorderSum=0，leftBorderSum=0;
　　for (i=mid;i>=left;i--)　			//求出以左边加上a[mid]元素
　　{  leftBorderSum+=a[i];　			//构成的序列的最大和
　     if (leftBorderSum>maxLeftBorderSum)
　　　　　　maxLeftBorderSum=leftBorderSum;
　　}
　　maxRightBorderSum=0，rightBorderSum=0;
　　for (j=mid+1;j<=right;j++)		//求出a[mid]右边元素
　　{  rightBorderSum+=a[j];  		//构成的序列的最大和
　　   if (rightBorderSum>maxRightBorderSum)
　　　　　　maxRightBorderSum=rightBorderSum;
　　}
　　return max3(maxLeftSum，maxRightSum，
		   maxLeftBorderSum+maxRightBorderSum); 
} 

```

【算法分析】设求解序列a[0..n-1]最大连续子序列和的执行时间为T(n)，第（1）、（2）两种情况的执行时间为T(n/2)，第（3）种情况的执行时间为O(n)，所以得到以下递推式：

![image-20220705062119704](算法2_imgs\syIPYnMkncM.png)

容易推出，T(n)=O(nlog2n)。

### 填空题

递推式：

![image-20220705062119704](算法2_imgs\syIPYnMkncM.png)

复杂度：T(n)=O(nlog2n)

### 程序填空题

判断逻辑：落在中间的情况，左边子序列的最大值就是从中点开始往左数，右边子序列的最大值就是从中点+1开始往右数，注意中点不要重复使用；最后要将落在中间的情况、落在左边的情况、落在右边的情况求出最大值

临界条件：子序列只有一个元素时，如果元素大于0则返回该元素，否则返回0

# C4 蛮力法（程序填空题）

　　蛮力法是一种简单直接地解决问题的方法，通常直接基于问题的描述和所涉及的概念定义，找出所有可能的解。
　　然后选择其中的一种或多种解，若该解不可行则试探下一种可能的解。

## 求解连续子序列和问题

   【问题描述】给定一个有n（n≥1）个整数的序列，要求求出其中最大连续子序列的和。
    例如：
    序列（-2，11，-4，13，-5，-2）的最大子序列和为20
    序列（-6，2，4，-7，5，3，2，-1，6，-9，10，-2）的最大子序列和为16。
    规定一个序列最大连续子序列和至少是0，如果小于0，其结果为0。

【问题求解】　　解法1：设含有n个整数的序列a[0..n-1]，其中任何连续子序列a[i..j]（i≤j，0≤i≤n-1，i≤j≤n-1）求出它的所有元素之和thisSum。
    通过比较将最大值存放在maxSum中，最后返回maxSum。

　　解法2：改进前面的解法，在求两个相邻子序列和时，它们之间是关联的。
    例如a[0..3]子序列和=a[0]+a[1]+a[2]+a[3]，a[0..4]子序列和=a[0]+a[1]+a[2]+a[3]+a[4]，在前者计算出来后，求后者时只需在前者基础上加以a[4]即可，没有必须每次都重复计算。从而提高了算法效率。

　解法3：更一步改进解法2。
　 如果扫描中遇到负数，当前子序列和thisSum将会减小，若thisSum为负数，表明前面已经扫描的那个子序列可以抛弃了，则放弃这个子序列，重新开始下一个子序列的分析，并置thisSum为0。
　 若这个子序列和thisSum不断增加，那么最大子序列和maxSum也不断增加。

```cpp
int maxSubSum3(int a[],int n)
{  int i,maxSum=0,thisSum=0;
   for (i=0;i<n;i++)
   {  thisSum+=a[i];
      if (thisSum<0)        //若当前子序列和为负数，重新开始下一子序列
　　　　　thisSum=0;
      if (maxSum<thisSum)   //比较求最大连续子序列和
　　　　　maxSum=thisSum;
   }
   return maxSum;
}
```

### 程序填空题

在子序列和的基础上增加；如果当前子序列和为负数，重新开始下一个子序列

## 求解幂集问题

【问题描述】对于给定的正整数n（n≥1），求1～n构成的集合的所有子集（幂集）。

【问题求解】解法1：采用直接蛮力法求解，将1～n的存放在数组a中，求解问题变为构造集合a的所有子集。设集合a[0..2]={1，2，3}，其所有子集对应的二进制位及其十进制数如下。

![image-20220705065037091](算法2_imgs\5UlJCPgJJTZ.png)

对于含有n（n≥1）个元素的集合a，求幂集的过程如下：

for (i=0;i<2n;i++)	  //穷举a的所有子集并输出
{  将i转换为二进制数b;
   输出b中为1的位对应的a元素构成一个子集;
}

显然该算法的时间复杂度为O(n×2n)，属于指数级的算法。

首先b[0..2]=000，每调用一次inc，b表示十进制数的增加1

```cpp
void inc(int b[], int n)	//将b表示的二进制数增1
{  for(int i=0;i<n;i++)	//遍历数组b
   {  if (b[i])		//将元素1改为0
	 b[i]=0;
      else			//将元素0改为1并退出for循环
      {  b[i]=1;
         break;
      }
   }
}
void PSet(int a[],int b[],int n)	//求幂集
{  int i,k;
   int pw=(int)pow(2,n);		//求2^n
   printf("1～%d的幂集:\n  ",n);
   for(i=0;i<pw;i++)			//执行2^n次
   {	printf("{ ");
	for (k=0;k<n;k++)		//执行n次
	   if(b[k])
	      printf("%d ",a[k]);
	printf("} ");
	inc(b,n);			//b表示的二进制数增1
   }
   printf("\n");
}
```

解法2：采用增量蛮力法求解1～n的幂集，当n=3时的求解过程。

![image-20220705065352793](算法2_imgs\rNBIGuVb8VB.png)

```cpp
#include <stdio.h>
#include <vector>
using namespace std;
vector<vector<int> > ps;		//存放幂集
void PSet(int n)			//求1～n的幂集ps
{  vector<vector<int> > ps1;		//子幂集
   vector<vector<int> >::iterator it;//幂集迭代器
   vector<int> s;
   ps.push_back(s);			//添加{}空集合元素
   for (int i=1;i<=n;i++)		//循环添加1～n
   {  ps1=ps;				//ps1存放上一步得到的幂集
      for (it=ps1.begin();it!=ps1.end();++it)
	 (*it).push_back(i);		//在ps1的每个集合元素末尾添加i
      for (it=ps1.begin();it!=ps1.end();++it)
	 ps.push_back(*it);		//将ps1的每个集合元素添加到ps中
   }
}
```

   【算法分析】对于给定的n，每一个集合元素都要处理，有2n个，所以上述算法的时间复杂度为O(2n)。

### 程序填空题

蛮力法 --> 对应二进制位

```cpp
void inc(int b[], int n)	//将b表示的二进制数增1
{  for(int i=0;i<n;i++)	//遍历数组b
   {  if (b[i])		//将元素1改为0
	 b[i]=0;
      else			//将元素0改为1并退出for循环
      {  b[i]=1;
         break;
      }
   }
}
```

增量法 --> 每次增加元素形成子集添加到原序列中

```cpp
void PSet(int n)			//求1～n的幂集ps
{  vector<vector<int> > ps1;		//子幂集
   vector<vector<int> >::iterator it;//幂集迭代器
   vector<int> s;
   ps.push_back(s);			//添加{}空集合元素
   for (int i=1;i<=n;i++)		//循环添加1～n
   {  ps1=ps;				//ps1存放上一步得到的幂集
      for (it=ps1.begin();it!=ps1.end();++it)
	 (*it).push_back(i);		//在ps1的每个集合元素末尾添加i
      for (it=ps1.begin();it!=ps1.end();++it)
	 ps.push_back(*it);		//将ps1的每个集合元素添加到ps中
   }
}
```

## 求解简单0/1背包问题

　　【问题描述】有n个重量分别为{w1，w2，…，wn}的物品，它们的价值分别为{v1，v2，…，vn}，给定一个容量为W的背包。设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，而且具有最大的价值。
　　并对下表所示的4个物品求出W=6时的所有解和最佳解。

　　【问题求解】对于n个物品、容量为W的背包问题，采用前面求幂集的方法求出所有的物品组合。
　　对于每一种组合，计算其总重量sumw和总价值sumv，当sumw小于等于W时，该组合是一种解，并通过比较将最佳方案保存在maxsumw和maxsumv中，最后输出所有的解和最佳解。

```cpp
#include <stdio.h>
#include <vector>
using namespace std;
vector<vector<int> > ps;		//存放幂集
void PSet(int n)			//求1～n的幂集ps
{  vector<vector<int> > ps1;		//子幂集
   vector<vector<int> >::iterator it;//幂集迭代器
   vector<int> s;
   ps.push_back(s);			//添加{}空集合元素
   for (int i=1;i<=n;i++)		//循环添加1～n
   {	ps1=ps;				//ps1存放上一步得到的幂集
	for (it=ps1.begin();it!=ps1.end();++it)
	  (*it).push_back(i);		//在ps1的每个集合元素末尾添加i
	for (it=ps1.begin();it!=ps1.end();++it)
	  ps.push_back(*it);		//将ps1的每个集合元素添加到ps中
   }
}
void Knap(int w[],int v[],int W)	//求所有的方案和最佳方案
{  int count=0;			//方案编号
   int sumw,sumv;			//当前方案的总重量和总价值
   int maxi,maxsumw=0,maxsumv=0;	//最佳方案的编号、总重量和总价值
   vector<vector<int> >::iterator it;	//幂集迭代器
   vector<int>::iterator sit;			//幂集集合元素迭代器
   printf("  序号\t选中物品\t总重量\t总价值\t能否装入\n");
   for (it=ps.begin();it!=ps.end();++it)	//扫描ps中每一个集合元素
   {	printf("  %d\t",count+1);
	sumw=sumv=0;
	printf("{");
	for (sit=(*it).begin();sit!=(*it).end();++sit)
	{   printf("%d ",*sit);
	    sumw+=w[*sit-1];			//w数组下标从0开始
	    sumv+=v[*sit-1];			//v数组下标从0开始
	}
      printf("}\t\t%d\t%d  ",sumw,sumv);
      if (sumw<=W)
      {  printf("能\n");
         if (sumv>maxsumv)			//比较求最优方案
         {  maxsumw=sumw;
            maxsumv=sumv;
            maxi=count;
         }
      }
      else printf("否\n");
      count++;					//方案编号增加1
   }
   printf("最佳方案为: ");
   printf("选中物品");
   printf("{ ");
   for (sit=ps[maxi].begin();sit!=ps[maxi].end();++sit)
	printf("%d ",*sit);
   printf("},");
   printf("总重量:%d,总价值:%d\n",maxsumw,maxsumv);
}
void main()
{  int n=4,W=6;
   int w[]={5,3,2,1};
   int v[]={4,4,3,1};
   PSet(n);
   printf("0/1背包的求解方案\n",n);
   Knap(w,v,W);
}
```

### 程序填空题

先求幂集，通过比较将最佳方案保存在maxsumw和maxsumv中，最后输出所有的解和最佳解。

## 求解全排列问题

【问题描述】对于给定的正整数n（n≥1），求1～n的所有全排列。

【问题求解】这里采用增量蛮力法求解。产生1～3全排列的过程如下：

![image-20220705070150824](算法2_imgs\65T5kOHFp2u.png)

```cpp
void Insert(vector<int> s,int i,vector<vector<int> > &ps1)
//在每个集合元素中间插入i得到ps1
{  vector<int> s1;
   vector<int>::iterator it;
   for (int j=0;j<i;j++)	//在s(含i-1个整数)的每个位置插入i
   {  s1=s;
      it=s1.begin()+j;	//求出插入位置
      s1.insert(it,i);	//插入整数i
      ps1.push_back(s1);	//添加到ps1中
   }
}
void Perm(int n)			//求1～n的所有全排列
{  vector<vector<int> > ps1;		//临时存放子排列
   vector<vector<int> >::iterator it;//全排列迭代器
   vector<int> s,s1;
   s.push_back(1);
   ps.push_back(s);			//添加{1}集合元素
   for (int i=2;i<=n;i++)		//循环添加1～n
   {  ps1.clear();			//ps1存放插入i的结果
      for (it=ps.begin();it!=ps.end();++it)
	 Insert(*it,i,ps1);		//在每个集合元素中间插入i得到ps1
      ps=ps1;
   }
}

```

​       【算法分析】对于给定的正整数n，每一种全排列都必须处理，有n!种，所以上述算法的时间复杂度为O(n*n!)。

### 程序填空题

循环将i插入到各个位置上

```cpp
ps.push_back(s);			//添加{1}集合元素
for (int i=2;i<=n;i++)		//循环添加1～n
{  ps1.clear();			//ps1存放插入i的结果
	for (it=ps.begin();it!=ps.end();++it)
		Insert(*it,i,ps1);		//在每个集合元素中间插入i得到ps1
		ps=ps1;
}
```

## 求解任务分配问题

【问题描述】有n（n≥1）个任务需要分配给n个人执行，每个任务只能分配给一个人，每个人只能执行一个任务。
第i个人执行第j个任务的成本是c\[i][j]（1≤i，j≤n）。求出总成本最小的分配方案。

【问题求解】所谓一种分配方案就是由第i个人执行第j个任务，用（a1，a2，…，an）表示，即第1个人执行第a1个任务，第2个人执行第a2个任务，以此类推。全部的分配方案恰好是1～n的全排列。
 这里采用增量穷举法求出所有的分配方案ps（全排列），再计算出每种方案的成本，比较求出最小成本的方案，即最优方案。以n=4，成本如下表所示为例讨论。

```cpp
//问题表示
int n=4;
int c[MAXN][MAXN]={ {9,2,7,8},{6,4,3,7},{5,8,1,8},{7,6,9,4} };
vector<vector<int> > ps;	//存放全排列
void Insert(vector<int> s,int i,vector<vector<int> > &ps1)
//在每个集合元素中间插入i得到ps1
{  vector<int> s1;
   vector<int>::iterator it;
   for (int j=0;j<i;j++)	//在s(含i-1个整数)的每个位置插入i
   {	s1=s;
	it=s1.begin()+j;	//求出插入位置
	s1.insert(it,i);	//插入整数i
	ps1.push_back(s1);	//添加到ps1中
   }
}
void Perm(int n)			   //求1～n的所有全排列
{  vector<vector<int> > ps1;		   //临时存放子排列
   vector<vector<int> >::iterator it;  //全排列迭代器
   vector<int> s,s1;
   s.push_back(1);
   ps.push_back(s);			   //添加{1}集合元素
   for (int i=2;i<=n;i++)		   //循环添加1～n
   {	ps1.clear();			   //ps1存放插入i的结果
	for (it=ps.begin();it!=ps.end();++it)
	   Insert(*it,i,ps1);	  //在每个集合元素中间插入i得到ps1
	ps=ps1;
   }
}
void Allocate(int n,int &mini,int &minc)
//求任务分配问题的最优方案
{  Perm(n);				//求出全排列ps
   for (int i=0;i<ps.size();i++)	//求每个方案的成本
   {  int cost=0;
      for (int j=0;j<ps[i].size();j++)
	  cost+=c[j][ps[i][j]-1];
      if (cost<minc)			//比较求最小成本的方案
      {  minc=cost;
         mini=i;
      }
   }
}
void main()
{  int mincost=INF,mini;			   
		//mincost为最小成本,mini为ps中最优方案编号
   Allocate(n,mini,mincost);
   printf("最优方案:\n");
   for (int k=0;k<ps[mini].size();k++)
	printf("   第%d个人安排任务%d\n",k+1,ps[mini][k]);
   printf("   总成本=%d\n",mincost);
}
```

### 程序填空题

先求全排列，根据每一种排列计算总成本记录最小成本

# C5 回溯法（填空题、判断题、算法复杂度分析）

## 回溯法概述

回溯法实际上一个类似穷举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”（即回退），尝试别的路径。 

**回溯法原理：**

在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点（开始结点）出发搜索解空间树。

首先根结点成为活结点（活结点是指自身已生成但其孩子结点没有全部生成的结点），同时也成为当前的扩展结点（扩展结点是指正在产生孩子结点的结点）。

在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为新的活结点，并成为当前扩展结点。

如果在当前的扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点（死结点是指由根结点到该结点构成的部分解不满足约束条件，或者其子结点已经搜索完毕）。

此时应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。

回溯法以这种方式递归地在解空间中搜索，直至找到所要求的解或解空间中已无活结点为止。

当从状态si搜索到状态si+1后，如果si+1变为死结点，则从状态si+1回退到si，再从si找其他可能的路径，所以回溯法体现出走不通就退回再走的思路。

若用回溯法求问题的所有解时，需要回溯到根结点，且根结点的所有可行的子树都要已被搜索完才结束。而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。

回溯法搜索解空间时，通常采用两种策略避免无效搜索，提高回溯的搜索效率:　

- 用<u>约束函数</u>在扩展结点处剪除不满足约束的子树；

- 用<u>限界函数</u>剪去得不到问题解或最优解的子树。

这两类函数统称为<u>剪枝函数</u>。

归纳起来，用回溯法解题的一般步骤如下：

- 针对所给问题，确定问题的解空间树，问题的解空间树应至少包含问题的一个（最优）解。
- 确定结点的扩展搜索规则。
- 以深度优先方式搜索解空间树，并在搜索过程中可以采用剪枝函数来避免无效搜索。

**回溯法与深度优先遍历的异同：**

两者的相同点：

回溯法在实现上也是遵循深度优先的，即一步一步往前探索，而不像广度优先遍历那样，由近及远一片一片地搜索。

两者的不同点：
（1）访问序不同：深度优先遍历目的是“遍历”，本质是无序的。而回溯法目的是“求解过程”，本质是有序的。
（2）访问次数的不同：深度优先遍历对已经访问过的顶点不再访问，所有顶点仅访问一次。而回溯法中已经访问过的顶点可能再次访问。
（3）剪枝的不同：深度优先遍历不含剪枝，而很多回溯算法采用剪枝条件剪除不必要的分枝以提高效能。

**回溯法算法的时间分析**

通常情况下，回溯法的效率会高于蛮力法。 

### 填空题

剪枝函数-->约束函数、限界函数

子集树、排列树

### 判断题

回溯法和深度优先的不同：访问序、访问次数、剪枝

## 求解0/1背包问题

【问题描述】有n个重量分别为{w1，w2，…，wn}的物品，它们的价值分别为{v1，v2，…，vn}，给定一个容量为W的背包。
    设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，而且重量和恰好为W具有最大的价值。

【问题求解】第4章采用蛮力法求解，这里采用回溯法求解该问题。
 用x[1..n]数组存放最优解，其中每个元素取1或0，x[i]=1表示第i个物品放入背包中，x[i]=0表示第i个物品不放入背包中。
 为了更清楚地描述算法，将这些给定的算法输入设计成全局变量。
 这是一个求最优解问题。

​    对第i层上的某个分枝结点，对应的状态为dfs(i，tw，tv，op)，其中tw表示装入背包中的物品总重量，tv表示背包中物品总价值，op记录一个解向量。该状态的两种扩展如下：

（1）选择第i个物品放入背包：op[i]=1，tw=tw+w[i]，tv=tv+v[i]，转向下一个状态dfs(i+1，tw，tv，op)。该决策对应左分枝。
（2）不选择第i个物品放入背包：op[i]=0，tw不变，tv不变，转向下一个状态dfs(i+1，tw，tv，op)。该决策对应右分枝。

​    叶子结点表示已经对n个物品做了决策，对应一个解。对所有叶子结点进行比较求出满足tw≤W的最大tw，用maxv表示，对应的最优解op存放到x中。

![image-20220705071749197](算法2_imgs\cv0TbCQWTlj.png)

改进：左剪枝
对于第i层的有些结点，tw+a[i]已超过了W，显然再选择a[i]是不合适的。如第2层的（5，4）结点，tw=5，a[2]=3，而tw+a[2]>W，选择物品2进行扩展是不必要的，可以增加一个限界条件进行剪枝，如若选择物品i会导致超重即tw+w[i]>W，就不再扩展该结点，也就是仅仅扩展tw+w[i]≤W的左孩子结点。

改进：右剪枝
    用rw表示考虑第i个物品时剩余物品的重量。
    当不选择物品i时，若tw+rw≤W（注意rw中包含w[i]）时，也就是说即使选择后面的所有物品，重量也不会达到W，因此不必要再考虑扩展这样的结点，也就是说，对于右分枝仅仅扩展tw+rw>W的结点。

```cpp
//问题表示
int n=4;			//4种物品
int W=6;			//限制重量为6
int w[]={0,5,3,2,1};		//存放4个物品重量,不用下标0元素
int v[]={0,4,4,3,1};		//存放4个物品价值,不用下标0元素
//求解结果表示
int x[MAXN];			//存放最终解
int maxv; 			//存放最优解的总价值
void dfs(int i,int tw,int tv,int rw,int op[]) //求解0/1背包问题
{  //初始调用时rw为所有物品重量和
   int j;
   if (i>n)				//找到一个叶子结点
   {  if (tw==W && tv>maxv) 		//找到一个满足条件的更优解,保存
      {  maxv=tv;
         for (j=1;j<=n;j++)		//复制最优解
            x[j]=op[j];
      }
   }
   else					//尚未找完所有物品
   {  if (tw+w[i]<=W)			//左孩子结点剪枝
      {  op[i]=1;			//选取第i个物品
         dfs(i+1,tw+w[i],tv+v[i],rw-w[i],op);
      }
      op[i]=0;				//不选取第i个物品,回溯
      if (tw+rw>W)			//右孩子结点剪枝
         dfs(i+1,tw,tv,rw-w[i],op);
   }
}
```

   【算法分析】该算法不考虑剪枝时解空间树中有2n+1-1个结点，对应的算法时间复杂度为O(2n)。

### 算法复杂度分析

左剪枝 --> 超重

右剪枝 --> 剩下的物品不满足重量

时间复杂度O(2n)(2的n次方)-->每次一个问题选择或者不选择

## 求解n皇后问题

非递归回溯算法对应的算法：

```cpp
void Queens(int n)	//求解n皇后问题
{  int i=1;		//i表示当前行,也表示放置第i个皇后
   q[i]=0;		//q[i]是当前列,每个新考虑的皇后初始位置置为0列
   while (i>=1)	//尚未回溯到头，循环
   {  q[i]++;		//原位置后移动一列
      while (q[i]<=n && !place(i))  //试探一个位置(i,q[i])
        q[i]++;//不能放则继续向后移动
      if (q[i]<=n)	//为第i个皇后找到了一个合适位置(i,q[i])
      {  if (i==n)	//若放置了所有皇后,输出一个解
           dispasolution(n);
         else		//皇后没有放置完
         {  i++;	//转向下一行,即开始下一个新皇后的放置
            q[i]=0;	//每个新考虑的皇后初始位置置为0列
         }
      }
      else i--; 	//若第i个皇后找不到合适的位置,则回溯到上一个皇后
   }
}
bool place(int i)	//测试第i行的q[i]列上能否摆放皇后
{  int j=1;
   if (i==1) return true;
   while (j<i)			//j=1～i-1是已放置了皇后的行
   {  if ((q[j]==q[i]) || (abs(q[j]-q[i])==abs(j-i))) 
	//该皇后是否与以前皇后同列，位置(j,q[j])与(i,q[i])是否同对角线
	 return false;
      j++;
   }
   return true;
}
```

【算法分析】该算法中每个皇后都要试探n列，共n个皇后，其解空间是一棵子集树，不同于前面一般的二叉树子集树，这里每个结点可能有n棵子树。
     对应的算法时间复杂度为O(n^n)。

### 算法复杂度分析

以行为递归选择列or以列为递归选择行-->算法时间复杂度都为O（n^n）(n的n次方)-->n个行对应n个列的解决结果

## 求解活动安排问题

【问题描述】假设有一个需要使用某一资源的n个活动所组成的集合S，S={1，…，n}。该资源任何时刻只能被一个活动所占用，活动i有一个开始时间bi和结束时间ei（bi<ei），其执行时间为ei-bi，假设最早活动执行时间为0。
一旦某个活动开始执行，中间不能被打断，直到其执行完毕。若活动i和活动j有bi≥ej或bj≥ei，则称这两个活动兼容。
设计算法求一种最优活动安排方案，使得所有安排的活动个数最多。

【问题求解】这里采用回溯法求解，相当于找到S={1，…，n}的某个排列即调度方案，使得其中所有兼容活动的执行时间和最大，显然对应的解空间是一个是排列树。
    直接采用排列树递归框架实现，对于每一种调度方案求出所有兼容活动个数，通过比较求出最多活动个数，对应的调度方案就是最优调度方案，即为本问题的解。

```cpp
//问题表示
struct Action
{  int b;				//活动起始时间
   int e;				//活动结束时间
};
int n=4;
Action A[]={ {0,0},{1,3},{2,5},{4,8},{6,10} }; //下标0不用
//结果表示
int x[MAX];		//临时解向量,初始化为1-n，代表任务执行的顺序
int bestx[MAX];	//最优解向量
int laste=0;		//一个调度方案中最后兼容活动的结束时间,初值为0
int sum=0;		//一个调度方案中所有兼容活动个数,初值为0
int maxsum=0;		
void dfs(int i)	//搜索活动问题最优解
{  if (i>n)		//到达叶子结点,产生一种调度方案
   {  if (sum>maxsum)
      {  maxsum=sum;
         for (int k=1;k<=n;k++)
            bestx[k]=x[k];
      }
   }
   else
   {  for(int j=i; j<=n; j++)	  	//没有到达叶子结点,考虑i到n的活动
      {    //第i层结点选择活动x[j]
         int sum1=sum;		//保存sum，laste以便回溯
         int laste1=laste;
         if (A[x[j]].b>=laste)	//活动x[j]与前面兼容
         {  sum++;			//兼容活动个数增1
            laste=A[x[j]].e;		//修改本方案的最后兼容时间
         }
         swap(x[i],x[j]);//排序树问题递归框架:交换x[i],x[j]，第i个执行的任务是x[j]
         dfs(i+1);		//排序树问题递归框架:进入下一层
         swap(x[i],x[j]);	//排序树问题递归框架:交换x[i],x[j],回到原来的状态以供下次交换
         sum=sum1;		//回溯
         laste=laste1;	//即撤销第i层结点对活动x[j]的选择
      }
   }
}
```

   【算法分析】该算法对应解空间树是一棵排列树，与求全排列算法的时间复杂度相同，即为O(n!)。

### 算法复杂度分析

时间复杂度-->O(n!)

空间复杂度-->O(n)

# C6 分支界限法（判断题、算法过程分析）

**队列式分枝限界法**

- 将根结点加入活结点队列。
- 从活结点队中取出队头结点，作为当前扩展结点。
- 对当前扩展结点，先从左到右地产生它的所有孩子结点，用约束条件检查，把所有满足约束条件的孩子结点加入活结点队列。
- 重复步骤②和③，直到找到一个解或活结点队列为空为止。

**优先队列式分枝限界法**

优先队列式分枝限界法的主要特点是将活结点表组组成一个优先队列，并选取优先级最高的活结点成为当前扩展结点。

### 判断题

活结点队列、优先队列、广度遍历

## 求解0/1背包问题

【问题描述】有n个重量分别为{w1，w2，…，wn}的物品，它们的价值分别为{v1，v2，…，vn}，给定一个容量为W的背包。
设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，而且重量和为W具有最大的价值。

![image-20220704192449761](算法2_imgs\8KN8iqWTkPi.png)

对于第i层的某个结点e，用e.w表示结点e时已装入的总重量，用e.v表示已装入的总价值：

如果所有剩余的物品都能装入背包，那么价值的上界e.ub=e.v+ (v[i+1]+…+v[n])
如果所有剩余的物品不能全部装入背包，那么价值的上界e.ub=e.v+ (v[i+1]+…+v[k])+(物品k+1装入的部分重量)×物品k+1的单位价值//这里必须按性价比降序排序

```cpp
//问题表示
int n=3,W=30;
int w[]={0,16,15,15};		//重量，下标0不用
int v[]={0,45,25,25};  	//价值，下标0不用，已经按性价比降序排序
//求解结果表示
int maxv=-9999;		//存放最大价值,初始为最小值
int bestx[MAXN];		//存放最优解,全局变量
int total=1;			//解空间中结点数累计,全局变量
struct NodeType		//队列中的结点类型
{  int no;			//结点编号
   int i;			//当前结点在搜索空间中的层次
   int w;			//当前结点的总重量
   int v;			//当前结点的总价值
   int x[MAXN];		//当前结点包含的解向量
   double ub;			//上界
};
void EnQueue(NodeType e,queue<NodeType> &qu)
//结点e进队qu
{  if (e.i==n)					//到达叶子结点
   {  if (e.v>maxv)				//找到更大价值的解
      {  maxv=e.v;
         for (int j=1;j<=n;j++)
           bestx[j]=e.x[j];
      }
   }
   else qu.push(e);				//非叶子结点进队
}
void bound(NodeType &e)			//计算分枝结点e的上界
{  int i=e.i+1;				//考虑结点e的余下物品
   int sumw=e.w;				//求已装入的总重量
   double sumv=e.v;				//求已装入的总价值
   while ((sumw+w[i]<=W) && i<=n)
   {  sumw+=w[i];				//计算背包已装入载重
      sumv+=v[i];				//计算背包已装入价值
      i++;
   }
   if (i<=n)					//余下物品只能部分装入
      e.ub=sumv+(W-sumw)*v[i]/w[i];//？？？为什么这么写？？？
   else						//余下物品全部可以装入
      e.ub=sumv;
}
void bfs()				//求0/1背包的最优解
{  int j;
   NodeType e,e1,e2;			//定义3个结点
   queue<NodeType> qu;		//定义一个队列
   e.i=0;				//根结点置初值，其层次计为0
   e.w=0; e.v=0;
   e.no=total++; 
   for (j=1;j<=n;j++)
	e.x[j]=0;
   bound(e);				//求根结点的上界
   qu.push(e);				//根结点进队
  while (!qu.empty())				//队不空循环
  {  e=qu.front(); qu.pop();			//出队结点e
     if (e.w+w[e.i+1]<=W)			//剪枝：检查左孩子结点
     {  e1.no=total++; e1.i=e.i+1;		//建立左孩子结点
        e1.w=e.w+w[e1.i];
        e1.v=e.v+v[e1.i];
        for (j=1;j<=n;j++)			//复制解向量
           e1.x[j]=e.x[j];
        e1.x[e1.i]=1;
        bound(e1);				//求左孩子结点的上界
        EnQueue(e1,qu);			//左孩子结点进队操作
     }
     e2.no=total++;				//建立右孩子结点
     e2.i=e.i+1;
     e2.w=e.w; e2.v=e.v;
     for (j=1;j<=n;j++)			//复制解向量
        e2.x[j]=e.x[j];
     e2.x[e2.i]=0;
     bound(e2);				//求右孩子结点的上界
     if (e2.ub>maxv)		//若右孩子结点可行,则进队,否则被剪枝
        EnQueue(e2,qu);
   }
}

```

**优先队列法**

```cpp
struct NodeType		//队列中的结点类型
{  int no;			//结点编号
   int i;			//当前结点在搜索空间中的层次
   int w;			//当前结点的总重量
   int v;			//当前结点的总价值
   int x[MAXN];		//当前结点包含的解向量
   double ub;			//上界
   bool operator<(const NodeType &s) const	//重载<关系函数
   {
      return ub<s.ub;		//ub越大越优先出队
   }
};
```

### 算法过程分析

如果所有剩余的物品都能装入背包，那么价值的上界e.ub=e.v+ (v[i+1]+…+v[n])
如果所有剩余的物品不能全部装入背包，那么价值的上界e.ub=e.v+ (v[i+1]+…+v[k])+(物品k+1装入的部分重量)×物品k+1的单位价值//这里必须按性价比降序排序

每次结点入队先求上界、左剪枝要求重量不超过、右剪枝要求期待价值大于目前最大价值

# C7 贪心法（填空题）

## 求解活动安排问题

【问题描述】假设有一个需要使用某一资源的n个活动所组成的集合S，S={1，…，n}。该资源任何时刻只能被一个活动所占用，活动i有一个开始时间bi和结束时间ei（bi<ei），其执行时间为ei-bi，假设最早活动执行时间为0。一旦某个活动开始执行，中间不能被打断，直到其执行完毕。若活动i和活动j有bi≥ej或bj≥ei，则称这两个活动兼容。设计算法求一种最优活动安排方案，使得所有安排的活动个数最多。
【问题求解】假设活动时间的参考原点为0。一个活动i（1≤i≤n）用一个区间[bi，ei)表示.当活动按结束时间（右端点）递增排序后，两个活动[bi，ei)和[bj，ej)兼容（满足bi≥ej或bj≥ei）实际上就是指它们不相交。用数组A存放所有的活动，A[i].b（1≤i≤n），存放活动起始时间，A[i].e存放活动结束时间。

```cpp
//问题表示
struct Action			//活动的类型声明
{  int b;			//活动起始时间
   int e;			//活动结束时间
   bool operator<(const Action &s) const	//重载<关系函数
   {
	return e<=s.e;		//用于按活动结束时间递增排序
   }
};
int n=11;//一共11项活动
Action A[]={ {0},{1,4},{3,5},{0,6},{5,7},{3,8},{5,9},{6,10},{8,11},
	 {8,12},{2,13},{12,15} };	//下标0不用
//求解结果表示
bool flag[MAX];		//标记选择的活动
int Count=0;		//选取的兼容活动个数
void solve()				//求解最大兼容活动子集
{  
   memset(flag,0,sizeof(flag));	//初始化为false
   sort(A+1,A+n+1);			//A[1..n]按活动结束时间递增排序
   int preend=0;			//前一个兼容活动的结束时间
   for (int i=1;i<=n;i++)		//扫描所有活动
   {  if (A[i].b>=preend)		//找到一个兼容活动
      {  flag[i]=true;		//选择A[i]活动
         preend=A[i].e;		//更新preend值
      }
   }
}

```

【算法分析】算法的主要时间花费在排序上，排序时间为O(nlog2n)，所以整个算法的时间复杂度为O(nlog2n)。

### 填空题

以结束时间递增排序后，从活动1开始选择

## 求解背包问题

【问题描述】设有编号为1、2、…、n的n个物品，它们的重量分别为w1、w2、…、wn，价值分别为v1、v2、…、vn，其中wi、vi（1≤i≤n）均为正数。有一个背包可以携带的最大重量不超过W。求解目标：在不超过背包负重的前提下，使背包装入的总价值最大（即效益最大化），与0/1背包问题的区别是，这里的每个物品可以取一部分装入背包。

【问题求解】贪心策略：选择单位重量价值最大的物品。每次从物品集合中选择单位重量价值最大的物品，如果其重量小于背包容量，就可以把它装入，并将背包容量减去该物品的重量，然后就面临了一个最优子问题——它同样是背包问题，只不过背包容量减少了，物品集合减少了。
因此背包问题具有<u>最优子结构</u>性质。

```cpp
//问题表示
int n=5;
double W=100;				//限重
struct NodeType
{  double w;
   double v;
   double p;				//p=v/w
   bool operator<(const NodeType &s) const
   {
	return p>s.p;			//按p递减排序
   }
};
NodeType A[]={ {0},{10,20},{20,30},{30,66},{40,40},{50,60} };//下标0不用
//求解结果表示
double V;				//最大价值
double x[MAXN];
void Knap()			//求解背包问题并返回总价值
{  V=0;				//V初始化为0
   double weight=W;		//背包中能装入的余下重量
   memset(x,0,sizeof(x));	//初始化x向量
   int i=1;
   while (A[i].w<weight)	//物品i能够全部装入时循环
   {  x[i]=1;			//装入物品i
      weight-=A[i].w;		//减少背包中能装入的余下重量
      V+=A[i].v;		//累计总价值
      i++;			//继续循环
   }
   if (weight>0)		//当余下重量大于0
   {  x[i]=weight/A[i].w;	//将物品i的一部分装入
      V+=x[i]*A[i].v;		//累计总价值
   }
}
void main()
{  printf("求解过程\n");
   for (int i=1;i<=n;i++)		//求v/w
     A[i].p=A[i].v/A[i].w;
   printf("(1)排序前\n");dispA();
   sort(A+1,A+n+1);			//A[1..n]排序
   printf("(2)排序后\n"); dispA();
   Knap();
   printf("(3)求解结果\n");		//输出结果
   printf("    x: [");
   for (int j=1;j<=n;j++)
      printf("%g, ",x[j]);
   printf("%g]\n",x[n]);
   printf("    总价值=%g\n",V);
}
```

### 填空题

以性价比降序排序，可以装一部分物品进入背包

## 用贪心法求解的问题应该具有的性质

1. 贪心选择性质：

   所谓贪心选择性质是指<u>所求问题的整体最优解可以通过一系列局部最优的选择</u><u>，即贪心选择来达到</u>。也就是说，贪心法仅在当前状态下做出最好选择，即局部最优选择，然后再去求解做出这个选择后产生的相应子问题的解。 

2. 最优子结构性质

   如果<u>一个问题的最优解包含其子问题的最优解</u>，则称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心法求解的关键特征。

### 填空题

贪心选择性质、最优子结构性质

## 证明一个问题适用贪心算法

**数学归纳法**

- 证明当n= 1时命题成立。
- 假设n=m时命题成立，那么可以推导出在n=m+1时命题也成立。（m代表任意自然数）

**反证法**

首先假设某命题成立（即在原命题的条件下，结论不成立），然后推理出明显矛盾的结果，从而下结论说原假设不成立，原命题得证。

**集装箱问题**
n个集装箱1,2…,n装上轮船，集装箱i的重量为w i w_iw i

轮船载重量限制为c cc ,无体积限制。如何使装上船的集装箱最多。(假设每个集装箱重量小于c)

贪心策略：将集装箱按照从轻到重排序，轻者先装

这里用的反证法，首先证明n=1时贪心选择得到最优解；

设对于n-1，即N={1,2,...,n}的输入，最优解为I，选择的总重量为c

由上得N' = {2,3,...,n},重量c' = c - w1,最优解I’,满足I = {1}UI‘

证明没有比I更大的解

如果存在包含1的关于N的最优解I\*，I\*的数量大于I，如果I*中没有1，用1替换I\*中的第一个元素得到的解也是最优解

那么I* - {1} 是N'的解且|I*-{1}|是N’的解且|I\*-{1}|>|I-{1}|=|I'|

与I‘的最优性矛盾

**活动安排问题**

增量的量级是选中的任务数量

通常证明一个贪心选择得出的解是最优解的一般的方法是，构造一个初始最优解，然后对该解进行修正，使其第一步为一个贪心选择，证明总是存在一个以贪心选择开始的求解方案。

对于本问题，所有活动按结束时间递增排序，就是要证明：若X是活动安排问题A的最优解，X=X'∪{1}（任务一），则X'是A'={i∈A：ei≥b1}的活动安排问题的最优解。（一定存在一个最优解，以任务一开始）

首先证明总存在一个以活动1开始的最优解。

如果第一个选中的活动为k（k≠1），可以构造另一个最优解Y，Y中的活动是兼容的，Y与X的活动数相同。

那么用活动1取代活动k得到Y'，因为e1≤ek，所以Y'中的活动是兼容的，即Y'也是最优的，这就说明总存在一个以活动1开始的最优解。

当做出了对活动1的贪心选择后，原问题就变成了在活动2、…、n中找与活动1兼容的那些活动的子问题。亦即，如果X为原问题的一个最优解，则X'=X-{1}也是活动选择问题A'={i∈A | bi≥e1}的一个最优解。

    反证法：如果能找到一个A'的含有比X'更多活动的解Y'，则将活动1加入Y'后就得到A的一个包含比X更多活动的解Y，这就与X是最优解的假设相矛盾。
    因此，在每一次贪心选择后，留下的是一个与原问题具有相同形式的最优化问题，即最优子结构性质。

**最小延迟调度问题**

![image-20220705082952911](算法2_imgs\OPnTJB28QWn.png)

贪心策略
按照截止时间：从小到大选择任务，安排时不留空闲时间

伪代码：

正确性证明：交换论证
上述算法的解的性质：没有空闲时间,没有逆序(不存在f ( i ) &lt; f ( j ) , d i &gt; d j 

命题1：所有没有逆序、没有空闲时间的调度具有相同的最大延迟

命题1证明：f 1 和 f 2 都没有逆序,具有相同截止时间的任务必须被连续安排。在这些连续安排的任务中最大延迟是最后一个任务，被延迟的时间只与已安排任务加工时间之和有关，与任务标号无关。

证明思想：从一个没有空闲时间的最优解出发，在不改变最优性的条件下，转变为没有逆序的解。

1. 如果一个最优调度存在逆序，那么存在i < n使得(i,i+1构成一个逆序)
2. 存在逆序(i,j),j = i + 1,那么交换i和j得到的解的逆序数减一，后面证明这个新的调度仍然最优
3. 至多经过n(n-1)/2次交换得到一个没有逆序的最优调度

交换相邻逆序任务(i,j)不影响最优性：

1. 交换i,j显然对其他任务的延迟时间没有影响
2. 交换后不增加j的延迟
3. 任务i在f 2 的延迟L 2 小于任务j在f_1 的延迟L 1 j L_{1j}L  因此小于$ f_1 $的最大延迟

![image-20220705083616288](算法2_imgs\9KEkOSGbrRp.png)

# C8 动态规划（填空、判断、算法过程分析、算法复杂度分析）

 动态规划是一种解决多阶段决策问题的优化方法，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。

## 求解整数拆分问题

【问题描述】求将正整数n无序拆分成最大数为k（称为n的k拆分）的拆分方案个数，要求所有的拆分方案不重复。

【问题求解】设n=5，k=5，对应的拆分方案有：

① 5=5
② 5=4+1
③ 5=3+2
④ 5=3+1+1
⑤ 5=2+2+1
⑥ 5=2+1+1+1
⑦ 5=1+1+1+1+1

为了防止重复计数，让拆分数保持从大到小排序。正整数5的拆分数为7。

采用动态规划求解整数拆分问题。设f(n，k)为n的k拆分的拆分方案个数：

（1）当n=1，k=1时，显然f(n，k)=1。

（2）当n<k时，有f(n，k)=f(n，n)。

（3）当n=k时，其拆分方案有将n拆分成1个n的拆分方案，以及n的n-1拆分方案，前者仅仅一种，所以有f(n，n)=f(n，n-1)+1。

（4）当n>k时，根据拆分方案中是否包含k，可以分为两种情况：

① 拆分中包含k的情况：即一部分为单个k，另外一部分为{x1，x2，…，xi}，后者的和为n-k，后者中可能再次出现k，因此是（n-k）的k拆分，所以这种拆分方案个数为f(n-k，k)。

② 拆分中不包含k的情况：则拆分中所有拆分数都比k小，即n的（k-1）拆分，拆分方案个数为f(n，k-1)。

因此，f(n，k) = f(n-k，k) + f(n，k-1)

状态转移方程：

![image-20220704181838520](算法2_imgs\BxQFBXZ60nm.png)

显然，求f(n，k)满足动态规划问题的最优性原理、无后效性和有重叠子问题性质。所以特别适合采用动态规划法求解。设置动态规划数组dp，用dp\[n][k]存放f(n，k)。对应的完整程序如下：

```cpp
int dp[MAXN][MAXN];			//动态规划数组
void Split(int n，int k)		//求解算法
{  for (int i=1;i<=n;i++)
      for (int j=1;j<=k;j++)
      {  if (i==1 || j==1)
            dp[i][j]=1;
         else if (i<j)
            dp[i][j]=dp[i][i];
         else if (i==j)
            dp[i][j]=dp[i][j-1]+1;
         else
            dp[i][j]=dp[i][j-1]+dp[i-j][j];
      }
}
```

实际上，该问题本身是递归的，可以直接采用递归算法实现，但由于子问题重叠，存在重复的计算！
可以采用这样的方法避免重复计算：设置数组dp，用dp\[n][k]存放f(n，k)，首先初始化dp的所有元素为特殊值0，当dp\[n][k]不为0时表示对应的子问题已经求解，直接返回结果。

```cpp
int dp[MAXN][MAXN];
int dpf(int n，int k)			//求解算法
{  if (dp[n][k]!=0) return dp[n][k];
   if (n==1 || k==1)
   {	dp[n][k]=1;
	return dp[n][k];
   }
   else if (n<k)
   {	dp[n][k]=dpf(n，n);
   	return dp[n][k];
   }
   else if (n==k)
   {	dp[n][k]=dpf(n，k-1)+1;
	return dp[n][k];
   }
   else
   {	dp[n][k]=dpf(n，k-1)+dpf(n-k，k);
	return dp[n][k];
   }
}
```

这种方法是一种递归算法，其执行过程也是自顶向下的，但当某个子问题解求出后，将其结果存放在一张表（dp）中，而且相同的子问题只计算一次，在后面需要时只有简单查表，以避免大量的重复计算。这种方法称之为备忘录方法（memorization method）。
备忘录方法是动态规划方法的变形，与动态规划算法不同的是，备忘录方法的递归方式是自顶向下的，而动态规划算法则是自底向上的。

### 填空&&判断

备忘录方法是动态规划方法的变形，与动态规划算法不同的是，备忘录方法的递归方式是自顶向下的，而动态规划算法则是自底向上的。

能采用动态规划求解的问题的一般要具有3个性质：

最优性原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优性原理。
无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。

### 算法过程分析

状态转移方程：

![image-20220704181838520](算法2_imgs\BxQFBXZ60nm.png)

### 算法复杂度分析

时间复杂度O(n\*k),空间复杂度O(n*k)

## 求解最长公共子序列问题

【问题描述】字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。
    令给定的字符序列X=（x0，x1，…，xm-1），序列Y=（y0，y1，…，yk-1）是X的子序列，存在X的一个严格递增下标序列（i0，i1，…，ik-1），使得对所有的j=0，1，…，k-1，有    =yj。
    例如，X=（a，b，c，b，d，a，b），Y=（b，c，d，b）是X的一个子序列。
    给定两个序列A和B，称序列Z是A和B的公共子序列，是指Z同是A和B的子序列。该问题是求两序列A和B的最长公共子序列（LCS）

【问题求解】若设A=（a0，a1，…，am-1），B=（b0，b1，…，bn-1），设Z=（z0，z1，…，zk-1）为它们的最长公共子序列。不难证明有以下性质：

定义二维动态规划数组dp，其中dp\[i][j]为子序列（a0，a1，…，ai-1）和（b0，b1，…，bj-1）的最长公共子序列的长度。

每考虑一个字符a[i]或b[j]都为动态规划的一个阶段（共经历约m×n个阶段）。

情况1：a[i-1]=b[j-1]（最后两个数相同）

dp\[i][j]=dp\[i-1][j-1]+1

情况2：a[i-1]≠b[j-1]（最后两个数不相同）

dp\[i][j]=MAX(dp\[i][j-1]，dp\[i-1][j])

dp\[i][j]为子序列（a0，a1，…，ai-1）和（b0，b1，…，bj-1）的最长公共子序列的长度。

对应的状态转移方程如下：

dp\[i][j]=0				  								i=0或j=0―边界条件
dp\[i][j]=dp\[i-1][j-1]+1		 					a[i-1]=b[j-1]
dp\[i][j]=MAX(dp\[i][j-1]，dp\[i-1][j])	  	a[i-1]≠b[j-1]

如何由dp求出一个LCS？

当dp\[i][j] ≠ dp\[i][j-1]（左边）并且dp\[i][j] ≠ dp\[i-1][j]（上方）值时：
     a[i-1]=b[j-1]它是LCS的一个字符
将a[i-1]添加到LCS中。

其他情况时：a[i-1]或者b[j-1]是LCS的一个字符！

用vector<char>字符向量subs存放一个LCS，k=dp[m][n]（LCS的字符个数），从k到1循环求出subs中的k个字符：

（1）如果dp\[i][j]==dp\[i-1][j]（上方），说明a[i-1]或b[j-1]不是LCS中的字符    i--；
（2）如果dp\[i][j]==dp\[i][j-1]（左边），说明a[i-1]或b[j-1]不是LCS中的字符    j--；
（3）其他情况，说明a[i-1]或者b[j-1]是LCS的一个字符！
                i--;     j--; k--;表示求的字符减少1个 

```cpp
#define MAX 51				//序列中最多的字符个数
//问题表示
int m，n;
string a，b;				//求解结果表示
int dp[MAX][MAX];			//动态规划数组
vector<char> subs;			//存放LCS
void LCSlength()			//求dp
{  int i，j;
   for (i=0;i<=m;i++)			//将dp[i][0]置为0，边界条件
      dp[i][0]=0;
   for (j=0;j<=n;j++)			//将dp[0][j]置为0，边界条件   
      dp[0][j]=0;
   for (i=1;i<=m;i++)
      for (j=1;j<=n;j++)		//两重for循环处理a、b的所有字符
      {  if (a[i-1]==b[j-1])		//情况(1)
            dp[i][j]=dp[i-1][j-1]+1;
         else				//情况(2)
            dp[i][j]=max(dp[i][j-1]，dp[i-1][j]);
      }
}
void Buildsubs()		    //由dp构造从subs
{  int k=dp[m][n];		    //k为a和b的最长公共子序列长度
   int i=m;
   int j=n;
   while (k>0)			    //在subs中放入最长公共子序列(反向)
     if (dp[i][j]==dp[i-1][j])//如果dp等于左边的值，则向左移动一位
	i--;
     else if (dp[i][j]==dp[i][j-1])//如果dp等于上边的值，则向上移动一位
	j--;
     else			    //与上方、左边元素值均不相等
     {	 subs.push_back(a[i-1]);  //subs中添加a[i-1]
	 i--; j--; k--;//向斜方移动一位，并根据最长公共子序列的数量循环
     }
}
```

   【算法分析】 LCSlength算法中使用了两重循环，所以对于长度分别为m和n的序列，求其最长公共子序列的时间复杂度为O(m×n)。空间复杂度为O(m×n)。

### 算法过程分析

情况1：a[i-1]=b[j-1]（最后两个数相同）

dp\[i][j]=dp\[i-1][j-1]+1

情况2：a[i-1]≠b[j-1]（最后两个数不相同）

dp\[i][j]=MAX(dp\[i][j-1]，dp\[i-1][j])

dp\[i][j]为子序列（a0，a1，…，ai-1）和（b0，b1，…，bj-1）的最长公共子序列的长度。

对应的状态转移方程如下：

dp\[i][j]=0				  								i=0或j=0―边界条件
dp\[i][j]=dp\[i-1][j-1]+1		 					a[i-1]=b[j-1]
dp\[i][j]=MAX(dp\[i][j-1]，dp\[i-1][j])	  	a[i-1]≠b[j-1]

如何由dp求出一个LCS？

当dp\[i][j] ≠ dp\[i][j-1]（左边）并且dp\[i][j] ≠ dp\[i-1][j]（上方）值时：
     a[i-1]=b[j-1]它是LCS的一个字符
将a[i-1]添加到LCS中。

```cpp
while (k>0)			    //在subs中放入最长公共子序列(反向)
     if (dp[i][j]==dp[i-1][j])
	i--;
     else if (dp[i][j]==dp[i][j-1])
	j--;
     else			    //与上方、左边元素值均不相等
     {	 subs.push_back(a[i-1]);  //subs中添加a[i-1]
	 i--; j--; k--;
     }
```

### 算法复杂度分析

间复杂度为O(m×n)。空间复杂度为O(m×n)。

## 求解0/1背包问题

【问题描述】有n个重量分别为{w1，w2，…，wn}的物品，它们的价值分别为{v1，v2，…，vn}，给定一个容量为W的背包。
    设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，而且重量和为W具有最大的价值。

【问题求解】对于可行的背包装载方案，背包中物品的总重量不能超过背包的容量。
     最优方案是指所装入的物品价值最高，即 v1*x1+v2*x2+…+vn*xn（其中xi取0或1，取1表示选取物品i）取得最大值。
     在该问题中需要确定x1、x2、…、xn的值。假设按i=1，2，…，n的次序来确定xi的值，对应n次决策即n个阶段。

​      设置二维动态规划数组dp，dp\[i][r]表示背包剩余容量为r（1≤r≤W），已考虑物品1、2、…、i（1≤i≤n）时背包装入物品的最优价值。显然对应的状态转移方程如下：

这样， dp\[n][W]便是0/1背包问题的最优解。

当dp数组计算出来后，推导出解向量x的过程十分简单，从dp\[n][W]开始：

![image-20220704202824711](算法2_imgs\EGbDA8y3Van.png)

```cpp
//问题表示
int n=5，W=10;			//5种物品，限制重量不超过10
int w[MAXN]={0，2，2，6，5，4};	//下标0不用
int v[MAXN]={0，6，3，5，4，6};	//下标0不用
//求解结果表示
int dp[MAXN][MAXW];
int x[MAXN];
int maxv; 			//存放最优解的总价值
void Knap()			//动态规划法求0/1背包问题
{  int i，r;
   for (i=0;i<=n;i++)		//置边界条件dp[i][0]=0
      dp[i][0]=0;
   for (r=0;r<=W;r++)		//置边界条件dp[0][r]=0
      dp[0][r]=0;
   for (i=1;i<=n;i++)
   {  for (r=1;r<=W;r++)
        if (r<w[i])
           dp[i][r]=dp[i-1][r];
        else
           dp[i][r]=max(dp[i-1][r]，dp[i-1][r-w[i]]+v[i]);
   }
}
void Buildx()				//回推求最优解
{  int i=n，r=W;
   maxv=0;
   while (i>=0)			//判断每个物品
   {
      if (dp[i][r]!=dp[i-1][r]) 
      {  x[i]=1;			//选取物品i
         maxv+=v[i];			//累计总价值
         r=r-w[i];
      }
      else
        x[i]=0;			//不选取物品i
      i--;
   }
}
```

【算法分析】Knap()算法中含有两重for循环，所以时间复杂度为O(n×W)，空间复杂度为O(n×W)。

### 算法过程分析

状态转移方程

![image-20220704201407220](算法2_imgs\3G2Vky3ml7C.png)

### 算法复杂度分析

Knap()算法中含有两重for循环，所以时间复杂度为O(n×W)，空间复杂度为O(n×W)。

## 滚动数组

常用动态规划数组存放子问题的解，由于一般是存放连续的解，有时可以对数组的下标进行特殊处理，使每一次操作仅保留若干有用信息，新的元素不断循环刷新，看上去数组的空间被滚动地利用，这样的数组称为滚动数组（Scroll array）

如果仅仅求装入背包的最大价值（不需求解向量x）。
由于第i个阶段（考虑物品i）的解dp\[i][*]只与第i-1个阶段（考虑物品i-1）的解dp\[i-1][*]有关，这种情况下保存更前面的数据已经毫无意义。
所以可以利用滚动数组进行优化，将dp数组由dp\[MAXN][MAXW]改为dp\[2][MAXW]。dp\[c][r]代表当前解，dp\[1-c][r]代表上一个解

求0/1背包问题的状态转移方程如下：

![image-20220704203712131](算法2_imgs\poWCk8py4C3.png)

```cpp
void Knap()			//动态规划法求0/1背包问题
{  int i,r;
   int c=0;
   for (i=0;i<=1;i++)		//置边界条件dp[0..1][0]=0
	dp[i][0]=0;
   for (r=0;r<=W;r++)		//置边界条件dp[0][r]=0
	dp[0][r]=0;
   for (i=1;i<=n;i++)
   {	c=1-c;
	for (r=1;r<=W;r++)
	{   if (r<w[i])//放不下
		dp[c][r]=dp[1-c][r];
           else
		dp[c][r]=max(dp[1-c][r],dp[1-c][r-w[i]]+v[i]);//在放入和不放入中选最优解
	}
   }
}
```

### 填空&&判断

常用动态规划数组存放子问题的解，由于一般是存放连续的解，有时可以对数组的下标进行特殊处理，使每一次操作仅保留若干有用信息，新的元素不断循环刷新，看上去数组的空间被滚动地利用，这样的数组称为滚动数组（Scroll array）

### 算法过程分析

循环判断

```cpp
for (i=1;i<=n;i++)
   {	c=1-c;
	for (r=1;r<=W;r++)
	{   if (r<w[i])//放不下
		dp[c][r]=dp[1-c][r];
           else
		dp[c][r]=max(dp[1-c][r],dp[1-c][r-w[i]]+v[i]);//在放入和不放入中选最优解
	}
   }
```

边界条件：

dp00 = 0;dp10=0;

dp0r = 0;

### 算法复杂度分析

【算法分析】Knap()算法中含有两重for循环，所以时间复杂度为O(n×W)，空间复杂度为O(n×W)。

# C11 计算复杂性理论（判断题）

## 求解问题的分类

将存在<u>多项式时间</u>算法的问题看作是易解问题，将需要<u>指数时间级算法</u>解决的问题看作是难解问题。

归纳起来，在各种求解问题中，按求解问题算法的时间复杂度可分为3大类：

- 存在多项式算法的问题

- 肯定不存在多项式算法的问题

- 尚未找到多项式算法，也不能证明其不存在多项式算法的问题。第三类问题介于第一类和第二类之间。

## P类问题和NP类问题

确定性图灵机是现代电子计算机的理论模型。

一个对任意输入都停机的确定图灵机在多项式时间内可解的问题，必然存在多项式时间复杂度的计算机求解算法。

一个算法实质上就是一个以任何输入都停机的图灵机，因此已经找到的多项式时间界的计算机算法的问题都属于P类问题。

非确定性图灵机只是一种理论上的计算模型。不确定图灵机可解的问题，虽然也可以用确定性图灵机求解，但时间上的耗费（或说求解步数）是不一样的。

用非确定性图灵机以多项式时间界可求解的问题，用确定性图灵机不能保证在多项式时间界内可求解，但用确定性图灵机以指数时间界是肯定可以求解的。

用确定性图灵机以多项式时间界可解的问题称为P类问题，P指确定性图灵机上的具有多项式算法的问题集合。

用非确定性图灵机以多项式时间界可解的问题称为NP类问题，NP指非确定性图灵机上具有多项式算法的问题集合，这里N是不确定的意思。

## NPC问题

NPC（NP-completeness）的概念表明找到某个问题的有效算法至少和找NP中所有问题的有效算法一样难。

这里的有效性的含义是指为求解问题设计的算法的时间为多项式级的。

归纳起来，NP问题包含P问题和NPC问题，目前属于多项式时间界求解的问题都属P问题，NPC问题是属于NP问题中最难的问题，目前尚不能确定能否用多项式时间界算法来求解。

但已证明，如果NPC问题中有一个问题能用多项式时间界算法求解，则所有NPC问题都可用多项式时间界算法求解。

### 判断题

NP包括P和NPC问题

属于多项式时间界求解的问题都属于P问题

 P: 能在多项式时间内解决的问题

NP: 不能在多项式时间内解决或不确定能不能在多项式时间内解决，但能在多项式时间验证的问题

NPC: NP完全问题，所有NP问题在多项式时间内都能约化(Reducibility)到它的NP问题，即解决了此NPC问题，所有NP问题也都得到解决。

NP hard:NP难问题，所有NP问题在多项式时间内都能约化(Reducibility)到它的问题(不一定是NP问题)。
![image-20220705093158669](算法2_imgs\OtFc0nT8qjv.png)

　　1. P问题属于NP问题，NPC问题属于NP问题。

　　2. NPC问题同时属于NP hard问题，是NP与NPhard的交集。