 良好的抽象

- 每个类都只实现一个抽象数据类型(ADT)

- 提供成对的或相反的操作

- 如果类的一半子程序操作一半数据，另一半子程序操作另一半数据，则应该拆成两个类

- 尽可能使接口可编程而不是表达语义

  - 表达语义的接口

    ```java
    class DeviceManager {
        // 语义化的接口，直接提供 "开启 Wi-Fi" 功能
        void enableWifi() { 
            // 内部逻辑
        }
        
        // 语义化的接口，直接提供 "关闭 Wi-Fi" 功能
        void disableWifi() { 
            // 内部逻辑
        }
    }
    ```

  - 可编程的接口

    ```java
    class DeviceManager {
        void setWifiState(boolean enabled) { 
            // 通过参数控制 Wi-Fi 状态
        }
    }
    ```

- 最小化类的成员和可访问性
- 不要公开成员数据
- 避免将私有实现细节放到类的接口中
- 不要对接口的使用方式做出任何预设
- 避免友元类

  - 友元类（Friend Class）是 C++ 中的一种特殊机制，它允许一个类访问另一个类中被声明为私有（private）或受保护（protected）的成员。
- 倾向于读代码方便而不是写代码方便
- 警惕在语义上破坏封装

  - 不调用类A的InitializeOperations()子程序，因为你知道类A的PerformFirstOperation()子程序会自动调用它
  - 调用employee.Retrieve(database)之前不调用database.Connect()子程序，因为你知道employee.Retrieve()函数会在没有建立连接的前提下自动连接数据库
  - 不调用类A的Terminate()子程序，因为你知道类A的PerformFinalOperation()子程序已经调用过它了
  - 即使在ObjectA离开作用域后，也使用由ObjectA创建的到ObjectB的指针或引用，因为你知道ObjectA将ObjectB放在静态存储中，ObjectB依然有效
  - 使用类B的MAXIMUM_ELEMENTS常量，而不是使用ClassA.MAXIMUM_ELEMENTS，因为你知道它们都等于同一个值

良好的继承

- 除非万不得已，不要通过私有继承实现包含关系
- 警惕数据成员超过7个的类
- 如果派生类不打算完全遵守基类所定义的相同接口契约，继承就不是正确的实现技术
- 如果一个类不是为了继承而设计的，就应该定义成final
- （里氏替换原则）子类必须能通过基类的接口使用，使用者无需知道两者的差异
- 确保只继承想要继承的东西
- 不要在派生类中重用不可覆盖的基类子程序名称
- 将通用接口、数据和行为移到继承树中尽可能高的位置，但不要破坏高处对象的抽象性
- 如果一个类仅有一个实例，考虑是否直接创建一个对象，而不是要引入一个不同的类
- 如果一个基类仅有一个派生类，考虑基类的设计是否必要
- 避免继承后去除子程序的行为
  - 比如基类为Cat，子程序为Scratch()，如果有的Cat不能Scratch()，此时不应该继承Cat并重写Scratch()使其不做任何事，应该重写Cat基类，将子程序Scratch()改为一个Claw的数据成员。
- 避免过深的继承树，大多数人在大脑中很难处理超出两到三层的继承关系