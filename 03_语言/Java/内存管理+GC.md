# JVM 内存模型

JVM 内存大致分为 **线程私有区域** 和 **线程共享区域**，并且其主要由5个区域组成，见下图：

![JVM内存示意图](内存管理+GC_imgs\1460000038256032.png)

## 堆和栈

1. **堆（Heap）：**
   - **位置：** 堆位于Java虚拟机（JVM）管理的内存中。在物理内存中，堆的位置可以是任意的，不受程序控制，而是由操作系统及其内存管理器决定。
   - **用途：** 堆用于存储所有的Java对象实例，无论是哪个类的实例都存放在堆中。堆被所有线程共享，因此它是线程安全的。
   - **特点：** 堆的大小可以通过启动JVM时的参数来调整，例如`-Xms`和`-Xmx`用于设置堆的初始大小和最大大小。堆的内存空间动态分配和释放，用于支持Java程序的动态内存分配。
2. **栈（Stack）：**
   - **位置：** 栈位于线程私有的内存区域中，每个线程都有自己的栈。每个方法在执行时，会创建一个栈帧，用于存储局部变量、操作数栈、方法出口等信息。
   - **用途：** 栈用于存储基本数据类型的局部变量（如int、boolean等）和对象的引用变量（不包括对象本身，对象本身存储在堆中）。
   - **特点：** 栈是一个后进先出（LIFO）的数据结构，每个方法调用都会创建一个新的栈帧，方法执行完成后，对应的栈帧会被销毁，释放栈空间。因此，栈的空间管理由JVM自动管理，不需要手动调整栈大小。

## 主内存和工作内存

- 主内存与工作内存

  - **主内存（Main Memory）：** Java线程之间共享的内存区域，包含所有的实例变量、静态变量和数组元素。
    - <u>方法区</u>和<u>堆内存</u>
    - GC：因为这两个区域主要存放对象、数组等不具有确定性的数据，因此需要一套合理的内存管理机制来对这两个区域进行维护（GC）。

  - **工作内存（Working Memory）：** 每个线程私有的内存区域，包含该线程独占的本地变量副本以及缓存了主内存的变量副本。
    - <u>虚拟机栈、本地方法栈和程序计数器</u>，这三个区域是<u>线程私有</u>的。比如<u>栈帧的生命周期是和线程关联的，即随线程而生，随线程而死。</u>虚拟机栈其实就是用来描述 Java 方法执行的，所以<u>每个方法执行的时候都会创建一个栈帧，每个栈帧都包含：局部变量、操作数栈、动态链接、方法出口，当方法执行完成之后，对应的栈帧便会出栈</u>。
    - GC：几个线程私有区域的内存分配是具备确定性的，因此并不需要太过关注内存管理问题。

- 内存间交互操作

  - **读操作（Read）：** 将主内存中的变量值复制到工作内存中，以便线程使用。

  - **写操作（Write）：** 将工作内存中的变量值刷新到主内存中，以便其他线程可见。

- 内存可见性

  - Java内存模型保证了在正确同步的情况下，一个线程对共享变量的修改对其他线程是可见的。通过使用`synchronized`关键字、`volatile`变量、`final`关键字以及显示的锁（如`Lock`接口的实现）来确保内存可见性。

# GC机制

## 简介

1. **垃圾回收的基本原理**

Java 的垃圾回收主要依赖于以下两个基本概念：

- **引用计数**：每个对象都有一个引用计数，当对象被引用时计数增加，当引用被移除时计数减少。如果计数为零，则对象可以被回收。然而，引用计数无法解决循环引用的问题。（只出现在了早期的 JVM 中，现在基本不再使用了）
- **可达性分析（Reachability Analysis）**：通过一组称为“GC Roots”的对象作为起点，检查哪些对象是可达的。如果对象不可达，则认为它是垃圾，可以被回收。GC Roots 通常包括栈中的局部变量、静态变量和 JNI（Java Native Interface）引用。

2. **Java 中的垃圾回收算法**

Java 使用多种垃圾回收算法来实现内存管理，这些算法通常被组合在一起使用以提高效率：

- **标记-清除算法（Mark and Sweep）**：首先标记所有可达的对象，然后清除所有未标记的对象。标记阶段通过遍历对象图来标记可达对象，清除阶段则回收未标记的对象。
- **复制算法（Copying）**：将活动对象从一个内存区域复制到另一个内存区域，同时回收原内存区域的所有对象。这种方法避免了内存碎片，但需要额外的内存空间。
- **标记-整理算法（Mark-Compact）**：标记所有可达对象，然后将它们移动到内存的一端，清理掉所有未标记的对象。这种方法避免了内存碎片，但可能会导致较长的停顿时间。

3. **Java 垃圾回收器**

Java 提供了多种垃圾回收器，不同的垃圾回收器适用于不同的应用场景：

- **Serial GC**：适用于单线程环境，使用单个线程进行垃圾回收，主要用于客户端应用程序。
- **Parallel GC（也称为吞吐量 GC）**：使用多个线程进行垃圾回收，适用于多线程环境，主要用于提高吞吐量。
- **CMS（Concurrent Mark-Sweep） GC**：以最小化停顿时间为目标，适用于需要低延迟的应用程序。
- **G1（Garbage First） GC**：适用于大内存堆，目标是提供可预测的停顿时间，适合于各种场景。
- **ZGC** 和 **Shenandoah GC**：是相对较新的垃圾回收器，专为大内存应用和低停顿时间设计。

4. **GC的运行阶段**

垃圾回收通常分为以下几个阶段：

- **Young Generation Collection（新生代回收）**：主要处理短生命周期的对象，包括 Eden 区和 Survivor 区。新生代回收通常是频繁且较快的。
- **Old Generation Collection（老年代回收）**：处理生命周期较长的对象，回收过程相对较慢且复杂。
- **Permanent Generation（元空间回收）**：处理 JVM 的类、方法和常量池等元数据。

5. **GC 调优**

调优垃圾回收器的性能可以通过以下几种方式：

- 调整堆内存大小和比例（例如 -Xms 和 -Xmx 参数）。
- 选择合适的垃圾回收器（通过 -XX:+UseG1GC、-XX:+UseParallelGC 等参数）。
- 调整垃圾回收器的细节参数（例如 -XX、-XX等）。

6. **GC 日志**

通过启用 GC 日志，可以监控和分析垃圾回收的行为和性能：

- 使用参数 -XX:+PrintGCDetails、-Xlog等来启用和配置 GC 日志。

## 标记垃圾的算法

### 根搜索算法详解（Tracing Collector）

根搜索算法的中心思想，就是从某一些指定的根对象（GC Roots）出发，一步步遍历找到和这个根对象具有引用关系的对象，然后再从这些对象开始继续寻找，从而形成一个个的引用链（其实就和图论的思想一致），然后不在这些引用链上面的对象便被标识为引用不可达对象，也就是我们说的“垃圾”，这些对象便需要回收掉。这种算法很好地解决了上面 **引用计数算法** 的循环引用的问题了。

![可达对象标记](内存管理+GC_imgs\1460000038256040.png)

算法的核心思想是很简单的，就是标记不可达对象，然后交由 GC 进行回收，但是有一个点是很重要的，那就是 **何为根对象（GC Roots）**？

根对象，一般有如下几种：

- 虚拟机栈中引用的对象（栈帧中的本地变量表）；**????????????????????**
- 方法区中常量引用的对象；
- 方法区中静态属性引用的对象；
- 本地方法栈中 JNI（Native 方法）引用的对象；
- 活跃线程。

**但其实，上述算法只是一个算法的中心思想，实际执行过程是比这个复杂的，另外，GC 判断对象是否可达其实看的还是强引用。**

> 1、进行根搜索的时候，是需要暂停所有线程的，即执行一次 STW（Stop The World），最主要的目的是防止上述的对象图在算法运行的过程中有变化从而影响算法的准确性。
> 2、线程暂停的时间长短，取决于对象的多少，和堆内存的大小无关。
> 3、 宣告一个对象的“死亡”其实不仅仅通过上述的算法计算，而是需要经历两次的标记，本文暂不进行赘述。

## 回收垃圾的算法

除了需要上文研究的标记“垃圾对象”的算法，我们也需要“清理垃圾”的 **回收算法**。

常用的回收算法一般有：**标记-清除算法**、**标记-整理算法**、**复制算法**，以及系统自动进行判定使用的 **适应性算法**。

### 标记 - 清除算法（Tracing Collector）

标记-清除 算法是最基础的收集算法，它是由 **标记** 和 **清除** 两个步骤组成的。

标记的过程其实就是上面的 **根搜索算法** 所标记的不可达对象，当所有的待回收的“垃圾对象”标记完成之后，便进行第二个步骤：**统一清除**。

该算法的优点是当存活对象比较多的时候，性能比较高，因为该算法只需要处理待回收的对象，而不需要处理存活的对象。

但是缺点也很明显，就是在执行完 **标记-整理** 之后，由于将“垃圾对象”回收掉了，所以原本连续使用的内存块便会变得不连续，这样会导致内存块上面会出现很多小单元的内存区域，这些小单元的内存区域只能够存放比较小的对象，而比较大的对象是无法直接存储的。

> 即原本空闲 1M 的内存区域，有可能会出现无法直接存放 0.9M 大小的对象。

![标记-清除算法](内存管理+GC_imgs\1460000038256034.png)

### 标记 - 整理算法（Compacting Collector）

上述的 **标记-清除** 算法会产生内存区域使用的间断，所以为了将内存区域尽可能地连续使用， **标记-整理** 算法应运而生。

**标记-整理** 算法也是由两步组成，**标记** 和 **整理**。

第一步的 **标记** 动作也是使用的 **根搜索算法**，但是在标记完成之后的动作却和 **标记-清除算法** 天壤之别，该算法并不会直接清除掉可回收对象 ，而是让所有的对象都向一端移动，然后将端边界以外的内存全部清理掉。

该算法所带来的最大的优势便是使得内存上面不会再有碎片问题，并且新对象的分配只需要通过简单的指针碰撞便可完成。

![标记-整理算法](内存管理+GC_imgs\1460000038256035.png)

### 复制算法（Copying Collector）

无论是**标记-清除算法**还是**垃圾-整理算法**，都会涉及句柄的开销或是面对碎片化的内存回收，所以，**复制算法** 出现了。

复制算法将内存区域均分为了两块（记为S0和S1），而每次在创建对象的时候，只使用其中的一块区域（例如S0），当S0使用完之后，便将S0上面存活的对象全部复制到S1上面去，然后将S0全部清理掉。

复制算法的优势是：① 不会产生内存碎片；② 标记和复制可以同时进行；③ 复制时也只需要移动栈顶指针即可，按顺序分配内存，简单高效；④ 每次只需要回收一块内存区域即可，而不用回收整块内存区域，所以性能会相对高效一点。

但是缺点也是很明显的：可用的内存减小了一半，存在内存浪费的情况。

所以 **复制算法** 一般会用于对象存活时间比较短的区域，例如 **年轻代**，而存活时间比较长的 **老年代** 是不适合的，因为老年代存在大量存活时间长的对象，采用复制算法的时候会要求复制的对象较多，效率也就急剧下降，所以老年代一般会使用上文提到的 **标记-整理算法**。

![复制算法](内存管理+GC_imgs\1460000038256037.png)

### 适应性算法（Adaptive Collector）

**适应性算法** 其实不是一种单独的回收算法，他只是一种智能选择回收算法的机制，也就是该算法会根据堆内存具体的使用情况而自动选用更适合当前情况的回收算法。

### 分代回收

**分代回收** 并不是一种垃圾回收算法，它是上述各种垃圾回收算法的一个落地应用方案。

堆内存和方法区可以再根据对象的生命周期进行分为年轻代、老年代、持久代，见下图：

![堆内存示意图](内存管理+GC_imgs\1460000038256033.png)

堆内存主要由年轻代和老年代组成，而方法区主要存储持久代的数据，详细的细节在下文讲回收算法的时候会细说。

> 注意：从 JDK 1.8 开始，永久代已经被移除了，取而代之的是元空间（Meta Space），它和服务器的内存相关联，本文暂不赘述。

因为上述各个算法都有各自的优势，我们在内存的使用过程中，有些对象存活时间长，有些对象存活时间短，有些对象甚至一直存活着，所以根据对象的存活周期，我们将内存区域分为三大块：年轻代、老年代 和 永久代，并且年轻代也继续细分为：Eden区、S0 和 S1。

> 1、各个内存区域的内存大小可以见上文中的内存模型图，当然，我们也可以给 JVM 传递参数来进行调整，这些内容本文也暂不赘述。
> 2、 Eden : S0 : S1 的默认比例为 8:1:1，为什么这么设计呢？其实 IBM 有专门的研究表明，年轻代中 98% 的对象都是朝生夕死的，所以只需要划分为一个较大的 Eden 区和两个较小的 Survivor 区即可，而且这样做的好处是只有 10% 的 Survivor 区会被浪费掉，这也是可以接受的。

下面简单介绍下各个内存区的 GC 过程：

1. 对象首次创建进行内存分配的时候，首先会放置在 Eden 区，当 Eden 区放满了或者当该对象太大无法放进 Eden 区的时候，此时会对年轻代（Eden区 和 S0）进行一次 GC，将幸存下来的对象放置在 S1，然后清空掉 Eden区和 S0 区；（此时年轻代采用的是 **复制算法**）
2. 在上面第一步中对年轻代进行垃圾回收的时候，同时会对幸存的对象进行标记，统计每个幸存对象经历的 GC 次数；
3. 当 S1 区满了之后，或者年轻代的对象经历过指定次数的 GC 之后，这部分对象会被放置到老年代之中；
4. 当老年代也满了之后，便会对老年代进行一次 GC；（老年代采用的是 **标记-整理算法**）

## 垃圾回收器

好了，上文介绍过了 **“垃圾”的识别算法** 和 **“垃圾”的回收算法**，那么这些算法的执行者是谁呢？就是下文介绍的 **垃圾回收器（GC）** 了。

### 垃圾回收器的类型

在 Java 语言中，垃圾回收器按照执行机制来进行划分，主要分为四种类型：

1. 串行垃圾回收器（Serial Garbage Collector）；
2. 并行垃圾回收器（Parallel Garbage Collector）；
3. 并发标记扫描垃圾回收器（CMS Garbage Collector）；
4. G1垃圾回收器（G1 Garbage Collector）。

上述四种垃圾回收器都是有各自的优缺点的，我们可以通过向 JVM 传递参数来指定其中一款垃圾回收器。

![Java 垃圾回收器类型](内存管理+GC_imgs\1460000038256031.png)

#### 1、串行垃圾回收器（Serial Garbage Collector）

串行垃圾回收器会暂停所有的应用程序线程，并采用单独的的线程进行 GC。

适用于单 CPU、并且对应用程序的暂停时间要求不高的情况，所以不太适合当前的生产环境。

#### 2、并行垃圾回收器（Parallel Garbage Collector）

并行垃圾回收器是 JVM 默认的垃圾回收器，相较于串行垃圾回收器而言性能稍有提升，它也是需要暂停所有的应用程序线程的，但是区别是它会使用多线程进行 GC。

所以并行垃圾回收器适用于多 CPU 的服务器、并且能接受短暂的应用暂停的程序。

#### 3、并发标记扫描垃圾回收器（CMS Garbage Collector）

CMS 回收器也是一种并行的垃圾回收器，它会采用多线程来进行扫描堆内存，标记需要清理的对象并将这些对象清理掉。

但是 CMS 它需要更多的 CPU 来保证程序的吞吐量，并且它保证了最短的回收停顿时间，所以，在服务器允许的情况下，为了达到更到的性能，我们应该使用 CMS 来代替默认的 并行垃圾回收器。

#### 4、G1 垃圾回收器（G1 Garbage Collector）

G1 垃圾回收器是在 JDK1.7 中才正式引入的一款垃圾回收器，“科技在进步，所以一般越是先进的技术一般会更好用并且会替代陈旧的技术”，好了，玩笑归玩笑，但是 G1 的引入，目的就是为了取代 CMS 的。

不要被上面 G1 的示意图误导， G1 并没有将内存进行物理划分，它只是将堆内存划分为一个个的 Region，但是也是属于分代垃圾回收器，G1 仍然会区分年轻代和老年代，并且年轻代仍然会有 Eden 区和 Survivor 区。

这么做的目的是保证 G1 回收器在有限的时间内可以获得尽可能高的回收效率。

![G1 垃圾回收器](内存管理+GC_imgs\1460000038256038.png)

### HotSpot 虚拟机（HotSpot VM）提供的几种垃圾收集器

HotSpot VM 提供了 7 种垃圾收集器，分别为：

1. Serial
2. PraNew
3. Parallel Scavenge
4. Serial Old
5. Parallel Old
6. CMS
7. G1

其中，1、2、3 种适合年轻代内存区的垃圾回收，4、5、6种适合老年代内存区的垃圾回收，并且它们之间是两两组合来进行使用的，详见下图：

![HotSpot VM 提供的几种垃圾收集器](内存管理+GC_imgs\1460000038256039.png)

## 垃圾回收的时机

垃圾回收分为两种，Full GC 和 Scavenge GC。

Full GC 发生在整个堆内存中，而 Scavenge GC 仅仅发生在年轻代的 Eden 区，所以我们应该尽可能地减少 Full GC 的次数，当然，对于 JVM 的调优，很多情况下也是在想办法对 Full GC 进行调优。

因为 GC 是可能会对应用程序造成影响的，所以触发 GC 也是有一定的条件的，例如：

- 当应用程序空闲时，GC 有可能会被调用，因为 GC 运行线程的优先级是相对较低的，所以当线程忙的时候，它是不会运行的，当然，内存不足的情况除外；
- 堆内存不足的时候，GC 会被调用。例如创建对象的时候，若此时内存不足，则会触发 GC 用来给这个对象分配合适的内存，当进行完一次 GC 之后内存还是不足，则会继续进行第二次 GC，若第二次 GC 之后内存还是不足，则一般会提示 “out of memory”异常；

> **小 Tip：**
> `System.gc()` 方法会显示触发 Full GC，但是它只是对 JVM 的一个 GC 请求，至于何时触发，还是由 JVM 自行判断的。

GC 的调用开销是比较大的，所以我们需要有针对性地进行调优，一般有如下方案：

1. <u>不要显式调用 `System.gc()`。此函数虽然是建议 JVM 进行 GC，但很多情况下它会触发 GC，从而增加 GC 的频率；</u>
2. <u>尽量减少临时对象的使用。在方法结束后，临时对象便成为了垃圾，所以减少临时变量的使用就相当于减少了垃圾的产生，从而减少了GC的次数；</u>
3. <u>对象不用时最好显式置为 Null。一般而言，为 Null 的对象都会被作为垃圾处理</u>，所以将不用的对象显式地设为 Null 有利于 GC 收集器对垃圾的判定；
4. <u>尽量使用 StringBuilder 来代替 String 的字符串累加。因为 String 的底层是 final 类型的数组，所以 String 的增加其实是建了一个新的 String，从而产生了过多的垃圾；</u>
5. <u>允许的情况下尽量使用基本类型（如 int）来替代 Integer 对象。因为基本类型变量比相应的对象占用的内存资源会少得多；</u>
6. <u>合理使用静态对象变量。因为静态变量属于全局变量，不会被 GC 回收；</u>