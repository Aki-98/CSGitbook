# 四种作用域

在Java中，变量的作用域分为四个级别：类级、对象实例级、方法级、块级。

**类级变量**又称全局级变量或静态变量，需要使用static关键字修饰，你可以与 C/C++ 中的 static 变量对比学习。类级变量在类定义后就已经存在，占用内存空间，可以通过类名来访问，不需要实例化。

**对象实例级变量**就是成员变量，实例化后才会分配内存空间，才能访问。

**方法级变量**就是在方法内部定义的变量，就是局部变量。

**块级变量**就是定义在一个块内部的变量，变量的生存周期就是这个块，出了这个块就消失了，比如 if、for 语句的块。块是指由大括号包围的代码。

说明：

- 方法内部除了能访问方法级的变量，还可以访问类级和实例级的变量。
- 块内部能够访问类级、实例级变量，如果块被包含在方法内部，它还可以访问方法级的变量。
- 方法级和块级的变量必须被显示地初始化，否则不能访问。

# 作用域原理

大多数程序设计语言都提供了“作用域”（Scope）的概念。

对于在作用域里定义的名字，作用域同时决定了它的“可见性”以及“存在时间”。在C，C++和Java里，作用域是由花括号的位置决定的。

 

**变量的作用域**

例子：

```
 1 {
 2     int x = 12;
 3     /* only x available */
 4     {
 5         int q = 96;
 6         /* both x & q available */
 7     }
 8     /* only x available */
 9     /* q “out of scope” */
10 }
```

Java用一对大括号作为语句块的范围，称为作用域，作为在作用域里定义的一个变量，它只有在哪个作用域结束之前才可使用。

 

在Java中不能像下面这样书写代码：

```
1 {
2     int x = 12;
3     {
4         int x = 96; /* illegal */
5     }
6 }
```

Java编译器会认为变量已被定义，所以作用域中的变量不能重复定义，但是在C和C++中能将一个变量“隐藏”在一个更大的作用域里，在C和C++中被允许，在Java中是不允许的，因为Java的设计者认为这样做使程序产生了混淆。



**在同一作用域范围的包裹下成员变量名和局部变量名是可以变量名相同的，在同一个作用域范围的包裹下局部变量和局部变量不可以变量名相同（作用域内不能重复命名），在方法中使用变量的时候如果不指明使用成员变量还是局部变量，那么默认的就是使用局部的那个变量，但是如果局部变量超出了它本身的作用域范围则会失效，被JVM垃圾回收，那么则可以重复命名此变量，并使用最新定义的这个局部变量。**

 

**对象的作用域**

Java对象不具备与主类型一样的存在时间。用new关键字创建一个Java对象的时候，它会超出作用域的范围之外。所以假若使用下面这段代码：

```
1 {
2     String s = new String("a string");
3 } /* 作用域的终点 */
```

那么句柄s，也就是引用会在作用域的终点处消失。然而，s指向的String对象依然占据着内存空间。在上面这段代码里，我们没有办法继续使用这个对象，因为指向它的唯一一个句柄已经超出了作用域的边界。

这样造成的结果是：对于用new创建的对象，只要我们愿意，它们就会一直保留下去。这个编程问题在C和C++里特别突出。在C++里遇到的麻烦最大：由于不能从语言获得任何帮助，所以在需要对象的时候，根本无法确定它们是否可用。而且最麻烦的是，在C++里，一旦完成工作，必须保证将对象手动清除。

这样便带来了一个有趣的问题。假如 Java 让对象依然故我，怎样才能防止它们大量充斥内存，并最终造成程序的“凝固”呢。在 C++里，这个问题最令程序员头痛。但 Java 以后，情况却发生了改观。 Java 有一个特别的“垃圾收集器”，它会查找用 new 创建的所有对象，并辨别其中哪些不再被引用。随后，它会自动释放由那些闲置对象占据的内存，以便能由新对象使用。这意味着我们根本不必操心内存的回收问题。只需简单地创建对象，一旦不再需要它们，它们就会自动离去。这样做可防止在 C++里很常见的一个编程问题：由于程序员忘记释放内存造成的“内存溢出”。