## 第7章 高质量的子程序

### 1.创建子程序的原则

创建子程序的正当理由：

- 降低复杂性
- 引入一个中间的、易于理解的抽象概念
- 避免重复代码
- 支持子类化
- 隐藏处理顺序
- <u>隐藏指针操作</u>
- 提高可移植性
- <u>简化复杂的布尔表达式</u>
- <u>提高性能：将对代码的优化集中到子程序中</u>

此外，许多创建类的理由也是创建子程序的理由

- 隔离复杂性
- 隐藏实现细节
- 限制变更的影响
- 隐藏全局数据
- 建立集中的控制点
- 促进代码的重用
- 完成特定的重构

内聚性的层次：

- 功能内聚性
- 顺序内聚性：执行B之前，必须执行A
- 通信内聚性
- 瞬时内聚性
- 过程内聚性：执行A\B\C的顺序是安排的业务流程
- 逻辑内聚性
- 偶发内聚性：程序之间的多项操作并没有任何可识别的关联，低质量程序的代表



### 2.子程序命名

好的子程序命名：

- 描述子程序所作的所有事
- 可描述子程序得到的返回值
- 可使用动词+对象的结构命名
- 相反操作使用成对的反义词命名
- 为常用操作建立命名规范，GetId() ReadId()?
- 避免使用无意义、模糊或空泛的动词
- 不要只使用数字区分子程序
- 选择合适的长度，不要过长不要过短



### 3.子程序长度

子程序的理想长度？50-150/100-200

需要结合多种因素考量



### 4.子程序参数

- 按“输入-修改-输出”的顺序来排列参数
- 可考虑创建自己专属的IN/OUT关键字（p174）
- 将状态或错误变量放在最后
- 不要把子程序参数作为工作变量使用
- 将输入值赋给一个工作变量可以强调该值的来源
- 对有关参数的接口假设进行文档化说明
- 将子程序的参数限制在7个左右
- 接口应该使用来自对象的参数还是使用对象？（p178）



### 5.函数使用中的注意事项

- 注意使用函数和过程的区别
- 检查所有可能的返回逻辑路径
- 不要返回指向局部数据的引用或指针
- 注意宏子程序和内联子程序的使用（p182）



## 第8章 防御式编程

主要思想：即使向子程序输入错误数据，它也不会受到破坏

### 1.断言

断言可以用于检查如下类型的假设：

- 入参或出参的值在预期范围内
- 子程序开始或结束时，文件或流处于打开或关闭状态
- 子程序开始或结束执行时，文件或流处于开始或结束的位置
- 文件或流以只读、只写或读写的方式打开
- 只读属性的入参没有被子程序修改
- 指针不为空
- 传入子程序的数组或其他容器至少可以容纳X个数据元素
- 表已经使用真实的值进行了初始化
- 子程序开始或结束执行时，容器是空的或者满的
- 一个经过高度优化的复杂子程序的运算结果与一个较慢但条理清晰的子程序的结果是一致的

断言的指导原则：

- 用错误代码来处理预期会发生的情况，用断言处理永远不应该发生的情况
- 避免将要执行的代码放在断言中，避免编译器跳过断言代码

### 2.错误处理

几种遇到错误输入时的处理方式：

- 返回中立值
- 换用下一条有效数据
- 返回与上次相同的答案
- 换用最接近的合法值
- 在文件中记录警告信息
- 返回一个错误代码
- 调用错误处理子程序或对象
- 在遇到错误的地方显示出错消息
- 在最妥当的方式在局部处理错误
- 关闭程序

正确性与健壮性

- 正确性意味着永远不会返回不准确的结果，不返回结果好于返回不准确的结果
- 稳健性倾向于让软件继续允许，即使会导致结果不准确
- 强调人身安全第一的应用往往更诸种正确性而非健壮性，比如放疗仪
- 消费类应用下往往更注重健壮性而非正确性，比如输入法软件

### 3.异常

异常是把代码中的错误或异常事件传递给调用方代码的一种特定方式。

异常还可以用于清理一段代码中存在的混乱逻辑，上游其他代码块直接try-catch异常。

异常的使用准则

- 使用异常来通知程序其他部分不应忽略的错误
- 仅在真正异常的情况下才抛出异常
- 不要使用异常来推卸责任
- 除非再同一位置捕获，否则避免在构造函数和析构函数中抛出异常
- 应当再合适的抽象层次抛出异常
- 在异常消息中应包括导致异常的所有信息
- 避免使用空的catch 块
- 了解使用的库会抛出的异常，如果库代码的异常不能捕捉到，会导致程序崩溃
- 考虑创建一个集中式的异常报告程序。其中包括有哪些类型的异常、每个异常该如何处理和异常消息的格式等。

### 4.其他措施

**隔离程序**：使之包容由错误造成的伤害。进行一些数据清洗验证，将输入时将输入数据转换为合适的类型等

**调试辅助代码**：不要自动将生产版本的约束应用于开发版本

**进攻式编程**：

- 确保断言语句可以使程序终止运行，不要让程序员养成遇到已知问题只知道按回车键绕过的习惯
- 完全填充分配到的所有内存，以便可以检测内存分配方面的错误
- 完全填充分配到的所有文件或流，以便可以排查任何文件格式错误
- 确保每个case语句中的default分支或else分支都能产生严重错误，比如让程序终止运行，或者至少让这些错误不会被忽视
- 在删除对象之前使其填满垃圾数据
- 让程序把错误日志文件通过电子邮件发送给你，让你可以看到已发布软件中发生的各种错误

## 第9章 伪代码编造过程 Pseudocode Programming Process

### 1.伪代码的指导原则

- 使用自然语言风格的语句，精确描述具体的操作
- 避免使用目标编程语言的语法元素。
- 在意图层级上写伪代码。描述方法的含义，而不描述方法如何实现。
- 在足够低的层次上写伪代码，目的是几乎能直接转换成代码。如果伪代码层次太高，可能会掩盖代码中的问题细节。用越来越多的细节来完善伪代码，直到最后似乎能直接转换成代码。

### 2.使用PPP构造子程序

- 检查先决条件：要检查子程序的工作是否已经准确定义并清晰地融入总体设计中
- 定义子程序要解决的问题：
  - 子程序隐藏的信息
  - 子程序的输入
  - 子程序的输出
  - 调用该子程序之前保证成立的前置条件：
    - 输入值在特定范围内
    - 流已初始化
    - 文件已打开或关闭
    - 缓冲区已填充或刷新
    - ...
  - 子程序在将控制权传回调用者之前保证成立的后置条件：
    - 输出值在指定范围内
    - 流已初始化
    - 文件已打开或关闭
    - 缓冲区已填充或刷新
    - ...
  - 决定如何测试子程序
    - 单元测试
  - 研究标准库中的可用功能
    - 不要重复发明轮子去做多余且不必要的工作
  - 考虑错误处理
  - 考虑效率问题
  - 研究算法和数据类型
  - 在伪代码中多尝试一些思路，保留其中最好的
- 开始编写子程序
  - 写子程序声明
  - 将伪代码转换成高层次的注释
  - 在每条注释下填写代码
  - 检查代码是否要进一步分解

- 检查代码
  - 用心检查子程序的错误
  - 编译子程序
  - 在调试器中逐行执行代码
  - 消除子程序中的错误


# 第三部分 变量

## 第10章 变量使用中的常规问题

隐式声明：

- 关闭隐式声明
- 声明所有变量的类型
- 遵循命名规范
- 利用编译器查看程序的变量列表进行检查

变量初始化：

- 在声明时初始化每个变量
- 在靠近首次使用的地方初始化变量
- 理想情况下，应在靠近首次使用变量的地方声明和定义每个变量
- 尽可能使用final或const
- 特别注意计数器和累加器，是否忘记重置？
- 在构造函数中初始化该类的成员数据
- 检查是否需要重新初始化
- 使用内存访问检测工具来检查错误的指针（操作系统/专门工具）
- 在程序的开始初始化工作内存（P246）

变量作用域：

- 尽量减少变量的跨度（从初始化到第一次使用）和存活时间（从第一次使用到最后一次使用）
- 在循环之前立即初始化循环中使用的变量，而不是在包含该循环的子程序开头进行初始化
- 在使用变量之前不要为其赋值

变量使用：

- 保证每个变量只限用于单一的用途
- 避免使用具有隐含含义的变量
- 确保使用了所有已声明的变量

## 第11章 变量名称

选择好名称的注意事项

- 变量名称要足够充分而准确地描述变量所代表的实体
- 好的名称倾向于表达”什么(what)“，而不是"如何(how)"
- 名称最优长度 ~ 20
- 对全局命名空间中的命名使用限定符
- 计算值限定符（Total\Average\Max\Min），应放置在变量的最后
- 使用对仗词（Begin/End Old/New）
- 循环变量 i、j、k
- 警惕临时变量，考虑用准确的、具有描述性的变量名
- 使用肯定的bool变量名，bool变量名称已包含或真活假的含义
- 枚举类型使用组前缀

语言无关的命名规范指导原则

- 标识全局变量
- 标识成员变量
- 标识类型定义
- 表示具名常量
- 标识枚举类型的元素
- 在不强调入参只读的语言中标识只读入参
- 格式化命名以提高可读性 gymnasticsPointsTotal\gymnastics_points_total

特定语言的命名规范指导原则（P281）

混合语言编程的注意事项（P281）

前缀（P283）

使用缩写的注意

- 不要通过从每个单词中删除一个字符来得出缩写词
- 缩写词要保持一致
- 创建的名称要能够读的出来
- 避免误读或容易发音错误的组合
- 代码中使用缩写对照表

变量名称避坑指南

- 避免使用误导性的命名或缩写
- 避免含义相似、命名相似、发音相似
- 避免数字
- 避免拼写错误或容易拼写错误的单词

## 第12章 基本数据类型

### 1.浮点型

- 避免对大小差别很大的数进行加减运算
- 避免浮点数之前的相等判断
- 预测舍入误差
  - 改为具有更高精度的变量类型
  - 改为二进制编码的十进制变量
  - 将浮点型变量改为整型变量 自行处理小数部分 控制小数位数的长度（速度更快，精度能保持在一定范围内）

### 2.字符串

- 注意字符串结束标志
- 字符集（p302）
- C语言中的字符串（p303）

### 3.枚举

- 定义枚举的第一项和最后一项可便于循环控制
- 将枚举类型的第一个元素留作无效值，捕捉没有正确初始化的变量

### 4.数组

- 考虑使用容器（set、stack、queue）而不是数组，或将数组视为顺序结构：下表是危险的，数组永远不可随机访问

### 5.自定义类型（p316）

## 第13章 不常见的数据类型

### 1.结构体（p323)

### 2.指针(p327)

### 3.全局数据

 全局数据的常见问题

- 无意间修改了全局数据
- 全局数据中怪异和令人惊讶的别名问题
- 全局数据的可重入代码问题
- 全局数据阻碍代码复用
- 全局数据使情况变得复杂
- 不确定的全局数据初始化顺序问题
- 全局数据破坏了模块化和智力的可管理性
- 全局数据会给模块化能力带来漏洞

使用全局数据的理由

- 保存全局值
- 模拟具名常量
- 模拟枚举类型
- 简化对极其常用数据的使用
- 消除流浪数据

非必要，不用全局数据

- 所有变量开始都声明为局部变量，若非必要，不要设为全局变量
- 区分全局变量和类变量
- 使用访问器子程序

使用访问器子程序来替代全局数据

- 访问器子程序的优势

  - 可以集中控制数据

  - 可以确保所有对变量的引用都被隔离了

  - 可以自动获得信息隐藏的大部分好处

  - 访问器子程序很容易转换为抽象数据类型

- 如何使用访问器子程序

- 要求所有的代码通过访问器子程序来操作数据

- 不要将所有的全局数据都放到一起

- 使用上锁来控制对全局变量的访问

- 在访问器子程序中构建一个抽象层

- 将对数据的所有访问保持在同一抽象层

如何降低使用全局数据的风险

- 制定一种命名规范，使全局变量一目了然
- 为所有全局变量创建一份注释良好的列表
- 不要使用全局变量保存中间结果
- 不要把所有数据都放在一个庞大的对象中到处传递，假装没有使用全局数据



# 第四部分 语句

## 第14章 直线型代码的组织

顺序攸关的语句

- 组织代码，使依赖关系显而易见，比如将初始化变量的方法从业务代码中提取出来。
- 子程序的命名要揭示依赖关系
- 使用子程序参数揭示依赖关系
- 用注释记录不明确的依赖关系（p356）

顺序无关的语句

- 使用”就近原则“，把相关的行动放在一起
- 把相关的语句分为一组

## 第15章 使用条件语句

if语句

- 保证正常路径始终写在前面，所有出错情况都写在后面
- 使用 > 而不是 > = 使用 < 而不是 <=
- 可以仅仅写上else语句表明已考虑到else情况
- 测试else语句的正确性，检查if-else子句是否颠倒

if-then-else 测试链

- 用布尔函数调用简化复杂测试
- 最常见的情况放在最前面
- 确保覆盖所有情况
- 若语言支持，就用其他结构来替换if-then-else链

case语句

- 可以选择多种方式组织case语句针对的不同情况

  - 将正常情况放在最前面
  - 按频率排列情况
  - 按字母或数组顺序排列各种情况

  - 每个case的动作要简单，可以写一个子程序，从case中调用它
  - case语句应该用于容易归类的简单数据，如果数据不简单，可以使用if-then-else链来代替
  - default语句只用于检测错误，不要用于最后一种情况
  - 注意break的使用

## 第16章 控制循环

进入循环

- 只从一个位置进入循环
- 将初始化代码直接放在循环之前

退出条件

- 将所有退出条件都放在一个地方

## 第17章 不常见的控制结构

**return结束子方法**

**递归**

- 确保递归可以停止
- 使用安全计数器来防止无限递归
- 将递归限制在一个子程序中
- 留意栈以防溢出
- 计算阶乘和斐波那契数列时，不要用递归

**goto语句（p402）**

## 第18章 表驱动法

**表驱动法（Table-Driven Method）**是一种编程技巧，通过将逻辑或规则存储在表（如数组、字典、映射等）中，根据表中的数据来驱动程序的行为，而不是使用大量的条件语句（如 `if-else` 或 `switch-case`）。这种方法可以使代码更简洁、灵活和易于维护。

**表驱动法的核心思想**

- **逻辑映射到表**：将复杂的决策逻辑抽象为表的数据结构。
- **表驱动执行**：程序通过查找表中的数据来执行对应的操作，而不是直接编写复杂的条件分支。

**表驱动法的优点**

1. **代码简洁**：减少 `if-else` 或 `switch-case` 的嵌套，使代码结构更清晰。
2. **易于扩展**：添加新的逻辑或规则时，只需更新表而无需修改核心逻辑代码。
3. **维护性好**：逻辑集中在表中，修改需求时不需要修改大量代码。
4. **高效性**：直接查表通常比多层条件判断更高效，尤其是在规则较多时。

**常见应用场景**

1. **状态机（State Machine）**
   使用表来定义状态之间的转换关系。

   ```python
   # 状态机转移表
   state_transition_table = {
       ("idle", "start"): "running",
       ("running", "pause"): "paused",
       ("paused", "resume"): "running",
       ("running", "stop"): "idle",
   }
   
   # 根据当前状态和事件查表获取下一状态
   def get_next_state(current_state, event):
       return state_transition_table.get((current_state, event), "invalid")
   ```

2. **命令分发（Command Dispatcher）**
   使用表将命令映射到对应的处理函数。

   ```python
   # 命令与处理函数映射表
   command_table = {
       "start": lambda: print("Starting..."),
       "stop": lambda: print("Stopping..."),
       "pause": lambda: print("Pausing..."),
   }
   
   # 根据输入执行对应命令
   def execute_command(command):
       action = command_table.get(command, lambda: print("Invalid command"))
       action()
   ```

3. **数据解析**
   使用表来定义字段映射或解析规则。

   ```
   python复制代码# 数据解析规则表
   parse_table = {
       "name": lambda x: x.strip(),
       "age": lambda x: int(x),
       "active": lambda x: x.lower() == "true",
   }
   
   # 解析输入数据
   def parse_data(data):
       return {key: parse_table[key](value) for key, value in data.items()}
   
   raw_data = {"name": " Alice ", "age": "30", "active": "True"}
   parsed_data = parse_data(raw_data)
   print(parsed_data)  # {'name': 'Alice', 'age': 30, 'active': True}
   ```

4. **游戏开发**
   表驱动法常用于定义游戏中的规则、事件、技能效果等。

5. **配置驱动的程序**
   使用表来定义系统配置或行为规则，比如自动化脚本中的步骤和条件。

**表驱动法的示例**

假设需要根据天气条件给出建议，可以用表驱动法实现：

#### **传统写法**

```
python复制代码def suggest_activity(weather):
    if weather == "sunny":
        return "Go for a walk."
    elif weather == "rainy":
        return "Stay indoors."
    elif weather == "snowy":
        return "Build a snowman."
    else:
        return "Unknown weather."
```

**表驱动法**

```
python复制代码# 定义建议表
activity_table = {
    "sunny": "Go for a walk.",
    "rainy": "Stay indoors.",
    "snowy": "Build a snowman.",
}

# 根据天气查表获取建议
def suggest_activity(weather):
    return activity_table.get(weather, "Unknown weather.")

# 调用
print(suggest_activity("sunny"))  # 输出：Go for a walk.
```

## 第19章 常规控制问题

按数轴顺序来写数值表达式：MIN_ELEMENTS <=i and i <= MAX_ELEMENTS

显式处理比较逻辑：while(balance!=0) while(*chatPtr != '\0') while(bufferPtr!=NULL)

常量放在比较表达式左侧：MIN_ELEMENTS = i (报错)

减少深层嵌套

- 重复测试条件的一部分
- 转换为if-then-else
- 转换为case语句
- 将深度嵌套的代码转换为子程序
- 使用对象和多态分派
- 重写代码以使用状态变量
- 使用防卫子句退出子程序，使得代码的正常路径更清晰
- 使用异常
- 完全重新设计深层嵌套的代码。

# 第五部分 代码改进

## 第20章 软件质量概述

软件质量特性

- 用户感知到的特性
  - BUG发生情况
  - 学习和使用软件的容易程度
  - 是否尽可能少占用系统资源
  - MBTF：平均故障间隔时间
  - 系统组织未经授权或不正确访问其程序及其数据的能力
  - 为特定应用或环境设计的系统，在不做修改的情况下能够在其他应用或者环境种使用的程序
  - 输出结果的误差程度
  - 系统在接收无效输入或处于压力环境时正常运行的能力
- 代码质量
  - 是否能够很容易对系统进行修改，以改变或添加功能、提高性能或修正缺陷
  - 对于一个为特定用途或环境设计的系统，当该系统被用于其他的目的或环境时，需要对该系统做出修改的程度
  - 为了在原来设计的特定环境之外运行，对系统进行修改的难易程度
  - 系统的某些部分可被应用到其他系统中的程度以及此项工作的难易程度
  - 阅读并理解系统源代码的难易程度
  - 对系统进行单元测试和系统测试的程度
  - 在系统组织和细节语句层次上理解系统的难易程度



特性之间的促进/制约关系（p472）



代码审查比测试成本更低，缺陷检出率更高



提高生产率和改进质量的最佳方法时减少代码返工，不论返工是由于需求变化、设计变更、调试和与此相关的重构引起的。更多的质量保证工作能降低错误率，但不会增加开发的总成本



## 第21章 协同构建

### 结对编程

结对编程好处

- 全程采用结对编程的成本可能比单人开发高出10%~25%，但开发周期大概会缩短45%
- 使用结对编程可以达成与正式审查相当的代码质量水平，代码的可读性和可理解性往往可以提高到团队中最优秀程序员的水平

结对编程原则

- 先统一编码规范再开始结对编程
- 不要让结对编程变成旁观
- 不要强迫在简单的问题上使用结对编程
- 定期对结对人员和分配的工作任务进行轮换
- 鼓励双方跟上对方的步伐
- 确保双方都能看到显示器
- 不要强迫彼此看不顺眼的人结对
- 避免新手组合
- 如果整个团队维护的工程都采用结对编程方式，需要指定一个组长

### 代码审查

代码审查好处

- 独立的审查通常会捕捉到大约60%缺陷
- 审查占项目预算的10%~15%，并且会降低项目的整体成本

审查活动中的人员角色(p490)

- 主持人：负责让审查以一定速度进行
- 作者：次要，代码应该不言而喻
- 审查员：应事先准备找到的部分缺陷，随着审查会议中的讨论找到更多缺陷
- ...

审查的一般步骤（p491）*这里只简述注意点

- 规划：主持人应事先准备检查清单，带有行号，分发给审查人
- 会议：所有讨论在明确其是一个错误时就停止，不要讨论解决方案；每次会议不宜超过两小时；一天不宜开两次会议
- 报告：在审查会议的一天内，主持人制作报告列出每个缺陷，包括其类型和严重程度
- 返工、跟进、讨论解决方案（可选）

审查与自尊心：

- 作者不要视图为接受审查的代码辩护，应该认可每一个疑似的缺陷，哪怕可能其不存在
- 审查员不应发布攻击作者的评论，比如“任何一个java程序员都知道..."

### 走查

任何形式的开发人员之间检查代码

### 代码阅读

## 第22章 开发人员测试

（开发）单元测试：对完整的类、子程序、小程序执行的测试

（开发）组件测试：对类、包、小程序或其他程序元素执行的测试，独立于完整系统

（开发）集成测试：对多个类、包、组件或子系统执行的组合测试

回归测试：重复先前执行的测试用例

系统测试：将软件配置到最终环境中执行测试，包括与软硬件系统的集成，会查找安全性、性能、资源消耗、时序问题



黑盒测试

白盒测试
