

# 进程通信 IPC

Linux系统中进程通信的机制继承自Unix，后经贝尔实验室与BSD对进程间通讯手段的改进与扩充，以及POSIX标准对Unix标准的统一，发展出如今Linux系统中使用的进程通信(IPC)机制，即包含管道通信、信号量、消息队列、共享内存以及socket通信等的诸多通信机制。

## 管道

管道是一种最基本的进程通信机制，其实质是由内核管理的一个缓冲区，可以形象地认为管道的两端连接着两个要进行通信的进程。其中一个进程进行信息输出，将数据写入管道；另一个进程进行信息输入，从管道中读取信息。

管道的逻辑结构如图所示：

![image-20230411181858341](Linux - 进程管理（原理&命令&编程）_imgs\Kq2tvsaGNBs.png)

管道分为匿名管道(pipe)和命名管道(named pipe)。

在进程中创建的管道是匿名管道，进程退出后管道会被销毁，匿名管道只能用于有亲缘关系的进程间通信。

命名管道被具象化为一个文件，在进程中可使用操作文件的方式向内存中写入或从内存中读出数据，命名管道与进程的联系较弱。相当于一个读写内存的接口，进程退出后，命名管道依然存在。

### 匿名管道

#### pipe()

匿名管道利用fork机制建立联系，刚创建出的管道，读写两端都连接在同一个进程上，当进程中调用fork()创建子进程后，父子进程共享文件描述符，因此子进埕拥有与父进程相同的管道。pipe()创建管后读端对应的文件描述符为fd[0]，写端对应的文件描述符为fd[1]。

- 管道采用半双工通信方式。只能进行单向数据传递，为严谨起见，应使用close()函数关闭除通信端口之外的端口。
- 管道只能进行半双工通信。若要实现同时双向通信，需要为通信的进程创建两个管道
- 有指向管道读端的文件描述符打开时，向管道中与入数据才有意义。
- 若所有指向管道与端的文件描述符都被关闭后仍有进程从管道的读端读取数据，那么管道中剩余的数据都被读取后，再次read会返回0。
- 若有指向管道写端的文件描述符未关闭，而管道写端的进程也没有向管道中写入数据，那么当进程从管道中读取数据，且管道中剩余的数据都被读取时，再次read会阻塞，直到与端向管道写入数据，阻塞才会解除。
- 若有指向管道读端的文件描述符没关闭，但读端进程没有从管道中读取数庭，写端进程持续向管道中写入数据，那么管道缓存区写满时冉次write会阻塞，直到读端将数据读出，阻塞才会解除。
- 管道中的数据以字节流的形式传输，这要求管道两端的进程事先约定好数据的格式。

#### popen()/pclose()

```
FILE*popen(const char *command，const char *type);
int pclose(FILE *stream）；
```

popen()函数的功能是：调用pipe()函数创建管道，调用fork()函数创建子进程，之后在子进程中通过execve()函数调用shell命令执行相应功能。若整个流程都成功执行，则返回一个I/O文件指针；若pipe()或fork()函数调用失败，或因无法分配内存等原因造成popen()函数调用失败，该函数将会返回NULL。

![image-20230411183322659](Linux - 进程管理（原理&命令&编程）_imgs\ZElkFXnKQ1N.png)

pclose()函数的功能是关闭由popen()打开的I/O流，并通过调用wait()函数等待子进程命令执行结束，返回shell的终止状态，防止产生僵尸进程。与文件操作函数fopen()类似，popen()调用之后务必要使用pclose()函数关闭打开的文件I/O指针，若pclose()函数调用失攸，则返回-1。

### 命名管道

命名管道又名FIFO(first in first out)，它与匿名管道的不同之处在于：命名管道与系统中的一个路径名关朕，以文件的形式存在于文件系统中。如此，系统中的不同进程可以通过FIFO的路径名访问FIFO文件，实现彼此间的通信。

#### mkfifo()

mkfifo命令的参数一般为文件名，其常用参数为 -m，用于指定所创建文件的权限。

在程序中创建FIFO文件的函数与mkfifo同名，mkfifo()的头文件为sys/type.h与sys/stat.h，其函数声明如下：

```
int mkfifo(const char *pathname，mode_t_mode);
```

## 消息队列

消息队列的实质是一个存放消息的表，该链表由内核维护；消息队列中的每个消息可以视为一条记录，消息包括一个长整型的类型字段和需要传递的数据。消息队列由消息队列标识符(queue ID）标识，对消息队列有读权限的进程可以从队列中读取消息，对消息队列有写权限的进程可以照规则，向其中添加消息。

特点：

- 与管道相比。消息队列的通信方式更为灵活
- 提供有格式的字节流，无需通信双方额外约定数传输格式
- 将消息设定为不同类型，并分配了不同的优先级
- 新添加的消息总是在队尾，但接收消息的进程可以读取队列中间的数据
- 降低了读与进程间的耦合强度

与FIFO类似，消息队列可以实现无亲缘关系进程间的通信，且独立于通信双方的进程之外，若没有删除内核中的消息队列，即便所有使用消息队列的进程都已终止，消息队列仍存在于内核中，直到内核重新启动、管理命令被执行或调用系统接囗删除消息队列时，消息队列才会真正被销毁。

注意：

- 系统中的最大消息队列数与系统中最大消息数都有一定限制，分别由宏MSGMNI和F宏MSGTOL定义
- 消息队列的每个消息中所含数据块的长度以及队列中所含数据块的总长度也有限制，分别由宏MSGMAX和宏MSGMNB定义。

使用消息队列实现进程间通信的步骤如下：

- 创建消息队列 msgget()
- 发送消息到消息队列 msgnd()
- 从消息队列中读取数据 msgrcv()
- 删除消息队列 msgctl()

**键值与标识符:**

对多个进程来说。要通过消息队列机制实现进程间通信，必须能与相同消息队列进行关朕，键值(key)就是实现进程与消息队列关联的关腱。当在进程中调用msgget()函数创建消息队列时，传入的key值会被保存到内核中，与msgget()函数创建的消息队列一一对应：若进程中调用msgget()函数获取已存在的消息队列，只需向msgget()函数中传入键值。就能获取到内核中与键值对应的消息队列。也就是说，键值是消息队列在内存级别的唯一标识。

对单个进程来说，可能需要实现与多个进程间的通信，因此会与多个消息队列关朕，当多次调用msgget()函数与多个消息队列进行关联时，每个msgget()函数都会返回一个非负整数，这个非负整数就是进程对消息队列的标识。标识符是消息队列在进程级别的唯一标识。

## 信号量

Linux系统采用多道裎序设计技木，允许多个进程同时在内核中运行，但同一个系统中的多个进程之间，可能因为进程合作或资源共享，产生制约关系。



制约关系分为直接制约关系和间接制约关系：

- 需要进程间协调合作导致的制约关系。称为直接相互制约关系。
- 因资源共享导致的制约关系。称为间接相互制约关系．

直接相互制约的进程间有同步关系，间接相互制约的进程间有互斥关系，同步与互斥存在的根源是系统中存在临界资源(Critical Resource)



计算机中的硬件资源（如内存、打印机、磁盘）以及软件资源（如共享代码段．变量等）都是临界资源，为了避免多进程的并发执行造成的不一致性，临界资源在同时刻只允许有限个进程对其进行访问或修改。

计算机中的多个讲程必须互斥地访问系统中的临界资源，用于访问临界资源的代码称为临界区(Critical Section），临界区也属于临界资源，若能保证进程间互斥地进入自己的临界区，就能实现进程对临界资源的互斥访问。



信号量(Semaphore)是专门用于解决进程同步与互斥问题的一种通信机制，它与信号无关，也不同于管道、FIFO以及消息队列。一般不用来传输数据，信号量包括一个被称为信号量的表示资源数量的非负整型变量、修改信号量的原子操作P和V，以及该信号量下等待资源的进程队列。



在Linux系统中，不同的进程通过获取同一个信号量键值进行通信，实现进程间对资源的互斥访问。使用信号量进行通信时，通常需要以下步骤：

- 创建信号量/信号量集，或获取系统中已有的信号量/信号量集；semget()
- 初始化信号量。早期信号量通常被初始为1,但有些进程一次需要多个同类的临界资源，或多个不同类且不唯一的临界资源，因此可能需要初始化的不是信号量，而是一个信号量集；semctl()
- 信号量的P、V操作，根据进程请求，修改信号量的数量。执行P操作会使信号量 -1，执行V操作会使信号量 +1；semop()
- 从系统中删除不需要的信号量；semctl()

## 共享内存

共亨内存允许两个或多个进程访问给定的同一块存储区域。已知当一个进程被启动时，系统会为其创建一个0-4G的虚拟内存空间，根据虚拟地址与物理地址之间的映射关系，进程可以通过操作虚拟地址，实现对物理页面的操作。

一般情况下。每个进程的虚拟地址会与不同的物理地址进行映射．但是当使用共亨内存进行通信时，系统会将同一段物理内存映射给不同的进程。两个进程的虚拟地址空间与共享内存之间的映射关系如图：

![image-20230412173149840](Linux - 进程管理（原理&命令&编程）_imgs\vvGeG96UkAa.png)

- 创建一块新的共享内存，或打开一块已经存在的共享内存；shmget()
- 进行地址映射，将共享内存映射到进程虚拟地址空间中；shmat()
- 解除物理内存与进程虚拟地址空间的映射关系；shmdt()
- 对已存在的共享内存进行操作；shmctl()

# 进程

## 标识符

- 进程标识符，简称pid，是进程的唯一标识
- 父进程标识符，简称ppid，标识该进程的父进程，即创建进程的进程所对应的pid
- 用户标识符，简称uid，标识创建该进程的用户。此外euid标识有效用户的标识符
- 组标识符：简称gid，标识创建进程用户的所属组，Euid对应的组标识符即为egid

## 进程状态

![image-20230404110918887](Linux - 进程管理（原理&命令&编程）_imgs\KZ6Pe3GaR9Y.png)

通常进程的状态被划分为五种：初始态、就绪态、运行态、睡眠态和中止态。初始态一般不进行讨论，因为当初始化完成后，进程会立刻转化为就绪态。

- 就绪态：处于就绪态（Ready）的进程，所需的其它资源已分配到位，此时只等待cpu，当可以使用cpu时，进程会立刻变为运行态。
- 运行态：进程处于运行态（Execting）时会占用cpu，处于此状态的进程的数目必定小于等于处理器的数目，即每个cpu上至多只能运行一个进程
- 睡眠态：处于睡眠态（Sleeping）的进程会因某种原因暂时不能占有cpu。睡眠态分为不可中断的睡眠和可中断的睡眠。
- 终止态：处于终止态的进程已运行完毕，此时进程不会被调度，也不会再占用CPU。



## PCB

每个进程的PCB中都有一个指向页表的指针、进程、页表与内存之间的映射关系如图所示

![image-20230404161621762](Linux - 进程管理（原理&命令&编程）_imgs\vYXMafSaWEc.png)

进程组由用户启动的进程创建，用户启动的进程是进程组中的领导进程（process group leader），进程组中领导进程的pid亦是识别进程组的进程组id，即pgid。



## 进程组与会话

会话（session）是进程组的集合，会话中的每个进程组称为一个工作（job）

会话由其中的进程创建，创建会话的进程称为会话的领导进程（session leader），会话领导进程的pid也是标识会话的会话id，即sid

一个会话中一般有一个进程组工作在前台，使用终端，其余进程组工作在后台（在终端执行命令时，在命令之后添加“&”则将命令启动的进程放在后台执行）。会话的意义在于可在同一个终端执行多个进程组。



## 进程控制

![image-20230404162131621](Linux - 进程管理（原理&命令&编程）_imgs\yhZJ1wmN9OI.png)

fork()

exec函数族

exit()/_exit()

exit()和\_exit()都是用来终止进程的，但它们所做的操作有些许差别：当程序执行到 \_exit()函数时，系统会无条件地停止剩下操作，终止进程，并清除进程所用内存空间以及进程在内核中的各种数据结构；exit()函数对\_exit()进行了包装，在执行退出前还有若干道工序，最重要的就是它会在调用_exit()之前先检查文件的打开情况，将缓冲区中的内容写回文件。相对而言，exit()函数相比\_exit()函数更为安全。



孤儿进程：父进程在进程退出前退出，子进程变为孤儿进程。

僵尸进程：当进程调用了exit()函数后，该进程并不是马上消失，而是留下一个称为僵尸进程（Zombie）的数据结构。僵尸进程是Linux系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码，也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息，供父进程收集。



## 进程同步

wait()

处于僵尸态的进程不能再次被运行．但是却会占用一定的内存空间，并占据进程编号，当系统中僵尸进程较多时，将会消耗系统的大部分内存，新的进程可能因内存不足或无法获取pid而无法创建，因此应尽量免僵尸进程的产生。

在父进程中通过wait()和waitpid()函数可以有效防止僵尸进程的产生，对于内存中已经存在的僵尸进程，则可通过杀死其父进程的方法解决。

当僵尸进程的父进程被终止后，僵尸进程将作为孤儿进程被init进程接收，init进程会不断调用wait()函数获取子进程状态。对已处于僵尸态的进程进行处理。

孤儿程水远不会成为僵尸进程。



## 进程管理命令

### ps

Process Status 缩写，在命令行输入ps后回车就能查看当前系统中正在运行的进程

| 选项 | 说明                                               |
| ---- | -------------------------------------------------- |
| a    | 显示当前终端机下的所有进程，包括其它用户启动的进程 |
| u    | 以用户的形式，显示系统中的进程                     |
| x    | 忽视终端机，显示所有进程                           |
| e    | 显示每个进程使用的环境变量                         |
| r    | 只列出当前终端机中正在执行的进程                   |

### top

ps命令执行后，会显示执行命令那一刻系统中进程的相关信息，若想信息动态地显示，可以使用top命令。

top默认的更新间隔为3s。

### pstree

以树状图形式显示系统中的进程，可以直接观察到进程之间的派生关系

### pgrep

根据进程名从进程队列中查找进程，查找成功后默认显示进程的pid

### nice

设置Linux系统中进程的nice值

### bg

将进程放入后台运行，使前台可以执行其它任务

### fg

将后台的进程调往前台

### jobs

查看Linux系统中的作业列表及作业状态，进程中的作业也有编号，编号从1开始。Linux系统中作业从用户角度进行编号，进程从系统管理员的角度进行编号。

当选项和参数缺省时，默认显示作业编号、作业状态和启动作业的命令。

### kill

终止正在运行的进程，工作原理是发送某个信号到指定进程，以终止该进程。

# 线程

## 线程概述

与进程不同。线程(Thread)是系统调度分派的最小单位，与进程相比，线程没有独立的地址空间。多个线程共享一段地址空间。因此线程消耗更少的内存资源，线程间的通信也更为方便，有时线程也被称为轻量级进程(Light Weight Process，LWP)

Linux系统中的线程借助进程机制实现，线程与进程联系密切：

进程可以蜕变成线程，当在一个进程中创建一个线程时，原有的进程就会变成线程，两个线裎共用一段地址空间，

线程又被称为轻量级讲程。线程的TCB(Thread Control Block，线程控制块）与进程的PCB相同，因此也可以将TCB视为PCB；

对内核而言，线程与进程没有区别，cpu会为个线程与进程分配时间片，并通过PCB来调度不同的线程和进程。

![image-20230412180030852](Linux - 进程管理（原理&命令&编程）_imgs\OeWHOer9b8r.png)

进程与线程

- 进程组成：线程集+资源集（地址空间、打开的文件描述符、用户信息等）
- 线程组成：程序、数据、TCB以及少量必不可少的用于保证线程独立运行的资源、程序计数器、栈空间、寄存器
- 优点：同一个进程地址空间的多个线程共享虚拟地址空间，进而共享相同的页目录、页表和物理页面，因此线程间的许多数据是共享的，线程不必通过类似进程通信使用的管道、信号量等机制，便能进行通信
- 缺点：因为多个线程共享一段地址空间，当多个线程同时需要对其中的数据进行访问时，可能会因竞争导致读写错误，因此，正如控制多个进程对共享资的访问一样，系统同样也应实现对线程间的共享数据的同步。



### 线程操作

#### pthread_create()

进程拥有独立的地址空间，当使用fork()函数创建出新进程后，若其中一个讲程要对fork()之前的数据进行修改，进程中会依据“写时复制”原则，,先复制一分该数据到子进程的地址空间，再修改数据，因此即便是全局变量。在进程间也是平共享的。

但由于线程间共享地址空间，因此在一个线程中对全局区的数据进行修改，其它线程中访问到的也是修改后的数据。

#### pthread_exit()

return和exit()也有退出功能，但retum用于退出函数，exit()用于退出进程。

#### pthread_cancel()

线程机制中厍用于终止线程的函数为pthread_cancel，该函数对应线程机制中的kill()函数，pthread_cancel()函数可向指定线程发送信号CANCEL，使一个线程强行杀死另外一个线程。

#### pthread_join()

在进程中，父进程退出，子进程仍可继续执行；但在线程中，作为程序入口的主线程退出，属于同一进程中的所有线程都会退出。

为避免主线程提前退出对其它线程造成影响，可以使用pthread_join()函数将主线程挂起。

#### pthread_detach()

在线程终止后，其它线程调甲pthread_join()数获取该线程的终止状态前，该线程会一直保持终止状态，这种状态类似讲程中的僵尸态。为避兔处于终止状态的线程占用内存，线程机制中提供了pthread_detach()函数，可在线程被创建后设置线程分离，被分离的线程在执行结束后将会自动释放，不再等待其它线程回收

## 线程属性

### 线程同步

### 互斥锁

使用互斥锁实现线程同步时，系统会为共享资源添加一个称为互斥锁的标记，防止多个线程在同一时刻访问相同的共用资源。

### 条件变量

使用互斥锁实现线程同步时，系统会为共享资源添加一个称为互斥锁的标记，防止多个线程在同一时刻访问相同的共用资源。

### 信号量

使用信号量实现线程同步时，线程在访问共享资源时会根据操作类型执行P/V操作：若有线程申请访问共享资源，系统会执行P操作使共享资源计数减一；若有线程释放共亨资源，系统会执行V操作共享资源计数加一。

# 上下文切换

什么是上下文切换？

我们知道 Linux 是一个多任务操作系统，它能支持远大于 CPU 数量的任务同时运行。但实际上同一时刻只会有 CPU 数量的进程在运行，等 CPU 时间片到了之后，进程调度器就会把 CPU 资源分配给其他进程。

在这个过程中就会涉及到进程之间的切换，这时候就需要将当前进程的上下文信息保存下来，随后加载被调度进程的上下文信息，这就是上下文切换。

这里所说的上下文信息，既包括虚拟内存、栈、全局变量等用户态的资源，也包括内核堆栈、寄存器等内核态的资源。不同类型的上下文切换，会涉及到不同类型资源的切换，例如：同一进程不同线程的切换，只需要切换内核态的资源，而不需要切换用户态的资源。

## **上下文切换类型**

上下文还分为了三种类型，分别是：

- 进程上下文切换
- 线程上下文切换
- 中断上下文切换

### **进程上下文切换**

进程上下文切换指的是不同进程之间发生切换。一般来说，进程被调度有如下几个时机：

1. 某个进程时间片耗尽，会被系统挂起，切换到其他等待 CPU 的进程。
2. 进程所需系统资源不足，需要等到资源满足时才可运行，此时会被挂起，其他进程会被调度。
3. 进程通过 sleep 方法主动挂起，其他进程就有机会被调度。
4. 有更高优先级的进程，当前进程会被挂起，高优先级进程会被调度。
5. 硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。

当发生如上几种情况的时候，就会发生进程调度，进而发生进程上下文切换。

### **线程上下文切换**

我们都知道进程是资源分配的基本单位，线程是调度的基本单位，进程只是给线程提供了虚拟内存等资源。而线程上下文切换，就可以分为两种情况：

- 进程调度前后的两个线程，属于同一进程。此时因为资源共享，所以在切换的时候虚拟内存等这些资源就不需要变化，只需要切换线程的私有数据、寄存器等不共享的数据。
- 进程调度前后的两个线程，不属于同一进程。这时候因为资源部共享，所以切换过程和进程上下文切换是一样的。

所以你会发现同进程内的线程切换，要比多进程间的切换消耗更少的资源，这其实就是多线程比起多进程的一个优势。

### **中断上下文切换**

中断上下文切换指的是为了响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将当前的状态保存下来。这样在中断结束后，进程仍然可以从原来的状态恢复运行。

**中断上下文切换，并不需要保存和恢复进程的虚拟内存等用户态资源，只需要处理 CPU 寄存器、内核堆栈等内核态的资源即可。**

## **分析工具**

查看系统的上下文切换情况，有三个工具可以使用，分别是：`vmstat` 命令、`pidstat` 命令、`/proc/interrupts` 文件。

### **vmstat 命令**

vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。该命令的语法格式为：

```text
vmstat <选项> <时间间隔> <报告次数>
```

其中常用的选项有：

- -a：显示活动内页；
- -f：显示启动后创建的进程总数；
- -m：显示 slab 信息；
- -n：头信息仅显示一次；
- -s：以表格方式显示事件计数器和内存状态；
- -d：报告磁盘状态；
- -p：显示指定的硬盘分区状态；
- -S：输出信息的单位。

我们执行 `vmstat 5` 命令后，会每隔 5 秒输出一次结果，如下所示。

```text
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 6893400   2352 563768    0    0     2   425  153   32  1  3 96  0  0
```

其中与上下文相关的 4 列内容如下：

- cs（context switch）是每秒上下文切换的次数。
- in（interrupt）则是每秒中断的次数。
- r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。
- b（Blocked）则是处于不可中断睡眠状态的进程数。

可以看到上面输出中上下文切换次数 cs 是 32 次，而系统中断次数 in 是 153 次，而就绪队列长度 r 和不可中断状态进程数 b 都是 0。

### **pidstat 命令**

vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用我们前面提到过的 pidstat 了。**给它加上 -w 选项，你就可以查看每个进程上下文切换的情况了。** 例如执行如下命令，我们可以得到每个进程的上下文切换情况了。

```text
// 每隔 5 秒输出一次结果
// -w 表示显示每个进程的上下文切换情况
[root@iZwz92ezhi90syoqbgjgn1Z ~]# pidstat -w 5
Linux 4.18.0-348.7.1.el8_5.x86_64 (iZwz92ezhi90syoqbgjgn1Z)  23/08/22  _x86_64_ (4 CPU)

15:04:39      UID       PID   cswch/s nvcswch/s  Command
15:04:44        0         1      0.20      0.00  systemd
15:04:44        0        11     27.94      0.00  rcu_sched
15:04:44        0       497     19.56      0.00  xfsaild/vda3
15:04:44        0       603      0.20      0.00  systemd-journal
15:04:44        0       829      0.40      0.00  sssd_be
15:04:44        0       831      1.60      0.00  sssd_nss
15:04:44        0      3931      0.40      0.00  kworker/2:0-mm_percpu_wq
15:04:44        0      3998      0.40      0.00  kworker/1:0-mm_percpu_wq
15:04:44        0      4005      0.20      0.00  kworker/u8:0-flush-253:0
15:04:44        0      4021      0.80      0.00  kworker/3:2-mm_percpu_wq
15:04:44        0      4037      5.99      0.00  kworker/0:0-events
```

上述结果中的 cswch 与 nvcswch 是重点关注的对象。cswch 表示每秒自愿上下文切换（voluntary context switches）的次数，nvcswch 表示每秒非自愿上下文切换（non voluntary context switches）的次数。

所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。

而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。

### **/proc/interrupts 文件**

我们可以通过 vmstat 获取中断的次数，但是我们却无法获取中断类型。实际上我们可以通过 `/proc/interrupts` 文件获取中断的详细信息。`/proc` 实际上是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。`/proc/interrupts` 就是这种通信机制的一部分，提供了一个只读的中断使用情况。

我们可以通过如下命令，动态观察中断的变化情况：

```text
# -d 参数表示高亮显示变化的区域
$ watch -d cat /proc/interrupts
           CPU0       CPU1
...
RES:    4385721    4430589    3732298    4259089   Rescheduling interrupts
...
```

通过这种方式，我们就可以知道具体是哪种中断类型出现异常，从而定位到具体的资源。

## **如何排查异常？**

今天我们深入了解了一下上下文切换这个指标，但每秒上下文切换多少次才算正常呢？

这个数值取决于系统本身的 CPU 性能。如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。

具体遇到问题的时候，需要根据变化的上下文切换类型，再做具体的分析。例如：

- 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题。
- 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈。
- 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。

# 协程

可以在线程上通过分时复用的方式运行，但对操作系统来说，只有线程是可见的。

协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。也就是说，协程只有和异步IO结合起来，才能发挥最大的威力。

如何处理在协程中调用阻塞IO的操作呢？一般有2种处理方式：

1. **在调用阻塞IO操作的时候，重新启动一个线程去执行这个操作，等执行完成后，协程再去读取结果。这其实和多线程没有太大区别。**
2. **对系统的IO进行封装，改成异步调用的方式，这需要大量的工作，最好寄希望于编程语言原生支持。**

协程对计算密集型的任务也没有太大的好处，计算密集型的任务本身不需要大量的线程切换，因此协程的作用也十分有限，反而还增加了协程切换的开销。

总结：

- 在有大量IO操作业务的情况下，我们采用协程替换线程，可以到达很好的效果，一是降低了系统内存，二是减少了系统切换开销，因此系统的性能也会提升。
- 在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用。