# Socket

## 原理

计算机网络架构

![image-20230412182924636](Linux - 服务器（原理&编程）_imgs\rq0zfxUH6xv.png)

socket编程原理：

![image-20230412183037263](Linux - 服务器（原理&编程）_imgs\mZvI2TabXAy.png)

当使用socket进行通讯时，进程会先生成一个socket文件，之后再通过socket文件进行数据传递

## 编程

### 服务器专用接口

#### bind()

使服务器端的一个socket文件与网络中的一个进程进行绑定，因为文件描述符可标识socket文件，“主机名+端口号“可标识网络中的唯一进程，因此bind()函数实际上是将报务器端的socket文件与网络中的进程地址进程绑定。

#### listen()

listen()函数仍用于服务器端，从字面上看，其功能为使已绑定的socket监听对应客户端进程状态，但实际上，该函数用于设置服务器同时可建立的连接的数量。

#### accept()

accept()函数在listen()函数之后使用，其功能为阻塞等待客户端的连接请求。

当传输层使用TCP协议时，服务器与客户在创建连接前，会先经过“三次握手”机制测试连接，“三次握手”完成后，服务器调用accept()函数处理连接请求，此时若还没有客户端的请求到达。便阻塞等待调用accept()函数的进程，直到接
收到客户端发来的请求，且服务器中已创建的连接数末达到backlog，accept()函数才会返回，并传出客户端的地址。

recv()

该函数用于从已连接的套接字中接收信息

### 客户端专用接口

#### connect()

向服务器发起连接请求

#### send()

向处于连接状态的套接字中发送数据

### 服务器和客户端共用

socket()

socket()函数用于创建套接字，也可以说socket()函数用于打开网络通讯端口。该函数类似于文件操作中的open()函数，若调用成功，也返回一个文件描述符，之后应用裎序可以采用socket通信中的读写函数在网络中收发数据；若调
用失败会返回-1，并设置errno。

close()
用于释放系统分配给套接字的资源

### socket网络编程实例

**socket本地通信：**
socket原本是为网络通讯设计的，但后来在socket框架的基础上发展出了一种IPC（进程通信）机制，即UNIX Domain Socket,专门用来实现使用socket实现的本地进程通信。

本地通信的流程与使用的接囗与基于TCP协议的网络通信模型相同，其大致流程如下：

- 调用socket函数通信双方进程创建各自的socket文件；
- 定义并初始化服务器端进程的地址，并使用bind()函数将其与服务器端进程绑定；
- 调用listen()函数监听客户端进程请求，
- 客户端调用connect()函数，根据已明确的客户端进程地址，向服务器发送请求；
- 服务器端调用accept()函数，处理客户端进程的请求，若客户端与服务器端进程成功建立连接，则双方进程可开始通信。
- 通信双方以数据流的形式通过已创建的连接互相发送和接收数据，进行通信；
- 待通信结束后。通信双方各自调用close()函数关闭连接

与socket网络通信不同的是，在本地通信中用到的套接字的结构体类型为socket_sockaddr_un

# 高并发服务器

## 多进程并发服务器

在多进程并发服务器中，若有用户请求到达，服务器将会调用fork()函数，创建一个子讲程，之后父进程将继续调用accept(),而子进程则去处理用户请求。

说明：

1. 多进程并发服务器效率高目更加稳定。服务器中的进程不会受其它讲程状态的影响：
2. 多进程并发服务器中进程数量受可打开文件描述符的限制：
3. 多进程并发服务器中进程数量受内存容量限制。

## 多线程并发服务器

考虑到每个进程可打开的文件描述符数量有眼，且进程占用资源较多，系统中进程的数量又受到内存大小的限制，为在保证服务器效率的前提下，降低服务器的消耗，可利用多线程机制搭建并发服务器。

与多进程服务器相比：

- 线程占用的空间资源大大减少，因此内存堆服务器的限制也被降低；
- 多线程并发服务器稳定性较差·

因此在搭建服务器时。应从需求出发，选择更为合适的服务器。

### 线程池

当服务器程序启动后，预先在其中创建定数量的线程，并将这些线程依次加入队列中。

在没有客户端的请求抵达时，线程队列中的线程都处于阻塞状态，此时这些线程只占用一些内存，但不占cpu。

若随后有用户请求到达，由线程池从线程队列中选出一个空闲线程，并将用户请求传给选出的线程，由该线程完成用户请求。

用户请求处理完毕，该线程并不退出，而是再次被加入线程队列，等待下一次任务。

此外，若线程队列中处于阻塞状态的线程较多，为节约资源，线程池会自动销毁一部分线程。

若线程队列中所有线程都有任务执行，线程池会自动创建一定数量的新线程，以提高服务器效率。

## I/O多路转接服务器

为进一步提升服务器效率，人们提出了一种被称为I/O多路转接的模型。其中、"多路"指代连接到服务器的多个客户端程序。而"转接"则是指在服务器主线与各分支之间设置一个"岗位"，由该岗位实现监控多路连接中数据状态的功能，若某路连接中数据就绪，就通知服务器，使主程序对该路请求作出处理。

与多进程和多线程并发服务器相比，I/O多路转接服务器实现了I/O多路复用，系统不必创建多进程或多线捏，也不必维护多个进程或线程，因此大大降低了系统开开销。

Linux系统中提供了select()、poll()和epoll()函数来实现I/O多路转接，下面将对这几种机制进行详细讲解与演示。