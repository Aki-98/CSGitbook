{"./":{"url":"./","title":"01_计算机基础","keywords":"","body":"个人学习笔记仓库 项目 md文件行数 占比 01_计算机基础 1175 ⬛ 02_数据结构与算法 3238 ⬛⬛⬛ 03_语言\\C++ 162 ⬛ 03_语言\\Java 4465 ⬛⬛⬛⬛ 03_语言\\Javascript pdf only 03_语言\\Kotlin 3118 ⬛⬛⬛ 03_语言\\Python 5638 ⬛⬛⬛⬛⬛⬛ 04_Android\\应用层 15031 ⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛ 04_Android\\框架层 5485 ⬛⬛⬛⬛⬛ 04_Android\\代码测试 3754 ⬛⬛⬛⬛ 05_Linux 2190 ⬛⬛ 06_数据库 2502 ⬛⬛⬛ 07_项目管理 3420 ⬛⬛⬛ 08_Others 3977 ⬛⬛⬛⬛ No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:14 "},"01_计算机基础/":{"url":"01_计算机基础/","title":"Ebook","keywords":"","body":"01_计算机基础 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/ebook/REFERS.html":{"url":"01_计算机基础/ebook/REFERS.html","title":"Refers","keywords":"","body":" sicp 编码：隐匿在计算机软硬件背后的语言（美）佩措尔德 计算机程序的构造和解释 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/操作系统原理/假唤醒.html":{"url":"01_计算机基础/操作系统原理/假唤醒.html","title":"假唤醒","keywords":"","body":"pthread 的条件变量等待 pthread_cond_wait 是使用阻塞的系统调用实现的（比如 Linux 上的 futex），这些阻塞的系统调用在进程被信号中断后，通常会中止阻塞、直接返回 EINTR 错误。同样是阻塞系统调用，你从 read 拿到 EINTR 错误后可以直接决定重试，因为这通常不影响它本身的语义。而条件变量等待则不能，因为本线程拿到 EINTR 错误和重新调用 futex 等待之间，可能别的线程已经通过 pthread_cond_signal 或者 pthread_cond_broadcast发过通知了。 所以，虚假唤醒的一个可能性是条件变量的等待被信号中断。不过，把等待放到循环里的另一个原因是还可能有这样的情况（有人觉得它是虚假唤醒的一种，有人觉得不是）：明明有对应的唤醒，但条件不成立。这是因为可能由于线程调度的原因，被条件变量唤醒的线程在本线程内真正执行「加锁并返回」前，另一个线程插了进来，完整地进行了一套「拿锁、改条件、还锁」的操作。比如 Windows 下 SleepConditionVariableCS 的文档中就明确指出了可能出现这种情况。（pthread 里的情况则有点区别，人家的 pthread_cond_signal 本来就可能唤醒多个正在等待的线程。） No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/操作系统原理/操作系统原理.html":{"url":"01_计算机基础/操作系统原理/操作系统原理.html","title":"操作系统原理","keywords":"","body":"一、操作系统的主要功能 操作系统的主要功能是对处理机、存储器、IO设备以及文件（数据和程序）进行有效的管理。 ①处理机管理功能 进程控制、进程同步、进程通信、调度（作业调度、进程调度）。 ②存储器管理功能 内存分配 为每道程序分配内存空间，使它们“各得其所” 提高存储器的利用率，尽量减少不可用的内存空间（碎片） 允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要 OS在实现内存分配时，可采取静态和动态两种方式： (1) 静态分配方式：每个作业的内存空间是在作业装入 时确定的，在作业装入后的整个运行期间不允许该作业再申 请新的内存空间，也不允许作业在内存中“移动”。 (2) 动态分配方式：每个作业所要求的基本内存空间虽 然也是在装入时确定的，但允许作业在运行过程中继续申请 新的附加内存空间，以适应程序和数据的动态增长，也允许 作业在内存中“移动”。 内存保护 确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰。 绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其它用户程序中去进行。 地址映射 在多道程序环境下，由于每道程序经编译和链接后所形成的可装入程序其地址都是从0开始的（逻辑地址），而存储在内存空间中的地址不可能都是从0开始的（物理地址）。地址映射功能，即能够将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。该功能应在硬件的支持下完成。 内存扩充 内存扩充是借助于虚拟存储技术，从逻辑上扩充内存容量，使用户所感觉到 的内存容量比实际内存容量大得多，以便让更多的用户程序 能并发运行。为了能在逻辑上扩充内存，系统必须设置内存扩充机制 (包含少量的硬件)，用于实现下述各功能： (1) 请求调入功能。 (2) 置换功能。 ③设备管理功能 缓冲管理、设备分配、设备处理 主要任务： (1) 完成用户进程提出的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作。 (2) 提高CPU和I/O设备的利用率，提高I/O速度，方便用户使用I/O设备。 ④文件管理功能 文件存储空间的管理 目录管理 文件的读/写管理和保护 ⑤操作系统与用户之间的接口 用户接口（联机用户接口、脱机用户接口、图形用户接口） 程序接口 程序接口是为用户程序在执行中访问系统资源而设置的， 是用户程序取得操作系统服务的唯一途径。它是由一组系统 调用组成的，每一个系统调用都是一个能完成特定功能的子 程序。每当应用程序要求OS提供某种服务(功能)时，便调用 具有相应功能的系统调用(子程序)。早期的系统调用都是用 汇编语言提供的，只有在用汇编语言书写的程序中才能直接 使用系统调用。 ⑥现代操作系统的新功能 系统安全：认证技术、密码技术、访问控制技术、反病毒技术 网络的功能和服务：网络通信、资源管理、应用互操作 支持多媒体：接纳控制功能、实时调度、多媒体文件的存储 二、进程控制 1.进程控制块（PCB ProcessControlBlock） 作用：使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。 信息： 进程标识符：用于惟一地标识一个进程。一个进程通常有两种标识符： 内部标识符：在所有的操作系统中，都为每一个进程赋予一个惟一的数字标识符，它通常是一个进程的序号。 设置内部标识符主要是为了方便系统使用。 外部标识符：它由创建者提供，通常是由字母、数字组成，往往是由用户(进程)在访问该进程时使用。为了描述进程的家族关系， 还应设置父进程标识及子进程标识。 此外，还可设置用户标识，以指示拥有该进程的用户。 处理机状态信息：主要是由处理机的各种寄存器中的内容组成的。 通用寄存器：又称为用户可视寄存器，它们是 用户程序可以访问的，用于暂存信息， 在大多数处理机中， 有 8~32 个通用寄存器，在RISC结构的计算机中可超过 100 个； 指令计数器：其中存放了要访问的下一条指令的地址； 程序状态字PSW：其中含有状态信息，如条件码、 执行方式、 中断屏蔽标志等； 用户栈指针： 指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。 进程调度信息：在PCB中还存放一些与进程调度和进程对换有关的信息，包括： 进程状态：指明进程的当前状态， 作为进程调度和对换时的依据； 进程优先级：用于描述进程使用处理机的优先级别的一个整数， 优先级高的进程应优先获得处理机； 进程调度所需的其它信息：它们与所采 用的进程调度算法有关，比如，进程已等待CPU的时间总 和、 进程已执行的时间总和等； 事件：是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因 进程控制信息： 程序和数据的地址： 是指进 程的程序和数据所在的内存或外存地(首)址，以便再调度到该进程执行时，能从PCB中找到其程序和数据； 进程同步和通信机制：指实现进程同步和进程通信时必需的机制， 如消息队列指针、信号量等，它们可能全部或部分地 放在PCB中； 资源清单：是一张列出了除CPU以外的、 进程所需的全部资源及已经分配到该进程的资源的清单； 链接指针： 它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址。 2.进程状态的转换 ①进程创建 引起创建进程的事件：用户登录、多页调度、提供服务、应用请求。 进程的创建 申请空白PCB。 为新进程分配资源。 初始化进程控制块。 将新进程插入就绪队列，如果进程就绪队列能够接纳新进程， 便将新进程插入就绪队列。 ②进程终止 引起进程终止的事件 正常结束：在任何计算机系统中，都应有一个用于表示进程已经 运行完成的指示。例如，在批处理系统中，通常在程序的 最后安排一条Holt指令或终止的系统调用。当程序运行到 Holt指令时，将产生一个中断，去通知OS本进程已经完成。 在分时系统中，用户可利用Logs off去表示进程运行完毕， 此时同样可产生一个中断，去通知OS进程已运行完毕。 异常结束：在进程运行期间，由于出现某些错误和故障而迫使进程 终止。这类异常事件很多，常见的有： 越界错误：这是指程序所访问的存储区，已越出该进程的区域； 保护错：进 程试图去访问一个不允许访问的资源或文件，或者以不适当的方式进行访问，例如，进程试图去写一个只读文件； 非法指令：程序试图去执行一条不存在的指令。出现该错误的原因，可能是程序错误地转移到数据区，把数据当成了指令； 特权指令错：用户进程试图去执行一条只允许OS执行的指令； 运行超时：进程的执行时间超过了指定的最大值； 等待超时：进程等待某事件的时间， 超过了规定的最大值； 算术运算错：进程试图去执行一个被禁止的运算，例如， 被0除； I/O故障：这是指在I/O过程中发生了错误等。 外界干预：外界干预并非指在本进程运行中出现了异常事件， 而是指进程应外界的请求而终止运行。这些干预有： 操作员或操作系统干预。 由于某种原因，例如，发生了 死锁， 由操作员或操作系统终止该进程； 父进程请 求。 由于父进程具有终止自己的任何子孙进程的权利， 因而当父进程提出请求时，系统将终止该进程； 父进 程终止。 当父进程终止时，OS也将他的所有子孙进程终 止。 进程的中止过程 根据被终止进程的标识符，从PCB集合中检索出该 进程的PCB，从中读出该进程的状态。 若被终止进程正处于执行状态，应立即终止该进程 的执行，并置调度标志为真，用于指示该进程被终止后应 重新进行调度。 若该进程还有子孙进程，还应将其所有子孙进程予 以终止，以防他们成为不可控的进程。 将被终止进程所拥有的全部资源，或者归还给其父 进程， 或者归还给系统。 将被终止进程(它的PCB)从所在队列(或链表)中移出， 等待其他程序来搜集信息。 ③进程的阻塞与唤醒 引起进程阻塞和唤醒的事件：请求系统服务、启动某种操作、新数据尚未到达、无新工作可做。 进程阻塞过程：正在执行的进程，当发现上述某事件时，由于无法继续 执行，于是进程便通过调用阻塞原语block把自己阻塞。可见， 进程的阻塞是进程自身的一种主动行为。进入block过程后， 由于此时该进程还处于执行状态，所以应先立即停止执行， 把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插 入阻塞队列。如果系统中设置了因不同事件而阻塞的多个阻 塞队列，则应将本进程插入到具有相同事件的阻塞(等待)队列。 最后，转调度程序进行重新调度，将处理机分配给另一就绪 进程，并进行切换，亦即，保留被阻塞进程的处理机状态(在 PCB中)，再按新进程的PCB中的处理机状态设置CPU的环境。 进程唤醒过程：当被阻塞进程所期待的事件出现时，如I/O完成或其所 期待的数据已经到达，则由有关进程(比如，用完并释放 了该I/O设备的进程)调用唤醒原语wakeup( )，将等待该事 件的进程唤醒。唤醒原语执行的过程是：首先把被阻塞的 进程从等待该事件的阻塞队列中移出，将其PCB中的现行 状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。 ④进程的挂起与激活 进程的挂起：当出现了引起进程挂起的事件时，比如，用户进程 请求将自己挂起，或父进程请求将自己的某个子进程挂 起， 系统将利用挂起原语suspend( )将指定进程或处于阻 塞状态的进程挂起。挂起原语的执行过程是：首先检查 被挂起进程的状态，若处于活动就绪状态，便将其改为 静止就绪；对于活动阻塞状态的进程，则将之改为静止 阻塞。 为了方便用户或父进程考查该进程的运行情况而 把该进程的PCB复制到某指定的内存区域。最后，若被 挂起的进程正在执行，则转向调度程序重新调度。 进程的激活过程：当发生激活进程的事件时，例如，父进程或用户进程请 求激活指定进程，若该进程驻留在外存而内存中已有足够的 空间时，则可将在外存上处于静止就绪状态的进程换入内存。 这时，系统将利用激活原语active( )将指定进程激活。 激活 原语先将进程从外存调入内存，检查该进程的现行状态，若 是静止就绪，便将之改为活动就绪；若为静止阻塞便将之改 为活动阻塞。假如采用的是抢占调度策略，则每当有新进程 进入就绪队列时，应检查是否要进行重新调度，即由调度程 序将被激活进程与当前进程进行优先级的比较，如果被激活 进程的优先级更低，就不必重新调度；否则，立即剥夺当前 进程的运行，把处理机分配给刚被激活的进程。 3.进程同步 临界资源：一次仅允许一个进程使用的共享资源 AND同步机制：将进程在整个运行过程 中需要的所有资源，一次性全部地分配给进程，待进程使 用完后再一起释放。只要尚有一个资源未能分配给进程， 其它所有可能为之分配的资源，也不分配给他。亦即，对 若干个临界资源的分配，采取原子操作方式：要么全部分 配到进程，要么一个也不分配。 由死锁理论可知，这样就 可避免上述死锁情况的发生。 管程机制： 信号量的大量同步操作分散在各个进程中不便于管理，还有可能导致系统死锁。 管程即把所有进程堆某一种临界资源的同步操作都集中起来，构成一个秘书进程。凡要访问该临界资源的进程，都需先报告秘书，由秘书来实现诸进程对同一临界资源的互斥使用。 管程的构成： 局部于管程的共享数据结构； 对共享数据结构进行操作的一组函数； 对局部于管程的数据设置初始值的语句。 管道通信： 管道即用于连接一个读进程和一个写 进程以实现他们之间通信的一个共享文件，又名pipe文件。 管道机制必须提供以下三方面的协调能力： 互斥：即当一个进程正在对pipe执行读/ 写操作时，其它(另一)进程必须等待。 同步：指当写 (输入)进程把一定数量(如4 KB)的数据写入pipe，便去睡眠等待， 直到读(输出)进程取走数据后，再把他唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据 写入管道后，才将之唤醒。 确定对方是否存在，只有确定了对方已存在时，才能进行通信。 直接通信机制：当生产者生产出一个产品(消息)后，便用Send原语将消息发送 给消费者进程；而消费者进程则利用Receive原语来得到一个消 息。如果消息尚未生产出来，消费者必须等待，直至生产者进 程将消息发送过来。 Send(Receiver, message); 发送一个消息给接收进程； Receive(Sender, message); 接收Sender发来的消息； 间接通信机制：当进程之间要利用信箱进行通信 时，必须使用共享信箱。 Send(mailbox, message); 将一个消息发送到指定信箱； Receive(mailbox, message); 从指定信箱中接收一个消息； 有三类信箱：私有信箱、公用信箱、共享信箱。 发送进程和接收进程之间的关系：一对一、一对多、多对多。 根据通信的方式，又可分为：单向通信链路（只允许发送进程向接收进程发送消息）、双向链路 4.线程 ①线程的状态 状态参数： 寄存器状态：它包括程序计数器PC和堆栈指针中的内容 堆栈， 在堆栈中通常保存有局部变量和返回地址； 线程运行状态：用于描述线程正处于何种运行状态； 优先级：描述线程执行的优先程度； 线程专有存储器：用于保存线程自己的局部变量拷贝； 信号屏蔽：即对某些信号加以屏蔽 线程运行状态： 执行状态：表示线程正获得处理机而运行； 就绪状态：指线程已具备了各种执行条件，一旦获得CPU便可执行的状态； 阻塞状态：指线程在执行中因某事件而受阻，处 于暂停执行时的状态。 ②多线程OS环境 在多线程OS环境下，应用程序在启动时，通常仅有一 个线程在执行，该线程被人们称为“初始化线程” 。它可 根据需要再去创建若干个线程。在创建新线程时，需要利 用一个线程创建函数(或系统调用)，并提供相应的参数，如 指向线程主程序的入口指针、堆栈的大小，以及用于调度 的优先级等。在线程创建函数执行完后，将返回一个线程 标识符供以后使用。 在多线程OS中，进程是作为拥有系统资源的基本单位， 通常的进程都包含多个线程并为它们提供资源，但此时的进 程就不再作为一个执行的实体。 多线程OS中的进程有以下 属性： 作为系统资源分配的单位。 可包括多个线程。 进程不是一个可执行的实体。 线程的属性： 轻型实体。 独立调度和分派的基本单位。 可并发执行。 共享进程资源 ③内核支持线程和用户级线程 内核支持线程：这里所谓的内核支持线程，也都同样是在内核的支 持下运行的，即无论是用户进程中的线程，还是系统进 程中的线程，他们的创建、撤消和切换等，也是依靠内 核实现的。此外，在内核空间还为每一个内核支持线程 设置了一个线程控制块， 内核是根据该控制块而感知某 线程的存在的，并对其加以控制。 用户级线程：用户级线程仅存在于用户空间中。对于这种线程的 创建、 撤消、线程之间的同步与通信等功能，都无须利 用系统调用来实现。对于用户级线程的切换，通常是发 生在一个应用进程的诸多线程之间，这时，也同样无须 内核的支持。由于切换的规则远比进程调度和切换的规 则简单，因而使线程的切换速度特别快。可见，这种线 程是与内核无关的。 用户级线程的实现：运行时系统、内核控制线程。 运行时系统：所谓“运行时系统” ，实质上是用于管理和控制线程 的函数(过程)的集合， 其中包括用于创建和撤消线程的函 数、 线程同步和通信的函数以及实现线程调度的函数等。 正因为有这些函数，才能使用户级线程与内核无关。运行 时系统中的所有函数都驻留在用户空间，并作为用户级线 程与内核之间的接口。 内核控制线程：这种线程又称为轻型进程 LWP(Light Weight Process)。 每一个进程都可拥有多个LWP， 同用户级 线程一样， 每个LWP都有自己的数据结构(如TCB)，其 中包括线程标识符、优先级、 状态， 另外还有栈和局 部存储区等。 它们也可以共享进程所拥有的资源。 LWP可通过系统调用来获得内核提供的服务，这样， 当一个用户级线程运行时，只要将它连接到一个LWP 上，此时它便具有了内核支持线程的所有属性。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/数学/排列组合.html":{"url":"01_计算机基础/数学/排列组合.html","title":"排列组合","keywords":"","body":"排列（Permutation）： 排列是指从给定的元素集合中取出一些元素按照一定的顺序排列。如果有 n 个元素，取 r 个元素进行排列，表示为 P(n, r) 或 nPr，排列的计算公式为： P(n,r)=n!/(n−r)! 其中，n! 表示 n 的阶乘，即 n×(n−1)×…×2×1n×(n−1)×…×2×1。 组合（Combination）： 组合是指从给定的元素集合中取出一些元素，不考虑元素的顺序。如果有 n 个元素，取 r 个元素进行组合，表示为 C(n, r) 或 nCr，组合的计算公式为： C(n,r)=n!/(r!×(n−r*)!) 二项式定理： 二项式定理是组合数学中的一个重要定理，描述了一个二项式的展开形式。对于任意实数 a 和 b，以及非负整数 n，二项式定理表示为： 乘法法则和加法法则： 乘法法则用于计算一系列独立事件的总体可能性。如果事件 A 有 m 种可能发生方式，事件 B 有 n 种可能发生方式，那么 A 和 B 一起发生有 m×n 种可能。 加法法则用于计算互斥事件的总体可能性。如果事件 A 有 m 种可能发生方式，事件 B 有 n 种可能发生方式，且 A 和 B 不可能同时发生，那么 A 或 B 发生有 m+n* 种可能。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/栈与堆.html":{"url":"01_计算机基础/栈与堆.html","title":"栈与堆","keywords":"","body":"堆和栈是两种常见的数据结构，它们有以下不同点： 存储方式 栈是一种先进后出（Last In First Out，LIFO）的数据结构，它的元素只能从顶部插入和弹出。在计算机内存中，栈通常采用连续的内存空间存储，由操作系统自动分配和释放。 堆是一种基于树结构的数据结构，它的元素可以在任意位置插入和删除，没有固定的顺序。在计算机内存中，堆通常采用不连续的内存空间存储，由程序员手动分配和释放。 内存管理 栈的内存管理是由操作系统自动完成的，每当函数被调用时，栈会自动为函数的局部变量和返回地址分配一定的内存空间。当函数返回时，栈会自动释放这些空间。 堆的内存管理是由程序员手动完成的。在使用堆存储数据时，程序员需要手动分配一定的内存空间，使用完后需要手动释放。如果没有释放，就会造成内存泄漏问题。 存储内容 栈通常用于存储局部变量、函数调用信息和一些临时数据。栈中的数据通常比较小，但是访问速度比堆快。 堆通常用于存储动态分配的数据，例如数组、对象和指针等。堆中的数据可以比较大，但是访问速度比栈慢。 总的来说，栈和堆都有各自的优缺点，适用于不同的场景。程序员在使用时应根据具体的需求来选择合适的数据结构。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/编码.html":{"url":"01_计算机基础/编码.html","title":"编码","keywords":"","body":"GBK --> 中文字符编码，拓展自GB2312，包含一些繁体字等 Unicode --> 号称世界上所有语言的编码 ASCII --> 只支持英文 以GBK格式写入的文件，在UTF-8编码模式下会显示方块问号，如果此时保存，再用GBK格式打开，就会显示锟斤拷 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/计算机网络/HTTPS基础.html":{"url":"01_计算机基础/计算机网络/HTTPS基础.html","title":"Https基础","keywords":"","body":"HTTP存在的问题 可能被窃听 HTTP本身不具备加密的功能，HTTP报文使用明文方式发送 由于互联网是由联通世界各个地方的网络设施组成，所有发送和接收经过某些设备的数据都可能被截获或窥视。 认证问题 无法确认你发送到的服务器就是真正的目标服务器，可能服务器是伪装的 无法确定返回的客户端是否是按照真实意图接收的客户端，可能是伪装的客户端 无法确定正在通信的对方是否具备访问权限，Web服务器上某些重要的信息，只想发给特定用户即使是无意义的请求也会照单全收。无法阻止海量请求下的dos攻击（拒绝服务攻击） 可能被篡改 请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击被称为中间人攻击。 HTTPS定义 HTTP over SSL的简称，即工作在SSL（或TLS）上的HTTP。就是加密通信的HTTP。 工作原理 在客户端和服务器之间协商出一套对称密钥，每次发送信息之前将内容加密，收到之后解密，达到内容的加密传输。 为什么不直接用非对称加密？ 非对称加密由于使用了复杂的数学原理，因此计算想当复杂，如果完全使用非对称加密来加密通信内容，会严重影响网络通信的性能。 HTTPS 连接建立的过程 HTTPS的整体思路很简单，它其实就是做了三件事：认证、密钥协商、数据加密 通信双方身份的验证 通信双方协商出一个安全的会话密钥，注意中间人攻击的问题 使用会话密钥对称加密通信内容 下面是具体过程 ClientHello： 建立TCP连接之后，客户端率先发出Client Hello消息 ServerHello：服务端在收到Client Hello之后，根据客户端发来的消息内容作出回应，在这一步协商：密钥协商算法、身份验证算法、对称加密算法、摘要算法 服务器证书信任建立（Certificate） ：服务端在发送ServerHello之后会立马发送服务器的证书链信息，其实 Certificate 和 Server Hello 是在同一个数据包里面的，以降低延迟 Pre-masterSecret ： pre-master-secret由client产生，在产生该secret之前，client和server已经交换了client_random和server_random。然后client和server会使用一个PRF(Pseudo-Random Function)来产生master-secret 客户端通知:将使用加密通信 ：通知对方我已经准备好加密通信了 客户端发送:Finished ： 握手消息的完整性校验 服务器通知:将使用加密通信 服务器发送:Finished No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/计算机网络/HTTP基础.html":{"url":"01_计算机基础/计算机网络/HTTP基础.html","title":"Http基础","keywords":"","body":"什么是HTTP？ HTTP（HyperText Transfer Protocol，超文本传输协议），是客户端和服务器之间的一种数据传输协议。 HTTP的工作方式 浏览器：用户输入网址后回车或点击链接 -> DNS查询 -> 浏览器拼装HTTP报文并发送请求给服务器 -> 服务器处理请求后发送响应报文给浏览器 -> 浏览器解析响应报文并使用渲染引擎显示 手机APP：用户点击或界面自动触发联网 -> 代码调用拼装HTTP报文并发送请求到服务器 -> 服务器处理请求后发送响应报文给手机 -> 代码处理响应报文并作出相应处理（存储、展示、加工等） URI、URL URI，Uniform Resource Identifier ，统一资源标识符。 URL，Uniform Resource Locator，统一资源定位符。描述了一台特定服务器上某资源的特定位置。它分为三部分：协议类型、服务器地址（和端口号）、路径Path。一般遵循语法：协议类型://服务器地址[:端口号]/路径。比如：https://baidu.com/x/yy 可见笔记：URI和URL的区别 报文格式 分为2种：请求报文、响应报文 请求报文 GET /users HTTP/1.1 Host: api.github.com Content-Type: text/plain Content-Length: 243 fafasfajfhajfjas 第一行是请求行 method: GET path: /users HTTP version : HTTP/1.1 第2、3、4行是Header 最后一行是Body 响应报文 HTTP/1.1 200 0K content-type: application/ json; charset=utf-8 cache-control: public, max-age=60, s-maxage=60 vary: Accept , Accept-Encoding etag: W/\"Ø2eec5b334bØe4c05253d3f4138daa46\" content-encoding: gzip {\"data\":...} 第一行的状态行 HTTP version : HTTP/1.1 status code : 200 status message : OK 第2、3、4、5、6行是header 最后一行是Body 请求方法 Request Method HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1 新增了六种请求方法：PUT、DELETE、OPTIONS、PATCH、TRACE 和 CONNECT 方法。 下面我们来讲讲常用的GET、POST、PUT、DELETE、HEAD Retrofit介绍：https://cloud.tencent.com/developer/article/1179344 GET GET请求用于获取资源，对服务器数据不进行修改，不发送Body。 GET /users/1 HTTP/1.1 Host: api.github.com 对应的Retrofit代码： @GET(\"/users/{id}\") Call getUser(@Path(\"id\") String id,@Query(\"gender\") String gender); POST POST用于增加或修改资源，发送给服务器的内容写在Body里面。 POST /users HTTP/1.1 Host: api.github.com Content-Type: application/x-www-form-urlencoded Content-Length: 13 name=xfhy&gender=male 对应Retrofit代码 @FormUrlEncoded @POST(\"/users\") Call addUser(@Field(\"name\") String name,@Field(\"gender\") String gender); HEAD HEAD方法与GET类似，但是服务器只会返回首部，不会返回Body。 作用： 在不获取资源的情况下了解资源的情况（比如，判断其类型） 通过查看响应中的状态码，查看资源是否存在 通过查看首部，测试资源是否被修改 PUT PUT用于修改资源，发送给服务器的内容写在Body里面 PUT /useers/1 HTTP/1.1 Host: api.github.com Content-Type: application/x-www-form-urlencoded Content-Length: 13 gender=male 对应Retrofit代码： @FormUrlEncoded @PUT(\"users/{id}\") Call updateGender(@Path(\"id\") String id,@Field(\"gender\") String gender); DELETE DELETE用于删除资源，不发送Body。 DELETE /users/1 HTTP/1.1 Host: api.github.com 对应Retrofit代码： @DELETE(\"/users/{id}\") Call getUser(@Path(\"id\") String id,@Query(\"gender\") String gender); 状态码 Status Code 状态码是三位数字，用于对响应结果做出类型化描述（如「获取成功」「内容未找到」） 1xx：临时性消息。 如：100（继续发送）、101（正在切换协议） 2xx：成功。如200（OK）、201（创建成功） 3xx：重定向。如301（永久移动）、302（暂时移动）、304（内容未改变） 4xx：客户端错误。如400（客户端请求错误）、401（认证失败）、403（被禁止）、404（找不到内容） 5xx：服务器错误。如500（服务器内部错误） 首部 Header HTTP协议的请求和响应报文中必定包含HTTP首部，也就是Header。HTTP消息的元数据（metadata），有些东西放Body里面不合理，放Header里面就刚好。 下面来介绍一些常见的Header： HOST 目标主机。这个Host不是在网络上用于寻址的，而是在目标服务器上用于定位子服务器的。 Content-Type 指定Body的类型，主要有4类： text/html x-www-form-urlencoded multipart/form-data application/json,image/jpeg,application/zip ... text/html 请web页面返回响应的类型，Body中返回HTML文本。格式如下： HTTP/1.1 200 OK Content-Type: text/html; charset=utf-8 Content-Length: 432 ...... x-www-form-urlencoded web页面纯文本表单的提交方式 POST /users/ HTTP/1.1 Host: api.github.com Content-Type: application/x-www-form-urlencoded Content-Length: 21 name=xfhy&gender=male 对应Retrofit代码： @FormUrlEncoded @POST(\"/users\") Call addUser(@Field(\"name\") String name,@Field(\"gender\") String gender); multipart/form-data web页面含有二进制文件时的提交方式，比如同时提交一个文件+文件名。 POST /users HTTP/1.1 Host: api.github.com Content-Type: multipart/form-data; boundary=---- WebKitFormBoundary7MA4YWxkTrZu0gW Content-Length: 2382 ------WebKitFormBoundary7MA4YWxkTrZu0gW Content-Disposition: form-data; name=\"name\" xfhy ------WebKitFormBoundary7MA4YWxkTrZu0gW Content-Disposition: form-data; name=\"avatar\"; filename=\"avatar.jpg\" Content-Type: image/jpeg JFIFHHvOwX9jximQrWa...... ------WebKitFormBoundary7MA4YWxkTrZu0gW-- 其中boundary是分割符的意思，参数的名称是name，值是xfhy。 对应Retrofit代码： @Multipart @POST(\"/users\") Call addUser(@Part(\"name\") RequestBody name,@Part(\"avatar\") RequestBody avatar); ... RequestBody namePart = RequestBody.create(MediaType.parse(\"text/plain\"), nameStr); RequestBody avatarPart = RequestBody.create(MediaType.parse(\"image/jpeg\"), avatarFile); api.addUser(namePart, avatarPart); application/json,image/jpeg,application/zip ... 单项内容（文本或非文本都可以），用于Web Api的响应或者POST、PUT的请求 请求中提交JSON POST /users HTTP/1.1 Host: api.github.com Content-Type: application/json; charset=utf-8 Content-Length: 38 {\"data\":\"xxxx\"} 对应Retrofit代码： @POST(\"/users\") Call addUser(@Body(\"user\") User user); ... //需要使用JSON相关的Converter，Retrofit才会帮我们把JSON转为User api.addUser(user); 响应中返回JSON： HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Content-Length: 234 {\"data\":\"wocao\"} 请求中提交二进制内容： POST /user/1/avatar HTTP/1.1 Host: api.github.com Content-Type: image/jpeg Content-Length: 3132 JHFFGJFHJVVJ&... 对应Retrofit代码： @POST(\"users/{id}/avatar\") Call updateAvatar(@Path(\"id\") String id,@Body RequestBody avatar); ... RequestBody avatarBody = RequestBody.create(MediaType.parse(\"image/jpeg\"), avatarFile); api.updateAvatar(id, avatarBody) 响应中返回二进制内容： HTTP/1.1 200 OK Content-Type: image/jpeg Content-Length: 7989 JGGJHGGHJ6768.... Content-Length 指定Body的长度（字节）。 Transfer: chunked(分块传输编码) 用于当响应发起时，内容长度还没确定的情况下。和Content-Length不同时使用。用途是尽早给出响应，减少用户等待。 格式： HTTP/1.1 200 OK Content-Type: text/html Transfer-Encoding: chunked 2 aa 2 dd 6 fafafs 0 Location 指定重定向的目标URL User-Agent 用户代理，即是谁实际发送请求、接受响应的，例如手机浏览器、某款app。 Range/Accept-Range 按范围取数据（比如在断点续传时）。 Accept-Range: bytes 响应报文中出现，表示服务器支持按字节来取范围数据 Range: bytes=- 请求报文中出现，表示要取哪段数据 Content-Range: -/total 响应报文中出现，表示发送的是哪段数据 作用: 断点续传、多线程下载。 相关链接：https://blog.csdn.net/thewindkee/article/details/80189434 其他Header Accept：客户端能接受的数据类型。如text/html Accept-Charset: 客户端接受的字符集。如utf-8 Accept-Encoding: 客户端接受的压缩编码类型。如gzip Content-Encoding: 压缩类型。如gzip Cache 作用： 在客户端或中间网络节点缓存数据，降低从服务器取数据的频率，以提高网络性能。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/计算机网络/SSL.html":{"url":"01_计算机基础/计算机网络/SSL.html","title":"Ssl","keywords":"","body":"输安全性的标准加密技术。SSL通过在通信双方之间建立加密连接来确保数据的机密性和完整性，防止数据在传输过程中被窃取、篡改或伪造。 SSL技术的主要功能包括： 加密通信：SSL使用加密算法对传输的数据进行加密，使得只有授权的双方能够解密并读取数据，其他人无法窃取敏感信息。 身份验证：SSL通过数字证书验证通信双方的身份，确保通信的一方是合法的，并且双方的身份都是可信的，从而防止中间人攻击。 数据完整性：SSL使用消息摘要算法（如SHA）对传输的数据进行哈希计算，然后使用数字签名技术将摘要与发送方的公钥进行签名，确保数据在传输过程中没有被篡改。 SSL的最新版本是TLS（Transport Layer Security），目前广泛应用于Web浏览器和服务器之间的安全通信，用于保护网站的登录、支付、个人信息等敏感数据的传输安全。HTTPS（HyperText Transfer Protocol Secure）就是基于SSL/TLS的安全的HTTP协议，用于加密和保护Web页面的传输。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/计算机网络/TCP,IP协议族.html":{"url":"01_计算机基础/计算机网络/TCP,IP协议族.html","title":"Tcp,ip协议族","keywords":"","body":"TCP,IP协议族 目录 TCP/IP协议族 TCP连接 什么叫做连接 TCP连接的建立与关闭 3次握手 4次挥手 长连接 为什么要长连接 长连接的实现方式 TCP/IP协议族 概念：一系列协议所组成的一个网络分层模型 为什么要分层？因为网络的不稳定性 具体分层： 应用层（Application Layer）：HTTP、FTP、DNS 传输层（Transport Layer ）： 网络层（Internet Layer）： 数据链路层（Link Layer）： 层 英文名 协议 备注 应用层 Application Layer HTTP、FTP、DNS 给出需要传输的数据 传输层 Transport Layer TCP、UDP 将需要传输的数据分块，然后交给网络层，重传也是这里负责 网络层 Internet Layer IP 负责传输，路由、寻址什么的 数据链路层 Link Layer 以太网、WiFi TCP连接 什么叫做连接 这里的连接是TCP连接，必须先建立连接，双方才能发送消息，不然不认识你，就会把你的消息丢掉。 TCP连接的建立与关闭 3次握手 过程 具体描述 报文段信息 状态 第一次握手 客户端向服务器发送一个连接请求的报文段 同步标志位设为1：SYN=1；随机选择一个起始序号：seq=x；不携带数据；（因SYN位被设置为1的报文段不能携带数据，但要消耗一个序号） 客户端进入「同步已发送」状态（SYN_SEND）（等待服务器的确认） 第二次握手 服务器收到请求连接报文段后，若同意建立连接，则向客户端发回连接确认的报文段（为该TCP连接分配TCP缓存、变量） 同步标志位设为1：SYN-1；确认标志位设为1：ACK=1；随机选择一个起始序号：seq=y；确认号字段设为：ack=x+1；不携带数据（原因同上，但要消耗一个序号） 服务器进入「同步已接收」状态（SYN_RCVD） 第三次握手 客户端收到确认报文段后，向服务器再次发出连接确认报文段（为该TCP连接分配TCP缓存、变量） 确认标志位设为1：ACK=1；序号：seq=x+1；确认号字段设为ack=y+1；可携带数据（因SYN无需设为1，若不携带数据则不消耗序号） 客户端、服务器端都进入已创建状态（ESTABLISHED）（可开始发送数据） 为什么只有三次握手才能确认双方的接收与发送能力是否正常，而两次却不可以（为什么需要三次握手）？ 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常 三次握手的作用： 确认双方的接收能力、发送能力是否正常 指定自己的初始化序列号，为后面的可靠传输做准备 防止服务器端因接收了早已失效的连接请求报文，从而一直等待客户端请求，最终导致形成死锁、浪费资源 4次挥手 在通信结束后，双方都可以释放连接，共需四次挥手 过程 具体描述 报文段信息 状态 第一次挥手 客户端向服务器发送1个连接释放的报文段（停止再发送数据） 终止控制位设为1：FIN=1；报文段序号设为前面传送数据最后一个字节的序号加1：seq=u；可携带数据（FIN=1的报文即使不携带数据也消耗1个序号） 客户端进入终止等待1状态（FIN-WAIT-1）（等待服务器的确认） 第二次挥手 服务器收到连接释放报文段后，则向客户端发回连接释放确认的报文段 确认标记位设为1：ACK=1；报文段序号 设为前面传送数据最后一个字节的序号加1：seq=v；确认号字段设为：ack=u+1； 服务器进入关闭等待状态（CLOSE-WAIT）；客户端收到服务器的确认后，进入终止等待2状态（FIN-WAIT-2），等待服务器发出释放连接请求；至此，客户端->服务器的TCP连接已断开；即TCP连接处于半关闭状态；即客户端->服务器断开，但服务器->客户端未断开 第三次挥手 若服务器已无要向客户端发送数据，则发出释放连接的报文段 终止控制位 设为1：FIN=1；确认标记位设为1：ACK=1，报文段序号：seq=w；重复上次已发送的确认号字段，设为：ack=u+1；可携带数据（FIN=1的报文即时不携带数据也消耗1个序号） 服务器端进入最后确认状态（LAST-ACK） 第四次挥手 客户端收到连接释放报文段后，则向服务器发回连接释放确认的报文段 确认标记位 设为1：ACK=1；报文段序号：seq=u+1；确认号字段 设为ack=w+1；可携带数据（FIN=1的报文即使不携带数据也消耗1个序号） 客户端进入时间等待状态（TIME-WAIT），服务器进入 关闭状态（CLOSED）；此时TCP连接还未释放 ；须经过时间等待计时器设置的时间2MSL后，客户端才进入连接关闭状态（CLOSED）；即服务器进入关闭状态比客户端要早一些 长连接 为什么要长连接 移动网络并不在Internet中，而是在运营商的内网，并不具有真正的公网IP，因此当某个TCP连接在一段时间不通信之后，网关会出于网络性能考虑而关闭这条TCP连接和公网的连接通道，导致这个TCP端口不再能收到外部通信消息，即TCP连接被动关闭。 长连接的实现方式 心跳。即在一定间隔时间内，使用TCP连接发送超短无意义消息来让网关不能将自己定义为空闲连接，从而防止网关将自己的连接关闭。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/计算机网络/URL和URI的区别.html":{"url":"01_计算机基础/计算机网络/URL和URI的区别.html","title":"Url和uri的区别","keywords":"","body":"URL和URI之间的区别是： URL（统一资源定位符）主要用于链接网页，网页组件或网页上的程序，借助访问方法（http，ftp，mailto等协议）来检索位置资源。 URI（统一资源标识符）用于定义项目的标识，URI中不涉及协议规范。 URI包含URL（URL是URI的子集）。 URL包含以下信息： 1、用于访问资源的协议 2、服务器的位置（无论是通过IP地址还是域名） 3、服务器上的端口号（可选） 4、资源在服务器目录结构中的位置 5、片段标识符（可选） URI通用格式： scheme:[//[user:password@]host[:port]][/]path[?查询][#片段] Scheme（方案）：该方案列出了具体语法和URI的任何相关协议。方案不区分大小写，后跟冒号。理想情况下，URI方案应该在互联网号码分配机构（IANA）注册，但也可以使用非注册方案。 权限组件：权限组件由多个部分组成：可选的身份验证部分，主机（由注册名称或IP地址组成） , 以及可选的端口号。身份验证部分包含用户名和密码，用冒号分隔，后跟at（@）符号。在@之后是主机名，然后是冒号，然后是一个端口号。请务必注意，IPv4地址必须采用点十进制表示法，并且IPv6地址必须括在括号中。 查询（可选）：查询包含一串非分层数据。虽然语法没有明确定义，但通常是由分隔符分隔的属性值对序列，例如＆符号或分号。查询通过问号与前一部分分开。 片段（可选）：片段包含片段标识符，该标识符为辅助资源提供方向。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/计算机网络/登录和第三方授权.html":{"url":"01_计算机基础/计算机网络/登录和第三方授权.html","title":"登录和第三方授权","keywords":"","body":"目录 登录和授权的区别 HTTP中确认授权（或登录）的两种方式 Cookie 工作机制 Cookie的作用 Authorization Basic Bearer 登录和授权的区别 HTTP中确认授权（或登录）的两种方式 通过Cookie 通过Authorization Header Cookie 工作机制 服务器需要客户端保存的内容，放在Set-Cookie headers里返回，客户端会自动保存 客户端保存的Cookies，会在之后的所有请求里面都携带进Cookie header里发回给服务器 客户端保存Cookie是按照服务器域名来分来的 客户端保存的Cookie在超时后会被删除、没有设置超时时间的Cookie（称作Session Cookie）在浏览器关闭后就会自动删除；另外服务器也可以主动删除还未过期的客户端Cookies。 Cookie的作用 回话管理： 登录状态、购物车 个性化：用户偏好、主题 Tracking：分析用户行为 和Cookie相关的网络攻击 XSS(Cross-site scripting)：跨站脚本攻击。即使用 JavaScript 拿 到浏览器的 Cookie 之后，发送到自己的网站，以这种方式来盗取用户 Cookie。应对方式:Server 在发送 Cookie 时，敏感的 Cookie 加上 HttpOnly。应对方式:HttpOnly——这个 Cookie 只能用于 HTTP 请求，不能被 JavaScript 调用。它可以防止本地代码滥用 Cookie。 XSRF(Cross-site request forgery)：跨站请求伪造。即在用户不 知情的情况下访问已经保存了 Cookie 的网站，以此来越权操作用户账户(例如 盗取用户资金)。应对方式主要是从服务器安全⻆度考虑，就不多说了。应对方式:Referer 校验。 Authorization 一种header，两种主流使用方式：Basic和Bearer Basic 格式：Authorization: Basic 这里的username:password是Base64了的 Bearer 格式：Authorization：Bearer bearer token的获取方式：通过OAuth2的授权流程 OAuth2的流程 第三方网站（如掘金）向授权方网站（Github）申请第三方授权合作，拿到client id和client secret 用户在使用第三方网站时，点击「通过XX（如GitHub授权）」按钮，第三方网站将页面跳转到授权方网站，并传入client id作为自己的身份标识(用来标识自己是哪个第三方网站，比如自己是掘金) 授权方网站根据client id，将第三方网站的信息和第三方网站需要的用户权限展示给用户，并询问用户是否同意授权 用户点击同意授权按钮后，授权方网站将页面跳转回第三方网站，并传入Authorization code作为用户认可的凭证 第三方网站将Authorization code发送回自己的服务器 服务器将Authorization code和自己的client secret一并发送给授权方的服务器，授权方服务器在验证通过后，返回access token。OAuth流程结束。 在上面的过程结束后，第三方网站的服务器（掘金）就可以使用access token作为用户授权的令牌（或者有时这个操作也会放在客户端，但是不安全），向授权方网站发送请求来获取用户信息或操作用户账户。但这已经在OAuth流程之外。 为什么OAuth要引入Authorization code，并需要申请授权的第三方将Authorization code发送回自己的服务器，再从服务器来获取access token，而不是直接返回access token？这样复杂的流程意义何在？为了安全。OAuth不强制授权流程必须使用HTTPS，因此需要保证当通信路径中存在窃听者时，依然具有足够高的安全性。 第三方App通过微信登录的流程，也是一个OAuth2流程： 第三方App向腾讯申请第三方授权合作，拿到client id和client secret 用户在使用第三方App时，点击「通过微信登录」，第三方App将使用微信SDK跳转到微信，并传入自己的client id作为自己的身份标识 微信通过和服务器交互，拿到第三方App的信息，并限制在界面中，然后询问用户是否同意授权该App使用微信来登录 用户点击「使用微信登录」后，微信和服务器交互将授权信息提交，然后跳转回第三方App，并传入Authorization code作为用户认可的凭证 第三方App调用自己的服务器的微信登录API，并传入Authorization code，然后等待服务器的响应 服务器在收到登录请求后，拿收到的Authorization code去向微信的第三方授权接口发送请求，将Authorization code和自己的client secret一起作为参数发送，微信在验证通过后，返回access token 服务器在收到access token后，立即拿着access token去向微信的用户信息接口发送请求，微信验证通过后，返回用户信息 服务器在收到用户信息后，在自己的服务器中为用户创建一个账户，并使用从微信服务器拿来的用户信息填入自己的数据库，以及将用户的ID和用户的微信ID做关联 用户创建完成后，服务器向客户端的请求发送响应，传送回刚创建好的用户信息 客户端收到服务器响应，用户登录成功 在自家App中使用Bearer token: 有的App会在Api的设计中，将登录和授权设计成类似OAuth2的过程，但简化掉Authorization code概念。即：登录接口请求成功时，会返回access token，然后客户端在之后的请求中，就可以使用这个access token来当做bearer token进行用户操作了。 Refresh token： { \"token_type\": \"Bearer\", \"access_token\": \"xxxxx\", \"refresh_token\": \"xxxxx\", \"expires_time\": \"xxxxx\" } 用法：access_token有有效时间，在它失效后，调用refresh token接口，传入refresh_token来获取新的access token。 目的：安全。当access token失窃，由于它有有效时间，因此坏人只有较短的时间来做坏事；同时，由于（在标准的OAuth2流程中）refresh token永远只存在于第三方服务的服务器中，因此refresh token几乎没有失窃的风险。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/计算机网络/编码,加密,Hash,序列化和字符集.html":{"url":"01_计算机基础/计算机网络/编码,加密,Hash,序列化和字符集.html","title":"编码,加密,hash,序列化和字符集","keywords":"","body":"编码,加密,Hash,序列化和字符集 目录 加密 对称加密 非对称加密 扩展（⭐️⭐️⭐️⭐️⭐️） Base64 Base64的用途 Base64缺点 URL使用的百分号编码 压缩与解压缩 图片与音频、视频编解码 序列化 Hash 字符集 加密 对称加密 通信双方使用同一个密钥来加密，解密时使用加密过程的完全逆过程配合密钥来进行解密。 经典算法： DES（56位密钥，密钥太短而逐渐被弃用）、AES（128位、192位、256位密钥，现在最流行） 对称加密作用：加密通信，放在在不安全网络上被截获后，信息被人读取或篡改 对称加密的缺点：密钥泄露，不能在不安全网络上传输密钥，一旦密钥泄露则加密通信失败 非对称加密 使用公钥对数据进行加密得到密文；使用私钥对数据进行解密得到原数据。非对称加密使用的是复杂的数学技巧。 使用非对称加密通信，可以在不可信网络上将双方的公钥传给对方，然后在发消息前分别对消息使用对方的公钥来加密和使用自己的私钥来签名，做到不可信网络上的可靠密钥传播及加密通信。 由于私钥和公钥互相可解，因此非对称加密还可以用于数字签名技术。 通常会对原数据hash以后对hash签名，然后附加在原数据的后面作为签名。这是为了让数据更小。 经典算法：RSA（可用于加密和签名），DSA（仅用于签名，但速度更快） 拓展：https://zhuanlan.zhihu.com/p/53159565 非对称加密的优缺点： 优点：可以在不安全网络上传输密钥 缺点：计算复杂，因此性能相比对称加密差很多 扩展（⭐️⭐️⭐️⭐️⭐️） 数字签名：将原数据先用Hash函数，生成摘要，然后使用私钥，对这个摘要加密，生成数字签名（signature）。 假设发送方是张三,接收方是李四 数字签名跟随数据一起发送给李四，李四收到后，取下数字签名，用张三的公钥解密，得到信件的摘要，由此证明，这数据是从张三那里发出的。此时再对数据使用Hash函数，将得到的结果，与上一步得到的摘要进行对比，如果两者一致，就证明这数据未被修改过。 但是上面这种情况，有个问题，李四无法确定公钥真的属于张三。这个时候张三可以去找证书中心（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对张三的公钥和一些相关信息一起加密，生成数字证书（Digital Certificate）。张三拿到数字证书后，就可以放心了，以后给李四发数据，只要在签名的同时，再附上数字证书就行了。李四收到数据后，用CA的公钥解开数字证书，就可以拿到张三真实的公钥了，然后就能证明数字签名是否真的是张三签的。 证书的目的是确保公钥的合法性，它的本质就是为公钥加上数字签名（用CA的私钥来加密发送方的公钥，就成了数字签名），它的安全性由证书链顶端的根证书来保证。 Base64 拓展：https://cloud.tencent.com/developer/article/1868972 将二进制数据转换成由64个字符组成的字符串的编码算法。它的算法原理是将原数据每6位对应成Base 64索引表中的一个字符编排成一个字符串（每个字符占8位） Base64的用途 将二进制数据扩充了储存和传输途径（例如可以把数据保存到文本文件、可以通过聊天对话框或短信形式发送二进制数据、可以在URL中加入简单的二进制数据） 普通的字符串在经过Base64编码后的结果会变得肉眼不可读，因此可以适用于一定条件下的防偷窥（较少用）。 Base64缺点 因为自身的原理（将原数据的一个字符8位拆成6+2，这个6对应的是一个新的字符，占8位），因此每次Base64编码之后，数据会增大约1/3，所以会影响存储和传输性能。 URL使用的百分号编码 https://www.cnblogs.com/xzwblog/p/6932870.html#:~:text=URL%E7%BC%96%E7%A0%81%E9%80%9A%E5%B8%B8%E4%B9%9F%E8%A2%AB%E7%A7%B0%E4%B8%BA%E7%99%BE%E5%88%86%E5%8F%B7%E7%BC%96%E7%A0%81%EF%BC%88percent-encoding%EF%BC%89%EF%BC%8C%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%AE%83%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%EF%BC%9A,%E4%BD%BF%E7%94%A8%25%E5%8A%A0%E4%B8%8A%E4%B8%A4%E4%BD%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E2%80%94%E2%80%940123456789ABCDEF%E2%80%94%E2%80%94%E4%BB%A3%E8%A1%A8%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E7%9A%84%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%BD%A2%E5%BC%8F%E3%80%82 在URL的字符串中，对一些不用于特殊用途的保留字符，使用百分号%为前缀进行单独编码，以避免出现解析错误。 压缩与解压缩 压缩：将数据使用更具有存储优势的编码算法进行编码 解压缩：将压缩数据编码还原成原来的形式，以方便使用 目的是为了减小占用的存储空间。 压缩就是一种编码。所谓编码，即把数据从一种形式转换成另一种形式。压缩过程属于编码过程，解压缩过程属于解码过程。 常见压缩算法：DEFLATE、JPEG、MP3等。 图片与音频、视频编解码 将图像、音频、视频数据通过编码来转换成存档形式（编码），以及从存档形式转换回来（解码）。 目的是存储和压缩媒体数据（大多数媒体编码算法会压缩数据，但不是全部）。 序列化 把数据对象（一般是内存中的，例如JVM中的对象）转换成字节序列的过程。对象在程序内存里的存放形式是散乱的（存放在不同的内存区域、并且由引用进行连接），通过序列化可以把内存中的对象转换成一个字节序列，从而使用byte[]等形式进行本地存储或网络传输，在需要的时候重新组装（反序列化）来使用。 目的：让内存中的对象可以被储存和传输。 序列化并不是编码，编码是把数据由一种数据格式转换成另一种数据格式；而序列化是把数据由内存中的对象（而不是某种具体的格式）转换成字节序列。 Hash 定义：把任意数据转换成指定大小范围（通常很小，例如256字节以内）的数据。 作用：相当于从数据中提取出摘要信息，因此最主要用途是数字指纹。 实际用途：唯一性验证。例如Java中的hashCode()方法。 怎么重写hashCode方法：把equals()方法中的每个用于判断相等的变量都放进hashCode()中，一起生产一个尽量不会碰撞的整数即可。（一般equals和hashCode方法是成对出现的） Hash的实际用途1：数据完整性验证。从网上下载文后，通过对比文件的Hash值（例如MD5、SHA1），可以确认下载的文件是否有损坏。如果下载的文件Hash值和文件提供方给出的Hash值一致，则证明下载的文件是完好无损的。 Hash的实际用途2：快速查找，比如HashMap Hash的实际用途3：因私保护。当重要数据必须要暴露的时候，有时可以选择暴露它的Hash值（例如MD5），以保障原数据的安全。例如网站登录时，可以只保存用户密码的Hash值，在每次登录验证时只需要输入密码的Hash值和数据库中保存的Hash值作比对就好，网站无需知道用户的密码。（这不属于加密） MD5加盐：盐是一串随机数或者是固定的字符串。为什么要加盐：只要是明文相同，那么不加盐生成的MD5码就相同，于是攻击者就可以通过撞库的方式来破解出明文。加盐就是向明文中加入随机数，然后在生成MD5，这样一来即使明文相同，但由于盐不同，所以生成的MD5码也不同，如此一来就大大增加了暴力破解的难度，使其几乎不可能破解。 Hash不是编码，因为它是单向的过程，往往是不可逆的，无法进行逆向恢复操作。 Hash也不是加密，它是单向的过程，无法进行逆向恢复操作，因此Hash不属于加密。（MD5不是加密） 字符集 含义：一个由整数向现实世界中的文字符号的Map 分支： ASCII：128个字符，1字节 ISO-8859-1：对ASCII进行扩充，1字节 Unicode：13万个字符，多字节 UTF-8：Unicode的编码分支 UTF-16：Unicode的编码分支 GBK/GB2312/GB18030：中国自研标准，多字节，字符集+编码 https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html https://xiaozhuanlan.com/topic/3207594816 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"01_计算机基础/计算机网络/网络错误代码.html":{"url":"01_计算机基础/计算机网络/网络错误代码.html","title":"网络错误代码","keywords":"","body":"一些常见的状态码为： 200 - 服务器成功返回网页 404 - 请求的网页不存在 503 - 服务不可用 详细分解： 1xx（临时响应） 表示临时响应并需要请求者继续执行操作的状态代码。 代码 说明 100 （继续） 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功） 表示成功处理了请求的状态代码。 代码 说明 200 （成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 代码 说明 300 （多种选择） 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。 代码 说明 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足\"期望\"请求标头字段的要求。 5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码 说明 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 HttpWatch状态码Result is 200 - 服务器成功返回网页，客户端请求已成功。 302 - 对象临时移动。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 304 - 属于重定向。自上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 401 - 未授权。请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 404 - 未找到。服务器找不到请求的网页。 2xx - 成功。表示服务器成功地接受了客户端请求。 3xx - 重定向。表示要完成请求，需要进一步操作。客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。 4xx - 请求错误。这些状态代码表示请求可能出错，妨碍了服务器的处理。 5xx - 服务器错误。表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"02_数据结构与算法/REFERS.html":{"url":"02_数据结构与算法/REFERS.html","title":"Refers","keywords":"","body":" notes No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"02_数据结构与算法/算法.html":{"url":"02_数据结构与算法/算法.html","title":"算法","keywords":"","body":"第一章 概述 算法设计的目标：正确性、可使用性、可读性、健壮性、高效率与低储存量需求 算法的特征：有限性、确定性、可行性、输入性、输出性 时间复杂度分析 获得数组中的某个元素，只是算一个偏移量，一个常数操作 获得链表中的某个元素，需要进行i次操作，和数据量有关，不是常数操作 加减乘除都是常数操作 异或运算-->无进位相加 0^N = N ; N^N =0 ; 异或运算满足交换律和结合律，a^b-b^a , (a^b)^c=a^(b^c)； 对于两个整型数ab a=a^b;b=a^b;a=a^b;执行完毕后ab两个数交换 前提两个内存位置不同，不然会被洗成零 排列组合： 控制结构： 顺序、分支、循环 原操作： 数据类型的操作 ` 渐进符号 设n为算法中的问题规模，通常用大O、大和等三种渐进符号表示算法的执行时间与n之间的一种增长关系。 等差数列{an}的通项公式为：an=a1+(n-1)d。 前n项和公式为：$Sn=n*a1+n(n-1)d/2$ 非递归算法的时间复杂度分析 对于非递归算法，分析其时间复杂度相对比较简单，关键是求出代表算法执行时间的表达式。 通常是算法中基本语句的执行次数，是一个关于问题规模n的表达式，然后用渐进符号来表示这个表达式即得到算法的时间复杂度。 递归算法的时间复杂度分析 递归算法是采用一种分而治之的方法，把一个“大问题”分解为若干个相似的“小问题”来求解。 对递归算法时间复杂度的分析，关键是根据递归过程建立递推关系式，然后求解这个递推关系式，得到一个表示算法执行时间的表达式，最后用渐进符号来表示这个表达式即得到算法的时间复杂度。 算法空间复杂度分析 一个算法的存储量包括形参所占空间和临时变量所占空间。在对算法进行存储空间分析时，只考察临时变量所占空间。 例如，有以下算法，其中临时空间为变量i、maxi占用的空间。所以，空间复杂度是对一个算法在运行过程中临时占用的存储空间大小的量度，一般也作为问题规模n的函数，以数量级形式给出，记作： 其中渐进符号的含义与时间复杂度中的含义相同。 为什么算法占用的空间只考虑临时空间，而不必考虑形参的空间呢？这是因为形参的空间会在调用该算法的算法中考虑，例如，以下maxfun算法调用max算法： void maxfun(){ int b[]={1,2,3,4,5},n=5; 　　printf(\"Max=%d\\n\",max(b,n)); } maxfun算法中为b数组分配了相应的内存空间，其空间复杂度为O(n)，如果在max算法中再考虑形参a的空间，这样重复计算了占用的空间。 int max(int a[]，int n){ int i，maxi=0; for (i=1;ia[maxi]) maxi=i; return a[maxi]; } 算法空间复杂度的分析方法与前面介绍的时间复杂度分析方法相似。 算法设计工具STL STL主要由container（容器）、algorithm（算法）和iterator（迭代器）三大部分构成，容器用于存放数据对象（元素），算法用于操作容器中的数据对象。 STL容器 一个STL容器就是一种数据结构，如链表、栈和队列等，这些数据结构在STL中都已经实现好了，在算法设计中可以直接使用它们。 数据结构 说明 实现头文件 向量（vector） 连续存储元素。底层数据结构为数组，支持快速随机访问 字符串（string） 字符串处理容器 双端队列（deque） 连续存储的指向不同元素的指针所组成的数组。底层数据结构为一个中央控制器和多个缓冲区，支持首尾元素（中间不能）快速增删，也支持随机访问。 链表（list） 由结点组成的链表，每个结点包含着一个元素。底层数据结构为双向链表，支持结点的快速增删 栈（stack） 后进先出的序列。底层一般用deque（默认）或者list实现 队列（queue） 先进先出的序列。底层一般用deque（默认）或者list实现 优先队列（priority_queue） 元素的进出队顺序由某个谓词或者关系函数决定的一种队列。底层数据结构一般为vector（默认）或者deque 集合（set）/多重集合（multiset） 由结点组成的红黑树，每个结点都包含着一个元素，set中所有元素有序但不重复，multiset中所有关键字有序但不重复。 映射（map）/多重映射（multimap） 由（关键字，值）对组成的集合，底层数据结构为红黑树，map中所有关键字有序但不重复，multimap中所有关键字有序但可以重复 为此，使用STL时必须将下面的语句插入到源代码文件开头： using namespace std; 这样直接把程序代码定位到std命名空间中。 常用的STL容器: 顺序容器 vector（向量容器） 它是一个向量类模板。向量容器相当于数组。 用于存储具有相同数据类型的一组元素，可以从末尾快速的插入与删除元素，快速地随机访问元素，但是在序列中间插入、删除元素较慢，因为需要移动插入或删除处后面的所有元素。 定义vector容器的几种方式： //定义元素为int的向量v1 vector v1; //指定向量v2的初始大小为10个int元素 vector v2(10); //指定v3的10个初始元素的初值为1.23 vector v3(10，1.23); //用数组a[0..4]共5个元素初始化v4 vector v4(a，a+5); vector提供了一系列的成员函数，vector主要的成员函数如下： //判断当前向量容器是否为空。 empty(); //返回当前向量容器的中的实际元素个数。 size(); //返回指定下标的元素。 []; //为当前向量容器预分配n个元素的存储空间。 reserve(n); //返回当前向量容器在重新进行内存分配以前所能容纳的元素个数。 capacity(); //调整当前向量容器的大小，使其能容纳n个元素。 resize(n); //在当前向量容器尾部添加了一个元素。 push_back(); //在pos位置插入元素elem，即将元素elem插入到迭代器pos指定元素之前。 insert(pos，elem); //获取当前向量容器的第一个元素 front(); //获取当前向量容器的最后一个元素。 back(); //删除当前向量容器中某个迭代器或者迭代器区间指定的元素。 erase(); //删除当前向量容器中所有元素。 clear(); // 迭代器函数： begin(); end(); rbegin(); rend(); 示例 #include using namespace std; void main(){ vector myv; //定义vector容器myv vector::iterator it;//定义myv的正向迭代器it myv.push_back(1); //在myv末尾添加元素1 it=myv.begin(); //it迭代器指向开头元素1 myv.insert(it,2); //在it指向的元素之前插入元素2 myv.push_back(3); //在myv末尾添加元素3 myv.push_back(4); //在myv末尾添加元素4 it=myv.end(); //it迭代器指向尾元素4的后面 it--; //it迭代器指向尾元素4 myv.erase(it); //删除元素4 for (it=myv.begin();it!=myv.end();++it) printf(\"%d \",*it); printf(\"\\n\"); } string（字符串容器） string是一个保存字符序列的容器，所有元素为字符类型，类似vector。 除了有字符串的一些常用操作以外，还有包含了所有的序列容器的操作。字符串的常用操作包括增加、删除、修改、查找比较、连接、输入、输出等。 创建string容器的几种方式如下： char cstr[]=\"China! Greate Wall\"; //C-字符串 string s1(cstr); // s1:China! Greate Wall string s2(s1); // s2:China! Greate Wall string s3(cstr，7，11); // s3:Greate Wall string s4(cstr，6); // s4:China! string s5(5，'A'); // s5:AAAAA 常用的成员函数如下： //判断当前字符串是否为空串。 empty(); //返回当前字符串的实际字符个数（返回结果为size_type类型）。 size(); //返回当前字符串的实际字符个数。 length(); //返回当前字符串位于idx位置的字符，idx从0开始。 [idx]; //返回当前字符串位于idx位置的字符。 at(idx); //返回当前字符串与字符串str的比较结果。在比较时，若两者相等，返回0；前者小于后者，返回-1；否则返回1。 compare(const string& str); //在当前字符串的末尾添加一个字符串str。 append(cstr); //在当前字符串的idx处插入一个字符串str。 insert(size_type idx，const string& str); //迭代器函数 begin(); end(); rbegin(); rend(); 示例 #include #include using namespace std; void main() { string s1=\"\",s2,s3=\"Bye\"; s1.append(\"Good morning\"); //s1=\" Good morning\" s2=s1; //s1=\" Good morning\" int i=s2.find(\"morning\"); //i=5 s2.replace(i,s2.length()-i,s3); //相当于s2.replace(5,7,s3) cout #include #include #include #include using namespace std; vector content; //存放网页 map mymap; //存放转换字符串 int m，n; //网页转换 void trans(){ //转换content向量中的所有行 for(int i=0;i=0 && pos2>=0){ string var=content[i].substr(pos1+3，pos2-pos1-4); //提取形如{ {var} } if(mymap.count(var)){ string result = mymap[var].substr(2,mymap[var].length()-3); content[i].replace(pos1，var.length()+6，result); //替换 }else content[i].replace(pos1，var.length()+6，\"\"); pos=pos1+var.length(); } else //没有找到{ { } }，pos指向当前字符串末尾 pos = content[i].length(); } while(pos> m >> n; cin.ignore(); //屏蔽回车键 for(i=0;i::value_type( line.substr(0，pos)，line.substr(pos))); } trans(); for (i=0;i deque（双端队列容器） 它是一个双端队列类模板。双端队列容器由若干个块构成，每个块中元素地址是连续的，块之间的地址是不连续的，有一个特定的机制将这些块构成一个整体。可以从前面或后面快速插入与删除元素，并可以快速地随机访问元素，但删除元素较慢。 定义deque双端队列容器的几种方式如下： deque dq1; //定义元素为int的双端队列dq1 deque dq2(10); //指定dq2的初始大小为10个int元素 deque dq3(10，1.23);//指定dq3的10个初始元素的初值为1.23 deque dq4(dq2.begin()，dq2.end()); //用dq2的所有元素初始化dq4 deque主要的成员函数如下： //判断双端队列容器是否为空队。 empty(); //返回双端队列容器中元素个数。 size(); //在队头插入元素elem。 push_front(elem)： //在队尾插入元素elem。 push_back(elem)： //删除队头一个元素。 pop_front()： //删除队尾一个元素。 pop_back()： //从双端队列容器中删除一个或几个元素 erase()：。 //删除双端队列容器中所有元素。 clear()： //迭代器函数： begin()、end()、rbegin()、rend()。 示例 #include using namespace std; void disp(deque &dq) //输出dq的所有元素 { deque::iterator iter; //定义迭代器iter for (iter=dq.begin();iter!=dq.end();iter++) printf(\"%d \",*iter); printf(\"\\n\"); } void main() { deque dq; //建立一个双端队列dq dq.push_front(1); //队头插入1 dq.push_back(2); //队尾插入2 dq.push_front(3); //队头插入3 dq.push_back(4); //队尾插入4 printf(\"dq: \"); disp(dq); dq.pop_front(); //删除队头元素 dq.pop_back(); //删除队尾元素 printf(\"dq: \"); disp(dq); } list（链表容器） 它是一个双链表类模板。可以从任何地方快速插入与删除。它的每个结点之间通过指针链接，不能随机访问元素。 定义list容器的几种方式如下： list l1; //定义元素为int的链表l1 list l2 (10); //指定链表l2的初始大小为10个int元素 list l3 (10，1.23); //指定l3的10个初始元素的初值为1.23 list l4(a，a+5); //用数组a[0..4]共5个元素初始化l4 list的主要成员函数如下： //判断链表容器是否为空。 empty(); //返回链表容器中实际元素个数。 size(); //在链表尾部插入元素。 push_back(); //删除链表容器的最后一个元素。 pop_back(); //删除链表容器中所有指定值的元素。 remove (); //删除链表容器中满足条件的元素。 remove_if(cmp); //从链表容器中删除一个或几个元素。 erase(); //删除链表容器中相邻的重复元素。 unique(); //删除链表容器中所有的元素。 clear(); //在pos位置插入元素elem，即将元素elem插入到迭代器pos指定元素之前。 insert(pos，elem); //在pos位置插入n个元素elem。 insert(pos，n，elem); //在迭代器pos处插入[pos1，pos2)的元素。 insert(pos，pos1，pos2); //反转链表。 reverse(); //对链表容器中的元素排序。 sort(); //迭代器函数： begin()、end()、rbegin()、rend()。 说明：STL提供的sort()排序算法主要用于支持随机访问的容器，而list容器不支持随机访问，为此，list容器提供了sort()采用函数用于元素排序。类似的还有unique()、reverse()、merge()等STL算法。 示例 #include using namespace std; void disp(list &lst) //输出lst的所有元素 { list::iterator it; for (it=lst.begin();it!=lst.end();it++) printf(\"%d \",*it); printf(\"\\n\"); } void main() { list lst; //定义list容器lst list::iterator it,start,end; lst.push_back(5); //添加5个整数5,2,4,1,3 lst.push_back(2); lst.push_back(4); lst.push_back(1); lst.push_back(3); printf(\"初始lst: \"); disp(lst); it=lst.begin(); //it指向首元素5 start=++lst.begin(); //start指向第2个元素2 end=--lst.end(); //end指向尾元素3 lst.insert(it,start,end); printf(\"执行lst.insert(it,start,end)\\n\"); printf(\"插入后lst: \"); disp(lst); } 关联容器 set（集合容器）/ multiset（多重集容器） set和multiset都是集合类模板，其元素值称为关键字。set中元素的关键字是唯一的，multiset中元素的关键字可以不唯一，而且默认情况下会对元素按关键字自动进行升序排列。 查找速度比较快，同时支持集合的交、差和并等一些集合上的运算，如果需要集合中的元素允许重复那么可以使用multiset。 set/multiset的成员函数如下： //判断容器是否为空。 empty(); //返回容器中实际元素个数。 size(); //插入元素。 insert(); //从容器删除一个或几个元素。 erase(); //删除所有元素。 clear(); //返回容器中关键字k出现的次数。 count(k); //如果容器中存在关键字为k的元素，返回该元素的迭代器，否则返回end()值。 find(k); //返回一个迭代器，指向关键字大于k的第一个元素。 upper_bound(); //返回一个迭代器，指向关键字不小于k的第一个元素。 lower_bound(); //迭代器函数： begin(); end(); rbegin(); rend(); 示例 #include using namespace std; void main() { set s; //定义set容器s set::iterator it; //定义set容器迭代器it s.insert(1); s.insert(3); s.insert(2); s.insert(4); s.insert(2); printf(\" s: \"); for (it=s.begin();it!=s.end();it++) printf(\"%d \",*it); printf(\"\\n\"); multiset ms; //定义multiset容器ms multiset::iterator mit;//定义multiset容器迭代器mit ms.insert(1); ms.insert(3); ms.insert(2); ms.insert(4); ms.insert(2); printf(\"ms: \"); for (mit=ms.begin();mit!=ms.end();mit++) printf(\"%d \",*mit); printf(\"\\n\"); } map（映射容器）/ multimap（多重映射容器） map和multimap都是映射类模板。映射是实现关键字与值关系的存储结构，可以使用一个关键字key来访问相应的数据值value。 在set/multiset中的key和value都是key类型，而key和value是一个pair类结构。 pair类结构的声明形如： struct pair { T first; T second; } map/multimap利用pair的 map中不允许关键字重复出现，支持[]运算符；而multimap中允许关键字重复出现，但不支持[]运算符。 map/multimap的主要成员函数如下： //判断容器是否为空。 empty(); //返回容器中实际元素个数。 size(); //返回关键字为key的元素的引用，如果不存在这样的关键字，则以key作为关键字插入一个元素（不适合multimap）。 map[key]; //插入一个元素elem并返回该元素的位置。 insert(elem); //删除所有元素。 clear(); //在容器中查找元素。 find(); //容器中指定关键字的元素个数（map中只有1或者0）。 count(); //迭代器函数： begin(); end(); rbegin(); rend(); 在map中修改元素非常简单，这是因为map容器已经对[]运算符进行了重载。例如： map mymap;//定义map容器mymap，其元素类型为pair mymap['a'] = 1; //或者mymap.insert(pair('a',1) ); 获得map中一个值的最简单方法如下： int ans = mymap['a']; 只有当map中有这个关键字（'a'）时才会成功，否则会自动插入一个元素，值为初始化值。可以使用find() 方法来发现一个关键字是否存在。 示例 #include using namespace std; void main() { map mymap; //定义map容器mymap mymap.insert(pair('a',1));//插入方式1 mymap.insert(map::value_type('b',2));//插入方式2 mymap['c']=3;//插入方式3 map::iterator it; for(it=mymap.begin();it!=mymap.end();it++) printf(\"[%c,%d] \",it->first,it->second); printf(\"\\n\"); } 适配器容器 stack（栈容器） 它是一个栈类模板，和数据结构中的栈一样，具有后进先出的特点。栈容器默认的底层容器是deque。也可以指定其他底层容器。 例如，以下语句指定myst栈的底层容器为vector： stack > myst; //第2个参数指定底层容器为vector stack容器主要的成员函数如下： //判断栈容器是否为空。 empty(); //返回栈容器中实际元素个数。 size(); //元素elem进栈。 push(elem); //返回栈顶元素。 top(); //元素出栈。 pop(); 注意：stack容器没有begin()/end()和rbegin()/rend()这样的用于迭代器的成员函数。 示例 #include using namespace std; void main() { stack st; st.push(1); st.push(2); st.push(3); printf(\"栈顶元素: %d\\n\",st.top()); printf(\"出栈顺序: \"); while (!st.empty()) //栈不空时出栈所有元素 { printf(\"%d \",st.top()); st.pop() ; } printf(\"\\n\"); } queue（队列容器） 它是一个队列类模板，和数据结构中的队列一样，具有先进先出的特点。不允许顺序遍历，没有begin()/end()和rbegin()/rend()这样的用于迭代器的成员函数。 主要的成员函数如下： //判断队列容器是否为空。 empty(); //返回队列容器中实际元素个数。 size(); //返回队头元素。 front(); //返回队尾元素。 back(); //元素elem进队。 push(elem); //元素出队。 pop(); 示例 #include using namespace std; void main() { queue qu; qu.push(1); qu.push(2); qu.push(3); printf(\"队头元素: %d\\n\",qu.front()); printf(\"队尾元素: %d\\n\",qu.back()); printf(\"出队顺序: \"); while (!qu.empty()) //出队所有元素 { printf(\"%d \",qu.front()); qu.pop(); } printf(\"\\n\"); } priority_queue（优先队列容器） 它是一个优先队列类模板。优先队列是一种具有受限访问操作的存储结构，元素可以以任意顺序进入优先队列。 一旦元素在优先队列容器中，出队操作将出队列最高优先级元素。 主要的成员函数如下： //判断优先队列容器是否为空。 empty(); //返回优先队列容器中实际元素个数。 size(); //元素elem进队。 push(elem); //获取队头元素。 top(); //元素出队。 pop(); 示例 #include using namespace std; void main() { priority_queue qu; qu.push(3); qu.push(1); qu.push(2); printf(\"队头元素: %d\\n\",qu.top()); printf(\"出队顺序: \"); while (!qu.empty()) //出队所有元素 { printf(\"%d \",qu.top()); qu.pop(); } printf(\"\\n\"); } STL算法 STL算法是用来操作容器中数据的模板函数，STL提供了大约100个实现算法的模版函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象。 STL算法部分主要由头文件、和组成。 例如，以下程序使用STL算法sort()实现整型数组a的递增排序： #include using namespace std; void main() { int a[]={2,5,4,1,3}; sort(a,a+5); for (int i=0;i STL迭代器 STL迭代器用于访问容器中的数据对象。 每个容器都有自己的迭代器，只有容器自己才知道如何访问自己的元素。 迭代器像C/C++中的指针，算法通过迭代器来定位和操作容器中的元素。 常用的迭代器有： iterator：指向容器中存放元素的迭代器，用于正向遍历容器中的元素。 const_iterator：指向容器中存放元素的常量迭代器，只能读取容器中的元素。 reverse_iterator：指向容器中存放元素的反向迭代器，用于反向遍历容器中的元素。 const_reverse_iterator：指向容器中存放元素的常量反向迭代器，只能读取容器中的元素。 迭代器的常用运算如下： ++：正向移动迭代器。 --：反向移动迭代器。 *：返回迭代器所指的元素值。 vector myv； myv.push_back(1)； myv.push_back(2)； myv.push_back(3)； //定义正向迭代器it vector::iterator it； //从头到尾遍历所有元素 for (it=myv.begin();it!=myv.end();++it){ printf(\"%d \",*it); //输出：1 2 3 } printf(\"\\n\"); //定义反向迭代器rit vector::reverse_iterator rit; //从尾到头遍历所有元素 for (rit=myv.rbegin();rit!=myv.rend();++rit){ printf(\"%d \",*rit); //输出：3 2 1 } printf(\"\\n\"); STL应用 1.存放主数据 算法设计重要步骤是设计数据的存储结构，除非特别指定，程序员可以采用STL中的容器存放主数据，选择何种容器不仅要考虑数据的类型，还有考虑数据的处理过程。 例如，字符串可以采用string或者vector来存储，链表可以采用list来存储。 示例 #include #include #include using namespace std; void solve(string str,vector &words) //产生所有单词words { string w; int i=0; int j=str.find(\" \"); //查找第一个空格 while (j!=-1) //找到单词后循环 { w=str.substr(i,j-i); //提取一个单词 words.push_back(w); //单词添加到words中 i=j+1; j=str.find(\" \",i); //查找下一个空格 } if (i words; solve(str,words); cout ::iterator it; for (it=words.begin();it!=words.end();++it) cout 2.存放临时数据 在算法设计中，有时需要存放一些临时数据。通常的情况是，如果后存入的元素先处理，可以使用stack栈容器； 如果先存入的元素先处理，可以使用queue队列容器；如果元素处理顺序按某个优先级进行，可以使用priority_queue优先队列容器。 示例 #include #include #include using namespace std; bool solve(string str) //判断str中括号是否匹配 { stack st; int i=0; while (i 3.检测数据元素的唯一性 可以使用map容器或者哈希表容器检测数据元素是否唯一或者存放累计个数。 示例 bool isUnique(string &str) //检测str中的所有字符是否唯一的 { map mymap; for (int i=0;i1) return false; } return true; } 4.数据排序 对于list容器的元素排序可以使用其成员函数sort()，对于数组或者vector等具有随机访问特性的容器，可以使用STL算法sort()。 1）内置数据类型的排序 对于内置数据类型的数据，sort()默认是以less（小于关系函数）作为关系函数实现递增排序。 为了实现递减排序，需要调用头文件中定义的greater类模板。 例如，以下程序使用greater()实现vector容器元素的递减排序（其中sort(myv.begin(),myv.end(),less())语句等同于sort(myv.begin(),myv.end())，实现默认的递增排序）： #include #include #include #include //包含less、greater等 using namespace std; void Disp(vector &myv) //输出vector的元素 { vector::iterator it; for(it = myv.begin();it!=myv.end();it++) cout myv(a,a+n); cout ()); cout ()); cout 2）自定义数据类型的排序 对于自定义数据类型如结构体数据，同样默认是less（即小于关系函数）作为关系函数，但需要重载该函数。另外还可以自己定义关系函数()。在这些重载函数或者关系函数中指定数据的排序顺序（按哪些结构体成员排序，是递增还是递减）。 归纳起来，实现排序时主要有两种方式： 方式1：在声明结构体类型中重载 方式2：自己定义关系函数()，以实现按指定成员的递增或者递减排序。如sort(myv.begin(),myv.end(),Cmp())调用Cmp的()运算符对myv容器的所有元素实现排序。 #include #include #include #include using namespace std; struct Stud { int no; string name; Stud(int no1,string name1) //构造函数 { no=no1; name=name1; } bool operator则按no递增排序 } }; struct Cmp //方式2：定义关系函数() { bool operator()(const Stud &s,const Stud &t) const { return s.name则按name递减排序 } }; void Disp(vector &myv) //输出vector的元素 { vector::iterator it; for(it = myv.begin();it!=myv.end();it++) cout no name myv(a,a+n); cout 5.优先队列作为堆 在有些算法设计中用到堆，堆采用STL的优先队列来实现，优先级的高低由队列中数据元素的关系函数（比较运算符）确定，很多情况下需要重载关系函数。 1）元素为内置数据类型的堆 对于C/C++内置数据类型，默认是less（小于关系函数）作为关系函数，值越大优先级的越高（即大根堆），可以改为以greater作为关系函数，这样值越大优先级的越低（即小根堆）。 例如，以下程序中pq1为大根堆（默认），pq2为小根堆（通过greater实现）： #include #include using namespace std; void main() { int a[]={3,6,1,5,4,2}; int n=sizeof(a)/sizeof(a[0]); //(1)优先级队列pq1默认是使用vector作容器 priority_queue pq1(a,a+n); cout ,greater > pq2(a,a+n); cout 2）元素为自定义类型的堆 对于自定义数据类型如结构体数据，同样默认是less（即小于关系函数）作为关系函数，但需要重载该函数。 另外还可以自己定义关系函数()。在这些重载函数或者关系函数中指定数据的优先级（优先级取决于哪些结构体，是越大越优先还是越小越优先）。 #include #include #include using namespace std; struct Stud //声明结构体Stud { int no; string name; Stud(int n,string na) //构造函数 { no=n; name=na; } bool operator(const Stud &s) const //重载>关系函数 { return no>s.no; } }; //结构体的关系函数,改写operator() struct StudCmp { bool operator()(const Stud &s,const Stud &t) const { return s.name pq1(a,a+n); cout 关系函数定义pq2 priority_queue,greater > pq2(a,a+n); cout ,StudCmp > pq3(a,a+n); cout 第二章 递归算法设计技术 递归是什么 递归的定义 在定义一个过程或函数时出现调用本过程或本函数的成分，称之为递归。若调用自身，称之为直接递归。若过程或函数p调用过程或函数q，而q又调用p，称之为间接递归。 任何间接递归都可以等价地转换为直接递归。 如果一个递归过程或递归函数中递归调用语句是最后一条执行语句，则称这种递归调用为尾递归。 一般来说，能够用递归解决的问题应该满足以下三个条件： 需要解决的问题可以转化为一个或多个子问题来求解，而这些子问题的求解方法与原问题完全相同，只是在数量规模上不同。 递归调用的次数必须是有限的。 必须有结束递归的条件来终止递归。 何时使用递归 在以下三种情况下，常常要用到递归的方法： 定义是递归的： 有许多数学公式、数列等的定义是递归的。例如，求n!和Fibonacci数列等。这些问题的求解过程可以将其递归定义直接转化为对应的递归算法。 数据结构是递归的 有些数据结构是递归的。例如单链表就是一种递归数据结构，其结点类型声明如下： typedef struct LNode { ElemType data; struct LNode *next; } LinkList; 结构体LNode的定义中用到了它自身，即指针域next是一种指向自身类型的指针，所以它是一种递归数据结构。 对于递归数据结构，采用递归的方法编写算法既方便又有效。例如，求一个不带头结点的单链表L的所有data域（假设为int型）之和的递归算法如下： int Sum(LinkList *L) { if (L==NULL) 　　　　return 0; 　　else 　　　　return(L->data+Sum(L->next)); } s 例题1 题：分析二叉树的二叉链存储结构的递归性，设计求非空二叉链bt中所有结点值之和的递归算法，假设二叉链的data域为int型。 解：二叉树采用二叉链存储结构，其结点类型定义如下： typedef struct BNode { int data; struct BNode *lchild，*rchild; } BTNode; //二叉链结点类型 求解算法： int Sumbt(BTNode *bt) //求二叉树bt中所有结点值之和 { if (bt->lchild==NULL && bt->rchild==NULL) return bt->data; //只有一个结点时返回该结点值 else//否则返回左、右子树结点值之和加上根结点值 return Sumbt(bt->lchild)+ Sumbt(bt->rchild)+bt->data); } 问题的求解方法是递归的 盘片移动时必须遵守以下规则：每次只能移动一个盘片；盘片可以插在X、Y和Z中任一塔座；任何时候都不能将一个较大的盘片放在较小的盘片上。 设计递归求解算法，并将其转换为非递归算法。 设Hanoi(n，x，y，z)表示将n个盘片从x通过y移动到z上，递归分解的过程是：?? 递归模型 递归模型是递归算法的抽象，它反映一个递归问题的递归结构。例如前面的递归算法对应的递归模型如下： 其中，第一个式子给出了递归的终止条件，第二个式子给出了fun(n)的值与fun(n-1)的值之间的关系，我们把第一个式子称为递归出口，把第二个式子称为递归体。 一般地，一个递归模型是由递归出口和递归体两部分组成，前者确定递归到何时结束，后者确定递归求解时的递推关系。 递归出口的一般格式如下： 这里的s1与m1均为常量，有些递归问题可能有几个递归出口。 递归体的一般格式如下： 其中，n、i、j和m均为正整数。这里的sn+1是一个递归“大问题”，si、si+1、…、sn为递归“小问题”，cj、cj+1、…、cm是若干个可以直接（用非递归方法）解决的问题，g是一个非递归函数，可以直接求值。 递归算法设计 数学归纳法 第一数学归纳法原理：若{P(1)，P(2)，P(3)，P(4)，…}是命题序列且满足以下两个性质，则所有命题均为真： （1）P(1)为真。 （2）任何命题均可以从它的前一个命题推导得出。 第二数学归纳法原理：若{P(1)，P(2)，P(3)，P(4)，…}是满足以下两个性质的命题序列，则对于其他自然数，该命题序列均为真： （1）P(1)为真。 （2）任何命题均可以从它的前面所有命题推导得出。 递归算法设计的一般步骤 递归算法设计先要给出递归模型，再转换成对应的C/C++语言函数。 获取递归模型的步骤如下： （1）对原问题f(sn)进行分析，抽象出合理的“小问题”f(sn-1)（与数学归纳法中假设n=k-1时等式成立相似）； （2）假设f(sn-1)是可解的，在此基础上确定f(sn)的解，即给出f(sn)与f(sn-1)之间的关系（与数学归纳法中求证n=k时等式成立的过程相似）； （3）确定一个特定情况（如f(1)或f(0)）的解，由此作为递归出口（与数学归纳法中求证n=1或n=0时等式成立相似）。 由此得到递归模型如下： 对应的递归算法如下： int fmax(int a[]，int i) { if (i==1) return a[0]; else return(fmax(a，i-1)，a[i-1]); } 递归数据结构及其递归算法设计 递归数据结构的定义 采用递归方式定义的数据结构称为递归数据结构。在递归数据结构定义中包含的递归运算称为基本递归运算。 基于递归数据结构的递归算法设计 1）单链表的递归算法设计 在设计不带头结点的单链表的递归算法时： 设求解以L为首结点指针的整个单链表的某功能为“大问题”。 而求解除首结点外余下结点构成的单链表（由L->next标识，而该运算为递归运算）的相同功能为“小问题”。 由大小问题之间的解关系得到递归体。 再考虑特殊情况，通常是单链表为空或者只有一个结点时，这时很容易求解，从而得到递归出口。 对应的递归模型如下： f(L) ≡不做任何事件 //当L=NULL时 f(L) ≡ f(L->next); 释放*L结点 //其他情况 void DestroyList(LinkNode *&L) //释放单链表L中所有结点 { if (L!=NULL) { DestroyList(L->next); free(L); } } 2）二叉树的递归算法设计 二叉树是一种典型的递归数据结构，当一棵二叉树采用二叉链b存储时： 设求解以b为根结点的整个二叉树的某功能为“大问题”。 求解其左、右子树的相同功能为“小问题”。 由大小问题之间的解关系得到递归体。 再考虑特殊情况，通常是二叉树为空或者只有一个结点时，这时很容易求解，从而得到递归出口。 BTNode *CreateBTree(ElemType a[],ElemType b[],int n) //由先序序列a[0..n-1]和中序序列b[0..n-1]建立二叉链存储结构bt { int k; if (ndata=root; for (k=0;klchild=CreateBTree(a+1,b,k); //递归创建左子树 bt->rchild=CreateBTree(a+k+1,b+k+1,n-k-1); //递归创建右子树 return bt; } 对应的递归模型如下： void CopyBTree(BTNode *bt,BTNode *&bt1) //由二叉树bt复制产生bt1 { if (bt==NULL) bt1=NULL; else { bt1=(BTNode *)malloc(sizeof(BTNode)); bt1->data=bt->data; CopyBTree(bt->lchild,bt1->lchild); CopyBTree(bt->rchild,bt1->rchild); } } 【例2.11】假设二叉树采用二叉链存储结构，设计一个递归算法输出从根结点到值为x的结点的路径，假设二叉树中所有结点值不同。 解法2：用vector向量path存放从根结点到x结点的正向路径。 f(b，x，path)的求解过程是： 若b为空树，返回false； 否则将b结点值加入到path中，如果b->data=x，查找成功返回true； 如果b->data≠x，在左子树中查找，若在左子树找到值为x的结点，返回true，若在左子树没有找到值为x的结点，返回在右子树中的查找结果。 左、右子树中查找都是“小问题”。 //当b=NULL f(b，x，path)=false; //（将b->data加入到path中） 当b->data=x f(b，x，path)=true; //f(b->lchild，x，path)=true f(b，x，path)=true; //其他情况 f(b，x，path)= f(b->rchild，x，path); //求根结点到x结点的（正向）路径 bool Findxpath2(BTNode *bt,int x,vector tmppath,vector &path) { if (bt==NULL) //空树返回false return false; tmppath.push_back(bt->data); //当前结点加入path if (bt->data==x) //当前结点值为x，返回true { path=tmppath; //路径复制 return true; } bool find=Findxpath2(bt->lchild,x,tmppath,path); //在左子树中查找 if (find) //左子树中成功找到 return true; else //左子树中没有找到，在右子树中查找 return Findxpath2(bt->rchild,x,tmppath,path); } 递归算法转化非递归算法 如何用栈来访问树 递归算法和树的关系 通用代码格式 递推式的计算 用特征方程求解递归方程 线性齐次递推式的求解 常系数的线性齐次递推式的一般格式如下： 非齐次递推式的求解 常系数的线性非齐次递推式的一般格式如下： 其通解形式如下： $f(n)=f'(n)+f''(n)$ 其中，f'(n)是对应齐次递归方程的通解，f''(n)是原非齐次递归方程的特解。 p92 第三章 分治法 概述 对于一个规模为n的问题：若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。 这种算法设计策略叫做分治法。 分治法所能解决的问题一般具有以下几个特征： （1）该问题的规模缩小到一定的程度就可以容易地解决。 （2）该问题可以分解为若干个规模较小的相同问题。 （3）利用该问题分解出的子问题的解可以合并为该问题的解。 （4）该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 分治法的一般的算法设计框架如下： divide-and-conquer(P){ if |P|≤n0 return adhoc(P); 将P分解为较小的子问题 P1，P2，…，Pk; for(i=1;i 当k=1时称为减治法 当k=2时称为二分法 第四章 蛮力法 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"02_数据结构与算法/算法2.html":{"url":"02_数据结构与算法/算法2.html","title":"算法2","keywords":"","body":"void dfs(int i,int tw,int tv,int rw,int op[]) //求解0/1背包问题 { //初始调用时rw为所有物品重量和 int j; if (i>n) //找到一个叶子结点 { if (tw==W && tv>maxv) //找到一个满足条件的更优解,保存 { maxv=tv; for (j=1;jW) //右孩子结点剪枝 dfs(i+1,tw,tv,rw-w[i],op); } } `` C1 概论（填空题） 算法时间复杂度分析 填空题 C3 分治法（填空题、程序填空题） 对于一个规模为n的问题：若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。 这种算法设计策略叫做分治法。 寻找一个序列中第k小的元素 【问题描述】对于给定的含有n元素的无序序列，求这个序列中第k（1≤k≤n）小的元素。 【问题求解】假设无序序列存放在a[0..n-1]中，若将a递增排序，则第k小的元素为a[k-1]。 采用类似于快速排序的思想。 对于序列a[s..t]，在其中查找第k小元素的过程如下： 将a[s]作为基准划分，其对应下标为i。3种情况： 若k-1=i，a[i]即为所求，返回a[i]。 若k-1 若k-1>i，第k小的元素应在a[i+1..t]子序列中，递归在该子序列中求解并返回其结果。 int QuickSelect(int a[]，int s，int t，int k) //在a[s..t]序列中找第k小的元素 { int i=s，j=t,tmp; if (si && a[j]>=tmp) j--; 　　　　　a[i]=a[j]; //将a[j]前移到a[i]的位置 　　　　　while (i 【算法分析】对于QuickSelect(a，s，t，k)算法，设序列a中含有n个元素，其比较次数的递推式为： 　　T(n)=T(n/2)+O(n) 　　可以推导出T(n)=O(n)，这是最好的情况，即每次划分的基准恰好是中位数，将一个序列划分为长度大致相等的两个子序列。 　　在最坏情况下，每次划分的基准恰好是序列中的最大值或最小值，则处理区间只比上一次减少1个元素，此时比较次数为O(n2)。 　　在平均情况下该算法的时间复杂度为O(n)。 填空题 递推式：T(n) = T(n/2)+O(n) 最好情况：T(n) = T(n/2)+O(n) -- > O(n) 最坏情况：O(n2) 平均情况：O(n) 程序填空题 递归部分： if (k-1==i) return a[i];//要找第k个元素，即下标为k-1的元素，找到返回 else if (k-1 扫描部分 //从区间两端交替向中间扫描，直至i=j为止，即碰到为止 while (i!=j){ //当右边的小了，右边的往前替换 while (j>i && a[j]>=tmp) j--; a[i]=a[j]; //将a[j]前移到a[i]的位置 //当左边的大了，左边的往后替换 while (i 寻找两个等长有序序列的中位数 【问题描述】对于一个长度为n的有序序列（假设均为升序序列）a[0..n-1]，处于中间位置的元素称为a的中位数。 设计一个算法求给定的两个有序序列的中位数。 　 【问题求解】对于含有n个元素的有序序列a[s..t]，当n为奇数时，中位数是出现在m=(s+t)/2处；当n为偶数时，中位数下标有m=(s+t)/2（下中位）和m=(s+t)/2+1（上中位）两个。为了简单，仅考虑中位数为m=(s+t)/2处。 采用二分法求含有n个有序元素的序列a、b的中位数的过程如下： 分别求出a、b的中位数a[m1]和b[m2]： ① 若a[m1]=b[m2]，则a[m1]或b[m2]即为所求中位数，算法结束。 　 ② 若a[m1] ③ 若a[m1]>b[m2]，则舍弃序列a中后半部分（较大的一半），同时舍弃序列b中前半部分（较小的一半），要求舍弃的长度相等。 画图：舍弃头尾 int midnum(int a[]，int s1，int t1，int b[]，int s2，int t2) { //求两个有序序列a[s1..t1]和b[s2..t2]的中位数 　　int m1，m2; 　　if (s1==t1 && s2==t2) //两序列只有一个元素时返回较小者 　　　　return a[s1]b[m2]时 　 { prepart(s1，t1); //a取前半部分 　　 postpart(s2，t2); //b取后半部分 　　 return midnum(a，s1，t1，b，s2，t2); 　　 } 　　} } 【算法分析】对于含有n个元素的有序序列a和b，设调用midnum(a，0，n-1，b，0，n-1)求中位数的执行时间为T(n)，显然有以下递归式： 容易推出，T(n)=O(log2n)。 填空题 递推式： 复杂度：T(n)=O(log2n) 程序填空题 判断逻辑：如果中位数相等则返回，不相等则舍弃头尾 临界条件：两个序列只有一个元素时返回较小者 求解连续子序列和问题 【问题描述】给定一个有n（n≥1）个整数的序列，要求求出其中最大连续子序列的和。 例如： 序列（-2，11，-4，13，-5，-2）的最大子序列和为20 序列（-6，2，4，-7，5，3，2，-1，6，-9，10，-2）的最大子序列和为16。 规定一个序列最大连续子序列和至少是0，如果小于0，其结果为0。 【问题求解】对于含有n个整数的序列a[0..n-1]，若n=1，表示该序列仅含一个元素，如果该元素大于0，则返回该元素；否则返回0。 若n>1，采用分治法求解最大连续子序列时，取其中间位置mid=(n-1)/2，该子序列只可能出现3个地方。 （1）该子序列完全落在左半部即a[0..mid]中。采用递归求出其最大连续子序列和maxLeftSum。 （2）该子序列完全落在右半部即a[mid+1..n-1]中。采用递归求出其最大连续子序列和maxRightSum。 （3）该子序列跨越序列a的中部而占据左右两部分。 long maxSubSum(int a[]，int left，int right) //求a[left..high]序列中最大连续子序列和 { int i，j; long maxLeftSum，maxRightSum; long maxLeftBorderSum，leftBorderSum; long maxRightBorderSum，rightBorderSum; if (left==right) //子序列只有一个元素时 {　　if (a[left]>0) //该元素大于0时返回它 　　　　　　return a[left]; 　　　　else //该元素小于或等于0时返回0 　　　　　　　return 0; } 　　int mid=(left+right)/2; //求中间位置 　　maxLeftSum=maxSubSum(a，left，mid); //求左边 　　maxRightSum=maxSubSum(a，mid+1，right); //求右边 　　maxLeftBorderSum=0，leftBorderSum=0; 　　for (i=mid;i>=left;i--)　 //求出以左边加上a[mid]元素 　　{ leftBorderSum+=a[i];　 //构成的序列的最大和 　 if (leftBorderSum>maxLeftBorderSum) 　　　　　　maxLeftBorderSum=leftBorderSum; 　　} 　　maxRightBorderSum=0，rightBorderSum=0; 　　for (j=mid+1;jmaxRightBorderSum) 　　　　　　maxRightBorderSum=rightBorderSum; 　　} 　　return max3(maxLeftSum，maxRightSum， maxLeftBorderSum+maxRightBorderSum); } 【算法分析】设求解序列a[0..n-1]最大连续子序列和的执行时间为T(n)，第（1）、（2）两种情况的执行时间为T(n/2)，第（3）种情况的执行时间为O(n)，所以得到以下递推式： 容易推出，T(n)=O(nlog2n)。 填空题 递推式： 复杂度：T(n)=O(nlog2n) 程序填空题 判断逻辑：落在中间的情况，左边子序列的最大值就是从中点开始往左数，右边子序列的最大值就是从中点+1开始往右数，注意中点不要重复使用；最后要将落在中间的情况、落在左边的情况、落在右边的情况求出最大值 临界条件：子序列只有一个元素时，如果元素大于0则返回该元素，否则返回0 C4 蛮力法（程序填空题） 　　蛮力法是一种简单直接地解决问题的方法，通常直接基于问题的描述和所涉及的概念定义，找出所有可能的解。 　　然后选择其中的一种或多种解，若该解不可行则试探下一种可能的解。 求解连续子序列和问题 【问题描述】给定一个有n（n≥1）个整数的序列，要求求出其中最大连续子序列的和。 例如： 序列（-2，11，-4，13，-5，-2）的最大子序列和为20 序列（-6，2，4，-7，5，3，2，-1，6，-9，10，-2）的最大子序列和为16。 规定一个序列最大连续子序列和至少是0，如果小于0，其结果为0。 【问题求解】　　解法1：设含有n个整数的序列a[0..n-1]，其中任何连续子序列a[i..j]（i≤j，0≤i≤n-1，i≤j≤n-1）求出它的所有元素之和thisSum。 通过比较将最大值存放在maxSum中，最后返回maxSum。 　　解法2：改进前面的解法，在求两个相邻子序列和时，它们之间是关联的。 例如a[0..3]子序列和=a[0]+a[1]+a[2]+a[3]，a[0..4]子序列和=a[0]+a[1]+a[2]+a[3]+a[4]，在前者计算出来后，求后者时只需在前者基础上加以a[4]即可，没有必须每次都重复计算。从而提高了算法效率。 　解法3：更一步改进解法2。 　 如果扫描中遇到负数，当前子序列和thisSum将会减小，若thisSum为负数，表明前面已经扫描的那个子序列可以抛弃了，则放弃这个子序列，重新开始下一个子序列的分析，并置thisSum为0。 　 若这个子序列和thisSum不断增加，那么最大子序列和maxSum也不断增加。 int maxSubSum3(int a[],int n) { int i,maxSum=0,thisSum=0; for (i=0;i 程序填空题 在子序列和的基础上增加；如果当前子序列和为负数，重新开始下一个子序列 求解幂集问题 【问题描述】对于给定的正整数n（n≥1），求1～n构成的集合的所有子集（幂集）。 【问题求解】解法1：采用直接蛮力法求解，将1～n的存放在数组a中，求解问题变为构造集合a的所有子集。设集合a[0..2]={1，2，3}，其所有子集对应的二进制位及其十进制数如下。 对于含有n（n≥1）个元素的集合a，求幂集的过程如下： for (i=0;i 显然该算法的时间复杂度为O(n×2n)，属于指数级的算法。 首先b[0..2]=000，每调用一次inc，b表示十进制数的增加1 void inc(int b[], int n) //将b表示的二进制数增1 { for(int i=0;i 解法2：采用增量蛮力法求解1～n的幂集，当n=3时的求解过程。 #include #include using namespace std; vector > ps; //存放幂集 void PSet(int n) //求1～n的幂集ps { vector > ps1; //子幂集 vector >::iterator it;//幂集迭代器 vector s; ps.push_back(s); //添加{}空集合元素 for (int i=1;i 【算法分析】对于给定的n，每一个集合元素都要处理，有2n个，所以上述算法的时间复杂度为O(2n)。 程序填空题 蛮力法 --> 对应二进制位 void inc(int b[], int n) //将b表示的二进制数增1 { for(int i=0;i 增量法 --> 每次增加元素形成子集添加到原序列中 void PSet(int n) //求1～n的幂集ps { vector > ps1; //子幂集 vector >::iterator it;//幂集迭代器 vector s; ps.push_back(s); //添加{}空集合元素 for (int i=1;i 求解简单0/1背包问题 　　【问题描述】有n个重量分别为{w1，w2，…，wn}的物品，它们的价值分别为{v1，v2，…，vn}，给定一个容量为W的背包。设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，而且具有最大的价值。 　　并对下表所示的4个物品求出W=6时的所有解和最佳解。 　　【问题求解】对于n个物品、容量为W的背包问题，采用前面求幂集的方法求出所有的物品组合。 　　对于每一种组合，计算其总重量sumw和总价值sumv，当sumw小于等于W时，该组合是一种解，并通过比较将最佳方案保存在maxsumw和maxsumv中，最后输出所有的解和最佳解。 #include #include using namespace std; vector > ps; //存放幂集 void PSet(int n) //求1～n的幂集ps { vector > ps1; //子幂集 vector >::iterator it;//幂集迭代器 vector s; ps.push_back(s); //添加{}空集合元素 for (int i=1;i >::iterator it; //幂集迭代器 vector::iterator sit; //幂集集合元素迭代器 printf(\" 序号\\t选中物品\\t总重量\\t总价值\\t能否装入\\n\"); for (it=ps.begin();it!=ps.end();++it) //扫描ps中每一个集合元素 { printf(\" %d\\t\",count+1); sumw=sumv=0; printf(\"{\"); for (sit=(*it).begin();sit!=(*it).end();++sit) { printf(\"%d \",*sit); sumw+=w[*sit-1]; //w数组下标从0开始 sumv+=v[*sit-1]; //v数组下标从0开始 } printf(\"}\\t\\t%d\\t%d \",sumw,sumv); if (sumwmaxsumv) //比较求最优方案 { maxsumw=sumw; maxsumv=sumv; maxi=count; } } else printf(\"否\\n\"); count++; //方案编号增加1 } printf(\"最佳方案为: \"); printf(\"选中物品\"); printf(\"{ \"); for (sit=ps[maxi].begin();sit!=ps[maxi].end();++sit) printf(\"%d \",*sit); printf(\"},\"); printf(\"总重量:%d,总价值:%d\\n\",maxsumw,maxsumv); } void main() { int n=4,W=6; int w[]={5,3,2,1}; int v[]={4,4,3,1}; PSet(n); printf(\"0/1背包的求解方案\\n\",n); Knap(w,v,W); } 程序填空题 先求幂集，通过比较将最佳方案保存在maxsumw和maxsumv中，最后输出所有的解和最佳解。 求解全排列问题 【问题描述】对于给定的正整数n（n≥1），求1～n的所有全排列。 【问题求解】这里采用增量蛮力法求解。产生1～3全排列的过程如下： void Insert(vector s,int i,vector > &ps1) //在每个集合元素中间插入i得到ps1 { vector s1; vector::iterator it; for (int j=0;j > ps1; //临时存放子排列 vector >::iterator it;//全排列迭代器 vector s,s1; s.push_back(1); ps.push_back(s); //添加{1}集合元素 for (int i=2;i ​ 【算法分析】对于给定的正整数n，每一种全排列都必须处理，有n!种，所以上述算法的时间复杂度为O(n*n!)。 程序填空题 循环将i插入到各个位置上 ps.push_back(s); //添加{1}集合元素 for (int i=2;i 求解任务分配问题 【问题描述】有n（n≥1）个任务需要分配给n个人执行，每个任务只能分配给一个人，每个人只能执行一个任务。 第i个人执行第j个任务的成本是c[i][j]（1≤i，j≤n）。求出总成本最小的分配方案。 【问题求解】所谓一种分配方案就是由第i个人执行第j个任务，用（a1，a2，…，an）表示，即第1个人执行第a1个任务，第2个人执行第a2个任务，以此类推。全部的分配方案恰好是1～n的全排列。 这里采用增量穷举法求出所有的分配方案ps（全排列），再计算出每种方案的成本，比较求出最小成本的方案，即最优方案。以n=4，成本如下表所示为例讨论。 //问题表示 int n=4; int c[MAXN][MAXN]={ {9,2,7,8},{6,4,3,7},{5,8,1,8},{7,6,9,4} }; vector > ps; //存放全排列 void Insert(vector s,int i,vector > &ps1) //在每个集合元素中间插入i得到ps1 { vector s1; vector::iterator it; for (int j=0;j > ps1; //临时存放子排列 vector >::iterator it; //全排列迭代器 vector s,s1; s.push_back(1); ps.push_back(s); //添加{1}集合元素 for (int i=2;i 程序填空题 先求全排列，根据每一种排列计算总成本记录最小成本 C5 回溯法（填空题、判断题、算法复杂度分析） 回溯法概述 回溯法实际上一个类似穷举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”（即回退），尝试别的路径。 回溯法原理： 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点（开始结点）出发搜索解空间树。 首先根结点成为活结点（活结点是指自身已生成但其孩子结点没有全部生成的结点），同时也成为当前的扩展结点（扩展结点是指正在产生孩子结点的结点）。 在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为新的活结点，并成为当前扩展结点。 如果在当前的扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点（死结点是指由根结点到该结点构成的部分解不满足约束条件，或者其子结点已经搜索完毕）。 此时应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。 回溯法以这种方式递归地在解空间中搜索，直至找到所要求的解或解空间中已无活结点为止。 当从状态si搜索到状态si+1后，如果si+1变为死结点，则从状态si+1回退到si，再从si找其他可能的路径，所以回溯法体现出走不通就退回再走的思路。 若用回溯法求问题的所有解时，需要回溯到根结点，且根结点的所有可行的子树都要已被搜索完才结束。而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。 回溯法搜索解空间时，通常采用两种策略避免无效搜索，提高回溯的搜索效率:　 用约束函数在扩展结点处剪除不满足约束的子树； 用限界函数剪去得不到问题解或最优解的子树。 这两类函数统称为剪枝函数。 归纳起来，用回溯法解题的一般步骤如下： 针对所给问题，确定问题的解空间树，问题的解空间树应至少包含问题的一个（最优）解。 确定结点的扩展搜索规则。 以深度优先方式搜索解空间树，并在搜索过程中可以采用剪枝函数来避免无效搜索。 回溯法与深度优先遍历的异同： 两者的相同点： 回溯法在实现上也是遵循深度优先的，即一步一步往前探索，而不像广度优先遍历那样，由近及远一片一片地搜索。 两者的不同点： （1）访问序不同：深度优先遍历目的是“遍历”，本质是无序的。而回溯法目的是“求解过程”，本质是有序的。 （2）访问次数的不同：深度优先遍历对已经访问过的顶点不再访问，所有顶点仅访问一次。而回溯法中已经访问过的顶点可能再次访问。 （3）剪枝的不同：深度优先遍历不含剪枝，而很多回溯算法采用剪枝条件剪除不必要的分枝以提高效能。 回溯法算法的时间分析 通常情况下，回溯法的效率会高于蛮力法。 填空题 剪枝函数-->约束函数、限界函数 子集树、排列树 判断题 回溯法和深度优先的不同：访问序、访问次数、剪枝 求解0/1背包问题 【问题描述】有n个重量分别为{w1，w2，…，wn}的物品，它们的价值分别为{v1，v2，…，vn}，给定一个容量为W的背包。 设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，而且重量和恰好为W具有最大的价值。 【问题求解】第4章采用蛮力法求解，这里采用回溯法求解该问题。 用x[1..n]数组存放最优解，其中每个元素取1或0，x[i]=1表示第i个物品放入背包中，x[i]=0表示第i个物品不放入背包中。 为了更清楚地描述算法，将这些给定的算法输入设计成全局变量。 这是一个求最优解问题。 ​ 对第i层上的某个分枝结点，对应的状态为dfs(i，tw，tv，op)，其中tw表示装入背包中的物品总重量，tv表示背包中物品总价值，op记录一个解向量。该状态的两种扩展如下： （1）选择第i个物品放入背包：op[i]=1，tw=tw+w[i]，tv=tv+v[i]，转向下一个状态dfs(i+1，tw，tv，op)。该决策对应左分枝。 （2）不选择第i个物品放入背包：op[i]=0，tw不变，tv不变，转向下一个状态dfs(i+1，tw，tv，op)。该决策对应右分枝。 ​ 叶子结点表示已经对n个物品做了决策，对应一个解。对所有叶子结点进行比较求出满足tw≤W的最大tw，用maxv表示，对应的最优解op存放到x中。 改进：左剪枝 对于第i层的有些结点，tw+a[i]已超过了W，显然再选择a[i]是不合适的。如第2层的（5，4）结点，tw=5，a[2]=3，而tw+a[2]>W，选择物品2进行扩展是不必要的，可以增加一个限界条件进行剪枝，如若选择物品i会导致超重即tw+w[i]>W，就不再扩展该结点，也就是仅仅扩展tw+w[i]≤W的左孩子结点。 改进：右剪枝 用rw表示考虑第i个物品时剩余物品的重量。 当不选择物品i时，若tw+rw≤W（注意rw中包含w[i]）时，也就是说即使选择后面的所有物品，重量也不会达到W，因此不必要再考虑扩展这样的结点，也就是说，对于右分枝仅仅扩展tw+rw>W的结点。 //问题表示 int n=4; //4种物品 int W=6; //限制重量为6 int w[]={0,5,3,2,1}; //存放4个物品重量,不用下标0元素 int v[]={0,4,4,3,1}; //存放4个物品价值,不用下标0元素 //求解结果表示 int x[MAXN]; //存放最终解 int maxv; //存放最优解的总价值 void dfs(int i,int tw,int tv,int rw,int op[]) //求解0/1背包问题 { //初始调用时rw为所有物品重量和 int j; if (i>n) //找到一个叶子结点 { if (tw==W && tv>maxv) //找到一个满足条件的更优解,保存 { maxv=tv; for (j=1;jW) //右孩子结点剪枝 dfs(i+1,tw,tv,rw-w[i],op); } } 【算法分析】该算法不考虑剪枝时解空间树中有2n+1-1个结点，对应的算法时间复杂度为O(2n)。 算法复杂度分析 左剪枝 --> 超重 右剪枝 --> 剩下的物品不满足重量 时间复杂度O(2n)(2的n次方)-->每次一个问题选择或者不选择 求解n皇后问题 非递归回溯算法对应的算法： void Queens(int n) //求解n皇后问题 { int i=1; //i表示当前行,也表示放置第i个皇后 q[i]=0; //q[i]是当前列,每个新考虑的皇后初始位置置为0列 while (i>=1) //尚未回溯到头，循环 { q[i]++; //原位置后移动一列 while (q[i] 【算法分析】该算法中每个皇后都要试探n列，共n个皇后，其解空间是一棵子集树，不同于前面一般的二叉树子集树，这里每个结点可能有n棵子树。 对应的算法时间复杂度为O(n^n)。 算法复杂度分析 以行为递归选择列or以列为递归选择行-->算法时间复杂度都为O（n^n）(n的n次方)-->n个行对应n个列的解决结果 求解活动安排问题 【问题描述】假设有一个需要使用某一资源的n个活动所组成的集合S，S={1，…，n}。该资源任何时刻只能被一个活动所占用，活动i有一个开始时间bi和结束时间ei（bi 【问题求解】这里采用回溯法求解，相当于找到S={1，…，n}的某个排列即调度方案，使得其中所有兼容活动的执行时间和最大，显然对应的解空间是一个是排列树。 直接采用排列树递归框架实现，对于每一种调度方案求出所有兼容活动个数，通过比较求出最多活动个数，对应的调度方案就是最优调度方案，即为本问题的解。 //问题表示 struct Action { int b; //活动起始时间 int e; //活动结束时间 }; int n=4; Action A[]={ {0,0},{1,3},{2,5},{4,8},{6,10} }; //下标0不用 //结果表示 int x[MAX]; //临时解向量,初始化为1-n，代表任务执行的顺序 int bestx[MAX]; //最优解向量 int laste=0; //一个调度方案中最后兼容活动的结束时间,初值为0 int sum=0; //一个调度方案中所有兼容活动个数,初值为0 int maxsum=0; void dfs(int i) //搜索活动问题最优解 { if (i>n) //到达叶子结点,产生一种调度方案 { if (sum>maxsum) { maxsum=sum; for (int k=1;k=laste) //活动x[j]与前面兼容 { sum++; //兼容活动个数增1 laste=A[x[j]].e; //修改本方案的最后兼容时间 } swap(x[i],x[j]);//排序树问题递归框架:交换x[i],x[j]，第i个执行的任务是x[j] dfs(i+1); //排序树问题递归框架:进入下一层 swap(x[i],x[j]); //排序树问题递归框架:交换x[i],x[j],回到原来的状态以供下次交换 sum=sum1; //回溯 laste=laste1; //即撤销第i层结点对活动x[j]的选择 } } } 【算法分析】该算法对应解空间树是一棵排列树，与求全排列算法的时间复杂度相同，即为O(n!)。 算法复杂度分析 时间复杂度-->O(n!) 空间复杂度-->O(n) C6 分支界限法（判断题、算法过程分析） 队列式分枝限界法 将根结点加入活结点队列。 从活结点队中取出队头结点，作为当前扩展结点。 对当前扩展结点，先从左到右地产生它的所有孩子结点，用约束条件检查，把所有满足约束条件的孩子结点加入活结点队列。 重复步骤②和③，直到找到一个解或活结点队列为空为止。 优先队列式分枝限界法 优先队列式分枝限界法的主要特点是将活结点表组组成一个优先队列，并选取优先级最高的活结点成为当前扩展结点。 判断题 活结点队列、优先队列、广度遍历 求解0/1背包问题 【问题描述】有n个重量分别为{w1，w2，…，wn}的物品，它们的价值分别为{v1，v2，…，vn}，给定一个容量为W的背包。 设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，而且重量和为W具有最大的价值。 对于第i层的某个结点e，用e.w表示结点e时已装入的总重量，用e.v表示已装入的总价值： 如果所有剩余的物品都能装入背包，那么价值的上界e.ub=e.v+ (v[i+1]+…+v[n]) 如果所有剩余的物品不能全部装入背包，那么价值的上界e.ub=e.v+ (v[i+1]+…+v[k])+(物品k+1装入的部分重量)×物品k+1的单位价值//这里必须按性价比降序排序 //问题表示 int n=3,W=30; int w[]={0,16,15,15}; //重量，下标0不用 int v[]={0,45,25,25}; //价值，下标0不用，已经按性价比降序排序 //求解结果表示 int maxv=-9999; //存放最大价值,初始为最小值 int bestx[MAXN]; //存放最优解,全局变量 int total=1; //解空间中结点数累计,全局变量 struct NodeType //队列中的结点类型 { int no; //结点编号 int i; //当前结点在搜索空间中的层次 int w; //当前结点的总重量 int v; //当前结点的总价值 int x[MAXN]; //当前结点包含的解向量 double ub; //上界 }; void EnQueue(NodeType e,queue &qu) //结点e进队qu { if (e.i==n) //到达叶子结点 { if (e.v>maxv) //找到更大价值的解 { maxv=e.v; for (int j=1;j qu; //定义一个队列 e.i=0; //根结点置初值，其层次计为0 e.w=0; e.v=0; e.no=total++; for (j=1;jmaxv) //若右孩子结点可行,则进队,否则被剪枝 EnQueue(e2,qu); } } 优先队列法 struct NodeType //队列中的结点类型 { int no; //结点编号 int i; //当前结点在搜索空间中的层次 int w; //当前结点的总重量 int v; //当前结点的总价值 int x[MAXN]; //当前结点包含的解向量 double ub; //上界 bool operator 算法过程分析 如果所有剩余的物品都能装入背包，那么价值的上界e.ub=e.v+ (v[i+1]+…+v[n]) 如果所有剩余的物品不能全部装入背包，那么价值的上界e.ub=e.v+ (v[i+1]+…+v[k])+(物品k+1装入的部分重量)×物品k+1的单位价值//这里必须按性价比降序排序 每次结点入队先求上界、左剪枝要求重量不超过、右剪枝要求期待价值大于目前最大价值 C7 贪心法（填空题） 求解活动安排问题 【问题描述】假设有一个需要使用某一资源的n个活动所组成的集合S，S={1，…，n}。该资源任何时刻只能被一个活动所占用，活动i有一个开始时间bi和结束时间ei（bi //问题表示 struct Action //活动的类型声明 { int b; //活动起始时间 int e; //活动结束时间 bool operator=preend) //找到一个兼容活动 { flag[i]=true; //选择A[i]活动 preend=A[i].e; //更新preend值 } } } 【算法分析】算法的主要时间花费在排序上，排序时间为O(nlog2n)，所以整个算法的时间复杂度为O(nlog2n)。 填空题 以结束时间递增排序后，从活动1开始选择 求解背包问题 【问题描述】设有编号为1、2、…、n的n个物品，它们的重量分别为w1、w2、…、wn，价值分别为v1、v2、…、vn，其中wi、vi（1≤i≤n）均为正数。有一个背包可以携带的最大重量不超过W。求解目标：在不超过背包负重的前提下，使背包装入的总价值最大（即效益最大化），与0/1背包问题的区别是，这里的每个物品可以取一部分装入背包。 【问题求解】贪心策略：选择单位重量价值最大的物品。每次从物品集合中选择单位重量价值最大的物品，如果其重量小于背包容量，就可以把它装入，并将背包容量减去该物品的重量，然后就面临了一个最优子问题——它同样是背包问题，只不过背包容量减少了，物品集合减少了。 因此背包问题具有最优子结构性质。 //问题表示 int n=5; double W=100; //限重 struct NodeType { double w; double v; double p; //p=v/w bool operators.p; //按p递减排序 } }; NodeType A[]={ {0},{10,20},{20,30},{30,66},{40,40},{50,60} };//下标0不用 //求解结果表示 double V; //最大价值 double x[MAXN]; void Knap() //求解背包问题并返回总价值 { V=0; //V初始化为0 double weight=W; //背包中能装入的余下重量 memset(x,0,sizeof(x)); //初始化x向量 int i=1; while (A[i].w0) //当余下重量大于0 { x[i]=weight/A[i].w; //将物品i的一部分装入 V+=x[i]*A[i].v; //累计总价值 } } void main() { printf(\"求解过程\\n\"); for (int i=1;i 填空题 以性价比降序排序，可以装一部分物品进入背包 用贪心法求解的问题应该具有的性质 贪心选择性质： 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。也就是说，贪心法仅在当前状态下做出最好选择，即局部最优选择，然后再去求解做出这个选择后产生的相应子问题的解。 最优子结构性质 如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心法求解的关键特征。 填空题 贪心选择性质、最优子结构性质 证明一个问题适用贪心算法 数学归纳法 证明当n= 1时命题成立。 假设n=m时命题成立，那么可以推导出在n=m+1时命题也成立。（m代表任意自然数） 反证法 首先假设某命题成立（即在原命题的条件下，结论不成立），然后推理出明显矛盾的结果，从而下结论说原假设不成立，原命题得证。 集装箱问题 n个集装箱1,2…,n装上轮船，集装箱i的重量为w i w_iw i 轮船载重量限制为c cc ,无体积限制。如何使装上船的集装箱最多。(假设每个集装箱重量小于c) 贪心策略：将集装箱按照从轻到重排序，轻者先装 这里用的反证法，首先证明n=1时贪心选择得到最优解； 设对于n-1，即N={1,2,...,n}的输入，最优解为I，选择的总重量为c 由上得N' = {2,3,...,n},重量c' = c - w1,最优解I’,满足I = {1}UI‘ 证明没有比I更大的解 如果存在包含1的关于N的最优解I*，I*的数量大于I，如果I中没有1，用1替换I\\中的第一个元素得到的解也是最优解 那么I - {1} 是N'的解且|I-{1}|是N’的解且|I*-{1}|>|I-{1}|=|I'| 与I‘的最优性矛盾 活动安排问题 增量的量级是选中的任务数量 通常证明一个贪心选择得出的解是最优解的一般的方法是，构造一个初始最优解，然后对该解进行修正，使其第一步为一个贪心选择，证明总是存在一个以贪心选择开始的求解方案。 对于本问题，所有活动按结束时间递增排序，就是要证明：若X是活动安排问题A的最优解，X=X'∪{1}（任务一），则X'是A'={i∈A：ei≥b1}的活动安排问题的最优解。（一定存在一个最优解，以任务一开始） 首先证明总存在一个以活动1开始的最优解。 如果第一个选中的活动为k（k≠1），可以构造另一个最优解Y，Y中的活动是兼容的，Y与X的活动数相同。 那么用活动1取代活动k得到Y'，因为e1≤ek，所以Y'中的活动是兼容的，即Y'也是最优的，这就说明总存在一个以活动1开始的最优解。 当做出了对活动1的贪心选择后，原问题就变成了在活动2、…、n中找与活动1兼容的那些活动的子问题。亦即，如果X为原问题的一个最优解，则X'=X-{1}也是活动选择问题A'={i∈A | bi≥e1}的一个最优解。 反证法：如果能找到一个A'的含有比X'更多活动的解Y'，则将活动1加入Y'后就得到A的一个包含比X更多活动的解Y，这就与X是最优解的假设相矛盾。 因此，在每一次贪心选择后，留下的是一个与原问题具有相同形式的最优化问题，即最优子结构性质。 最小延迟调度问题 贪心策略 按照截止时间：从小到大选择任务，安排时不留空闲时间 伪代码： 正确性证明：交换论证 上述算法的解的性质：没有空闲时间,没有逆序(不存在f ( i ) d j 命题1：所有没有逆序、没有空闲时间的调度具有相同的最大延迟 命题1证明：f 1 和 f 2 都没有逆序,具有相同截止时间的任务必须被连续安排。在这些连续安排的任务中最大延迟是最后一个任务，被延迟的时间只与已安排任务加工时间之和有关，与任务标号无关。 证明思想：从一个没有空闲时间的最优解出发，在不改变最优性的条件下，转变为没有逆序的解。 如果一个最优调度存在逆序，那么存在i 存在逆序(i,j),j = i + 1,那么交换i和j得到的解的逆序数减一，后面证明这个新的调度仍然最优 至多经过n(n-1)/2次交换得到一个没有逆序的最优调度 交换相邻逆序任务(i,j)不影响最优性： 交换i,j显然对其他任务的延迟时间没有影响 交换后不增加j的延迟 任务i在f 2 的延迟L 2 小于任务j在f1 的延迟L 1 j L{1j}L 因此小于$ f_1 $的最大延迟 C8 动态规划（填空、判断、算法过程分析、算法复杂度分析） 动态规划是一种解决多阶段决策问题的优化方法，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。 求解整数拆分问题 【问题描述】求将正整数n无序拆分成最大数为k（称为n的k拆分）的拆分方案个数，要求所有的拆分方案不重复。 【问题求解】设n=5，k=5，对应的拆分方案有： ① 5=5 ② 5=4+1 ③ 5=3+2 ④ 5=3+1+1 ⑤ 5=2+2+1 ⑥ 5=2+1+1+1 ⑦ 5=1+1+1+1+1 为了防止重复计数，让拆分数保持从大到小排序。正整数5的拆分数为7。 采用动态规划求解整数拆分问题。设f(n，k)为n的k拆分的拆分方案个数： （1）当n=1，k=1时，显然f(n，k)=1。 （2）当n （3）当n=k时，其拆分方案有将n拆分成1个n的拆分方案，以及n的n-1拆分方案，前者仅仅一种，所以有f(n，n)=f(n，n-1)+1。 （4）当n>k时，根据拆分方案中是否包含k，可以分为两种情况： ① 拆分中包含k的情况：即一部分为单个k，另外一部分为{x1，x2，…，xi}，后者的和为n-k，后者中可能再次出现k，因此是（n-k）的k拆分，所以这种拆分方案个数为f(n-k，k)。 ② 拆分中不包含k的情况：则拆分中所有拆分数都比k小，即n的（k-1）拆分，拆分方案个数为f(n，k-1)。 因此，f(n，k) = f(n-k，k) + f(n，k-1) 状态转移方程： 显然，求f(n，k)满足动态规划问题的最优性原理、无后效性和有重叠子问题性质。所以特别适合采用动态规划法求解。设置动态规划数组dp，用dp[n][k]存放f(n，k)。对应的完整程序如下： int dp[MAXN][MAXN]; //动态规划数组 void Split(int n，int k) //求解算法 { for (int i=1;i 实际上，该问题本身是递归的，可以直接采用递归算法实现，但由于子问题重叠，存在重复的计算！ 可以采用这样的方法避免重复计算：设置数组dp，用dp[n][k]存放f(n，k)，首先初始化dp的所有元素为特殊值0，当dp[n][k]不为0时表示对应的子问题已经求解，直接返回结果。 int dp[MAXN][MAXN]; int dpf(int n，int k) //求解算法 { if (dp[n][k]!=0) return dp[n][k]; if (n==1 || k==1) { dp[n][k]=1; return dp[n][k]; } else if (n 这种方法是一种递归算法，其执行过程也是自顶向下的，但当某个子问题解求出后，将其结果存放在一张表（dp）中，而且相同的子问题只计算一次，在后面需要时只有简单查表，以避免大量的重复计算。这种方法称之为备忘录方法（memorization method）。 备忘录方法是动态规划方法的变形，与动态规划算法不同的是，备忘录方法的递归方式是自顶向下的，而动态规划算法则是自底向上的。 填空&&判断 备忘录方法是动态规划方法的变形，与动态规划算法不同的是，备忘录方法的递归方式是自顶向下的，而动态规划算法则是自底向上的。 能采用动态规划求解的问题的一般要具有3个性质： 最优性原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优性原理。 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。 算法过程分析 状态转移方程： 算法复杂度分析 时间复杂度O(n*k),空间复杂度O(n*k) 求解最长公共子序列问题 【问题描述】字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。 令给定的字符序列X=（x0，x1，…，xm-1），序列Y=（y0，y1，…，yk-1）是X的子序列，存在X的一个严格递增下标序列（i0，i1，…，ik-1），使得对所有的j=0，1，…，k-1，有 =yj。 例如，X=（a，b，c，b，d，a，b），Y=（b，c，d，b）是X的一个子序列。 给定两个序列A和B，称序列Z是A和B的公共子序列，是指Z同是A和B的子序列。该问题是求两序列A和B的最长公共子序列（LCS） 【问题求解】若设A=（a0，a1，…，am-1），B=（b0，b1，…，bn-1），设Z=（z0，z1，…，zk-1）为它们的最长公共子序列。不难证明有以下性质： 定义二维动态规划数组dp，其中dp[i][j]为子序列（a0，a1，…，ai-1）和（b0，b1，…，bj-1）的最长公共子序列的长度。 每考虑一个字符a[i]或b[j]都为动态规划的一个阶段（共经历约m×n个阶段）。 情况1：a[i-1]=b[j-1]（最后两个数相同） dp[i][j]=dp[i-1][j-1]+1 情况2：a[i-1]≠b[j-1]（最后两个数不相同） dp[i][j]=MAX(dp[i][j-1]，dp[i-1][j]) dp[i][j]为子序列（a0，a1，…，ai-1）和（b0，b1，…，bj-1）的最长公共子序列的长度。 对应的状态转移方程如下： dp[i][j]=0 i=0或j=0―边界条件 dp[i][j]=dp[i-1][j-1]+1 a[i-1]=b[j-1] dp[i][j]=MAX(dp[i][j-1]，dp[i-1][j]) a[i-1]≠b[j-1] 如何由dp求出一个LCS？ 当dp[i][j] ≠ dp[i][j-1]（左边）并且dp[i][j] ≠ dp[i-1][j]（上方）值时： a[i-1]=b[j-1]它是LCS的一个字符 将a[i-1]添加到LCS中。 其他情况时：a[i-1]或者b[j-1]是LCS的一个字符！ 用vector字符向量subs存放一个LCS，k=dp[m][n]（LCS的字符个数），从k到1循环求出subs中的k个字符： （1）如果dp[i][j]==dp[i-1][j]（上方），说明a[i-1]或b[j-1]不是LCS中的字符 i--； （2）如果dp[i][j]==dp[i][j-1]（左边），说明a[i-1]或b[j-1]不是LCS中的字符 j--； （3）其他情况，说明a[i-1]或者b[j-1]是LCS的一个字符！ i--; j--; k--;表示求的字符减少1个 #define MAX 51 //序列中最多的字符个数 //问题表示 int m，n; string a，b; //求解结果表示 int dp[MAX][MAX]; //动态规划数组 vector subs; //存放LCS void LCSlength() //求dp { int i，j; for (i=0;i0) //在subs中放入最长公共子序列(反向) if (dp[i][j]==dp[i-1][j])//如果dp等于左边的值，则向左移动一位 i--; else if (dp[i][j]==dp[i][j-1])//如果dp等于上边的值，则向上移动一位 j--; else //与上方、左边元素值均不相等 { subs.push_back(a[i-1]); //subs中添加a[i-1] i--; j--; k--;//向斜方移动一位，并根据最长公共子序列的数量循环 } } 【算法分析】 LCSlength算法中使用了两重循环，所以对于长度分别为m和n的序列，求其最长公共子序列的时间复杂度为O(m×n)。空间复杂度为O(m×n)。 算法过程分析 情况1：a[i-1]=b[j-1]（最后两个数相同） dp[i][j]=dp[i-1][j-1]+1 情况2：a[i-1]≠b[j-1]（最后两个数不相同） dp[i][j]=MAX(dp[i][j-1]，dp[i-1][j]) dp[i][j]为子序列（a0，a1，…，ai-1）和（b0，b1，…，bj-1）的最长公共子序列的长度。 对应的状态转移方程如下： dp[i][j]=0 i=0或j=0―边界条件 dp[i][j]=dp[i-1][j-1]+1 a[i-1]=b[j-1] dp[i][j]=MAX(dp[i][j-1]，dp[i-1][j]) a[i-1]≠b[j-1] 如何由dp求出一个LCS？ 当dp[i][j] ≠ dp[i][j-1]（左边）并且dp[i][j] ≠ dp[i-1][j]（上方）值时： a[i-1]=b[j-1]它是LCS的一个字符 将a[i-1]添加到LCS中。 while (k>0) //在subs中放入最长公共子序列(反向) if (dp[i][j]==dp[i-1][j]) i--; else if (dp[i][j]==dp[i][j-1]) j--; else //与上方、左边元素值均不相等 { subs.push_back(a[i-1]); //subs中添加a[i-1] i--; j--; k--; } 算法复杂度分析 间复杂度为O(m×n)。空间复杂度为O(m×n)。 求解0/1背包问题 【问题描述】有n个重量分别为{w1，w2，…，wn}的物品，它们的价值分别为{v1，v2，…，vn}，给定一个容量为W的背包。 设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，而且重量和为W具有最大的价值。 【问题求解】对于可行的背包装载方案，背包中物品的总重量不能超过背包的容量。 最优方案是指所装入的物品价值最高，即 v1x1+v2x2+…+vn*xn（其中xi取0或1，取1表示选取物品i）取得最大值。 在该问题中需要确定x1、x2、…、xn的值。假设按i=1，2，…，n的次序来确定xi的值，对应n次决策即n个阶段。 ​ 设置二维动态规划数组dp，dp[i][r]表示背包剩余容量为r（1≤r≤W），已考虑物品1、2、…、i（1≤i≤n）时背包装入物品的最优价值。显然对应的状态转移方程如下： 这样， dp[n][W]便是0/1背包问题的最优解。 当dp数组计算出来后，推导出解向量x的过程十分简单，从dp[n][W]开始： //问题表示 int n=5，W=10; //5种物品，限制重量不超过10 int w[MAXN]={0，2，2，6，5，4}; //下标0不用 int v[MAXN]={0，6，3，5，4，6}; //下标0不用 //求解结果表示 int dp[MAXN][MAXW]; int x[MAXN]; int maxv; //存放最优解的总价值 void Knap() //动态规划法求0/1背包问题 { int i，r; for (i=0;i=0) //判断每个物品 { if (dp[i][r]!=dp[i-1][r]) { x[i]=1; //选取物品i maxv+=v[i]; //累计总价值 r=r-w[i]; } else x[i]=0; //不选取物品i i--; } } 【算法分析】Knap()算法中含有两重for循环，所以时间复杂度为O(n×W)，空间复杂度为O(n×W)。 算法过程分析 状态转移方程 算法复杂度分析 Knap()算法中含有两重for循环，所以时间复杂度为O(n×W)，空间复杂度为O(n×W)。 滚动数组 常用动态规划数组存放子问题的解，由于一般是存放连续的解，有时可以对数组的下标进行特殊处理，使每一次操作仅保留若干有用信息，新的元素不断循环刷新，看上去数组的空间被滚动地利用，这样的数组称为滚动数组（Scroll array） 如果仅仅求装入背包的最大价值（不需求解向量x）。 由于第i个阶段（考虑物品i）的解dp[i][]只与第i-1个阶段（考虑物品i-1）的解dp[i-1][]有关，这种情况下保存更前面的数据已经毫无意义。 所以可以利用滚动数组进行优化，将dp数组由dp[MAXN][MAXW]改为dp[2][MAXW]。dp[c][r]代表当前解，dp[1-c][r]代表上一个解 求0/1背包问题的状态转移方程如下： void Knap() //动态规划法求0/1背包问题 { int i,r; int c=0; for (i=0;i 填空&&判断 常用动态规划数组存放子问题的解，由于一般是存放连续的解，有时可以对数组的下标进行特殊处理，使每一次操作仅保留若干有用信息，新的元素不断循环刷新，看上去数组的空间被滚动地利用，这样的数组称为滚动数组（Scroll array） 算法过程分析 循环判断 for (i=1;i 边界条件： dp00 = 0;dp10=0; dp0r = 0; 算法复杂度分析 【算法分析】Knap()算法中含有两重for循环，所以时间复杂度为O(n×W)，空间复杂度为O(n×W)。 C11 计算复杂性理论（判断题） 求解问题的分类 将存在多项式时间算法的问题看作是易解问题，将需要指数时间级算法解决的问题看作是难解问题。 归纳起来，在各种求解问题中，按求解问题算法的时间复杂度可分为3大类： 存在多项式算法的问题 肯定不存在多项式算法的问题 尚未找到多项式算法，也不能证明其不存在多项式算法的问题。第三类问题介于第一类和第二类之间。 P类问题和NP类问题 确定性图灵机是现代电子计算机的理论模型。 一个对任意输入都停机的确定图灵机在多项式时间内可解的问题，必然存在多项式时间复杂度的计算机求解算法。 一个算法实质上就是一个以任何输入都停机的图灵机，因此已经找到的多项式时间界的计算机算法的问题都属于P类问题。 非确定性图灵机只是一种理论上的计算模型。不确定图灵机可解的问题，虽然也可以用确定性图灵机求解，但时间上的耗费（或说求解步数）是不一样的。 用非确定性图灵机以多项式时间界可求解的问题，用确定性图灵机不能保证在多项式时间界内可求解，但用确定性图灵机以指数时间界是肯定可以求解的。 用确定性图灵机以多项式时间界可解的问题称为P类问题，P指确定性图灵机上的具有多项式算法的问题集合。 用非确定性图灵机以多项式时间界可解的问题称为NP类问题，NP指非确定性图灵机上具有多项式算法的问题集合，这里N是不确定的意思。 NPC问题 NPC（NP-completeness）的概念表明找到某个问题的有效算法至少和找NP中所有问题的有效算法一样难。 这里的有效性的含义是指为求解问题设计的算法的时间为多项式级的。 归纳起来，NP问题包含P问题和NPC问题，目前属于多项式时间界求解的问题都属P问题，NPC问题是属于NP问题中最难的问题，目前尚不能确定能否用多项式时间界算法来求解。 但已证明，如果NPC问题中有一个问题能用多项式时间界算法求解，则所有NPC问题都可用多项式时间界算法求解。 判断题 NP包括P和NPC问题 属于多项式时间界求解的问题都属于P问题 P: 能在多项式时间内解决的问题 NP: 不能在多项式时间内解决或不确定能不能在多项式时间内解决，但能在多项式时间验证的问题 NPC: NP完全问题，所有NP问题在多项式时间内都能约化(Reducibility)到它的NP问题，即解决了此NPC问题，所有NP问题也都得到解决。 NP hard:NP难问题，所有NP问题在多项式时间内都能约化(Reducibility)到它的问题(不一定是NP问题)。 　　1. P问题属于NP问题，NPC问题属于NP问题。 　　2. NPC问题同时属于NP hard问题，是NP与NPhard的交集。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"02_数据结构与算法/红黑树.html":{"url":"02_数据结构与算法/红黑树.html","title":"红黑树","keywords":"","body":"二叉查找树 二叉查找树（Binary Search Tree，BST）是一种基于树结构的数据结构，它具有以下特性： 每个节点包含一个键值对（key-value pair）。 树中的节点按照一定的顺序排列，使得对于任意节点，其左子树中的所有键值小于节点的键值，而右子树中的所有键值大于节点的键值。这个性质被称为\"二叉搜索树性质\"。 每个节点最多有两个子节点，分别是左子节点和右子节点。如果节点没有左子节点，则左子树为空；如果节点没有右子节点，则右子树为空。 二叉查找树退化成链表： 一颗二叉树的每个结点只有左子树，或者只有右子树，是不是成一个链表啦。 比如在二叉搜索树里面，如果一直从小到大插入元素，就退化成一个链表了。 完美平衡二叉树 完美平衡二叉树（Perfectly Balanced Binary Tree），也称为完全平衡二叉树（Perfectly Balanced Binary Tree）或高度平衡二叉树（Height Balanced Binary Tree），是一种特殊类型的二叉树，它具有以下特性： 每个叶子节点具有相同的深度：这意味着从根节点到每个叶子节点的路径长度都相同。因此，完美平衡二叉树的高度非常均匀，每个叶子节点的深度相等。 每个非叶子节点都有两个子节点：每个内部节点都有两个子节点，一个左子节点和一个右子节点。这确保了树的完美平衡性，每个节点的子树都具有相同的结构。 红黑树 红黑树定义和性质 红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质： 性质1：每个节点要么是黑色，要么是红色。 性质2：根节点是黑色。 性质3：每个叶子节点（NIL）是黑色。 性质4：每个红色结点的两个子结点一定都是黑色。 性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。 黑色完美平衡 红黑树并不是一个完美平衡二叉树，但能够保证左子树和右子树的黑结点层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"03_语言/":{"url":"03_语言/","title":"C++","keywords":"","body":"03_语言 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/C++/argc和argv.html":{"url":"03_语言/C++/argc和argv.html","title":"Argc和argv","keywords":"","body":"在C和C++中，argc和argv是用于处理命令行参数的标准变量。 argc 是一个整数，表示传递给程序的命令行参数的数量。它至少为1，因为第一个参数是程序的名称（包括路径）。 argv 是一个指向指针数组的指针，其中每个指针指向一个以空字符结尾的字符串，表示一个命令行参数。argv[0] 指向程序的名称，argv[1] 指向第一个参数，以此类推。 例如，在命令行中运行一个程序 ./my_program arg1 arg2，那么 argc 的值将为 3，argv 数组将包含以下内容： rustCopy codeargv[0] -> \"./my_program\" argv[1] -> \"arg1\" argv[2] -> \"arg2\" 使用 argc 和 argv，你可以在程序中访问和处理命令行传递的参数，这使得程序在运行时更加灵活和可配置。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"03_语言/C++/C++.html":{"url":"03_语言/C++/C++.html","title":"C++","keywords":"","body":"文件与编译 头文件 编译和执行过程 基本语法 关键字 数据类型 整型 sizeof()函数，传入变量，返回变量占用空间字节大小 实型（浮点型） 3.14默认为双精度 float f1=3.14 系统需要转换 建议写成float f1 = 3.14f 默认情况下输出一个小数会显示6位有效数字 科学计数法：float f=3e-2 (0.03) 字符型 a 97 A 65 转义字符 字符串 1.C风格字符串 char str[]=\"hello world\" cout 2.c++风格字符串 #include string str=\"hello world\"; cout 布尔型 bool 一个字节 非0 真 true 0 假 false 运算符 两个小数不能进行取模操作 数组 初始化一维数组 //后面未初始化的元素，默认值为0 int years[6] = {2020,2019,2018,2017} //元素个数为2，不可再改变 int days[] = {2,3} //错误！未知元素个数 int array[] = {} //c++特性，初始化数组可以省略“=” int days[]{1,15}; //c++特性，大括号可为空，所有元素置0 float m[100]{}; 函数 指针 指针的大小：32位 4字节 64位8字节 空指针： 空指针指向的内存不可访问，指向编号为0的空间 0-255之间的内存编号是不可以访问的 野指针：指向非法内存空间 CONST 修饰指针（看const后面跟的是啥） 1.const修饰指针：常量（的）指针 const int p = &a （int p指向的值是个常量） 指针的指向可以改，但指针指向的值不能改 2.const修饰常量：指针（是）常量 指针的指向不可以改，但指针指向的值可以改。 int * const p = &a (p的指向是个常量) 3.const既修饰指针，又修饰常量 const int * const p = &a 数据的输入 cin >> 变量 向量容器vector No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"03_语言/C++/":{"url":"03_语言/C++/","title":"Ebook","keywords":"","body":"C++ No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"03_语言/C++/ebook/REFERS.html":{"url":"03_语言/C++/ebook/REFERS.html","title":"Refers","keywords":"","body":" Accelerated C 中文版 通过示例进行编程实践_13042810 C++ primer中文版 C++.Primer.Plus.6th.Edition.Oct.2011 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/C++/REFERS.html":{"url":"03_语言/C++/REFERS.html","title":"Refers","keywords":"","body":" 黑马 02 C++核心 黑马 03 C++ 提高 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:12 "},"03_语言/Java/ArrayList源码解析.html":{"url":"03_语言/Java/ArrayList源码解析.html","title":"Arraylist源码解析","keywords":"","body":"一、ArrayList的基本特点 快速随机访问 允许存放多个null元素 底层是Object数组 增加元素个数可能很慢(可能需要扩容),删除元素可能很慢(可能需要移动很多元素),改对应索引元素比较快 二、ArrayList的继承关系 来看下源码中的定义 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable 可以看到继承了AbstractList,此类提供 List 接口的骨干实现，以最大限度地减少实现\"随机访问\"数据存储（如数组）支持的该接口所需的工作.对于连续的访问数据（如链表），应优先使用 AbstractSequentialList，而不是此类. 实现了List接口,意味着ArrayList元素是有序的,可以重复的,可以有null元素的集合. 实现了RandomAccess接口标识着其支持随机快速访问,实际上,我们查看RandomAccess源码可以看到,其实里面什么都没有定义.因为ArrayList底层是数组,那么随机快速访问是理所当然的,访问速度O(1). 实现了Cloneable接口,标识着可以它可以被复制.注意,ArrayList里面的clone()复制其实是浅复制(不知道此概念的赶快去查资料,这知识点非常重要). 实现了Serializable 标识着集合可被序列化。 三、ArrayList 的构造方法 在说构造方法之前我们要先看下与构造参数有关的几个全局变量： /** * ArrayList 默认的数组容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 用于空实例的共享空数组实例 */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * 另一个共享空数组实例，用的不多,用于区别上面的EMPTY_ELEMENTDATA */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * ArrayList底层的容器 */ transient Object[] elementData; // non-private to simplify nested class access //当前存放了多少个元素 并非数组大小 private int size; transient标识之后是不被序列化的 但是ArrayList实际容器就是这个数组为什么标记为不序列化??那岂不是反序列化时会丢失原来的数据? 其实是ArrayList在序列化的时候会调用writeObject()，直接将size和element写入ObjectOutputStream；反序列化时调用readObject()，从ObjectInputStream获取size和element，再恢复到elementData。 原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/":{"url":"03_语言/Java/","title":"Ebook","keywords":"","body":"Java No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/ebook/REFERS.html":{"url":"03_语言/Java/ebook/REFERS.html","title":"Refers","keywords":"","body":" Thinking in Java 3rd No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/ebook/Thinking in Java 读书笔记.html":{"url":"03_语言/Java/ebook/Thinking in Java 读书笔记.html","title":"Thinking in java 读书笔记","keywords":"","body":"把object看作服务的集合。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/java.html":{"url":"03_语言/Java/java.html","title":"Java","keywords":"","body":"Java 简介 JVM（Java Virtual Machine）: Java虚拟机，Java平台无关性的关键 Java程序的执行过程： .java源文件-->编译器compiler-->.class字节码文件-->解释器interpreter-->program（把字节码解释成具体平台上的机器语言后，实现一次编译、到处运行） JDK（Java Development Kit）: Java语言的软件开发工具包 两个主要组件： -javac -编译器，将源程序转成字节码 -java -运行编译后的java程序（.class后缀的） JRE（Java Runtime Environment）： 包括Java虚拟机（JVM），Java核心类库和支持文件 如果只需要运行Java程序，下载并安装JRE即可；如果要开发Java软件，需要下载JDK 在JDK中附带有JRE JDK、JRE、JVM三者的关系 JRE = JVM + JavaSE标准类库 JDK = JRE + 开发者工具集（例如javac编译工具等） Java平台 JavaSE Java标准版 桌面程序 JavaEE Java企业版 Web程序 JavaME Java微型版 移动设备（现在用得少了） 常量与变量 标识符的命名规则： 标识符可以由字母、数字、下划线和美元符（$）组成，不能以数字开头 标识符不能有空格 标识符不能和关键字相同（eclipse中紫色） 标识符不能是Java保留字（如goto 现在不使用以后可能会使用） 标识符的命名最好能反映其作用 关键字表格 数据类型 基本数据类型 进制表示 八进制：以0开头，包括0-7的数字 十六进制：以0x或0X开头，包括0-9的数字，及字母a-f，A-F 基本数据类型变量的存储 数据类型分为基本数据类型和引用数据类型 引用数据类型包括数组和类等 类定义的变量又叫对象 变量按作用范围分为： 类级、对象实例级、方法级（局部变量 ）、块级 Unicode 目标支持世界上所有的字符集，例：char c='\\u005d'（四位的） 自动类型转换顺序 常量 定义变量最前头加上final 运算符 运算符优先级 同一级别，从左到右进行运算。 关键字 访问控制 private 私有的 private 关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。 只能在声明 private（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。 protected 受保护的 protected 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。 public 公共的 public 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 可能只会在其他任何类或包中引用 public 类、方法或字段。 那么我们总结一下，Java之中的权限访问修饰符（其实还有一种权限访问情况，就是默认情况，暂且称作default吧）： 访问权限 当前类 包 子类 其他包 public ∨ ∨ ∨ ∨ protect ∨ ∨ ∨ × default ∨ ∨ × × private ∨ × × × 类、方法和变量修饰符 abstract 声明抽象 abstract关键字可以修改类或方法。abstract类可以扩展（增加子类），但不能直接实例化。abstract方法不在声明它的类中实现，但必须在某个子类中重写。采用 abstract方法的类本来就是抽象类，并且必须声明为abstract。 class类 class 关键字用来声明新的 Java 类，该类是相关变量和/或方法的集合。类是面向对象的程序设计方法的基本构造单位。类通常代表某种实际实体，如几何形状或人。类是对象的模板。每个对象都是类的一个实例。要使用类，通常使用 new 操作符将类的对象实例化，然后调用类的方法来访问类的功能。 extends 继承、扩展 extends 关键字用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends 关键字的类或接口的子类。子类继承父类的所有 public 和 protected 变量和方法（但是不包括构造函数）。 子类可以重写父类的任何非 final 方法。一个类只能扩展一个其他类。 extends 关键字用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends 关键字的类或接口的子类。 final 最终、不可改变 在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。final方法在编译阶段绑定，称为静态绑定(static binding)。下面就从这四个方面来了解一下final关键字的基本用法。 ①修饰类 当用final修饰一个类时，表明这个类不能被继承，不能有子类。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。 ②修饰方法 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。 因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。 还有就是，类的private方法会隐式地被指定为final方法。 ③修饰变量 修饰变量是final用得最多的地方。 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。引用变量被final修饰之后，虽然不能再指向其他对象，但是它指向的对象的内容是可变的。 ④final参数 当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值或者引用指向。道理同final变量。 概括起来就是： ● 在A类是声明为final类型的方法，那么不能在子类里被覆盖； ● 如果A类被声明为final类型的类，那么B类不能继承A类； ● 如果成员变量声明为final类型，那么成员变量不能被修改； 注意： 一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类。一个方法不能同时是 abstract 又是 fina**l。abstract 意味着必须重写方法，final 意味着不能重写方法。两者是相互矛盾的。 当用final作用于类的成员变量时，成员变量（注意是类的成员变量，局部变量只需要保证在使用之前被初始化赋值即可）必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了。 final变量和普通变量的区别。当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会进行优化，会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问的这个常量，不需要在运行时确定。这种和C语言中的宏替换有点像。而普通变量在编译时，确定不了自身的值，需要在运行时才能知道。 局部内部类和匿名内部类只能访问局部final变量。因为这里的局部变量，需要在编译阶段便需要确定下来的。也就是说，如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。（？？？？？？） implements实现 implements 关键字在 class 声明中使用，以指示所声明的类提供了在 implements 关键字后面的名称所指定的接口中所声明的所有方法的实现。类必须提供在接口中所声明的所有方法的实现。一个类可以实现多个接口。 interface 接口 interface 关键字用来声明新的 Java 接口，接口是方法的集合。 接口是 Java 语言的一项强大功能。任何类都可声明它实现一个或多个接口，这意味着它实现了在这些接口中所定义的所有方法。 实现了接口的任何类都必须提供在该接口中的所有方法的实现。一个类可以实现多个接口。 native 本地 native 关键字可以应用于方法，以指示该方法是用Java以外的语言实现的，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。。 Java不是完美的，Java的不足除了体现在运行速度上要比传统的C++慢许多之外，Java无法直接访问到操作系统底层（如系统硬件等)，为此Java使用native方法来扩展Java程序的功能。 可以将native方法比作Java程序同Ｃ程序的接口，其实现步骤： 在Java中声明native()方法，然后编译； 用javah产生一个.h文件； 写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）； 将第三步的.cpp文件编译成动态链接库文件； 在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。 JAVA本地方法适用的情况 为了使用底层的主机平台的某个特性，而这个特性不能通过JAVA API访问 为了访问一个老的系统或者使用一个已有的库，而这个系统或这个库不是用JAVA编写的 为了加快程序的性能，而将一段时间敏感的代码作为本地方法实现。 new 新,创建 new 关键字用于创建类的新实例。 new 关键字后面的参数必须是类名，并且类名的后面必须是一组构造方法参数（必须带括号）。 参数集合必须与类的构造方法的签名匹配。 = 赋值号左侧的变量的类型必须与要实例化的类或接口具有赋值兼容关系。 static 静态 static可以用于修饰属性，可以修饰代码块，也可以用于修饰方法，还可以用于修饰类。 static修饰属性： 无论一个类生成了多少个对象，所有这些对象共同使用唯一一份静态的成员变量；一个对象对该静态成员变量进行了修改，其他对象的该静态成员变量的值也会随之发生变化。如果一个成员变量是static的，那么我们可以通过‘类名.成员变量名’的方式来使用它。 static修饰方法： static修饰的方法叫做静态方法。对于静态方法来说，可以使用‘类名.方法名’的方式来访问。静态方法只能继承，不能重写（Override），因为重写是用于表现多态的，重写只能适用于实例方法，而静态方法是可以不生成实例直接用类名来调用，这就会与重写的定义所冲突，与多态所冲突，所以静态方法不能重写，只能是隐藏。 static方法与非static方法：不能在静态方法中访问非静态成员变量；可以在静态方法中访问静态的成员变量。可以在非静态方法中访问静态的成员变量：因为静态方法可以直接用类名来调用，而非静态成员变量是在创建对象实例时才为变量分配内存和初始化变量值。 不能在静态方法中使用this关键字：因为静态方法可以直接用类名来调用，而this实际上是创建实例时，实例对应的一个应用，所以不能在静态方法上使用this。 static修饰代码块： 静态代码块。静态代码块的作用也是完成一些初始化工作。首先执行静态代码块，然后执行构造方法。静态代码块在类被加载的时候执行，而构造方法是在生成对象的时候执行；要想调用某个类来生成对象，首先需要将类加载到Java虚拟机上（JVM），然后由JVM加载这个类来生成对象。 类的静态代码块只会执行一次，是在类被加载的时候执行的，因为每个类只会被加载一次，所以静态代码块也只会被执行一次；而构造方法则不然，每次生成一个对象的时候都会调用类的构造方法，所以new一次就会调用构造方法一次。如果继承体系中既有构造方法，又有静态代码块，那么首先执行最顶层的类的静态代码块，一直执行到最底层类的静态代码块，然后再去执行最顶层类的构造方法，一直执行到最底层类的构造方法。注意：静态代码块只会执行一次。 static修饰类： 这个有点特殊，首先，static是可以用来修饰类的，但是static是不允许用来修饰普通类，只能用来修饰内部类，被static所修饰的内部类可以用new关键字来直接创建一个实例，不需要先创建外部类实例。static内部类可以被其他类实例化和引用（即使它是顶级类）。 其实理解起来也简单。因为static主要是修饰类里面的成员，包括内部类、属性、方法这些。修饰这些变量的目的也很单纯，那就是暗示这个成员在该类之中是唯一的一份拷贝，即便是不断的实例化该类，所有的这个类的对象都会共享这些static成员。这样就好办了。因为是共享的、唯一的，所以，也就不需要在实例化这个类以后再通过这个类来调用这个成员了，显然有点麻烦，所以就简单一点，直接通过类名直接调用static成员，更加直接。然而这样设置之后，就出现了一个限制，就是，static方法之中不能访问非static属性，因为这个时候非static属性可能还没有给他分配内存，该类还没有实例化。 所以，通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。 可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。 strictfp 严格,精准 strictfp的意思是FP-strict，也就是说精确浮点的意思。在Java虚拟机进行浮点运算时，如果没有指定strictfp关键字时，Java的编译器以及运行环境在对浮点运算的表达式是采取一种近似于我行我素的行为来完成这些操作，以致于得到的结果往往无法令人满意。而一旦使用了strictfp来声明一个类、接口或者方法时，那么所声明的范围内Java的编译器以及运行环境会完全依照浮点规范IEEE-754来执行。因此如果想让浮点运算更加精确，而且不会因为不同的硬件平台所执行的结果不一致的话，那就请用关键字strictfp。 可以将一个类、接口以及方法声明为strictfp，但是不允许对接口中的方法以及构造函数声明strictfp关键字。 synchronized线程、同步 synchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。 synchronized 关键字可防止代码的关键代码段一次被多个线程执行。 如果应用于静态方法，那么，当该方法一次由一个线程执行时，整个类将被锁定。 如果应用于实例方法，那么，当该方法一次由一个线程访问时，该实例将被锁定。 如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。 一般的用法有： synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁 每个synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）。 在Java中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。 synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何synchronized 方法的调用都永远不会成功。当然我们可以通过将访问类成员变量的代码放到专门的方法中，将其声明为 synchronized ，并在主方法中调用来解决这一问题，但是 Java 为我们提供了更好的解决办法，那就是 synchronized块。 synchronized块 当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。 尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。 这里的关键之处在于，这个object的对象锁只有一把，一把锁对应一个线程。 transient 短暂（？？？？） transient 关键字可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。 当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。 transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 volatile易失 volatile 关键字用于表示可以被多个线程异步修改的成员变量。 注意：volatile 关键字在许多 Java 虚拟机中都没有实现。 volatile 的目标用途是为了确保所有线程所看到的指定变量的值都是相同的。 Volatile修饰的成员变量在每次被线程访问时，都强迫从主内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到主内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。** Java语言规范中指出： 为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。 这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。 而volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝,而应直接与共享成员变量交互。 使用建议：在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。 由于使用volatile屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。 Java 语言中的 volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。 数组 语法格式 数据类型[] 数组名; 数据类型 数组名[] 数组在内存中的存储 一段连续的内存空间，int数组默认值为0 增强型for循环 int[] arr = {1,2,3,4,5} for(int n:arr) System.out.println(n); 声明二维数组 列数可以省略，行数不能省略 方法 可变参数列表： 一个方法中，只能有一个可变参数列表作为参数；在方法的参数列表中，如果有两个以上的参数，可变参数列表一定是放在最后。 public void sum(int... n){} 可以将数组传递给可变参数列表： 但数组作为参数时，不能将多个值传递给数组。 可变参数列表所在的方法是最后被访问的。 文档注释： 通过命令去执行，可以将注释中的内容提取出来，生成java的帮助文档 面向对象 单一功能原则： 一个类只有一个功能。 实例化对象的过程可以分为两部分 ①声明对象：Cat one 在栈中开辟一片新的空间，空间内没有内容 ②实例化对象：new Cat() 在堆中开辟一片新的空间，完成了相关的初始化操作 ③Cat one = new Cat(); 将声明的对象指向实例化的具体的空间 构造方法 构造方法是不能被对象单独调用的，必须配合new关键字。 当没有指定构造方法时，系统会自动添加无参的构造方法 当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法 一个类中可以有多个构造方法 构造方法在类内不能被普通方法调用，构造方法只能在构造方法之间被调用 通过this调用构造方法，必须放在方法体内第一行 继承 方法重载与方法重写的区别 方法重载 在同一个类中 方法名相同，参数列表不同（参数顺序、个数、类型） 方法返回值、访问修饰符任意 与方法的参数名无关 方法重写： 有继承关系的子类中 方法名相同，参数列表相同（参数顺序、个数、类型），方法返回值相同 访问修饰符，访问范围需要大于等于父类的访问范围 与方法的参数名无关 继承中的构造方法 父类的构造方法不允许被继承，不允许被重写 子类构造默认调用父类无参构造方法 调用父类构造方法的语句必须在子类构造方法的第一行 继承后初始化的顺序 父类静态成员 子类静态成员 父类对象构造 子类对象构造 继承中的关键字 private、public、protected 访问修饰符不影响成员加载顺序，跟书写位置有关 super关键字 访问父类成员方法 super.print(); 访问父类属性 super.name; 访问父类构造方法 super(); this 不能在静态方法中调用。 final 编写过程中final和public是可以互换的，只要都写在class前面就可以 final 关键字可以用于成员变量、本地变量、方法以及类 final 类中的成员属性：一旦初始化不能修改，如果定义的同时没有初始化，则初始化位置只能在构造函数、构造代码块。 不能够对 final 变量再次赋值 本地变量必须在声明时赋值 在匿名类中所有变量都必须是 final 变量 final 方法不能被重写 final 类不能被继承 接口中声明的所有变量本身是 final 的 final 和 abstract 这两个关键字是反相关的，final 类就不可能是 abstract 的 没有在声明时初始化 final 变量的称为空白 final 变量(blank final variable)，它们必须在构造器中初始化，或者调用 this() 初始化，不这么做的话，编译器会报错final变量(变量名)需要进行初始化 按照 Java 代码惯例，final 变量就是常量，而且通常常量名要大写 对于集合对象声明为 final 指的是引用不能被更改 final方法：该方法不允许被子类重写，允许正常被子类继承使用 final修饰的引用数据类型，不能修改它的引用，可以修改属性值。 final不可以修饰构造方法 final方法内的局部变量：只要在具体被使用之前进行赋值即可，一旦赋值不允许被修改 拓展：https://developer.aliyun.com/article/723832（没看懂） 多态 多态分两种： 编译时多态：设计时多态方法重载 运行时多态：程序运行时动态决定调用哪个方法 大多数是运行时多态 多态的必要条件： 满足继承关系 父类引用指向子类对象 instanceof 判断左边对象是否为右边类 的实例 返回true/false cat0 instanceof Cat java中只支持单继承，即一个子类只有一个父类 父类中的成员变量和接口中的常量重名时，子类无法自动解析 父类中的函数与接口中的函数重名时，子类会使用父类的函数、 接口可以同时继承自两个父类 静态外部类对象可以不依赖于内部类，直接使用，静态方法之间才能够直接调用 封装 建议采用\"import 包名.类名的方式加载，提高效率\" 加载类的顺序跟import导入语句的位置无关，会先找能够直接解析到的那个类 比如com.immoc.下有mechanics.Cat和animal.Cat 语句： import com.imooc.mechanics.* import com.imooc.animal.Cats 会先加载com.imooc.animal.Cats static 为类对象共享，在类加载时产生，销毁时释放，生命周期长 可以有静态属性、静态方法，没有静态类，没有方法中的静态局部变量 在成员方法中可以直接访问静态成员 静态方法只能访问静态成员（属性、方法），只能通过对象实例化后，对象.成员方法的方式访问非静态成员 -static + 属性/方法/类/方法内局部变量/代码块 静态块和构造块 静态块：用static申明，JVM加载类时执行，仅执行一次 构造块：类中直接用{}定义，每一次创建对象时执行 例子 public class Study_static { //静态对象 public static char text = 'a'; //构造函数 public Study_static(){ System.out.println('c'); } //构造块 { System.out.println('b'); } //静态块 static{ System.out.println(text); } //执行入口 public static void main(String[] args){ Study_static a = new Study_static(); } } 不同代码块中可以使用同样命名的变量，采用就近原则。同一代码块结束后，数据被回收。 int temp=14; { int .temp=12; System.out.printlnC\"我是普通代码块1，temp=\"+temp);}//普通代码块 System. out.println(name +\"快跑,temp=\"+temp; { int temp=13; System.out.println(\"我是普通代码块2，temp=\"+temp);//普通代码块 } 代码块外的变量作用域是整个类/方法体 定义包：package 包名; 必须放在Java源文件的第一行 一个Java源文件中只能有一个package语句 包名全部英文小写 命名方法：域名倒序+模块+功能 注解 注解，按照运行机制分： 源码注解：注解只在源码中存在，编译成.class文件就不存在了 编译时注解：注解在源码和.class文件中都存在 运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解 按照来源分： 来自JDK的注解 来自第三方的注解 我们自己定义的注解 还有： 元注解 常用类 Object类 Object类是所有类的父类 方法和方法的作用 Java面试中经常会被问到Object类的具有哪些方法以及每个方法的作用。这个题目很好的考察了面试者的Java基础，使得面试者都能有话说，但是想回答完全却还是很难的。 Object类中的方法如下图所示。 上图中的这些方法中除了registerNatives方法用于注册本地方法，不常考之外，其他都有可能详细考察，下面针对这些方法一一讲解。 getClass方法 可以返回这个实体的Class对象，可以用来获得这个类的元数据。在反射中经常使用。 clone方法 被用来拷贝一个新对象。在Java中使用等号只是拷贝对象的引用并不是对象，需要拷贝对象的时候，可以借助clone方法。 要通过clone方法复制某一个对象，在该类中必须实现java.lang.Cloneable接口。 下面的代码将演示浅拷贝。 public class Province { private String name; Province(String name){ this.name = name; } public String getName(){ return name; } public void setName(String name){ this.name = name; } } public class Student implements Cloneable { private String name; private int age; private Province province; public Student(int age, String name, Province province){ this.age = age; this.name = name; this.province = province; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override protected Object clone(){ try { return super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return null; } public static void main(String[] args) { Province teacher = new Province(\"Shannxi\"); Student student1 = new Student(23, \"mianjingxiangjie\", teacher); Student student2 = (Student) student1.clone(); student1.province.setName(\"Beijing\"); System.out.println(student1.province.getName()); System.out.println(student2.province.getName()); } } 上面的代码输出如下： BeijingBeijing 可见当实现Cloneable 接口的对象有其他对象的成员变量时，clone方法并不会复制一个新的成员变量。上面的student1和student2使用的是同一个province对象，当更改了student1的province名称，student2的province也相应的改变了。这就是浅拷贝。 那么怎么实现深拷贝呢？ 以上面的例子为例只需要改变clone方法如下： @Override protected Object clone(){ try { Student temp = (Student) super.clone(); temp.province equals与hashcode()的区别 obj1.equals(obj2) 根据《effective java》第七条之规定：在改写equals的时候遵守通用约定 当符合以下条件时不需要重写equals方法： 一个类的每一个实例本质上都是唯一的 不关心一个类是否提供了“逻辑相等”的测试功能 超类已经改写了equals方法，并且从超类继承过来的行为对于子类也是合适的 一个类时私有的或者是package私有的，并且可以确定它的equals方法永远不会被调用。（这种情况下最好将equals方法改写成以下方式： public boolean equals(Object obj){ throws new UnsupportOperationException(); } 只有当一个类有自己特定的“逻辑相等”概念，而且超类也没有改写equals以实现期望的行为，我们需要改写equals方法。通常适用于“值类”。 在改写equals方法时，也要遵守他们的通用约定（equals方法实现了等价关系）： 自反性：x.equals(x) = true; 对称性：如果有x.equals(y) = true,那么一定有y.equals(x) = true; 传递性：对任意的x,y,z。如果有x.equals(y) = y.equals(z) = true,那么一定有x.equals(z)= true; 一致性：无论多少次调用，x.equals(y)总会返回相同的结果。 非空性（暂定）：所有的对象都必须！=null; 上面的只是理论性的说法，更加具体的做法如下： 使用==操作符检查“实参是否为指向对象的一个引用”，如果是则返回true； 使用instanceof操作符检查“实参是否为正确的类型”，如果不是，则返回false; 将实参装换为正确的类型； 对于该类中的每一个关键域，检查实参中的域与当前对象中对应的域是否匹配。如果所有测试都成功，则返回true，否则返回false。 方法完成之后，确定equals方法的对称性，传递性，一致性。 一些忠告： 改写equals方法的时候，必须改写hashCode方法； 不要把equals声明中的Object对象替换为其他类型； 改写的形式必须为: public boolean equals（Object obj）{...code segment...} 根据《effective java》第八条：改写equals时总要改写hashCode hashCode的通用约定如下： 只要对象equals方法涉及到的关键域内容不改变，那么这个对象的hashCode总是返回相同的整数。（如果关键域内容改变，则hashCode返回的整数就可以改变）。 如果两个对象的equals(Object obj)方法时相等的，那么调用这两个对象中的任意一个对象的hashCode方法必须产生相同的整数结果。如果两个对象equals方法不同，那么必定返回不同的hashCode整数结果。（简而言之：相等的对象必须有相等的散列码即hashCode）； 一个好的hashCode方法趋向于“为不相等的对象产生不相等的散列码”理想情况下的散列函数应该把一个集合中不相等的实例均匀分布到所有可能的散列值上。下面给出一种参考方法： 把某个非零常数值保存在一个叫做result的int类型的变量中 为该对象中的每一个关键域f计算int类型的散列码。 ​ a) 为该域计算int类型的散列码c： ​ i.如果域是Boolean类型，计算：(f?0:1) ​ ii.如果是byte,char,short,int类型，计算：(int)f ​ iii.如果是long类型，计算：(int)(f^(f>>32)) ​ iv.如果是float类型，计算：Float.floatToIntBits(f) ​ v.如果是double类型，计算Double.doubleToLongBits(f)得到long类型的值，在按照long值对待，继续进一步计算 ​ vi.如果是对象引用，递归调用hashCode方法计算，如果遇到为null的关键域，则返回0 ​ vii.如果是数组，将每一个元素都当做单独的域来计算，递归应用上述规则 ​ b) 按照下面公式，将a得到的散列码c组合到result中 ​ result = 37*result + c; 返回result 写完之后，检查hashCode方法是否相等的实例具有相等的散列码，并找出错误原因。 包装类 包装类对象的初始值为null 字符串 String 特点： 不可变性：String对象是不可变的，一旦创建，其值就不能改变。如果需要对字符串进行修改，实际上会创建一个新的String对象。 线程安全：由于不可变性，String是线程安全的，可以在多个线程中安全使用而无需同步。 String的常用方法 StringBuffer 特点： 可变性：StringBuffer对象是可变的，可以对其内容进行修改而不创建新的对象。 线程安全：StringBuffer是同步的，所有方法都被synchronized修饰，所以它是线程安全的，但同步导致性能开销较大。 StringBuilder 特点： 可变性：StringBuilder与StringBuffer类似，都是可变的。 非线程安全：StringBuilder不是同步的，所以在单线程环境下性能比StringBuffer高。 性能优越：因为没有同步开销，StringBuilder在单线程操作字符串时比StringBuffer更快。 StringBuffer和StringBuilder的常用方法 append()：添加字符串到末尾 insert()：在指定位置插入字符串 replace()：替换指定范围内的字符串 delete()：删除指定范围内的字符 deleteCharAt()：删除指定位置的字符 reverse()：反转字符串 setCharAt()：修改指定位置的字符 substring()：获取子字符串 toString()：转换为 String 集合 集合长度是动态改变的 集合的应用场景： 无法预测存储数据的数量 同时存储具有一对一关系的数据 需要进行数据的增删 数据重复问题 List List是元素有序并且可以重复的集合，称为序列 List可以精确的控制每个元素的插入位置，或删除某个位置的元素 List的两个主要实现类是ArrayList和LinkedList ArrayList ArrayList底层是由数组实现的 动态增长，以满足应用程序的需求 在列表尾部插入或删除数据非常有效 更适合查找和更新元素 ArrayList中的元素可以为null List&ArrayList的区别https://www.geeksforgeeks.org/difference-between-list-and-arraylist-in-java/ List ArrayList List is an interface ArrayList is a class List interface extends the Collection framework ArrayList extends AbstractList class and implements List interface List cannot be instantiated. ArrayList can be instantiated. List interface is used to create a list of elements(objects) that are associated with their index numbers. ArrayList class is used to create a dynamic array that contains objects. List interface creates a collection of elements that are stored in a sequence and they are identified and accessed using the index. ArrayList creates an array of objects where the array can grow dynamically. set 元素无序且不可重复的集合 HashSet 一种set 只允许一个null元素 具有良好的存取和查找性能 Map Map中的数据是以键值对（key-value）的形式存储的 key-value以Entry类型的对象实例存在 可以通过key值快速地查找value 一个映射不能包含重复的键 HashMap 允许使用null值和null键，null键只能有一个 key值不允许重复 Entry对象是无序排列的 迭代器Iterator 比较器Comparator 文件读写 相对目录：..返回到上一级目录，默认在工程目录下 时间戳转换为时间 https://www.runoob.com/java/date-timestamp2date.html No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/JNI.html":{"url":"03_语言/Java/JNI.html","title":"Jni","keywords":"","body":"Java 调用 C++ 函数 要从Java调用C++函数，你需要进行以下操作: 在Java类中创建一个native方法，此方法被本类其他方法调用 private native void functionName(parameters) 创建一个头文件，可以利用javah命令生成 在头文件中定义它的签名，如下所示： extern \"C\" { JNIEXPORT void JNICALL Java_package_MyClass_functionName(JNIEnv *, jclass); } 接口规范： JNIEXPORT JNICALL Java___(JNIEnv*, ，..) extern \"C\" 只被C++编译器识别，标明此方法利用C的函数命名协议来编译。 JNIEXPORT 是JNI必要的修饰符。 数据类型带有\"j\"前缀的：jdouble,jobject..等是Java对象或类型在C++中的映射 JNIEnv* 指向JNI 环境，可以利用其调用所有JNI函数 jobject 引用当前Java对象 创建一个源文件，实现头文件中定义的接口。实现内容就是Java代码调用的C/C++代码 编译头文件和源文件生成C/C++动态链接库 .so/.dll 文件 此native方法所在类，加载动态链接库。因为加载链接库要在执行native方法之前，所以此加载过程一般放在静态初始化块内执行 static { System.loadLibrary(\"libraryName\");//库名即可（从java.library.path对应路径下搜索对应名称的库文件并加载） } 或 static { System.load(\"libraryFile\");//绝对地址 包含路径、库名、后缀 } 总结一下，从Java代码中调用C/C++代码的流程： （1）创建一个有native标识的方法，并且从其他Java方法调用它 （2）Java编译器生成字节码 （3）C/C++ 编译器生成动态库 .so文件（Linux）或 .dll文件（Windows） （4）运行程序，执行字节码 （5）执行到loadLibary或load调用的时候，添加一个 .so文件到这个进程中 （6）执行到native方法的时候，通过方法签名，在已打开的.so文件中进行搜索。 （7）如果链接库内有对应方法，就会被执行，否则程序崩溃 C代码访问Java对象的实例变量 获取对象的实例变量的步骤： 通过GetObjectClass()方法获得此对象的类引用 通过类引用的GetFieldID()方法获得实例变量的Field ID. 需要提供变量名，字段类型描述符 对于Java 类， 字段描述符格式为 \"L;\" 类全称中，点\".\"用 \"/\"代替。例如，String 的描述符为\"Ljava/lang/String;\" 注意：这里不要漏了分号\";\" 对于基本类型，则有固定标识。注：这里不需要分号。int => \"I\" ，byte => \"B\"，short => \"S\"，long => \"J\"，float => \"F\"，double => \"D\"，char => \"C\"，boolean => \"Z\" 对于数组，则结合以上类型描述符，加上前缀\"[\"， 　　　　　　如Object数组，用\"[L/java/lang/Object;\"表示 　　　　　　int数组，用\"[I\"表示 基于FieldID，通过GetObjectField()方法或GetField()方法获取实例变量 如果需要更新实例变量，可以使用SetObjectField()或SetField()函数进行 jni.h //returns the class of an object jclass GetObjectClass(JNIEnv *env, jobject obj); //returns the field ID for an instance variable of a class jfieldID GetFieldID(JNIEnv *env, jclass cls, const char *name, const char *sig); //Get/Set the value of an instance variable of an object // includes each of the eight primitive types plus Object. NativeType GetField(JNIEnv *env, jobject obj, jfieldID fieldID); void SetField(JNIEnv *env, jobject obj, jfieldID fieldID, NativeType value); Java调用C语言代码回调Java方法 要想调用实例对象的方法，需要进行以下步骤： 通过对象实例，获取到对象类的引用 => GetObjectClass() 通过类引用，获取到方法ID => GetMethodID() 需要提供方法名，和方法签名。也就是需要这两个信息来标识确定一个方法 方法签名格式：（参数列表）返回值类型 你可以通过javap命令工具，查看方法的签名 private TestCallbackMethods(); descriptor:()V private native void nativeMethod(); descriptor:()V private void callback(); descriptor:()V private void callback(java.lang.String); descriptor:(Ljava/lang/String;)V private static java.lang.String callbackStatic(); descriptor:()Ljava/lang/String public static void main(java.lang.String[]); descriptor:([Ljava/lang/String;)V static{}; descriptor:()V 基于方法ID，你可以根据返回值类型，调用CallMethod()或者CallVoidMethod()或CallObjectMethod()，来调用对应的方法。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/JVM机制.html":{"url":"03_语言/Java/JVM机制.html","title":"Jvm机制","keywords":"","body":"JVM的生命周期 JVM在Java程序开始运行的时候，它才运行，程序结束的时它就停止。 一个Java程序会开启一个JVM进程，如果一台机器上运行3个Java程序，那么就会有3个运行中的JVM进程。 JVM中的线程分为两种：守护线程和普通线程 守护线程是JVM自己使用的线程，比如垃圾回收（GC）就是一个守护线程。 普通线程一般是Java程序的线程，只要JVM中有普通线程在执行，那么JVM就不会停止。 结束生命周期 在如下几种情况下，Java虚拟机将结束生命周期 1、执行了System.exit()方法 2、程序正常执行结束 3、程序在执行过程中遇到了异常或错误而终止进程 4、由于操作系统出现错误而导致Java虚拟机进程终止 JDK和JRE的区别 JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境，JDK中包含了JRE。 JRE是Java的运行环境，是面向所有Java程序的使用者，包括开发者。 JVM是包含在JRE里面的。 JVM的结构体系 Class文件 Class文件由Java编译器生成，我们创建的.Java文件在经过编译器后，会变成.Class的文件，这样才能被JVM所识别并运行。 Class文件的核心设计思想是 平台无关性，它存储的不是操作系统可以直接识别的二进制本地机器码，而是根据Java虚拟机规范所自定义的指令集、符号表和一些其他信息，所以只要任何一个操作系统下开发有对应的Java虚拟机，开发者的Java程序就能跑起来。 类加载子系统（类加载器） 类加载子系统也可以称之为类加载器，JVM默认提供三个类加载器： 1、Bootstrap ClassLoader ：称之为启动类加载器，是最顶层的类加载器，负责加载JDK中的核心类库，如 rt.jar、resources.jar、charsets.jar等。 2、Extension ClassLoader：称之为扩展类加载器，负责加载Java的扩展类库，默认加载$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。 3、App ClassLoader：称之为系统类加载器，负责加载应用程序classpath目录下所有jar和class文件。 除了Java默认提供的三个加载器之外，我们还可以根据自身需求自定义ClassLoader，自定义的类加载器必须继承自 java.lang.ClassLoader 类。 除了 BootStrap ClassLoader 之外的两个默认加载器都是继承自 java.lang.ClassLoader ，BootStrap ClassLoader 不是一个普通的Java类，它底层由C++编写，已嵌入到了JVM的内核当中，当JVM启动后，BootStrap ClassLoader 也随之启动，负责加载完核心类库，并构造Extension ClassLoader 和App ClassLoader 类加载器。 类加载器子系统不仅仅负责定位并加载类文件，它还严格按照以下步骤做了很多事情： 1、加载：寻找并导入Class文件的二进制信息 2、连接：进行验证、准备和解析 1）验证：确保导入类型的正确性 2）准备：为类型分配内存并初始化为默认值 3）解析：将字符引用解析为直接引用 3、初始化：调用Java代码，初始化类变量为指定初始值 详细请参考另一篇文章：Java类加载机制 - 知乎专栏 方法区（Method Area） 方法区用于存储JVM加载完成的类型信息、常量、静态变量、即时编译器编译后的代码缓存，方法区和 Java 堆区一样，都是线程共享的内存区域。 在JDK8以前，使用永久代的方式来实现方法区，JDK8以后，永久代的概念被废弃了，方法区改用和 JRockit、J9一样的在本地内存中实现的元空间（Meta Space）来代替，好处是元空间会在运行时根据需要动态调整，只要没有超过当前进程可用的内存上限（32位和64位系统各不相同），就不会出现溢出的问题。 方法区也可以被垃圾回收，但条件非常严苛，必须在该类没有任何引用的情况下，详情可以参考另一篇文章：Java性能优化之JVM GC（垃圾回收机制） - 知乎专栏 当需要扩展时空间不足，会分别 OutOfMemoryError 异常。 类型信息包括什么？ 1、类型的全名（The fully qualified name of the type） 2、类型的父类型全名（除非没有父类型，或者父类型是java.lang.Object）（The fully qualified name of the typeís direct superclass） 3、该类型是一个类还是接口（class or an interface）（Whether or not the type is a class ） 4、类型的修饰符（public，private，protected，static，final，volatile，transient等）（The typeís modifiers） 5、所有父接口全名的列表（An ordered list of the fully qualified names of any direct superinterfaces） 6、类型的字段信息（Field information） 7、类型的方法信息（Method information） 8、所有静态类变量（非常量）信息（All class (static) variables declared in the type, except constants） 9、一个指向类加载器的引用（A reference to class ClassLoader） 10、一个指向Class类的引用（A reference to class Class） 11、常量池（The constant pool for the type） Java堆（JVM堆、Java heap） 堆区负责存放对象实例，当Java创建一个类的实例对象或者数组时，都会在堆中为新的对象分配内存。 虚拟机中只有一个堆，程序中所有的线程都共享它。 通常情况下，堆占用的内存空间是最多的。 堆的存取方式为管道类型，先进先出。 在程序运行中，可以动态的分配堆的内存大小。 堆的内存资源回收是交给JVM GC进行管理的，详情请参考：Java性能优化之JVM GC（垃圾回收机制） - 知乎专栏 当需要扩展时空间不足，会分别 OutOfMemoryError 异常。 虚拟机栈（JVM栈、VM Stack） 在Java栈中只保存基础数据类型（参考：Java 基本数据类型 - 四类八种 - 知乎专栏）和对象的引用，注意只是对象的引用而不是对象本身哦，对象是保存在堆区中的。 拓展知识：像String、Integer、Byte、Short、Long、Boolean等等包装类型，它们是存放于堆中的。 栈的存取类型为类似于水杯，先进后出。 栈内创建的基本类型数据在超出其作用域后，会被自动释放掉，它不由JVM GC管理。而在栈内创建的引用类型实例，则还是由JVM GC管理。 当一个线程创建运行的时候，与之对应的栈就创建了，每个栈中的数据都是私有的，其他线程不能访问。 每个线程都会建立一个栈，每个栈又包含了若干个栈帧，每个栈帧对应着每个方法的每次调用，栈帧包含了三个部分： 局部变量区（方法内基本类型变量、对象实例的引用） 操作数栈区（存放方法执行过程中产生的中间结果） 运行环境区（动态连接、正确的方法返回相关信息、异常捕捉） 虚拟机栈在深度溢出或扩展失败的时候，会分别抛出StackOverflowError 和 OutOfMemoryError 异常。 本地方法栈（Native Method Stack） 本地方法栈的功能和JVM栈非常类似，区别在于虚拟机栈执行的是Java方法，本地方法栈执行的是本地（Native）方法服务，存储的也是本地方法的局部变量表，本地方法的操作数栈等信息。 栈的存取类型为类似于水杯，先进后出。 栈内的数据在超出其作用域后，会被自动释放掉，它不由JVM GC管理。 每一个线程都包含一个栈区，每个栈中的数据都是私有的，其他栈不能访问。 本地方法栈是在 程序调用 或 JVM调用 本地方法接口（Native）时候启用。 本地方法都不是使用Java语言编写的，它们可能由C或其他语言编写，本地方法也不由JVM去运行，所以本地方法的运行不受JVM管理。 HotSpot VM将本地方法栈和JVM栈合并了。 本地方法栈也会在深度溢出或扩展失败的时候，分别抛出StackOverflowError 和 OutOfMemoryError 异常。 程序计数器 在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以每条线程都会有一个独立的程序计数器。 程序计数器仅占很小的一块内存空间。 当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址。如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。 程序计数器不会抛出 OutOfMemoryError（内存不足错误）。 JVM执行引擎 Java虚拟机相当于一台虚拟的“物理机”，这两种机器都有代码执行能力，区别主要是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而JVM的执行引擎是自己实现的，因此程序员可以自行制定指令集和执行引擎的结构体系。 执行引擎的主要职责，就是把这些自行制定的指令集翻译成硬件所支持的指令集格式，然后执行。 在JVM规范中制定了虚拟机字节码执行引擎的概念模型，这个模型称之为JVM执行引擎的统一外观，各个Java 虚拟机的发行厂商都需要按照这个规范来实现。 在不同的虚拟机实现中，可能会有两种的执行方式：解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码）。虚拟机可以按自身的需求，采用一种或同时采用多种组合的方式来实现执行引擎。但无论内部怎么实现，都要遵循输入的是字节码文件、处理过程是等效字节码解析过程、输出的是执行结果这个JVM规范要求。 本地方法接口（JNI） JNI是Java Native interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C和C++）。 JNI的适用场景 当我们有一些旧的库，已经使用C语言编写好了，如果要移植到Java上来，非常浪费时间，而JNI可以支持Java程序与C语言编写的库进行交互，这样就不必要进行移植了。或者是与硬件、操作系统进行交互、提高程序的性能等，都可以使用JNI。需要注意的一点是需要保证本地代码能工作在任何Java虚拟机环境。 JNI的副作用 一旦使用JNI，Java程序将丢失了Java平台的两个优点： 1、程序不再跨平台，要想跨平台，必须在不同的系统环境下程序编译配置本地语言部分。 2、程序不再是绝对安全的，本地代码的使用不当可能会导致整个程序崩溃。一个通用规则是，调用本地方法应该集中在少数的几个类当中，这样就降低了Java和其他语言之间的耦合。 JVM GC（垃圾回收机制） 详情请参考我的另外一篇文章：Java性能优化之JVM GC（垃圾回收机制） - 知乎专栏 常量池 要理解常量池，首先要知道，常量池是分3种类型的 1、Class文件内容里的常量池 2、运行时常量池（Runtime Constant Pool） 3、各个包装类型里实现的常量池，例如String类里面的字符串常量池（String Pool） Class 常量池 Java代码在经过编译器后，会生成一个Class文件，这个常量池就是Class文件里的一大段内容（通常是最大的一段内容），它主要存放着 字面量、符号引用 等信息，在JVM把Class文件加载完成后，Class 常量池里的数据会存放到运行时常量池中。 运行时常量池（Runtime Constant Pool） 运行时常量池是方法区（Method Area）的一部分，运行时常量池中存储的，是基本类型的数据和对象的引用，注意是对象的引用而不是对象实例本身哦。 Java虚拟机在加载Class文件时，Class文件内容里常量池的数据会放入运行时常量池。每一个加载好的Class对象里都会有一个运行时常量池。 字符串常量池（String Constant Pool） & 其他包装类型里实现的常量池 字符串由一个char[]构成，当我们的Java程序里频繁出现相同字面量的代码时，重复的创建和销毁对象是一件很浪费资源的事情，所以Java实现了一个字符串常量池。 JDK7之后，字符串常量池从方法区迁移到了堆区，它的底层实现可以理解为是一个HashTable。Java虚拟机中只会存在一份字符串常量池。字符串常量池里，存放的数据可以是引用也可以是对象实例本身。 字符串常量池 也具备 运行时常量池 动态性的特征，它支持运行期间将新的常量放入池中，这种特性被开发人员利用比较多的就是 String.intern() 方法。 基本类型的包装类和常量池 Byte、Short、Integer、Long、Character、Boolean、String 这 7 种包装类都各自实现了自己的常量池。 Float 和Double 这两个浮点类型没有实现常量池。 //例子： Integer i1 = 20; Integer i2 = 20; System.out.println(i1==i2);//输出TRUE Byte、Short、Integer、Long、Character这5种包装类都默认创建了数值[-128 , 127]的缓存数据。当这5个类型的数据不在这个区间内的时候，将会去创建新的对象，并且不会将这些新的对象放入常量池中。 //IntegerCache.low = -128 //IntegerCache.high = 127 public static Integer valueOf(int i) { if (i >= IntegerCache.low && i 字符串常量池（String pool）的实例 String str1 = \"aaa\"; 当以上代码运行时，JVM会到字符串常量池查找 \"aaa\" 这个字面量对象是否存在： 存在：则返回该对象的引用给变量 str1 。 不存在：则创建一个对象，同时将引用返回给变量 str1 。（JDK8之后，对象实例直接存储在字符串常量池里） String str1 = \"aaa\"; String str2 = \"aaa\"; System.out.println(str1 == str2);//返回TRUE 因为变量str1 和str2 都指向同一个对象，所以返回true。 String str3 = new String(\"aaa\"); System.out.println(str1 == str3);//返回FALSE 当我们使用了new来构造字符串对象的时候，不管字符串常量池中是否有相同内容的对象的引用，新的字符串对象都会创建。因为两个指向的是不同的对象，所以返回FALSE 。 String.intern()方法 对于使用了new 创建的字符串对象，如果想要将这个对象添加到字符串常量池，可以使用intern() 方法。 String str1 = \"aaa\"; String str2 = \"aaa\"; String str3 = new String(\"aaa\"); String interns = str3.intern(); System.out.println(interns == str1);//返回TRUE intern() 方法会检查字符串常量池中是否有与之匹配的对象，并做如下操作： 存在：直接返回对象引用给interns变量。 不存在：将这个对象引用加入到常量池，再返回对象引用给interns变量。 以下创建了多少个对象呢？ String str4 = \"abc\"+\"efg\"; String str5 = \"abcefg\"; System.out.println(str4 == str5);//返回TRUE 答案是三个。第一个：\"abc\" ，第一个：\"efg\"，第三个：\"abc\"+\"efg\"（\"abcefg\"） String str5 = \"abcefg\"; 这句代码并没有创建对象，它从常量池中找到了\"abcefg\" 的引用，所以str4 == str5 返回TRUE，因为它们都指向一个相同的对象。 什么情况下会将字符串对象引用自动加入字符串常量池？ //只有在这两种情况下会将对象引用自动加入到常量池： String str1 = \"aaa\"; String str2 = \"aa\"+\"a\"; //以下都不会将对象引用自动加入到常量池： String str3 = new String(\"aaa\"); String str4 = New StringBuilder(\"aa\").append(\"a\").toString(); StringBuilder sb = New StringBuilder(); sb.append(\"aa\"); sb.append(\"a\"); String str5 = sb.toString(); 双等号（==）的含义 基本数据类型之间使用双等号，比较的是值。 引用类型（Class类）之间使用双等号，比较的是对象的引用地址是否相等。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/lambda.html":{"url":"03_语言/Java/lambda.html","title":"Lambda","keywords":"","body":"lambda表达式通常用于实现函数式接口（接口中只有一个抽象方法的接口） Lambda 表达式的基本语法 (parameters) -> expression 或者 (parameters) -> { statements; } 使用场景和示例 使用lambda表达式实现函数式接口 首先，定义一个函数式接口（只有一个抽象方法的接口）。 @FunctionalInterface interface MyFunctionalInterface { void doSomething(); } 然后，使用lambda表达式来实现这个接口： public class LambdaExample { public static void main(String[] args) { MyFunctionalInterface func = () -> System.out.println(\"Doing something!\"); func.doSomething(); } } 使用lambda表达式实现有参数的函数式接口 例如，定义一个有参数和返回值的函数式接口： @FunctionalInterface interface MyFunctionalInterface { int add(int a, int b); } 使用lambda表达式来实现这个接口： public class LambdaExample { public static void main(String[] args) { MyFunctionalInterface adder = (a, b) -> a + b; int result = adder.add(5, 3); System.out.println(\"Result: \" + result); } } 在集合操作中使用lambda表达式 lambda表达式在Java的集合框架中非常有用，例如在List中使用forEach方法： import java.util.Arrays; import java.util.List; public class LambdaExample { public static void main(String[] args) { List names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // 使用lambda表达式打印列表中的每个元素 names.forEach(name -> System.out.println(name)); } } 使用lambda表达式进行过滤和映射 lambda表达式与Stream API结合使用，可以更高效地进行集合操作： import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class LambdaExample { public static void main(String[] args) { List names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"David\"); // 使用lambda表达式进行过滤 List filteredNames = names.stream() .filter(name -> name.startsWith(\"A\")) .collect(Collectors.toList()); System.out.println(filteredNames); // 使用lambda表达式进行映射 List nameLengths = names.stream() .map(name -> name.length()) .collect(Collectors.toList()); System.out.println(nameLengths); } } 变量作用域 Lambda表达式中访问局部变量： Lambda表达式可以访问外部方法中的局部变量，但是这些变量必须是隐式最终（effectively final）的。隐式最终意味着变量实际上不可更改，即一旦赋值后就不应该再修改。Java编译器会强制要求这些变量是隐式最终的，否则会编译错误。 int x = 10; Runnable r = () -> { // 可以访问外部变量x System.out.println(x); }; Lambda表达式中访问类成员变量： Lambda表达式可以直接访问和修改其所在类的成员变量和静态变量，没有限制。 public class LambdaScopeTest { private int x = 10; public void test() { Runnable r = () -> { // 可以访问类的成员变量x System.out.println(x); }; r.run(); } } Lambda表达式中的参数： Lambda表达式中可以使用传递给它的参数，它们的作用域只限于Lambda表达式的主体内部。 interface MyInterface { void myMethod(int x); } public class LambdaScopeTest { public void test() { MyInterface obj = (x) -> { // 可以访问参数x System.out.println(\"Value of x is: \" + x); }; obj.myMethod(5); } } 总结来说，Lambda表达式可以捕获外部方法的局部变量和类的成员变量（包括静态变量），但捕获的局部变量必须是隐式最终的。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/note.html":{"url":"03_语言/Java/note.html","title":"Note","keywords":"","body":"/ 是正斜杠 \\ 是反斜杠 Java中用于注释 Java中用于转义序列 final变量： final 用于声明一个不可变的变量，这意味着一旦该变量被初始化赋值后，就不能再被修改。 final 变量通常在运行时分配内存，并且每个对象都有自己的拷贝，因此它们对于每个对象都可以有不同的值。 通常情况下，final 变量会在声明时或构造函数中初始化。 static final变量： static final 用于声明一个静态常量，这意味着它是类级别的，只有一个副本存在于内存中，不与对象关联。 static final 常量通常用于表示不会改变的全局值，例如数学常数、配置信息或其他全局常量。 static final 常量在类加载时初始化，可以通过类名直接访问，而不需要创建类的实例。 常量.equals(变量) TextUtils.isEmpty(String变量) No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/内存管理+GC.html":{"url":"03_语言/Java/内存管理+GC.html","title":"内存管理+gc","keywords":"","body":"JVM 内存模型 JVM 内存大致分为 线程私有区域 和 线程共享区域，并且其主要由5个区域组成，见下图： 堆和栈 堆（Heap）： 位置： 堆位于Java虚拟机（JVM）管理的内存中。在物理内存中，堆的位置可以是任意的，不受程序控制，而是由操作系统及其内存管理器决定。 用途： 堆用于存储所有的Java对象实例，无论是哪个类的实例都存放在堆中。堆被所有线程共享，因此它是线程安全的。 特点： 堆的大小可以通过启动JVM时的参数来调整，例如-Xms和-Xmx用于设置堆的初始大小和最大大小。堆的内存空间动态分配和释放，用于支持Java程序的动态内存分配。 栈（Stack）： 位置： 栈位于线程私有的内存区域中，每个线程都有自己的栈。每个方法在执行时，会创建一个栈帧，用于存储局部变量、操作数栈、方法出口等信息。 用途： 栈用于存储基本数据类型的局部变量（如int、boolean等）和对象的引用变量（不包括对象本身，对象本身存储在堆中）。 特点： 栈是一个后进先出（LIFO）的数据结构，每个方法调用都会创建一个新的栈帧，方法执行完成后，对应的栈帧会被销毁，释放栈空间。因此，栈的空间管理由JVM自动管理，不需要手动调整栈大小。 主内存和工作内存 主内存与工作内存 主内存（Main Memory）： Java线程之间共享的内存区域，包含所有的实例变量、静态变量和数组元素。 方法区和堆内存 GC：因为这两个区域主要存放对象、数组等不具有确定性的数据，因此需要一套合理的内存管理机制来对这两个区域进行维护（GC）。 工作内存（Working Memory）： 每个线程私有的内存区域，包含该线程独占的本地变量副本以及缓存了主内存的变量副本。 虚拟机栈、本地方法栈和程序计数器，这三个区域是线程私有的。比如栈帧的生命周期是和线程关联的，即随线程而生，随线程而死。虚拟机栈其实就是用来描述 Java 方法执行的，所以每个方法执行的时候都会创建一个栈帧，每个栈帧都包含：局部变量、操作数栈、动态链接、方法出口，当方法执行完成之后，对应的栈帧便会出栈。 GC：几个线程私有区域的内存分配是具备确定性的，因此并不需要太过关注内存管理问题。 内存间交互操作 读操作（Read）： 将主内存中的变量值复制到工作内存中，以便线程使用。 写操作（Write）： 将工作内存中的变量值刷新到主内存中，以便其他线程可见。 内存可见性 Java内存模型保证了在正确同步的情况下，一个线程对共享变量的修改对其他线程是可见的。通过使用synchronized关键字、volatile变量、final关键字以及显示的锁（如Lock接口的实现）来确保内存可见性。 GC机制 简介 垃圾回收的基本原理 Java 的垃圾回收主要依赖于以下两个基本概念： 引用计数：每个对象都有一个引用计数，当对象被引用时计数增加，当引用被移除时计数减少。如果计数为零，则对象可以被回收。然而，引用计数无法解决循环引用的问题。（只出现在了早期的 JVM 中，现在基本不再使用了） 可达性分析（Reachability Analysis）：通过一组称为“GC Roots”的对象作为起点，检查哪些对象是可达的。如果对象不可达，则认为它是垃圾，可以被回收。GC Roots 通常包括栈中的局部变量、静态变量和 JNI（Java Native Interface）引用。 Java 中的垃圾回收算法 Java 使用多种垃圾回收算法来实现内存管理，这些算法通常被组合在一起使用以提高效率： 标记-清除算法（Mark and Sweep）：首先标记所有可达的对象，然后清除所有未标记的对象。标记阶段通过遍历对象图来标记可达对象，清除阶段则回收未标记的对象。 复制算法（Copying）：将活动对象从一个内存区域复制到另一个内存区域，同时回收原内存区域的所有对象。这种方法避免了内存碎片，但需要额外的内存空间。 标记-整理算法（Mark-Compact）：标记所有可达对象，然后将它们移动到内存的一端，清理掉所有未标记的对象。这种方法避免了内存碎片，但可能会导致较长的停顿时间。 Java 垃圾回收器 Java 提供了多种垃圾回收器，不同的垃圾回收器适用于不同的应用场景： Serial GC：适用于单线程环境，使用单个线程进行垃圾回收，主要用于客户端应用程序。 Parallel GC（也称为吞吐量 GC）：使用多个线程进行垃圾回收，适用于多线程环境，主要用于提高吞吐量。 CMS（Concurrent Mark-Sweep） GC：以最小化停顿时间为目标，适用于需要低延迟的应用程序。 G1（Garbage First） GC：适用于大内存堆，目标是提供可预测的停顿时间，适合于各种场景。 ZGC 和 Shenandoah GC：是相对较新的垃圾回收器，专为大内存应用和低停顿时间设计。 GC的运行阶段 垃圾回收通常分为以下几个阶段： Young Generation Collection（新生代回收）：主要处理短生命周期的对象，包括 Eden 区和 Survivor 区。新生代回收通常是频繁且较快的。 Old Generation Collection（老年代回收）：处理生命周期较长的对象，回收过程相对较慢且复杂。 Permanent Generation（元空间回收）：处理 JVM 的类、方法和常量池等元数据。 GC 调优 调优垃圾回收器的性能可以通过以下几种方式： 调整堆内存大小和比例（例如 -Xms 和 -Xmx 参数）。 选择合适的垃圾回收器（通过 -XX:+UseG1GC、-XX:+UseParallelGC 等参数）。 调整垃圾回收器的细节参数（例如 -XX、-XX等）。 GC 日志 通过启用 GC 日志，可以监控和分析垃圾回收的行为和性能： 使用参数 -XX:+PrintGCDetails、-Xlog等来启用和配置 GC 日志。 标记垃圾的算法 根搜索算法详解（Tracing Collector） 根搜索算法的中心思想，就是从某一些指定的根对象（GC Roots）出发，一步步遍历找到和这个根对象具有引用关系的对象，然后再从这些对象开始继续寻找，从而形成一个个的引用链（其实就和图论的思想一致），然后不在这些引用链上面的对象便被标识为引用不可达对象，也就是我们说的“垃圾”，这些对象便需要回收掉。这种算法很好地解决了上面 引用计数算法 的循环引用的问题了。 算法的核心思想是很简单的，就是标记不可达对象，然后交由 GC 进行回收，但是有一个点是很重要的，那就是 何为根对象（GC Roots）？ 根对象，一般有如下几种： 虚拟机栈中引用的对象（栈帧中的本地变量表）；???????????????????? 方法区中常量引用的对象； 方法区中静态属性引用的对象； 本地方法栈中 JNI（Native 方法）引用的对象； 活跃线程。 但其实，上述算法只是一个算法的中心思想，实际执行过程是比这个复杂的，另外，GC 判断对象是否可达其实看的还是强引用。 1、进行根搜索的时候，是需要暂停所有线程的，即执行一次 STW（Stop The World），最主要的目的是防止上述的对象图在算法运行的过程中有变化从而影响算法的准确性。 2、线程暂停的时间长短，取决于对象的多少，和堆内存的大小无关。 3、 宣告一个对象的“死亡”其实不仅仅通过上述的算法计算，而是需要经历两次的标记，本文暂不进行赘述。 回收垃圾的算法 除了需要上文研究的标记“垃圾对象”的算法，我们也需要“清理垃圾”的 回收算法。 常用的回收算法一般有：标记-清除算法、标记-整理算法、复制算法，以及系统自动进行判定使用的 适应性算法。 标记 - 清除算法（Tracing Collector） 标记-清除 算法是最基础的收集算法，它是由 标记 和 清除 两个步骤组成的。 标记的过程其实就是上面的 根搜索算法 所标记的不可达对象，当所有的待回收的“垃圾对象”标记完成之后，便进行第二个步骤：统一清除。 该算法的优点是当存活对象比较多的时候，性能比较高，因为该算法只需要处理待回收的对象，而不需要处理存活的对象。 但是缺点也很明显，就是在执行完 标记-整理 之后，由于将“垃圾对象”回收掉了，所以原本连续使用的内存块便会变得不连续，这样会导致内存块上面会出现很多小单元的内存区域，这些小单元的内存区域只能够存放比较小的对象，而比较大的对象是无法直接存储的。 即原本空闲 1M 的内存区域，有可能会出现无法直接存放 0.9M 大小的对象。 标记 - 整理算法（Compacting Collector） 上述的 标记-清除 算法会产生内存区域使用的间断，所以为了将内存区域尽可能地连续使用， 标记-整理 算法应运而生。 标记-整理 算法也是由两步组成，标记 和 整理。 第一步的 标记 动作也是使用的 根搜索算法，但是在标记完成之后的动作却和 标记-清除算法 天壤之别，该算法并不会直接清除掉可回收对象 ，而是让所有的对象都向一端移动，然后将端边界以外的内存全部清理掉。 该算法所带来的最大的优势便是使得内存上面不会再有碎片问题，并且新对象的分配只需要通过简单的指针碰撞便可完成。 复制算法（Copying Collector） 无论是标记-清除算法还是垃圾-整理算法，都会涉及句柄的开销或是面对碎片化的内存回收，所以，复制算法 出现了。 复制算法将内存区域均分为了两块（记为S0和S1），而每次在创建对象的时候，只使用其中的一块区域（例如S0），当S0使用完之后，便将S0上面存活的对象全部复制到S1上面去，然后将S0全部清理掉。 复制算法的优势是：① 不会产生内存碎片；② 标记和复制可以同时进行；③ 复制时也只需要移动栈顶指针即可，按顺序分配内存，简单高效；④ 每次只需要回收一块内存区域即可，而不用回收整块内存区域，所以性能会相对高效一点。 但是缺点也是很明显的：可用的内存减小了一半，存在内存浪费的情况。 所以 复制算法 一般会用于对象存活时间比较短的区域，例如 年轻代，而存活时间比较长的 老年代 是不适合的，因为老年代存在大量存活时间长的对象，采用复制算法的时候会要求复制的对象较多，效率也就急剧下降，所以老年代一般会使用上文提到的 标记-整理算法。 适应性算法（Adaptive Collector） 适应性算法 其实不是一种单独的回收算法，他只是一种智能选择回收算法的机制，也就是该算法会根据堆内存具体的使用情况而自动选用更适合当前情况的回收算法。 分代回收 分代回收 并不是一种垃圾回收算法，它是上述各种垃圾回收算法的一个落地应用方案。 堆内存和方法区可以再根据对象的生命周期进行分为年轻代、老年代、持久代，见下图： 堆内存主要由年轻代和老年代组成，而方法区主要存储持久代的数据，详细的细节在下文讲回收算法的时候会细说。 注意：从 JDK 1.8 开始，永久代已经被移除了，取而代之的是元空间（Meta Space），它和服务器的内存相关联，本文暂不赘述。 因为上述各个算法都有各自的优势，我们在内存的使用过程中，有些对象存活时间长，有些对象存活时间短，有些对象甚至一直存活着，所以根据对象的存活周期，我们将内存区域分为三大块：年轻代、老年代 和 永久代，并且年轻代也继续细分为：Eden区、S0 和 S1。 1、各个内存区域的内存大小可以见上文中的内存模型图，当然，我们也可以给 JVM 传递参数来进行调整，这些内容本文也暂不赘述。 2、 Eden : S0 : S1 的默认比例为 8:1:1，为什么这么设计呢？其实 IBM 有专门的研究表明，年轻代中 98% 的对象都是朝生夕死的，所以只需要划分为一个较大的 Eden 区和两个较小的 Survivor 区即可，而且这样做的好处是只有 10% 的 Survivor 区会被浪费掉，这也是可以接受的。 下面简单介绍下各个内存区的 GC 过程： 对象首次创建进行内存分配的时候，首先会放置在 Eden 区，当 Eden 区放满了或者当该对象太大无法放进 Eden 区的时候，此时会对年轻代（Eden区 和 S0）进行一次 GC，将幸存下来的对象放置在 S1，然后清空掉 Eden区和 S0 区；（此时年轻代采用的是 复制算法） 在上面第一步中对年轻代进行垃圾回收的时候，同时会对幸存的对象进行标记，统计每个幸存对象经历的 GC 次数； 当 S1 区满了之后，或者年轻代的对象经历过指定次数的 GC 之后，这部分对象会被放置到老年代之中； 当老年代也满了之后，便会对老年代进行一次 GC；（老年代采用的是 标记-整理算法） 垃圾回收器 好了，上文介绍过了 “垃圾”的识别算法 和 “垃圾”的回收算法，那么这些算法的执行者是谁呢？就是下文介绍的 垃圾回收器（GC） 了。 垃圾回收器的类型 在 Java 语言中，垃圾回收器按照执行机制来进行划分，主要分为四种类型： 串行垃圾回收器（Serial Garbage Collector）； 并行垃圾回收器（Parallel Garbage Collector）； 并发标记扫描垃圾回收器（CMS Garbage Collector）； G1垃圾回收器（G1 Garbage Collector）。 上述四种垃圾回收器都是有各自的优缺点的，我们可以通过向 JVM 传递参数来指定其中一款垃圾回收器。 1、串行垃圾回收器（Serial Garbage Collector） 串行垃圾回收器会暂停所有的应用程序线程，并采用单独的的线程进行 GC。 适用于单 CPU、并且对应用程序的暂停时间要求不高的情况，所以不太适合当前的生产环境。 2、并行垃圾回收器（Parallel Garbage Collector） 并行垃圾回收器是 JVM 默认的垃圾回收器，相较于串行垃圾回收器而言性能稍有提升，它也是需要暂停所有的应用程序线程的，但是区别是它会使用多线程进行 GC。 所以并行垃圾回收器适用于多 CPU 的服务器、并且能接受短暂的应用暂停的程序。 3、并发标记扫描垃圾回收器（CMS Garbage Collector） CMS 回收器也是一种并行的垃圾回收器，它会采用多线程来进行扫描堆内存，标记需要清理的对象并将这些对象清理掉。 但是 CMS 它需要更多的 CPU 来保证程序的吞吐量，并且它保证了最短的回收停顿时间，所以，在服务器允许的情况下，为了达到更到的性能，我们应该使用 CMS 来代替默认的 并行垃圾回收器。 4、G1 垃圾回收器（G1 Garbage Collector） G1 垃圾回收器是在 JDK1.7 中才正式引入的一款垃圾回收器，“科技在进步，所以一般越是先进的技术一般会更好用并且会替代陈旧的技术”，好了，玩笑归玩笑，但是 G1 的引入，目的就是为了取代 CMS 的。 不要被上面 G1 的示意图误导， G1 并没有将内存进行物理划分，它只是将堆内存划分为一个个的 Region，但是也是属于分代垃圾回收器，G1 仍然会区分年轻代和老年代，并且年轻代仍然会有 Eden 区和 Survivor 区。 这么做的目的是保证 G1 回收器在有限的时间内可以获得尽可能高的回收效率。 HotSpot 虚拟机（HotSpot VM）提供的几种垃圾收集器 HotSpot VM 提供了 7 种垃圾收集器，分别为： Serial PraNew Parallel Scavenge Serial Old Parallel Old CMS G1 其中，1、2、3 种适合年轻代内存区的垃圾回收，4、5、6种适合老年代内存区的垃圾回收，并且它们之间是两两组合来进行使用的，详见下图： 垃圾回收的时机 垃圾回收分为两种，Full GC 和 Scavenge GC。 Full GC 发生在整个堆内存中，而 Scavenge GC 仅仅发生在年轻代的 Eden 区，所以我们应该尽可能地减少 Full GC 的次数，当然，对于 JVM 的调优，很多情况下也是在想办法对 Full GC 进行调优。 因为 GC 是可能会对应用程序造成影响的，所以触发 GC 也是有一定的条件的，例如： 当应用程序空闲时，GC 有可能会被调用，因为 GC 运行线程的优先级是相对较低的，所以当线程忙的时候，它是不会运行的，当然，内存不足的情况除外； 堆内存不足的时候，GC 会被调用。例如创建对象的时候，若此时内存不足，则会触发 GC 用来给这个对象分配合适的内存，当进行完一次 GC 之后内存还是不足，则会继续进行第二次 GC，若第二次 GC 之后内存还是不足，则一般会提示 “out of memory”异常； 小 Tip： System.gc() 方法会显示触发 Full GC，但是它只是对 JVM 的一个 GC 请求，至于何时触发，还是由 JVM 自行判断的。 GC 的调用开销是比较大的，所以我们需要有针对性地进行调优，一般有如下方案： 不要显式调用 System.gc()。此函数虽然是建议 JVM 进行 GC，但很多情况下它会触发 GC，从而增加 GC 的频率； 尽量减少临时对象的使用。在方法结束后，临时对象便成为了垃圾，所以减少临时变量的使用就相当于减少了垃圾的产生，从而减少了GC的次数； 对象不用时最好显式置为 Null。一般而言，为 Null 的对象都会被作为垃圾处理，所以将不用的对象显式地设为 Null 有利于 GC 收集器对垃圾的判定； 尽量使用 StringBuilder 来代替 String 的字符串累加。因为 String 的底层是 final 类型的数组，所以 String 的增加其实是建了一个新的 String，从而产生了过多的垃圾； 允许的情况下尽量使用基本类型（如 int）来替代 Integer 对象。因为基本类型变量比相应的对象占用的内存资源会少得多； 合理使用静态对象变量。因为静态变量属于全局变量，不会被 GC 回收； No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/反射机制.html":{"url":"03_语言/Java/反射机制.html","title":"反射机制","keywords":"","body":"Java反射机制是Java语言被视为准动态语言的关键性质。Java反射机制的核心就是允许在运行时通过Java Reflection APIs来取得已知名字的class类的相关信息，动态地生成此类，并调用其方法或修改其域（甚至是本身声明为private的域或方法）。 Class类 调用Object对象的getClass方法可以获得一个对象的类型，此函数返回的就是一个Class类 得到Class类对象的方法 Class object 诞生管道 示例 运用getClass()注：每个class 都有此函数 String str = \"abc\";Class c1 = str.getClass(); 运用Class.getSuperclass() Button b = new Button();Class c1 = b.getClass();Class c2 = c1.getSuperclass(); 运用static methodClass.forName()（最常被使用） Class c1 = Class.forName (\"java.lang.String\");Class c2 = Class.forName (\"java.awt.Button\");Class c3 = Class.forName (\"java.util.LinkedList$Entry\");Class c4 = Class.forName (\"I\");Class c5 = Class.forName (\"[I\"); 运用.class 语法 Class c1 = String.class;Class c2 = java.awt.Button.class;Class c3 = Main.InnerClass.class;Class c4 = int.class;Class c5 = int[].class; 运用primitive wrapper classes的TYPE 语法 Class c1 = Boolean.TYPE;Class c2 = Byte.TYPE;Class c3 = Character.TYPE;Class c4 = Short.TYPE;Class c5 = Integer.TYPE;Class c6 = Long.TYPE;Class c7 = Float.TYPE;Class c8 = Double.TYPE;Class c9 = Void.TYPE; 获得Class类对象的基本信息 Java class 内部模块 Java class 内部模块说明 相应之Reflection API，多半为Class methods。 返回值类型(return type) package class隶属哪个package getPackage() Package import class导入哪些classes 无直接对应之API。可间接获取。 modifier class（或methods, fields）的属性 int getModifiers()Modifier.toString(int)Modifier.isInterface(int) intStringbool class name or interface name class/interface 名称getName() String type parameters 参数化类型的名称 getTypeParameters() TypeVariable [] base class base class（只可能一个） getSuperClass() Class implemented interfaces 实现有哪些interfaces getInterfaces() Class[] inner classes 内部classes getDeclaredClasses() Class[] outer class 如果我们观察的class 本身是inner classes，那么相对它就会有个outer class。 getDeclaringClass() Class 类中最重要的三个信息 构造函数 > 成员函数 > 成员变量 之前提到的信息都是只读的，这三个信息可以在运行时被调用（构造函数和成员函数）或者被修改（成员变量）。 构造函数 获取构造函数的方法有以下几个： Constructor getConstructor(Class[] params) Constructor[] getConstructors() Constructor getDeclaredConstructor(Class[] params) Constructor[] getDeclaredConstructors() 当知道构造函数的参数时，可以利用getConstructor(Class[] params) 和getDeclaredConstructor(Class[] params)获得唯一确定的构造函数； 当不知道构造函数的参数时，可以利用getConstructors()和getDeclaredConstructors()获得所有的构造函数。 getConstructor(Class[] params) 和getConstructors()仅仅可以获取到public的构造函数； 而getDeclaredConstructor(Class[] params) 和getDeclaredConstructors()则能获取所有（包括public和非public）的构造函数。 成员函数 获取成员函数的方法有以下一些： Method getMethod(String name, Class[] params) Method[] getMethods() Method getDeclaredMethod(String name, Class[] params) Method[] getDeclaredMethods() 其中需要注意，String name参数，需要写入方法名。关于访问权限和确定性的问题，和构造函数基本一致。 成员变量 成员变量，我们经常叫做一个对象的域。从内存的角度来说，构造函数和成员函数都仅仅是Java对象的行为或过程，而成员变量则是真正构成对象本身的细胞和血肉。简单的说，就是成员变量占用的空间之和几乎就是对象占用的所有内存空间。 获取成员变量的方法与上面两种方法类似，具体如下： Field getField(String name) Field[] getFields() Field getDeclaredField(String name) Field[] getDeclaredFields() 其中，String name参数，需要写入变量名。关于访问权限和确定性的问题，与前面两例基本一致。 让动态真正动起来 动态语言是指在程序运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化。 Java不能算作动态语言，但是和C、C++等纯静态语言相比，java语言允许使用者在运行时加载、探知、使用编译期间完全位置的classes，所以说算是“准动态语言”。 反射机制如何让Java动起来？ 创生 获取构造函数的方法返回Constructor类 Constructor支持泛型，也就是它本身应该是Constructor。这个类有一个public成员函数，T newInstance(Object... args)，其中args为对应的参数。 行为 利用Object invoke(Object receiver, Object... args) 可以调用对象的成员函数。 object.method()这种调用方式是为了表明具体method()的调用对象。而invoke(Object receiver, Object... args)的第一个参数正是指明调用对象。在C++中，object.method()其实是有隐含参数的，那就是object对象的指针，method原型的第一个参数其实是this指针，于是原型为method(void* this) 如果某个方法是Java类的静态方法，那么Object receiver参数可以传入null，因为静态方法不从属于对象。 属性 java传输一个对象时可以利用Java对象序列化接口。记录对象的属性然后再远程恢复。 Field类有两个public方法，分别对应对象属性的读与写，它们是： Object get(Object object) void set(Object object, Object value) 关于反射的一些高级话题 Java反射中对数组做过单独的优化处理，具体可查看java.lang.reflect.Array类；还有关于泛型的支持，可查看java.lang.reflect.ParameterizedType及相关资料。 Android编译期问题 Android的安全权限问题我把它简单的划分成三个层次，最不严格的一层就是仅仅骗过编译器的“@hide”标记。对于一款开源的操作系统而言，并不具备安全上的限制，方便硬件厂商做闭源的二次开发。 软件的解耦合 配置文件 + ClassLoader + 反射机制结合形成的这种软件解耦和方式 反射安全 作为Java的安全模型，它包括了：字节码验证器、类加载器、安全管理器、访问控制器等一系列的组件。之前文中提到过，我把Android安全权限划分为三个等级：第一级是针对编译期的“@hide”标记；第二级是针对访问权限的private等修饰；第三级则是以安全管理器为托管的Permission机制。 Java反射确实可以访问private的方法和属性，这是绕过第二级安全机制的方法（之一）。它其实是Java本身为了某种目的而留下的类似于“后门”的东西，或者说是为了方便调试？不管如何，它的原理其实是关闭访问安全检查。 Field、Method和Constructor类，它们都有一个共同的父类AccessibleObject 。AccessibleObject 有一个公共方法：void setAccessible(boolean flag)。正是这个方法，让我们可以改变动态的打开或者关闭访问安全检查，从而访问到原本是private的方法或域。另外，访问安全检查是一件比较耗时的操作，关闭它反射的性能也会有较大提升。 不要认为我们绕过了前两级安全机制就沾沾自喜了，因为这两级安全并不是真正为了安全而设置的。它们的作用更多的是为了更好的完善规则。而第三级安全才是真正为了防止恶意攻击而出现的。在这一级的防护下，可能都无法完成反射（ReflectPermission），其他的一切自然无从说起。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/变量作用域.html":{"url":"03_语言/Java/变量作用域.html","title":"变量作用域","keywords":"","body":"四种作用域 在Java中，变量的作用域分为四个级别：类级、对象实例级、方法级、块级。 类级变量又称全局级变量或静态变量，需要使用static关键字修饰，你可以与 C/C++ 中的 static 变量对比学习。类级变量在类定义后就已经存在，占用内存空间，可以通过类名来访问，不需要实例化。 对象实例级变量就是成员变量，实例化后才会分配内存空间，才能访问。 方法级变量就是在方法内部定义的变量，就是局部变量。 块级变量就是定义在一个块内部的变量，变量的生存周期就是这个块，出了这个块就消失了，比如 if、for 语句的块。块是指由大括号包围的代码。 说明： 方法内部除了能访问方法级的变量，还可以访问类级和实例级的变量。 块内部能够访问类级、实例级变量，如果块被包含在方法内部，它还可以访问方法级的变量。 方法级和块级的变量必须被显示地初始化，否则不能访问。 作用域原理 大多数程序设计语言都提供了“作用域”（Scope）的概念。 对于在作用域里定义的名字，作用域同时决定了它的“可见性”以及“存在时间”。在C，C++和Java里，作用域是由花括号的位置决定的。 变量的作用域 例子： 1 { 2 int x = 12; 3 /* only x available */ 4 { 5 int q = 96; 6 /* both x & q available */ 7 } 8 /* only x available */ 9 /* q “out of scope” */ 10 } Java用一对大括号作为语句块的范围，称为作用域，作为在作用域里定义的一个变量，它只有在哪个作用域结束之前才可使用。 在Java中不能像下面这样书写代码： 1 { 2 int x = 12; 3 { 4 int x = 96; /* illegal */ 5 } 6 } Java编译器会认为变量已被定义，所以作用域中的变量不能重复定义，但是在C和C++中能将一个变量“隐藏”在一个更大的作用域里，在C和C++中被允许，在Java中是不允许的，因为Java的设计者认为这样做使程序产生了混淆。 在同一作用域范围的包裹下成员变量名和局部变量名是可以变量名相同的，在同一个作用域范围的包裹下局部变量和局部变量不可以变量名相同（作用域内不能重复命名），在方法中使用变量的时候如果不指明使用成员变量还是局部变量，那么默认的就是使用局部的那个变量，但是如果局部变量超出了它本身的作用域范围则会失效，被JVM垃圾回收，那么则可以重复命名此变量，并使用最新定义的这个局部变量。 对象的作用域 Java对象不具备与主类型一样的存在时间。用new关键字创建一个Java对象的时候，它会超出作用域的范围之外。所以假若使用下面这段代码： 1 { 2 String s = new String(\"a string\"); 3 } /* 作用域的终点 */ 那么句柄s，也就是引用会在作用域的终点处消失。然而，s指向的String对象依然占据着内存空间。在上面这段代码里，我们没有办法继续使用这个对象，因为指向它的唯一一个句柄已经超出了作用域的边界。 这样造成的结果是：对于用new创建的对象，只要我们愿意，它们就会一直保留下去。这个编程问题在C和C++里特别突出。在C++里遇到的麻烦最大：由于不能从语言获得任何帮助，所以在需要对象的时候，根本无法确定它们是否可用。而且最麻烦的是，在C++里，一旦完成工作，必须保证将对象手动清除。 这样便带来了一个有趣的问题。假如 Java 让对象依然故我，怎样才能防止它们大量充斥内存，并最终造成程序的“凝固”呢。在 C++里，这个问题最令程序员头痛。但 Java 以后，情况却发生了改观。 Java 有一个特别的“垃圾收集器”，它会查找用 new 创建的所有对象，并辨别其中哪些不再被引用。随后，它会自动释放由那些闲置对象占据的内存，以便能由新对象使用。这意味着我们根本不必操心内存的回收问题。只需简单地创建对象，一旦不再需要它们，它们就会自动离去。这样做可防止在 C++里很常见的一个编程问题：由于程序员忘记释放内存造成的“内存溢出”。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/并发与多线程.html":{"url":"03_语言/Java/并发与多线程.html","title":"并发与多线程","keywords":"","body":"Thread stop()现在在jdk中不推荐使用 -join不写时间参数的话，会等调用join方法的线程执行完毕后执行其他的线程，如果写了时间，就会等调用join方法的线程执行那段时间后执行其他的线程 数字越大优先级越高 ExecutorService 一、ExecutorService介绍 ExecutorService是Java中对线程池定义的一个接口，它java.util.concurrent包中，在这个接口中定义了和后台任务执行相关的方法： Java API对ExecutorService接口的实现有两个，所以这两个即是Java线程池具体实现类： ThreadPoolExecutor ScheduledThreadPoolExecutor 除此之外，ExecutorService还继承了Executor接口（注意区分Executor接口和Executors工厂类），这个接口只有一个execute()方法，最后我们看一下整个继承树： 任务的委托（Task Delegation） 下方展示了一个线程的把任务委托异步执行的ExecutorService的示意图。 一旦线程把任务委托给 ExecutorService，该线程就会继续执行与运行任务无关的其它任务。 二、ExecutorService的创建 创建一个什么样的ExecutorService的实例（即线程池）需要根据具体应用场景而定，不过Java给我们提供了一个Executors工厂类，它可以帮助我们很方便的创建各种类型ExecutorService线程池，Executors一共可以创建下面这四类线程池： newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 备注：Executors只是一个工厂类，它所有的方法返回的都是ThreadPoolExecutor、ScheduledThreadPoolExecutor这两个类的实例。 三、ExecutorService的使用 ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new Runnable() { public void run() { System.out.println(\"Asynchronous task\"); } }); executorService.shutdown(); 四、ExecutorService的执行 ExecutorService有如下几个执行方法： execute(Runnable) submit(Runnable) submit(Callable) invokeAny(...) invokeAll(...) execute(Runnable) 仅执行 这个方法接收一个Runnable实例，并且异步的执行，请看下面的实例： ExecutorService executorService = Executors.newSingleThreadExecutor(); executorService.execute(new Runnable() { public void run() { System.out.println(\"Asynchronous task\"); } }); executorService.shutdown(); 这个方法有个问题，就是没有办法获知task的执行结果。如果我们想获得task的执行结果，我们可以传入一个Callable的实例（下面会介绍）。 submit(Runnable) 执行并获知执行完毕时机 submit(Runnable)和execute(Runnable)区别是前者可以返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕，请看下面执行的例子： Future future = executorService.submit(new Runnable() { public void run() { System.out.println(\"Asynchronous task\"); } }); future.get(); //returns null if the task has finished correctly. 如果任务执行完成，future.get()方法会返回一个null。注意，future.get()方法会产生阻塞。 submit(Callable) 执行并获知执行完毕返回值 submit(Callable)和submit(Runnable)类似，也会返回一个Future对象，但是除此之外，submit(Callable)接收的是一个Callable的实现，Callable接口中的call()方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的run()方法是void的，没有返回值。请看下面实例： Future future = executorService.submit(new Callable(){ public Object call() throws Exception { System.out.println(\"Asynchronous Callable\"); return \"Callable Result\"; } }); System.out.println(\"future.get() = \" + future.get()); 如果任务执行完成，future.get()方法会返回Callable任务的执行结果。注意，future.get()方法会产生阻塞。 invokeAny(…) 执行任意Callable，获知任意返回值 invokeAny(...)方法接收的是一个Callable的集合，执行这个方法不会返回Future，但是会返回所有Callable任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个。请看下面实例： ExecutorService executorService = Executors.newSingleThreadExecutor(); Set> callables = new HashSet>(); callables.add(new Callable() { public String call() throws Exception { return \"Task 1\"; } }); callables.add(new Callable() { public String call() throws Exception { return \"Task 2\"; } }); callables.add(new Callable() { public String call() throws Exception { return \"Task 3\"; } }); String result = executorService.invokeAny(callables); System.out.println(\"result = \" + result); executorService.shutdown(); 大家可以尝试执行上面代码，每次执行都会返回一个结果，并且返回的结果是变化的，可能会返回“Task2”也可是“Task1”或者其它。 invokeAll(…) 执行全部Callable，获知全部返回值 invokeAll(...)与 invokeAny(...)类似也是接收一个Callable集合，但是前者执行之后会返回一个Future的List，其中对应着每个Callable任务执行后的Future对象。情况下面这个实例： ExecutorService executorService = Executors.newSingleThreadExecutor(); Set> callables = new HashSet>(); callables.add(new Callable() { public String call() throws Exception { return \"Task 1\"; } }); callables.add(new Callable() { public String call() throws Exception { return \"Task 2\"; } }); callables.add(new Callable() { public String call() throws Exception { return \"Task 3\"; } }); List> futures = executorService.invokeAll(callables); for(Future future : futures){ System.out.println(\"future.get = \" + future.get()); } executorService.shutdown(); 五、ExecutorService的关闭 当我们使用完成ExecutorService之后应该关闭它，否则它里面的线程会一直处于运行状态。 举个例子，如果的应用程序是通过main()方法启动的，在这个main()退出之后，如果应用程序中的ExecutorService没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为ExecutorService中运行的线程会阻止JVM关闭。 如果要关闭ExecutorService中执行的线程，我们可以调用ExecutorService.shutdown()方法。在调用shutdown()方法之后，ExecutorService不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在shutdown()执行之前提交的任务都会被执行。 如果我们想立即关闭ExecutorService，我们可以调用ExecutorService.shutdownNow()方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。 ThreadPoolExecutor ThreadPoolExecutor 是 Java 中用于管理和调度线程池的一个类。它是 java.util.concurrent 包中的一部分，提供了一种灵活而强大的方式来处理多线程任务。以下是对 ThreadPoolExecutor 类的详细介绍： 主要特点和功能 线程池管理：ThreadPoolExecutor 允许你创建一个线程池，线程池可以重用线程来执行多个任务，从而避免了频繁创建和销毁线程的开销。 任务队列：它使用任务队列来保存待执行的任务。任务队列可以是各种类型的阻塞队列，例如 LinkedBlockingQueue、SynchronousQueue、ArrayBlockingQueue 等。 线程管理：它可以根据需要创建新线程或重用现有线程来执行任务。你可以配置核心线程数、最大线程数和空闲线程的生存时间等参数。 饱和策略：当线程池和队列都满时，ThreadPoolExecutor 提供了几种处理任务溢出的策略（例如，抛弃任务、抛出异常、调用任务的 rejectedExecutionHandler 等）。 可扩展性：可以通过继承 ThreadPoolExecutor 类，覆盖其方法来提供更复杂的行为或进行定制化处理。 构造函数 ThreadPoolExecutor 提供了多个构造函数，其中一个常用的构造函数是： public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 参数解释： corePoolSize：核心线程数，即使空闲也会保留在线程池中的线程数量。 maximumPoolSize：最大线程数，线程池能容纳的最大线程数量。 keepAliveTime：非核心线程的空闲时间超过这个时间后会被终止。 unit：时间单位，通常是 TimeUnit.SECONDS、TimeUnit.MILLISECONDS 等。 workQueue：任务队列，用于保存待执行的任务。 threadFactory：线程工厂，用于创建新线程。 handler：任务拒绝处理器，当线程池饱和时如何处理新任务。 示例代码 以下是一个使用 ThreadPoolExecutor 的简单示例： import java.util.concurrent.*; public class ThreadPoolExecutorExample { public static void main(String[] args) { // 创建一个线程池 ThreadPoolExecutor executor = new ThreadPoolExecutor( 2, // corePoolSize 4, // maximumPoolSize 60, // keepAliveTime TimeUnit.SECONDS, // unit new LinkedBlockingQueue(), // workQueue Executors.defaultThreadFactory(), // threadFactory new ThreadPoolExecutor.AbortPolicy() // handler ); // 提交任务 for (int i = 0; i JDK自带的几种线程池 newFixedThreadPool是固定大小的线程池，poolCoreSize和maxPoolSize相等，到达coreSize则将新的任务放到缓存队列，有线程执行完毕则直接去取 newSingleThreadExecutor创建一个单线程的线程池，核心池和最大池大小都为1 newCacheThreadPool是无大小限制的线程池，提交一个任务就创建一个线程来执行 为什么需要线程池（服务器角度） 多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。 假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。 如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。 一个线程池包括以下四个基本组成部分： 线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务； 工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务； 任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等； 任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。 线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。 线程池不仅调整T1,T3产生的时间段，而且它还显著减少了创建线程的数目，看一个例子： 假设一个服务器一天要处理50000个请求，并且每个请求需要一个单独的线程完成。在线程池中，线程数一般是固定的，所以产生线程总数不会超过线程池中线程的数目，而如果服务器不利用线程池来处理这些请求则线程总数为50000。一般线程池大小是远小于50000。所以利用线程池的服务器程序不会为了创建50000而在处理请求时浪费时间，从而提高效率。 如何保证线程安全（编译器\\处理器角度） 为什么需要多线程 CPU 增加了缓存，以均衡与内存的速度差异；// 导致 可见性问题 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 原子性问题 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 有序性问题 指令重排序是什么 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序： 上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。 这些重排序都可能会导致多线程程序出现内存可见性问题。 对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。 对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止） JMM(Java内存模型)如何保证线程安全 原子性：在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 x = 10; //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中 y = x; //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。 x++; //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。 x = x + 1; //语句4： 同语句3 可见性：当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。 有序性：在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。 Happens-Before规则是什么 1. 单一线程原则 在一个线程内，在程序前面的操作先行发生于后面的操作。 2. 管程锁定规则 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。 3. volatile 变量规则 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。 4. 线程启动规则 Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。 5. 线程加入规则 Thread 对象的结束先行发生于 join() 方法返回。 6. 线程中断规则 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生， 可以通过 interrupted() 方法检测到是否有中断发生。 7. 对象终结规则 一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。 8. 传递性 如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。 选择线程安全的策略 一个类在可以被多个线程安全调用时就是线程安全的。 线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 1. 不可变 不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。 多线程环境下，应当尽量使对象成为不可变，来满足线程安全。 不可变的类型: final 关键字修饰的基本数据类型 String 枚举类型 Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。 对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。 public class ImmutableExample { public static void main(String[] args) { Map map = new HashMap<>(); Map unmodifiableMap = Collections.unmodifiableMap(map); unmodifiableMap.put(\"a\", 1); } } Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。 Exception in thread \"main\" java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1457) at ImmutableExample.main(ImmutableExample.java:9) 2. 绝对线程安全 不管运行时环境如何，调用者都不需要任何额外的同步措施。 3. 相对线程安全 相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。 在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。 对于下面的代码，如果删除元素的线程删除了 Vector 的一个元素，而获取元素的线程试图访问一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。 public class VectorUnsafeExample { private static Vector vector = new Vector<>(); public static void main(String[] args) { while (true) { for (int i = 0; i { for (int i = 0; i { for (int i = 0; i Exception in thread \"Thread-159738\" java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 3 at java.util.Vector.remove(Vector.java:831) at VectorUnsafeExample.lambda$main$0(VectorUnsafeExample.java:14) at VectorUnsafeExample$$Lambda$1/713338599.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) 如果要保证上面的代码能正确执行下去，就需要对删除元素和获取元素的代码进行同步。 executorService.execute(() -> { synchronized (vector) { for (int i = 0; i { synchronized (vector) { for (int i = 0; i 4. 线程兼容 线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。 5. 线程对立 线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。 线程安全的实现方法 1.互斥同步 synchronized和ReentrantLock 2.非阻塞同步 互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。 乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。 3.无同步方案 (一)栈封闭 多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于每个访问线程私有的。 (二)线程本地存储(Thread Local Storage) 如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。 符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。 可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。 在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。 *(三)可重入代码(Reentrant Code) 这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/异常处理.html":{"url":"03_语言/Java/异常处理.html","title":"异常处理","keywords":"","body":" 1. Java 中的异常分类和处理机制 异常的基本分类 所有异常（包括错误）都有共同的祖先 Throwable。Throwable 有两个重要的子类：Error 和 Exception。 Error: 这类异常是程序无法处理的，大多数与程序本身无关，如内存溢出等。 Exception: 这类异常是程序可以处理的。Exception 又分为运行时异常（RuntimeException）和非运行时异常。 Unchecked Exception非检查异常：编译器不要求强制处理的异常 RuntimeException NullPointerException空指针异常 ArrayIndexOutOfBoundsException数组下标越界异常 ArithmeticException算数异常 ClassCastException类型转换异常 CheckedException检查异常：需要在编译时处理的异常 IOException SQLException Java 的异常处理机制 Java 的异常处理机制主要包括捕获异常和抛出异常。 捕获异常: 当方法抛出异常时，运行时系统会寻找合适的异常处理器。如果找不到，程序将会停止。 抛出异常: 当方法出现异常时，将异常抛给上层调用者处理。如果调用者不处理，可以继续向上抛出。 示例代码： try { // 对代码块进行异常监控 ... } catch (Exception e) { // 捕获异常，处理异常 ... } finally { // 无论是否出现异常，都会被执行 // 但有几种情况不会执行：1. finally 块发生异常；2. 前面使用了 System.exit()；3. 线程死亡；4. CPU 关闭 ... } throws: 方法声明中使用，表示该方法可能抛出异常，由调用者处理。 throw: 在方法内部使用，抛出具体的异常实例。 2. JVM 的异常处理机制 JVM 使用异常表（Exception Table）来处理异常。 示例： public static void main(String[] args) { try { methodA(); } catch (NullPointerException e) { System.out.println(\"Caught NullPointerException in main\"); } } public static void methodA() { try { methodB(); } catch (ArithmeticException e) { System.out.println(\"Caught ArithmeticException in methodA\"); } } public static void methodB() { throw new NullPointerException(\"NullPointerException in methodB\"); } 解释： methodB 抛出 NullPointerException。 JVM 在 methodB 中查找异常表，但找不到处理 NullPointerException 的处理器。 methodA 捕获 ArithmeticException，但没有捕获 NullPointerException，所以继续向上查找。 methodA 调用处在 main 方法中，main 方法捕获了 NullPointerException。 情况： 如果找到合适的处理者，调用处理者处理异常 如果所有栈帧都未处理，抛给当前的线程，线程会终止 如果当前线程是最后一个非守护线程且未处理异常，JVM 将终止运行 3. 异常耗时的原因 创建一个异常对象的耗时大约是创建普通对象的 20 倍，而抛出和捕获异常对象的耗时大约是创建异常对象的 4 倍。这主要是因为 Throwable 类的构造函数和 fillInStackTrace 方法涉及大量的栈帧信息处理。 Throwable 类的部分源码如下： public class Throwable { private static final StackTraceElement[] UNASSIGNED_STACK = new StackTraceElement[0]; private StackTraceElement[] stackTrace = UNASSIGNED_STACK; private String detailMessage; private Throwable cause = this; public synchronized Throwable fillInStackTrace() { if (stackTrace != null || backtrace != null) { fillInStackTrace(0); stackTrace = UNASSIGNED_STACK; } return this; } private native Throwable fillInStackTrace(int dummy); } 造成异常耗时的主要原因 同步锁: 创建异常对象时使用了同步锁。 堆栈遍历: fillInStackTrace 方法需要遍历所有栈帧，记录栈帧信息，包括类名、方法名和行号等。 自定义异常时，如果不需要堆栈信息，可以重写 fillInStackTrace 方法以提高性能。 Throwable- Error/Exception Error：程序无法处理的错误，表示运行应用程序中较严重的问题：VirtualMachineError虚拟机错误、OutOfMemoryError内存溢出、ThreadDeath线程死锁 Exception：程序本身可以处理的异常：Checked Exception检查异常、Unchecked Exception 非检查异常 4.try-catch的使用 1.try块后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块 2.throw抛出的只能够是可抛出类Throwable或者其子类的实例对象 好处： 使用try-catch可以让程序在遇到错误时执行特定的恢复代码。这对资源管理（如关闭文件、释放资源等）特别有用。finally块可以确保无论是否发生异常，特定代码都会执行。 坏处： 异常处理机制在抛出和捕获异常时需要进行堆栈回溯，这比普通的条件判断要昂贵得多。因此，应避免在性能关键的代码路径中频繁使用异常来控制流程。 开发者需要注意异常的类型和范围。捕获过于宽泛的异常（如catch (Exception e)）可能会掩盖真正的错误源，并使调试和排错变得困难。最好捕获具体的异常类型，并提供有针对性的处理。 5.try-with-resources的使用 在 Java 中，任何实现了 AutoCloseable 接口的资源都可以用于 try-with-resources 语句。AutoCloseable 接口包含一个 close() 方法，该方法在资源使用完毕后会被自动调用。Java 7 引入了 try-with-resources 语法，以便简化资源管理并减少资源泄漏的风险。 以下是一些常见的可用于 try-with-resources 的资源类型： InputStream FileInputStream, BufferedInputStream OutputStream FileOutputStream, BufferedOutputStream Reader FileReader, BufferedReader Writer FileWriter, BufferedWriter 数据库连接 Connection JDBC 连接对象 StatementJDBC 语句对象 网络资源 Socket 网络套接字 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/泛型.html":{"url":"03_语言/Java/泛型.html","title":"泛型","keywords":"","body":"Java 基础 - 泛型机制详解 Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。本文综合多篇文章后，总结了Java 泛型的相关知识，希望可以提升你对Java中泛型的认知效率。 为什么会引入泛型 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 引入泛型的意义在于： 适用于多种数据类型执行相同的代码（代码复用） 我们通过一个例子来阐述，先看下下面的代码： private static int add(int a, int b) { System.out.println(a + \"+\" + b + \"=\" + (a + b)); return a + b; } private static float add(float a, float b) { System.out.println(a + \"+\" + b + \"=\" + (a + b)); return a + b; } private static double add(double a, double b) { System.out.println(a + \"+\" + b + \"=\" + (a + b)); return a + b; } 如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法： private static double add(T a, T b) { System.out.println(a + \"+\" + b + \"=\" + (a.doubleValue() + b.doubleValue())); return a.doubleValue() + b.doubleValue(); } 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型） 看下这个例子： List list = new ArrayList(); list.add(\"xxString\"); list.add(100d); list.add(new Person()); 我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。 引入泛型，它将提供类型的约束，提供编译前的检查： List list = new ArrayList(); // list中只能放String, 不能放其它类型的元素 泛型的基本使用 提示 我们通过一些例子来学习泛型的使用；泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。一些例子可以参考《李兴华 - Java实战经典》。@pdai 泛型类 从一个简单的泛型类看起： class Point{ // 此处可以随便写标识符号，T是type的简称 private T var ; // var的类型由T指定，即：由外部指定 public T getVar(){ // 返回值的类型由外部决定 return var ; } public void setVar(T var){ // 设置的类型也由外部决定 this.var = var ; } } public class GenericsDemo06{ public static void main(String args[]){ Point p = new Point() ; // 里面的var类型为String类型 p.setVar(\"it\") ; // 设置字符串 System.out.println(p.getVar().length()) ; // 取得字符串的长度 } } 多元泛型 class Notepad{ // 此处指定了两个泛型类型 private K key ; // 此变量的类型由外部决定 private V value ; // 此变量的类型由外部决定 public K getKey(){ return this.key ; } public V getValue(){ return this.value ; } public void setKey(K key){ this.key = key ; } public void setValue(V value){ this.value = value ; } } public class GenericsDemo09{ public static void main(String args[]){ Notepad t = null ; // 定义两个泛型类型的对象 t = new Notepad() ; // 里面的key为String，value为Integer t.setKey(\"汤姆\") ; // 设置第一个内容 t.setValue(20) ; // 设置第二个内容 System.out.print(\"姓名；\" + t.getKey()) ; // 取得信息 System.out.print(\"，年龄；\" + t.getValue()) ; // 取得信息 } } 泛型接口 简单的泛型接口 interface Info{ // 在接口上定义泛型 public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型 } class InfoImpl implements Info{ // 定义泛型接口的子类 private T var ; // 定义属性 public InfoImpl(T var){ // 通过构造方法设置属性内容 this.setVar(var) ; } public void setVar(T var){ this.var = var ; } public T getVar(){ return this.var ; } } public class GenericsDemo24{ public static void main(String arsg[]){ Info i = null; // 声明接口对象 i = new InfoImpl(\"汤姆\") ; // 通过子类实例化对象 System.out.println(\"内容：\" + i.getVar()) ; } } 泛型方法 泛型方法，是在调用方法的时候指明泛型的具体类型。重点看下泛型的方法 定义泛型方法语法格式 调用泛型方法语法格式 说明一下，定义泛型方法时，必须在返回值前边加一个，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。 Class的作用就是指明泛型的具体类型，而Class类型的变量c，可以用来创建泛型类的对象。 为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。 泛型方法要求的参数是Class类型，而Class.forName()方法的返回值也是Class，因此可以用Class.forName()作为参数。其中，forName()方法中的参数是何种类型，返回的Class就是何种类型。在本例中，forName()方法中传入的是User类的完整路径，因此返回的是Class类型的对象，因此调用泛型方法时，变量c的类型就是Class，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。 当然，泛型方法不是仅仅可以有一个参数Class，可以根据需要添加其他参数。 为什么要使用泛型方法呢？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。 泛型的上下限 先看下如下的代码，很明显是会报错的 （具体错误原因请参考后文）。 class A{} class B extends A {} // 如下两个方法不会报错 public static void funA(A a) { // ... } public static void funB(B b) { funA(b); // ... } // 如下funD方法会报错 public static void funC(List listA) { // ... } public static void funD(List listB) { funC(listB); // Unresolved compilation problem: The method doPrint(List) in the type test is not applicable for the arguments (List) // ... } 那么如何解决呢？ 为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。 public static void funC(List listA) { // ... } public static void funD(List listB) { funC(listB); // OK // ... } 泛型上下限的引入 在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 上限 class Info{ // 此处泛型只能是数字类型 private T var ; // 定义泛型变量 public void setVar(T var){ this.var = var ; } public T getVar(){ return this.var ; } public String toString(){ // 直接打印 return this.var.toString() ; } } public class demo1{ public static void main(String args[]){ Info i1 = new Info() ; // 声明Integer的泛型对象 } } 下限 class Info{ private T var ; // 定义泛型变量 public void setVar(T var){ this.var = var ; } public T getVar(){ return this.var ; } public String toString(){ // 直接打印 return this.var.toString() ; } } public class GenericsDemo21{ public static void main(String args[]){ Info i1 = new Info() ; // 声明String的泛型对象 Info i2 = new Info() ; // 声明Object的泛型对象 i1.setVar(\"hello\") ; i2.setVar(new Object()) ; fun(i1) ; fun(i2) ; } public static void fun(Info temp){ // 只能接收String或Object类型的泛型，String类的父类只有Object类 System.out.print(temp + \", \") ; } } 小结 无限制通配符 extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类 super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类 // 使用原则《Effictive Java》 // 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限 1. 如果参数化类型表示一个 T 的生产者，使用 ; 2. 如果它表示一个 T 的消费者，就使用 ； 3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。 再看一个实际例子，加深印象 private > E max(List e1) { if (e1 == null){ return null; } //迭代器返回的元素属于 E 的某个子类型 Iterator iterator = e1.iterator(); E result = iterator.next(); while (iterator.hasNext()){ E next = iterator.next(); if (next.compareTo(result) > 0){ result = next; } } return result; } 上述代码中的类型参数 E 的范围是>，我们可以分步查看： 要进行比较，所以 E 需要是可比较的类，因此需要 extends Comparable（注意这里不要和继承的 extends 搞混了，不一样） Comparable 要对 E 进行比较，即 E 的消费者，所以需要用 super 而参数 List 表示要操作的数据是 E 的子类的列表，指定上限，这样容器才够大 多个限制 使用&符号 public class Client { //工资低于2500元的上斑族并且站立的乘客车票打8折 public static void discount(T t){ if(t.getSalary() 泛型数组 首先，我们泛型数组相关的申明： List[] list11 = new ArrayList[10]; //编译错误，非法创建 List[] list12 = new ArrayList[10]; //编译错误，需要强转类型 List[] list13 = (List[]) new ArrayList[10]; //OK，但是会有警告 List[] list14 = new ArrayList[10]; //编译错误，非法创建 List[] list15 = new ArrayList[10]; //OK List[] list6 = new ArrayList[10]; //OK，但是会有警告 那么通常我们如何用呢？ 讨巧的使用场景 public class GenericsDemo30{ public static void main(String args[]){ Integer i[] = fun1(1,2,3,4,5,6) ; // 返回泛型数组 fun2(i) ; } public static T[] fun1(T...arg){ // 接收可变参数 return arg ; // 返回泛型数组 } public static void fun2(T param[]){ // 输出 System.out.print(\"接收泛型数组：\") ; for(T t:param){ System.out.print(t + \"、\") ; } } } 合理使用 public ArrayWithTypeToken(Class type, int size) { array = (T[]) Array.newInstance(type, size); } No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/注解.html":{"url":"03_语言/Java/注解.html","title":"注解","keywords":"","body":"注解基础 注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面： 生成文档，通过代码里标识的元数据生成javadoc文档。 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。 这么来说是比较抽象的，我们具体看下注解的常见分类： Java自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。 元注解，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。 自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。 接下来我们通过这个分类角度来理解注解。 Java内置注解 我们从最为常见的Java内置的注解开始说起，先看下下面的代码： class A{ public void test() { } } class B extends A{ /** * 重载父类的test方法 */ @Override public void test() { } /** * 被弃用的方法 */ @Deprecated public void oldMethod() { } /** * 忽略告警 * * @return */ @SuppressWarnings(\"rawtypes\") public List processList() { List list = new ArrayList(); return list; } } Java 1.5开始自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings： @Override：表示当前的方法定义将覆盖父类中的方法 @Deprecated：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告 @SuppressWarnings：表示关闭编译器警告信息 我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。 @Override 我们先来看一下这个注解类型的定义： @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } 从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。 @Deprecated 这个注解的定义如下： @Documented @Retention(RetentionPolicy.RUNTIME) @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE}) public @interface Deprecated { } 从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。 @SuppressWarnings 这个注解我们也比较常用到，先来看下它的定义： @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) @Retention(RetentionPolicy.SOURCE) public @interface SuppressWarnings { String[] value(); } 它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示： 参数 作用 原描述 all 抑制所有警告 to suppress all warnings boxing 抑制装箱、拆箱操作时候的警告 to suppress warnings relative to boxing/unboxing operations cast 抑制映射相关的警告 to suppress warnings relative to cast operations dep-ann 抑制启用注释的警告 to suppress warnings relative to deprecated annotation deprecation 抑制过期方法警告 to suppress warnings relative to deprecation fallthrough 抑制确在switch中缺失breaks的警告 to suppress warnings relative to missing breaks in switch statements finally 抑制finally模块没有返回的警告 to suppress warnings relative to finally block that don’t return hiding 抑制与隐藏变数的区域变数相关的警告 to suppress warnings relative to locals that hide variable（） incomplete-switch 忽略没有完整的switch语句 to suppress warnings relative to missing entries in a switch statement (enum case) nls 忽略非nls格式的字符 to suppress warnings relative to non-nls string literals null 忽略对null的操作 to suppress warnings relative to null analysis rawtype 使用generics时忽略没有指定相应的类型 to suppress warnings relative to un-specific types when using restriction 抑制与使用不建议或禁止参照相关的警告 to suppress warnings relative to usage of discouraged or serial 忽略在serializable类中没有声明serialVersionUID变量 to suppress warnings relative to missing serialVersionUID field for a serializable class static-access 抑制不正确的静态访问方式警告 to suppress warnings relative to incorrect static access synthetic-access 抑制子类没有按最优方法访问内部类的警告 to suppress warnings relative to unoptimized access from inner classes unchecked 抑制没有进行类型检查操作的警告 to suppress warnings relative to unchecked operations unqualified-field-access 抑制没有权限访问的域的警告 to suppress warnings relative to field access unqualified unused 抑制没被使用过的代码的警告 to suppress warnings relative to unused code 元注解 上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在JDK 1.5中提供了4个标准的元注解：@Target，@Retention，@Documented，@Inherited, 在JDK 1.8中提供了两个元注解 @Repeatable和@Native。 元注解 - @Target Target注解的作用是：描述注s解的使用范围（即：被修饰的注解可以用在什么地方） 。 Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。 public enum ElementType { TYPE, // 类、接口、枚举类 FIELD, // 成员变量（包括：枚举常量） METHOD, // 成员方法 PARAMETER, // 方法参数 CONSTRUCTOR, // 构造方法 LOCAL_VARIABLE, // 局部变量 ANNOTATION_TYPE, // 注解类 PACKAGE, // 可用于修饰：包 TYPE_PARAMETER, // 类型参数，JDK 1.8 新增 TYPE_USE // 使用类型的任何地方，JDK 1.8 新增 } 元注解 - @Retention & @RetentionTarget Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。 Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。 public enum RetentionPolicy { SOURCE, // 源文件保留 CLASS, // 编译期保留，默认值 RUNTIME // 运行期保留，可通过反射去获取注解信息 } 为了验证应用了这三种策略的注解类有何区别，分别使用三种策略各定义一个注解类做测试。 @Retention(RetentionPolicy.SOURCE) public @interface SourcePolicy { } @Retention(RetentionPolicy.CLASS) public @interface ClassPolicy { } @Retention(RetentionPolicy.RUNTIME) public @interface RuntimePolicy { } 用定义好的三个注解类分别去注解一个方法。 public class RetentionTest { @SourcePolicy public void sourcePolicy() { } @ClassPolicy public void classPolicy() { } @RuntimePolicy public void runtimePolicy() { } } 通过执行 javap -verbose RetentionTest命令获取到的RetentionTest 的 class 字节码内容如下。 { public retention.RetentionTest(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"\":()V 4: return LineNumberTable: line 3: 0 public void sourcePolicy(); flags: ACC_PUBLIC Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 7: 0 public void classPolicy(); flags: ACC_PUBLIC Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 11: 0 RuntimeInvisibleAnnotations: 0: #11() public void runtimePolicy(); flags: ACC_PUBLIC Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 15: 0 RuntimeVisibleAnnotations: 0: #14() } 从 RetentionTest 的字节码内容我们可以得出以下两点结论： 编译器并没有记录下 sourcePolicy() 方法的注解信息； 编译器分别使用了 RuntimeInvisibleAnnotations 和 RuntimeVisibleAnnotations 属性去记录了classPolicy()方法 和 runtimePolicy()方法 的注解信息； 元注解 - @Documented Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。 以下代码在使用Javadoc工具可以生成@TestDocAnnotation注解信息。 import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Target; @Documented @Target({ElementType.TYPE,ElementType.METHOD}) public @interface TestDocAnnotation { public String value() default \"default\"; } @TestDocAnnotation(\"myMethodDoc\") public void testDoc() { } 元注解 - @Inherited Inherited注解的作用：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。 我们来测试下这个注解： 定义@Inherited注解： @Inherited @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE,ElementType.METHOD}) public @interface TestInheritedAnnotation { String [] values(); int number(); } 使用这个注解 @TestInheritedAnnotation(values = {\"value\"}, number = 10) public class Person { } class Student extends Person{ @Test public void test(){ Class clazz = Student.class; Annotation[] annotations = clazz.getAnnotations(); for (Annotation annotation : annotations) { System.out.println(annotation.toString()); } } } 输出 xxxxxxx.TestInheritedAnnotation(values=[value], number=10) 即使Student类没有显示地被注解@TestInheritedAnnotation，但是它的父类Person被注解，而且@TestInheritedAnnotation被@Inherited注解，因此Student类自动有了该注解。 元注解 - @Repeatable (Java8) @Repeatable请参考Java 8 - 重复注解 元注解 - @Native (Java8) 使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可 注解与反射接口 定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。 AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。我们看下具体的先关接口 boolean isAnnotationPresent(Class annotationClass) 判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。 T getAnnotation(Class annotationClass) 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。 Annotation[] getAnnotations() 返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。 T[] getAnnotationsByType(Class annotationClass) 返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。getAnnotationsByType方法与 getAnnotation的区别在于，getAnnotationsByType会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。 T getDeclaredAnnotation(Class annotationClass) 返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null T[] getDeclaredAnnotationsByType(Class annotationClass) 返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释 Annotation[] getDeclaredAnnotations() 返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。 自定义注解 当我们理解了内置注解, 元注解和获取注解的反射接口后，我们便可以开始自定义注解了。这个例子我把上述的知识点全部融入进来, 代码很简单： 定义自己的注解 package com.pdai.java.annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyMethodAnnotation { public String title() default \"\"; public String description() default \"\"; } 使用注解 package com.pdai.java.annotation; import java.io.FileNotFoundException; import java.lang.annotation.Annotation; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.List; public class TestMethodAnnotation { @Override @MyMethodAnnotation(title = \"toStringMethod\", description = \"override toString method\") public String toString() { return \"Override toString method\"; } @Deprecated @MyMethodAnnotation(title = \"old static method\", description = \"deprecated old static method\") public static void oldMethod() { System.out.println(\"old method, don't use it.\"); } @SuppressWarnings({\"unchecked\", \"deprecation\"}) @MyMethodAnnotation(title = \"test method\", description = \"suppress warning static method\") public static void genericsTest() throws FileNotFoundException { List l = new ArrayList(); l.add(\"abc\"); oldMethod(); } } 用反射接口获取注解信息 在TestMethodAnnotation中添加Main方法进行测试： public static void main(String[] args) { try { // 获取所有methods Method[] methods = TestMethodAnnotation.class.getClassLoader() .loadClass((\"com.pdai.java.annotation.TestMethodAnnotation\")) .getMethods(); // 遍历 for (Method method : methods) { // 方法上是否有MyMethodAnnotation注解 if (method.isAnnotationPresent(MyMethodAnnotation.class)) { try { // 获取并遍历方法上的所有注解 for (Annotation anno : method.getDeclaredAnnotations()) { System.out.println(\"Annotation in Method '\" + method + \"' : \" + anno); } // 获取MyMethodAnnotation对象信息 MyMethodAnnotation methodAnno = method .getAnnotation(MyMethodAnnotation.class); System.out.println(methodAnno.title()); } catch (Throwable ex) { ex.printStackTrace(); } } } } catch (SecurityException | ClassNotFoundException e) { e.printStackTrace(); } } 测试的输出 Annotation in Method 'public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()' : @java.lang.Deprecated() Annotation in Method 'public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()' : @com.pdai.java.annotation.MyMethodAnnotation(title=old static method, description=deprecated old static method) old static method Annotation in Method 'public static void com.pdai.java.annotation.TestMethodAnnotation.genericsTest() throws java.io.FileNotFoundException' : @com.pdai.java.annotation.MyMethodAnnotation(title=test method, description=suppress warning static method) test method Annotation in Method 'public java.lang.String com.pdai.java.annotation.TestMethodAnnotation.toString()' : @com.pdai.java.annotation.MyMethodAnnotation(title=toStringMethod, description=override toString method) toStringMethod 注解目录 @inheritDoc 方法注释继承自父文档的解释 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/浅拷贝与深拷贝.html":{"url":"03_语言/Java/浅拷贝与深拷贝.html","title":"浅拷贝与深拷贝","keywords":"","body":"1.引用拷贝与对象拷贝 （1）引用拷贝 创建一个指向对象的引用变量的拷贝。 Teacher teacher = new Teacher(\"Taylor\",26); Teacher otherteacher = teacher; System.out.println(teacher); System.out.println(otherteacher); 输出结果： blog.Teacher@355da254 blog.Teacher@355da254 结果分析：由输出结果可以看出，它们的地址值是相同的，那么它们肯定是同一个对象。teacher和otherteacher的只是引用而已，他们都指向了一个相同的对象Teacher(“Taylor”,26)。 这就叫做引用拷贝。 （2）对象拷贝 创建对象本身的一个副本。 Teacher teacher = new Teacher(\"Swift\",26); Teacher otherteacher = (Teacher)teacher.clone(); System.out.println(teacher); System.out.println(otherteacher); 输出结果： blog.Teacher@355da254 blog.Teacher@4dc63996 结果分析：由输出结果可以看出，它们的地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个新的引用变量,这就叫做对象拷贝。 注：深拷贝和浅拷贝都是对象拷贝 2.浅拷贝 （1）定义 被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。 （2）浅拷贝实例 package com.test; public class ShallowCopy { public static void main(String[] args) throws CloneNotSupportedException { Teacher teacher = new Teacher(); teacher.setName(\"riemann\"); teacher.setAge(27); Student2 student1 = new Student2(); student1.setName(\"edgar\"); student1.setAge(18); student1.setTeacher(teacher); Student2 student2 = (Student2) student1.clone(); System.out.println(\"拷贝后\"); System.out.println(student2.getName()); System.out.println(student2.getAge()); System.out.println(student2.getTeacher().getName()); System.out.println(student2.getTeacher().getAge()); System.out.println(\"修改老师的信息后-------------\"); // 修改老师的信息 teacher.setName(\"Games\"); System.out.println(student1.getTeacher().getName()); System.out.println(student2.getTeacher().getName()); } } class Teacher implements Cloneable { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } class Student2 implements Cloneable { private String name; private int age; private Teacher teacher; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Teacher getTeacher() { return teacher; } public void setTeacher(Teacher teacher) { this.teacher = teacher; } public Object clone() throws CloneNotSupportedException { Object object = super.clone(); return object; } } 输出结果： 拷贝后 edgar 18 riemann 27 修改老师的信息后------------- Games Games 结果分析： 两个引用student1和student2指向不同的两个对象，但是两个引用student1和student2中的两个teacher引用指向的是同一个对象，所以说明是浅拷贝。 3.深拷贝 （1）定义 深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。 （2）深拷贝实例 package com.test;public class DeepCopy { public static void main(String[] args) throws CloneNotSupportedException { Teacher2 teacher = new Teacher2(); teacher.setName(\"riemann\"); teacher.setAge(27); Student3 student1 = new Student3(); student1.setName(\"edgar\"); student1.setAge(18); student1.setTeacher(teacher); Student3 student2 = (Student3) student1.clone(); System.out.println(\"拷贝后\"); System.out.println(student2.getName()); System.out.println(student2.getAge()); System.out.println(student2.getTeacher().getName()); System.out.println(student2.getTeacher().getAge()); System.out.println(\"修改老师的信息后-------------\"); // 修改老师的信息 teacher.setName(\"Games\"); System.out.println(student1.getTeacher().getName()); System.out.println(student2.getTeacher().getName()); } } class Teacher2 implements Cloneable { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Object clone() throws CloneNotSupportedException { return super.clone(); } } class Student3 implements Cloneable { private String name; private int age; private Teacher2 teacher; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Teacher2 getTeacher() { return teacher; } public void setTeacher(Teacher2 teacher) { this.teacher = teacher; } public Object clone() throws CloneNotSupportedException { // 浅复制时： // Object object = super.clone(); // return object; // 改为深复制： Student3 student = (Student3) super.clone(); // 本来是浅复制，现在将Teacher对象复制一份并重新set进来 student.setTeacher((Teacher2) student.getTeacher().clone()); return student; } } 输出结果： 拷贝后 edgar 18 riemann 27 修改老师的信息后------------- Games riemann 结果分析： 两个引用student1和student2指向不同的两个对象，两个引用student1和student2中的两个teacher引用指向的是两个对象，但对teacher对象的修改只能影响student1对象,所以说是深拷贝。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/集合框架.html":{"url":"03_语言/Java/集合框架.html","title":"集合框架","keywords":"","body":"Collection 类关系图 Collection Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN) HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 List ArrayList：基于动态数组实现，支持随机访问。 Vector：和 ArrayList 类似，但它是线程安全的。 LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 Queue LinkedList：可以用它来实现双向队列。 PriorityQueue：基于堆结构实现，可以用它来实现优先队列。 Map TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。 Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。 Collection ArrayList 底层原理： 实现了List接口 底层通过数组实现 是顺序容器，即元素存放的数据与放进去的顺序相同。 每个ArrayList都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。 add()\\addAll()执行之前，都会进行剩余空间检 remove()方法，将删除点之后的元素向前移动一个位置，需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。 使用注意： 允许放入null元素 size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。 为追求效率，ArrayList没有实现同步(synchronized)，如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。 在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。新的容量需要大于原来容量的1.5倍，不然会被强行转化为1.5倍 trimToSize()将底层数组的容量调整为当前列表保存的实际元素的大小 ArrayList也采用了Fail-Fast的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。 LinkedList 底层原理： LinkedList底层通过双向链表实现，双向链表的每个节点用内部类Node表示，其中Node是私有的内部类。LinkedList通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。 getFirst(), getLast() 获取第一个元素， 和获取最后一个元素 removeFirst(), removeLast(), remove(e), remove(index) remove()方法也有两个版本，一个是删除跟指定元素相等的第一个元素remove(Object o)，另一个是删除指定下标处的元素remove(int index) 删除元素 - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判断的依据是equals方法， 如果equals，则直接unlink这个node；由于LinkedList可存放null元素，故也可以删除第一次出现null的元素；remove(int index)使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。 add()方法有两个版本，一个是add(E e)，该方法在LinkedList的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是add(int index, E element)，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。 node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index > 1)，也即是index是靠近前端还是后端。从这里也可以看出，linkedList通过index检索元素的效率没有arrayList高。 addAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次； clear() 为了让GC更快可以回收放置的元素，需要将node之间的引用关系赋空。 使用注意： LinkedList同时实现了List接口和Deque（双端队列）接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(Queue)，同时又可以看作一个栈(Stack)。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue的类(它是个接口名字)。关于栈或队列，现在的首选是ArrayDeque，它有着比LinkedList(当作栈或队列使用时)有着更好的性能。 LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装。 Stack & Queue Java里有一个叫做Stack的类，却没有叫做Queue的类(它是个接口名字)。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了(次选是LinkedList)。 Queue Queue接口继承自Collection接口，除了最基本的Collection的方法之外，它还支持额外的insertion, extraction和inspection操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。 Throws exception Returns special value Insert add(e) offer(e) Remove remove() poll() Examine element() peek() element()/peek() 获取队列的头部元素，及最早进入队列的元素，但不会删除该元素 Deque Deque是\"double ended queue\", 表示双向的队列，英文读作\"deck\". Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持insert, remove和examine操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。共12个方法如下: First Element - Head Last Element - Tail Throws exception Special value Throws exception Special value Insert addFirst(e) offerFirst(e) addLast(e) offerLast(e) Remove removeFirst() pollFirst() removeLast() pollLast() Examine getFirst() peekFirst() getLast() peekLast() 当把Deque当做FIFO的queue来使用时，元素是从deque的尾部添加，从头部进行删除的； 所以deque的部分方法是和queue是等同的。具体如下: Queue Method Equivalent Deque Method add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口: Queue Method Equivalent Deque Method 说明 add(e) addLast(e) 向队尾插入元素，失败则抛出异常 offer(e) offerLast(e) 向队尾插入元素，失败则返回false remove() removeFirst() 获取并删除队首元素，失败则抛出异常 poll() pollFirst() 获取并删除队首元素，失败则返回null element() getFirst() 获取但不删除队首元素，失败则抛出异常 peek() peekFirst() 获取但不删除队首元素，失败则返回null 下表列出了Deque与Stack对应的接口: Stack Method Equivalent Deque Method 说明 push(e) addFirst(e) 向栈顶插入元素，失败则抛出异常 无 offerFirst(e) 向栈顶插入元素，失败则返回false pop() removeFirst() 获取并删除栈顶元素，失败则抛出异常 无 pollFirst() 获取并删除栈顶元素，失败则返回null peek() getFirst() 获取但不删除栈顶元素，失败则抛出异常 无 peekFirst() 获取但不删除栈顶元素，失败则返回null PriorityQueue 前面以Java ArrayDeque为例讲解了Stack和Queue，其实还有一种特殊的队列叫做PriorityQueue，即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(*natural ordering*)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。 Java中PriorityQueue实现了Queue接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树(complete binary tree)实现的小顶堆(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为PriorityQueue的底层实现。 上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系: leftNo = parentNo*2+1 rightNo = parentNo*2+2 parentNo = (nodeNo-1)/2 通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。 PriorityQueue的peek()和element操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是log(N)。 关于add() 和 offer()： add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于PriorityQueue这两个方法其实没什么差别。 新加入的元素x可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为 : 从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x >= queue[parent]为止。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。 注意数据存储的元素并不是递增的，只是保证子节点一定小于父节点，从而保证队列每次取出的元素都是队列中权值最小的。 关于remove() 和poll() 需要调用sitfDown()方法重新调整元素顺序：从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止。 remove(Object o) remove(Object o)方法用于删除队列中跟o相等的某一个元素(如果有多个相等，只删除一个)，该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(Object o)可以分为2种情况: 1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown() ArrayDeque 底层原理： ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组(circular array)，也就是说数组的任何一点都可能被看作起点或者终点。 使用head = (head - 1) & (elements.length - 1)解决head下标为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数(其实只可能是-1)，则相当于对其取相对于elements.length的补码。 doubleCapacity() 会申请一个空间两倍于原数组的数组，然后将原数组复制过去。 由于ArrayDeque中不允许放入null，当elements[head] == null时，意味着容器为空。 使用注意： ArrayDeque是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步； 该容器不允许放入null元素 Map HashSet & HashMap HashMap是对HashSet的封装 哈希表是一种以键-值对存储数据的数据结构，它通过哈希函数将键映射到存储桶的位置。当你插入一个键-值对时，哈希表会使用哈希函数计算键的哈希值，并将值存储在相应的桶中。同样，在查找时，哈希表也会使用哈希函数计算键的哈希值，然后直接跳到存储桶的位置来获取值。 特点： 跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。Java7 *HashMap*采用的是冲突链表方式。 如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。 使用注意： HashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素； 除该类未实现同步外，其余跟Hashtable大致相同； 有两个参数可以影响HashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。 将对象放入到HashMap或HashSet中时，有两个方法需要特别关心: hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要@Override hashCode()和equals()方法。 get() get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.getValue()。因此getEntry()是算法的核心。 算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过key.equals(k)方法来判断是否是要找的那个entry。 put() put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry，插入方式为头插法。 remove() remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry(修改链表的相应引用)。查找过程跟getEntry()过程类似。 Java8 HashMap Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。 根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。 为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。 Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。 我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。 LinkedHashSet & LinkedHashMap LinkedHashSet里面有一个LinkedHashMap(适配器模式) 特点： LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表(doubly-linked list)的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同 除了可以保迭代历顺序，这种结构还有一个好处 : 迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说LinkedHashMap的迭代时间就只跟entry的个数相关，而跟table的大小无关。 使用注意： LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素 get() get(Object key)方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样。 put() put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于get()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry。 注意，这里的插入有两重含义: 从table的角度看，新的entry需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。 从header的角度看，新的entry需要插入到双向链表的尾部。 remove() remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry(修改链表的相应引用)。查找过程跟get()方法类似。 注意，这里的删除也有两重含义: 从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。 从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。 固定大小的FIFO策略的缓存 LinkedHashMap有一个子类方法protected boolean removeEldestEntry(Map.Entry eldest)，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回true，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问removeEldestEntry()是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让removeEldestEntry()返回true，就能够实现一个固定大小的FIFO策略的缓存 /** 一个固定大小的FIFO替换策略的缓存 */ class FIFOCache extends LinkedHashMap{ private final int cacheSize; public FIFOCache(int cacheSize){ this.cacheSize = cacheSize; } // 当Entry个数超过cacheSize时，删除最老的Entry @Override protected boolean removeEldestEntry(Map.Entry eldest) { return size() > cacheSize; } } TreeSet & TreeMap 之所以把TreeSet和TreeMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说TreeSet里面有一个TreeMap(适配器模式)。因此本文将重点分析TreeMap。 特点： TreeMap\\底层通过红黑树(Red-Black tree)实现，也就意味着containsKey(), get(), put(), remove()都有着log(n)的时间复杂度。 使用注意： Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator)。 出于性能原因，TreeMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成(wrapped)同步的: SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...)); WeekHashMap 将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。 特别适用于需要缓存的场景 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Java/面试题.html":{"url":"03_语言/Java/面试题.html","title":"面试题","keywords":"","body":" 垃圾回收机制。。。(主要从下面几方面解答 GC原理、最好画图解释一下年轻代（Eden区和Survival区）、年老代、比例分配及为啥要这样分代回收) 对象分配问题，堆栈里的问题，详细的会问道方法区、堆、程序计数器、本地方法栈、虚拟机栈，问题入口从String a,new String(\"\")开始 关键字，private protected public static final 组合着问 Object类里面有哪几种方法，作用 equals 和 hashCode方法，重写equals的原则() 向上转型 Java引用类型(强引用，软引用，弱引用，虚引用) 线程相关的，主要是volitate，synchorized，wait()，notify()，notifyAll()，join() Exception和Error 反射的用途 HashMap实现原理(数组+链表)，查找数据的时间复杂度 List有哪些子类，各有什么区别 NIO相关，缓冲区、通道、selector。。。(不熟，面了这么多，挂在这里。其实主要是表现在同步阻塞和异步，传输方式不同。标准IO无法实现非阻塞模式、文件锁、读选择、分散聚集等) 内存泄露，举个例子 OOM是怎么出现的，有哪几块JVM区域会产生OOM，如何解决(对于该问题，建议去《Java特种兵》的3.6章) Java里面的观察者模式实现 单例实现(我一般用enum写，不容易被挑毛病) 用Java模拟一个栈，并能够做到扩容，并且能有同步锁。（用数组实现） Java泛型机制，泛型机制的优点，以及类型变量 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Javascript/REFERS.html":{"url":"03_语言/Javascript/REFERS.html","title":"Refers","keywords":"","body":" BOM基础 DOM事件 DOM基础 javascript 内置对象 javascript 函数 javascript 变量 作用域 内存 javascript 对象 javascript 语句 javascript 语法 调试工具 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Kotlin/Kotlin-Basics.html":{"url":"03_语言/Kotlin/Kotlin-Basics.html","title":"Kotlin-basics","keywords":"","body":"一、Types Basic types String 字符串类型 Kotlin有两种String类型 Escaped strings 转义字符串 Raw strings 原始字符串 转义字符串：可以包含转义字符： val s = \"Hello, world!\\n\" 原始字符串：可以包含换行符和任意文本。它由三引号 （“”“） 分隔，不包含转义，可以包含换行符和任何其他字符： val text = \"\"\" for (c in \"foo\") print(c) \"\"\" 要从原始字符串中删除前导空格，请使用 trimMargin（） 函数： val text = \"\"\" |Tell me and I forget. |Teach me and I remember. |Involve me and I learn. |(Benjamin Franklin) \"\"\".trimMargin() 默认情况下，管道符号|用作边距前缀，但您可以选择另一个字符并将其作为参数传递，例如 trimMargin（“>”）。 字符串模板 字符串文本可能包含模板表达式 - 经过计算的代码片段，其结果连接到字符串中。模板表达式以美元符号 （$） 开头，由名称组成： val i = 10 println(\"i = $i\") // Prints \"i = 10\" 或大括号中的表达式： val s = \"abc\" println(\"$s.length is ${s.length}\") // Prints \"abc.length is 3\" 可以在原始字符串和转义字符串中使用模板。若要在任何允许作为标识符开头的符号（允许作为标识符的开头）之前插入原始字符串（不支持反斜杠转义）中的美元符号 $，请使用以下语法： val price = \"\"\" ${'$'}_9.99 \"\"\" Type checks and casts is and !is operators﻿ Use the is operator or its negated form !is to perform a runtime check that identifies whether an object conforms to a given type: if (obj is String) { print(obj.length) } if (obj !is String) { // same as !(obj is String) print(\"Not a String\") } else { print(obj.length) } Smart casts﻿ In most cases, you don't need to use explicit cast operators in Kotlin because the compiler tracks the is-checks and explicit casts for immutable values and inserts (safe) casts automatically when necessary: fun demo(x: Any) { if (x is String) { print(x.length) // x is automatically cast to String } } The compiler is smart enough to know that a cast is safe if a negative check leads to a return: if (x !is String) return print(x.length) // x is automatically cast to String or if it is on the right-hand side of && or || and the proper check (regular or negative) is on the left-hand side: // x is automatically cast to String on the right-hand side of `||` if (x !is String || x.length == 0) return // x is automatically cast to String on the right-hand side of `&&` if (x is String && x.length > 0) { print(x.length) // x is automatically cast to String } Smart casts work for when expressions and while loops as well: when (x) { is Int -> print(x + 1) is String -> print(x.length + 1) is IntArray -> print(x.sum()) } Note that smart casts work only when the compiler can guarantee that the variable won't change between the check and the usage. More specifically, smart casts can be used under the following conditions: val local variables - always, with the exception of local delegated properties. val properties - if the property is private or internal or if the check is performed in the same module where the property is declared. Smart casts cannot be used on open properties or properties that have custom getters. var local variables - if the variable is not modified between the check and the usage, is not captured in a lambda that modifies it, and is not a local delegated property. var properties - never, because the variable can be modified at any time by other code. \"Unsafe\" cast operator﻿ Usually, the cast operator throws an exception if the cast isn't possible. And so, it's called unsafe. The unsafe cast in Kotlin is done by the infix operator as. val x: String = y as String Note that null cannot be cast to String, as this type is not nullable. If y is null, the code above throws an exception. To make code like this correct for null values, use the nullable type on the right-hand side of the cast: val x: String? = y as String? \"Safe\" (nullable) cast operator﻿ To avoid exceptions, use the safe cast operator as?, which returns null on failure. val x: String? = y as? String Note that despite the fact that the right-hand side of as? is a non-null type String, the result of the cast is nullable. Generics type checks and casts﻿ Please see the corresponding section in the generics documentation page for information on which type checks and casts you can perform with generics. 二、Controlflow Conditions and loops﻿ If expression﻿ In Kotlin, if is an expression: it returns a value. Therefore, there is no ternary operator (condition ? then : else) because ordinary if works fine in this role. var max = a if (a b) { max = a } else { max = b } // As expression val max = if (a > b) a else b Branches of an if expression can be blocks. In this case, the last expression is the value of a block: val max = if (a > b) { print(\"Choose a\") a } else { print(\"Choose b\") b } If you're using if as an expression, for example, for returning its value or assigning it to a variable, the else branch is mandatory. When expression﻿ when defines a conditional expression with multiple branches. It is similar to the switch statement in C-like languages. Its simple form looks like this. when (x) { 1 -> print(\"x == 1\") 2 -> print(\"x == 2\") else -> { print(\"x is neither 1 nor 2\") } } when matches its argument against all branches sequentially until some branch condition is satisfied. when can be used either as an expression or as a statement. If it is used as an expression, the value of the first matching branch becomes the value of the overall expression. If it is used as a statement, the values of individual branches are ignored. Just like with if, each branch can be a block, and its value is the value of the last expression in the block. The else branch is evaluated if none of the other branch conditions are satisfied. If when is used as an expression, the else branch is mandatory, unless the compiler can prove that all possible cases are covered with branch conditions, for example, with enum class entries and sealed class subtypes). enum class Bit { ZERO, ONE } val numericValue = when (getRandomBit()) { Bit.ZERO -> 0 Bit.ONE -> 1 // 'else' is not required because all cases are covered } In when statements, the else branch is mandatory in the following conditions: when has a subject of an Boolean, enum, or sealed type, or their nullable counterparts. branches of when don't cover all possible cases for this subject. enum class Color { RED, GREEN, BLUE } when (getColor()) { Color.RED -> println(\"red\") Color.GREEN -> println(\"green\") Color.BLUE -> println(\"blue\") // 'else' is not required because all cases are covered } when (getColor()) { Color.RED -> println(\"red\") // no branches for GREEN and BLUE else -> println(\"not red\") // 'else' is required } To define a common behavior for multiple cases, combine their conditions in a single line with a comma: when (x) { 0, 1 -> print(\"x == 0 or x == 1\") else -> print(\"otherwise\") } You can use arbitrary expressions (not only constants) as branch conditions when (x) { s.toInt() -> print(\"s encodes x\") else -> print(\"s does not encode x\") } You can also check a value for being in or !in a range or a collection: when (x) { in 1..10 -> print(\"x is in the range\") in validNumbers -> print(\"x is valid\") !in 10..20 -> print(\"x is outside the range\") else -> print(\"none of the above\") } Another option is checking that a value is or !is of a particular type. Note that, due to smart casts, you can access the methods and properties of the type without any extra checks. fun hasPrefix(x: Any) = when(x) { is String -> x.startsWith(\"prefix\") else -> false } when can also be used as a replacement for an if-else if chain. If no argument is supplied, the branch conditions are simply boolean expressions, and a branch is executed when its condition is true: when { x.isOdd() -> print(\"x is odd\") y.isEven() -> print(\"y is even\") else -> print(\"x+y is odd\") } You can capture when subject in a variable using following syntax: fun Request.getBody() = when (val response = executeRequest()) { is Success -> response.body is HttpError -> throw HttpException(response.status) } The scope of variable introduced in when subject is restricted to the body of this when. For loops﻿ The for loop iterates through anything that provides an iterator. This is equivalent to the foreach loop in languages like C#. The syntax of for is the following: for (item in collection) print(item) The body of for can be a block. for (item: Int in ints) { // ... } As mentioned before, for iterates through anything that provides an iterator. This means that it: has a member or an extension function iterator() that returns Iterator<>: has a member or an extension function next() has a member or an extension function hasNext() that returns Boolean. All of these three functions need to be marked as operator. To iterate over a range of numbers, use a range expression: for (i in 1..3) { println(i) } for (i in 6 downTo 0 step 2) { println(i) } Open in Playground → Target: JVMRunning on v.1.8.0 A for loop over a range or an array is compiled to an index-based loop that does not create an iterator object. If you want to iterate through an array or a list with an index, you can do it this way: for (i in array.indices) { println(array[i]) } Open in Playground → Target: JVMRunning on v.1.8.0 Alternatively, you can use the withIndex library function: for ((index, value) in array.withIndex()) { println(\"the element at $index is $value\") } Open in Playground → Target: JVMRunning on v.1.8.0 While loops﻿ while and do-while loops execute their body continuously while their condition is satisfied. The difference between them is the condition checking time: while checks the condition and, if it's satisfied, executes the body and then returns to the condition check. do-while executes the body and then checks the condition. If it's satisfied, the loop repeats. So, the body of do-while executes at least once regardless of the condition. while (x > 0) { x-- } do { val y = retrieveData() } while (y != null) // y is visible here! Break and continue in loops﻿ Kotlin supports traditional break and continue operators in loops. See Returns and jumps. Nothing类 此类型没有值，用于标记永远无法访问的代码位置。在你自己的代码中，你可以使用 Nothing 来标记一个永远不会返回的函数： fun fail(message: String): Nothing { throw IllegalArgumentException(message) } 调用此函数时，编译器将知道执行不会在调用之后继续： val s = person.name ?: fail(\"Name required\") println(s) // 's' is known to be initialized at this point 在处理类型推断时，也可能会遇到此类型。此类型的可为 null 的变体 Nothing？，只有一个可能的值，即 null。如果使用 null 初始化推断类型的值，并且没有其他信息可用于确定更具体的类型，则编译器将推断 Nothing？类型： val x = null // 'x' has type `Nothing?` val l = listOf(null) // 'l' has type `List 三、Packages and imports Packages and imports﻿ A source file may start with a package declaration: package org.example fun printMessage() { /*...*/ } class Message { /*...*/ } // ... All the contents, such as classes and functions, of the source file are included in this package. So, in the example above, the full name of printMessage() is org.example.printMessage, and the full name of Message is org.example.Message. If the package is not specified, the contents of such a file belong to the default package with no name. Default imports﻿ A number of packages are imported into every Kotlin file by default: kotlin.* kotlin.annotation.* kotlin.collections.* kotlin.comparisons.* kotlin.io.* kotlin.ranges.* kotlin.sequences.* kotlin.text.* Additional packages are imported depending on the target platform: JVM: java.lang.* kotlin.jvm.* JS: kotlin.js.* Imports﻿ Apart from the default imports, each file may contain its own import directives. You can import either a single name: import org.example.Message // Message is now accessible without qualification or all the accessible contents of a scope: package, class, object, and so on: import org.example.* // everything in 'org.example' becomes accessible If there is a name clash, you can disambiguate by using as keyword to locally rename the clashing entity: import org.example.Message // Message is accessible import org.test.Message as TestMessage // TestMessage stands for 'org.test.Message' The import keyword is not restricted to importing classes; you can also use it to import other declarations: top-level functions and properties functions and properties declared in object declarations enum constants Visibility of top-level declarations﻿ If a top-level declaration is marked private, it is private to the file it's declared in (see Visibility modifiers). 四、Classes and objects Classes﻿ Classes in Kotlin are declared using the keyword class: class Person { /*...*/ } The class declaration consists of the class name, the class header (specifying its type parameters, the primary constructor, and some other things), and the class body surrounded by curly braces. Both the header and the body are optional; if the class has no body, the curly braces can be omitted. class Empty Constructors﻿ A class in Kotlin can have a primary constructor and one or more secondary constructors. The primary constructor is a part of the class header, and it goes after the class name and optional type parameters. class Person constructor(firstName: String) { /*...*/ } If the primary constructor does not have any annotations or visibility modifiers, the constructor keyword can be omitted: class Person(firstName: String) { /*...*/ } The primary constructor cannot contain any code. Initialization code can be placed in initializer blocks prefixed with the init keyword. During the initialization of an instance, the initializer blocks are executed in the same order as they appear in the class body, interleaved with the property initializers: class InitOrderDemo(name: String) { val firstProperty = \"First property: $name\".also(::println) init { println(\"First initializer block that prints $name\") } val secondProperty = \"Second property: ${name.length}\".also(::println) init { println(\"Second initializer block that prints ${name.length}\") } } Primary constructor parameters can be used in the initializer blocks. They can also be used in property initializers declared in the class body: class Customer(name: String) { val customerKey = name.uppercase() } Kotlin has a concise syntax for declaring properties and initializing them from the primary constructor: class Person(val firstName: String, val lastName: String, var age: Int) Such declarations can also include default values of the class properties: class Person(val firstName: String, val lastName: String, var isEmployed: Boolean = true) You can use a trailing comma when you declare class properties: class Person(................................... val firstName: String, val lastName: String, var age: Int, // trailing comma ) { /*...*/ } Much like regular properties, properties declared in the primary constructor can be mutable (var) or read-only (val). If the constructor has annotations or visibility modifiers, the constructor keyword is required and the modifiers go before it: class Customer public @Inject constructor(name: String) { /*...*/ } Learn more about visibility modifiers. Secondary constructors﻿ A class can also declare secondary constructors, which are prefixed with constructor: class Person(val pets: MutableList = mutableListOf()) class Pet { constructor(owner: Person) { owner.pets.add(this) // adds this pet to the list of its owner's pets } } If the class has a primary constructor, each secondary constructor needs to delegate to the primary constructor, either directly or indirectly through another secondary constructor(s). Delegation to another constructor of the same class is done using the this keyword: class Person(val name: String) { val children: MutableList = mutableListOf() constructor(name: String, parent: Person) : this(name) { parent.children.add(this) } } Code in initialize blocks effectively becomes part of the primary constructor. Delegation to the primary constructor happens as the first statement of a secondary constructor, so the code in all initializer blocks and property initializers is executed before the body of the secondary constructor. Even if the class has no primary constructor, the delegation still happens implicitly, and the initializer blocks are still executed: class Constructors { init { println(\"Init block\") } constructor(i: Int) { println(\"Constructor $i\") } } If a non-abstract class does not declare any constructors (primary or secondary), it will have a generated primary constructor with no arguments. The visibility of the constructor will be public. If you don't want your class to have a public constructor, declare an empty primary constructor with non-default visibility: class DontCreateMe private constructor() { /*...*/ } On the JVM, if all of the primary constructor parameters have default values, the compiler will generate an additional parameterless constructor which will use the default values. This makes it easier to use Kotlin with libraries such as Jackson or JPA that create class instances through parameterless constructors. class Customer(val customerName: String = \"\") Creating instances of classes﻿ To create an instance of a class, call the constructor as if it were a regular function: val invoice = Invoice() val customer = Customer(\"Joe Smith\") Kotlin does not have a new keyword. The process of creating instances of nested, inner, and anonymous inner classes is described in Nested classes. Class members﻿ Classes can contain: Constructors and initializer blocks Functions Properties Nested and inner classes Object declarations Inheritance﻿ Classes can be derived from each other and form inheritance hierarchies. Learn more about inheritance in Kotlin. Abstract classes﻿ A class may be declared abstract, along with some or all of its members. An abstract member does not have an implementation in its class. You don't need to annotate abstract classes or functions with open. abstract class Polygon { abstract fun draw() } class Rectangle : Polygon() { override fun draw() { // draw the rectangle } } You can override a non-abstract open member with an abstract one. open class Polygon { open fun draw() { // some default polygon drawing method } } abstract class WildShape : Polygon() { // Classes that inherit WildShape need to provide their own // draw method instead of using the default on Polygon abstract override fun draw() } Companion objects﻿ If you need to write a function that can be called without having a class instance but that needs access to the internals of a class (such as a factory method), you can write it as a member of an object declaration inside that class. Even more specifically, if you declare a companion object inside your class, you can access its members using only the class name as a qualifier. Properties﻿ Declaring properties﻿ Properties in Kotlin classes can be declared either as mutable, using the var keyword, or as read-only, using the val keyword. class Address { var name: String = \"Holmes, Sherlock\" var street: String = \"Baker\" var city: String = \"London\" var state: String? = null var zip: String = \"123456\" } To use a property, simply refer to it by its name: fun copyAddress(address: Address): Address { val result = Address() // there's no 'new' keyword in Kotlin result.name = address.name // accessors are called result.street = address.street // ... return result } Getters and setters﻿ The full syntax for declaring a property is as follows: var [: ] [= ] [] [] The initializer, getter, and setter are optional. The property type is optional if it can be inferred from the initializer or the getter's return type, as shown below: var initialized = 1 // has type Int, default getter and setter // var allByDefault // ERROR: explicit initializer required, default getter and setter implied The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with val instead of var and does not allow a setter: val simple: Int? // has type Int, default getter, must be initialized in constructor val inferredType = 1 // has type Int and a default getter You can define custom accessors for a property. If you define a custom getter, it will be called every time you access the property (this way you can implement a computed property). Here's an example of a custom getter: class Rectangle(val width: Int, val height: Int) { val area: Int // property type is optional since it can be inferred from the getter's return type get() = this.width * this.height } You can omit the property type if it can be inferred from the getter: val area get() = this.width * this.height If you define a custom setter, it will be called every time you assign a value to the property, except its initialization. A custom setter looks like this: var stringRepresentation: String get() = this.toString() set(value) { setDataFromString(value) // parses the string and assigns values to other properties } By convention, the name of the setter parameter is value, but you can choose a different name if you prefer. If you need to annotate an accessor or change its visibility, but you don't need to change the default implementation, you can define the accessor without defining its body: var setterVisibility: String = \"abc\" private set // the setter is private and has the default implementation var setterWithAnnotation: Any? = null @Inject set // annotate the setter with Inject Backing fields﻿ In Kotlin, a field is only used as a part of a property to hold its value in memory. Fields cannot be declared directly. However, when a property needs a backing field, Kotlin provides it automatically. This backing field can be referenced in the accessors using the field identifier: var counter = 0 // the initializer assigns the backing field directly set(value) { if (value >= 0) field = value // counter = value // ERROR StackOverflow: Using actual name 'counter' would make setter recursive } The field identifier can only be used in the accessors of the property. A backing field will be generated for a property if it uses the default implementation of at least one of the accessors, or if a custom accessor references it through the field identifier. For example, there would be no backing field in the following case: val isEmpty: Boolean get() = this.size == 0 Backing properties﻿ If you want to do something that does not fit into this implicit backing field scheme, you can always fall back to having a backing property: private var _table: Map? = null public val table: Map get() { if (_table == null) { _table = HashMap() // Type parameters are inferred } return _table ?: throw AssertionError(\"Set to null by another thread\") } On the JVM: Access to private properties with default getters and setters is optimized to avoid function call overhead. Compile-time constants﻿ If the value of a read-only property is known at compile time, mark it as a compile time constant using the const modifier. Such a property needs to fulfil the following requirements: It must be a top-level property, or a member of an object declaration or a companion object. It must be initialized with a value of type String or a primitive type It cannot be a custom getter The compiler will inline usages of the constant, replacing the reference to the constant with its actual value. However, the field will not be removed and therefore can be interacted with using reflection. Such properties can also be used in annotations: const val SUBSYSTEM_DEPRECATED: String = \"This subsystem is deprecated\" @Deprecated(SUBSYSTEM_DEPRECATED) fun foo() { ... } Late-initialized properties and variables﻿ Normally, properties declared as having a non-null type must be initialized in the constructor. However, it is often the case that doing so is not convenient. For example, properties can be initialized through dependency injection, or in the setup method of a unit test. In these cases, you cannot supply a non-null initializer in the constructor, but you still want to avoid null checks when referencing the property inside the body of a class. To handle such cases, you can mark the property with the lateinit modifier: public class MyTest { lateinit var subject: TestSubject @SetUp fun setup() { subject = TestSubject() } @Test fun test() { subject.method() // dereference directly } } This modifier can be used on var properties declared inside the body of a class (not in the primary constructor, and only when the property does not have a custom getter or setter), as well as for top-level properties and local variables. The type of the property or variable must be non-null, and it must not be a primitive type. Accessing a lateinit property before it has been initialized throws a special exception that clearly identifies the property being accessed and the fact that it hasn't been initialized. Checking whether a lateinit var is initialized﻿ To check whether a lateinit var has already been initialized, use .isInitialized on the reference to that property: if (foo::bar.isInitialized) { println(foo.bar) } This check is only available for properties that are lexically accessible when declared in the same type, in one of the outer types, or at top level in the same file. Overriding properties﻿ See Overriding properties Delegated properties﻿ The most common kind of property simply reads from (and maybe writes to) a backing field, but custom getters and setters allow you to use properties so one can implement any sort of behavior of a property. Somewhere in between the simplicity of the first kind and variety of the second, there are common patterns for what properties can do. A few examples: lazy values, reading from a map by a given key, accessing a database, notifying a listener on access. Such common behaviors can be implemented as libraries using delegated properties. Extensions﻿ Kotlin provides the ability to extend a class or an interface with new functionality without having to inherit from the class or use design patterns such as Decorator. This is done via special declarations called extensions. For example, you can write new functions for a class or an interface from a third-party library that you can't modify. Such functions can be called in the usual way, as if they were methods of the original class. This mechanism is called an extension function. There are also extension properties that let you define new properties for existing classes. Extension functions﻿ To declare an extension function, prefix its name with a receiver type, which refers to the type being extended. The following adds a swap function to MutableList: fun MutableList.swap(index1: Int, index2: Int) { val tmp = this[index1] // 'this' corresponds to the list this[index1] = this[index2] this[index2] = tmp } The this keyword inside an extension function corresponds to the receiver object (the one that is passed before the dot). Now, you can call such a function on any MutableList: val list = mutableListOf(1, 2, 3) list.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'list' This function makes sense for any MutableList, and you can make it generic: fun MutableList.swap(index1: Int, index2: Int) { val tmp = this[index1] // 'this' corresponds to the list this[index1] = this[index2] this[index2] = tmp } You need to declare the generic type parameter before the function name to make it available in the receiver type expression. For more information about generics, see generic functions. Extensions are resolved statically﻿ Extensions do not actually modify the classes they extend. By defining an extension, you are not inserting new members into a class, only making new functions callable with the dot-notation on variables of this type. Extension functions are dispatched statically, which means they are not virtual by receiver type. An extension function being called is determined by the type of the expression on which the function is invoked, not by the type of the result from evaluating that expression at runtime. For example: open class Shape class Rectangle: Shape() fun Shape.getName() = \"Shape\" fun Rectangle.getName() = \"Rectangle\" fun printClassName(s: Shape) { println(s.getName()) } printClassName(Rectangle()) This example prints Shape, because the extension function called depends only on the declared type of the parameter s, which is the Shape class. If a class has a member function, and an extension function is defined which has the same receiver type, the same name, and is applicable to given arguments, the member always wins. For example: class Example { fun printFunctionType() { println(\"Class method\") } } fun Example.printFunctionType() { println(\"Extension function\") } Example().printFunctionType() This code prints Class method. However, it's perfectly OK for extension functions to overload member functions that have the same name but a different signature: class Example { fun printFunctionType() { println(\"Class method\") } } fun Example.printFunctionType(i: Int) { println(\"Extension function #$i\") } Example().printFunctionType(1) Nullable receiver﻿ Note that extensions can be defined with a nullable receiver type. These extensions can be called on an object variable even if its value is null, and they can check for this == null inside the body. This way, you can call toString() in Kotlin without checking for null, as the check happens inside the extension function: fun Any?.toString(): String { if (this == null) return \"null\" // after the null check, 'this' is autocast to a non-null type, so the toString() below // resolves to the member function of the Any class return toString() } Extension properties﻿ Kotlin supports extension properties much like it supports functions: val List.lastIndex: Int get() = size - 1 Since extensions do not actually insert members into classes, there's no efficient way for an extension property to have a backing field. This is why initializers are not allowed for extension properties. Their behavior can only be defined by explicitly providing getters/setters. Example: val House.number = 1 // error: initializers are not allowed for extension properties Companion object extensions﻿ If a class has a companion object defined, you can also define extension functions and properties for the companion object. Just like regular members of the companion object, they can be called using only the class name as the qualifier: class MyClass { companion object { } // will be called \"Companion\" } fun MyClass.Companion.printCompanion() { println(\"companion\") } fun main() { MyClass.printCompanion() } Scope of extensions﻿ In most cases, you define extensions on the top level, directly under packages: package org.example.declarations fun List.getLongestString() { /*...*/} To use an extension outside its declaring package, import it at the call site: package org.example.usage import org.example.declarations.getLongestString fun main() { val list = listOf(\"red\", \"green\", \"blue\") list.getLongestString() } See Imports for more information. Declaring extensions as members﻿ You can declare extensions for one class inside another class. Inside such an extension, there are multiple implicit receivers - objects whose members can be accessed without a qualifier. An instance of a class in which the extension is declared is called a dispatch receiver, and an instance of the receiver type of the extension method is called an extension receiver. class Host(val hostname: String) { fun printHostname() { print(hostname) } } class Connection(val host: Host, val port: Int) { fun printPort() { print(port) } fun Host.printConnectionString() { printHostname() // calls Host.printHostname() print(\":\") printPort() // calls Connection.printPort() } fun connect() { /*...*/ host.printConnectionString() // calls the extension function } } fun main() { Connection(Host(\"kotl.in\"), 443).connect() //Host(\"kotl.in\").printConnectionString() // error, the extension function is unavailable outside Connection } In the event of a name conflict between the members of a dispatch receiver and an extension receiver, the extension receiver takes precedence. To refer to the member of the dispatch receiver, you can use the qualified this syntax. class Connection { fun Host.getConnectionString() { toString() // calls Host.toString() this@Connection.toString() // calls Connection.toString() } } Extensions declared as members can be declared as open and overridden in subclasses. This means that the dispatch of such functions is virtual with regard to the dispatch receiver type, but static with regard to the extension receiver type. open class Base { } class Derived : Base() { } open class BaseCaller { open fun Base.printFunctionInfo() { println(\"Base extension function in BaseCaller\") } open fun Derived.printFunctionInfo() { println(\"Derived extension function in BaseCaller\") } fun call(b: Base) { b.printFunctionInfo() // call the extension function } } class DerivedCaller: BaseCaller() { override fun Base.printFunctionInfo() { println(\"Base extension function in DerivedCaller\") } override fun Derived.printFunctionInfo() { println(\"Derived extension function in DerivedCaller\") } } fun main() { BaseCaller().call(Base()) // \"Base extension function in BaseCaller\" DerivedCaller().call(Base()) // \"Base extension function in DerivedCaller\" - dispatch receiver is resolved virtually DerivedCaller().call(Derived()) // \"Base extension function in DerivedCaller\" - extension receiver is resolved statically } Note on visibility﻿ Extensions utilize the same visibility modifiers as regular functions declared in the same scope would. For example: An extension declared at the top level of a file has access to the other private top-level declarations in the same file. If an extension is declared outside its receiver type, it cannot access the receiver's private or protected members. Data classes﻿ It is not unusual to create classes whose main purpose is to hold data. In such classes, some standard functionality and some utility functions are often mechanically derivable from the data. In Kotlin, these are called data classes and are marked with data: data class User(val name: String, val age: Int) The compiler automatically derives the following members from all properties declared in the primary constructor: equals()/hashCode() pair toString() of the form \"User(name=John, age=42)\" componentN() functions corresponding to the properties in their order of declaration. copy() function (see below). To ensure consistency and meaningful behavior of the generated code, data classes have to fulfill the following requirements: The primary constructor needs to have at least one parameter. All primary constructor parameters need to be marked as val or var. Data classes cannot be abstract, open, sealed, or inner. Additionally, the generation of data class members follows these rules with regard to the members' inheritance: If there are explicit implementations of equals(), hashCode(), or toString() in the data class body or final implementations in a superclass, then these functions are not generated, and the existing implementations are used. If a supertype has componentN() functions that are open and return compatible types, the corresponding functions are generated for the data class and override those of the supertype. If the functions of the supertype cannot be overridden due to incompatible signatures or due to their being final, an error is reported. Providing explicit implementations for the componentN() and copy() functions is not allowed. Data classes may extend other classes (see Sealed classes for examples). On the JVM, if the generated class needs to have a parameterless constructor, default values for the properties have to be specified (see Constructors). data class User(val name: String = \"\", val age: Int = 0) Properties declared in the class body﻿ The compiler only uses the properties defined inside the primary constructor for the automatically generated functions. To exclude a property from the generated implementations, declare it inside the class body: data class Person(val name: String) { var age: Int = 0 } Only the property name will be used inside the toString(), equals(), hashCode(), and copy() implementations, and there will only be one component function component1(). While two Person objects can have different ages, they will be treated as equal. val person1 = Person(\"John\") val person2 = Person(\"John\") person1.age = 10 person2.age = 20 Open in Playground → Target: JVMRunning on v.1.8.0 Copying﻿ Use the copy() function to copy an object, allowing you to alter some of its properties while keeping the rest unchanged. The implementation of this function for the User class above would be as follows: fun copy(name: String = this.name, age: Int = this.age) = User(name, age) You can then write the following: val jack = User(name = \"Jack\", age = 1) val olderJack = jack.copy(age = 2) Data classes and destructuring declarations﻿ Component functions generated for data classes make it possible to use them in destructuring declarations: val jane = User(\"Jane\", 35) val (name, age) = jane println(\"$name, $age years of age\") // prints \"Jane, 35 years of age\" Standard data classes﻿ The standard library provides the Pair and Triple classes. In most cases, though, named data classes are a better design choice because they make the code more readable by providing meaningful names for the properties. Sealed classes﻿ Sealed classes and interfaces represent restricted class hierarchies that provide more control over inheritance. All direct subclasses of a sealed class are known at compile time. No other subclasses may appear outside a module within which the sealed class is defined. For example, third-party clients can't extend your sealed class in their code. Thus, each instance of a sealed class has a type from a limited set that is known when this class is compiled. The same works for sealed interfaces and their implementations: once a module with a sealed interface is compiled, no new implementations can appear. In some sense, sealed classes are similar to enum classes: the set of values for an enum type is also restricted, but each enum constant exists only as a single instance, whereas a subclass of a sealed class can have multiple instances, each with its own state. As an example, consider a library's API. It's likely to contain error classes to let the library users handle errors that it can throw. If the hierarchy of such error classes includes interfaces or abstract classes visible in the public API, then nothing prevents implementing or extending them in the client code. However, the library doesn't know about errors declared outside it, so it can't treat them consistently with its own classes. With a sealed hierarchy of error classes, library authors can be sure that they know all possible error types and no other ones can appear later. To declare a sealed class or interface, put the sealed modifier before its name: sealed interface Error sealed class IOError(): Error class FileReadError(val file: File): IOError() class DatabaseError(val source: DataSource): IOError() object RuntimeError : Error A sealed class is abstract by itself, it cannot be instantiated directly and can have abstract members. Constructors of sealed classes can have one of two visibilities: protected (by default) or private: sealed class IOError { constructor() { /*...*/ } // protected by default private constructor(description: String): this() { /*...*/ } // private is OK // public constructor(code: Int): this() {} // Error: public and internal are not allowed } Location of direct subclasses﻿ Direct subclasses of sealed classes and interfaces must be declared in the same package. They may be top-level or nested inside any number of other named classes, named interfaces, or named objects. Subclasses can have any visibility as long as they are compatible with normal inheritance rules in Kotlin. Subclasses of sealed classes must have a proper qualified name. They can't be local nor anonymous objects. enum classes can't extend a sealed class (as well as any other class), but they can implement sealed interfaces. These restrictions don't apply to indirect subclasses. If a direct subclass of a sealed class is not marked as sealed, it can be extended in any way that its modifiers allow: sealed interface Error // has implementations only in same package and module sealed class IOError(): Error // extended only in same package and module open class CustomError(): Error // can be extended wherever it's visible Inheritance in multiplatform projects﻿ There is one more inheritance restriction in multiplatform projects: direct subclasses of sealed classes must reside in the same source set. It applies to sealed classes without the expect and actual modifiers. If a sealed class is declared as expect in a common source set and have actual implementations in platform source sets, both expect and actual versions can have subclasses in their source sets. Moreover, if you use a hierarchical structure, you can create subclasses in any source set between the expect and actual declarations. Learn more about the hierarchical structure of multiplatform projects. Sealed classes and when expression﻿ The key benefit of using sealed classes comes into play when you use them in a when expression. If it's possible to verify that the statement covers all cases, you don't need to add an else clause to the statement: fun log(e: Error) = when(e) { is FileReadError -> { println(\"Error while reading file ${e.file}\") } is DatabaseError -> { println(\"Error while reading from database ${e.source}\") } is RuntimeError -> { println(\"Runtime error\") } // the `else` clause is not required because all the cases are covered } when expressions on expect sealed classes in the common code of multiplatform projects still require an else branch. This happens because subclasses of actual platform implementations aren't known in the common code. Object expressions and declarations﻿ Sometimes you need to create an object that is a slight modification of some class, without explicitly declaring a new subclass for it. Kotlin can handle this with object expressions and object declarations. Object expressions﻿ Object expressions create objects of anonymous classes, that is, classes that aren't explicitly declared with the class declaration. Such classes are useful for one-time use. You can define them from scratch, inherit from existing classes, or implement interfaces. Instances of anonymous classes are also called anonymous objects because they are defined by an expression, not a name. Creating anonymous objects from scratch﻿ Object expressions start with the object keyword. If you just need an object that doesn't have any nontrivial supertypes, write its members in curly braces after object: val helloWorld = object { val hello = \"Hello\" val world = \"World\" // object expressions extend Any, so `override` is required on `toString()` override fun toString() = \"$hello $world\" } Open in Playground → Target: JVMRunning on v.1.8.10 Inheriting anonymous objects from supertypes﻿ To create an object of an anonymous class that inherits from some type (or types), specify this type after object and a colon (:). Then implement or override the members of this class as if you were inheriting from it: window.addMouseListener(object : MouseAdapter() { override fun mouseClicked(e: MouseEvent) { /*...*/ } override fun mouseEntered(e: MouseEvent) { /*...*/ } }) If a supertype has a constructor, pass appropriate constructor parameters to it. Multiple supertypes can be specified as a comma-delimited list after the colon: open class A(x: Int) { public open val y: Int = x } interface B { /*...*/ } val ab: A = object : A(1), B { override val y = 15 } Using anonymous objects as return and value types﻿ When an anonymous object is used as a type of a local or private but not inline declaration (function or property), all its members are accessible via this function or property: class C { private fun getObject() = object { val x: String = \"x\" } fun printX() { println(getObject().x) } } If this function or property is public or private inline, its actual type is: Any if the anonymous object doesn't have a declared supertype The declared supertype of the anonymous object, if there is exactly one such type The explicitly declared type if there is more than one declared supertype In all these cases, members added in the anonymous object are not accessible. Overridden members are accessible if they are declared in the actual type of the function or property: interface A { fun funFromA() {} } interface B class C { // The return type is Any. x is not accessible fun getObject() = object { val x: String = \"x\" } // The return type is A; x is not accessible fun getObjectA() = object: A { override fun funFromA() {} val x: String = \"x\" } // The return type is B; funFromA() and x are not accessible fun getObjectB(): B = object: A, B { // explicit return type is required override fun funFromA() {} val x: String = \"x\" } } Accessing variables from anonymous objects﻿ The code in object expressions can access variables from the enclosing scope: fun countClicks(window: JComponent) { var clickCount = 0 var enterCount = 0 window.addMouseListener(object : MouseAdapter() { override fun mouseClicked(e: MouseEvent) { clickCount++ } override fun mouseEntered(e: MouseEvent) { enterCount++ } }) // ... } Object declarations﻿ The Singleton pattern can be useful in several cases, and Kotlin makes it easy to declare singletons: object DataProviderManager { fun registerDataProvider(provider: DataProvider) { // ... } val allDataProviders: Collection get() = // ... } This is called an object declaration, and it always has a name following the object keyword. Just like a variable declaration, an object declaration is not an expression, and it cannot be used on the right-hand side of an assignment statement. The initialization of an object declaration is thread-safe and done on first access. To refer to the object, use its name directly: DataProviderManager.registerDataProvider(...) Such objects can have supertypes: object DefaultListener : MouseAdapter() { override fun mouseClicked(e: MouseEvent) { ... } override fun mouseEntered(e: MouseEvent) { ... } } Object declarations can't be local (that is, they can't be nested directly inside a function), but they can be nested into other object declarations or non-inner classes. Data objects﻿ Data object declarations is an Experimental feature. It may be dropped or changed at any time. Opt-in is required with the compilerOptions.languageVersion.set(KotlinVersion.KOTLIN_1_9) compiler option. When printing a plain object declaration in Kotlin, you'll notice that its string representation contains both its name and the hash of the object: object MyObject fun main() { println(MyObject) // MyObject@1f32e575 } Just like data classes, you can mark your object declaration with the data modifier to get a nicely formatted string representation without having to manually provide an implementation for its toString function: data object MyObject fun main() { println(MyObject) // MyObject } Sealed class hierarchies are a particularly good fit for data object declarations, since they allow you to maintain symmetry with any data classes you might have defined alongside the object: sealed class ReadResult { data class Number(val value: Int): ReadResult() data class Text(val value: String): ReadResult() data object EndOfFile: ReadResult() } fun main() { println(ReadResult.Number(1)) // Number(value=1) println(ReadResult.Text(\"Foo\")) // Text(value=Foo) println(ReadResult.EndOfFile) // EndOfFile } Companion objects﻿ An object declaration inside a class can be marked with the companion keyword: class MyClass { companion object Factory { fun create(): MyClass = MyClass() } } Members of the companion object can be called simply by using the class name as the qualifier: val instance = MyClass.create() The name of the companion object can be omitted, in which case the name Companion will be used: class MyClass { companion object { } } val x = MyClass.Companion Class members can access the private members of the corresponding companion object. The name of a class used by itself (not as a qualifier to another name) acts as a reference to the companion object of the class (whether named or not): class MyClass1 { companion object Named { } } val x = MyClass1 class MyClass2 { companion object { } } val y = MyClass2 Note that even though the members of companion objects look like static members in other languages, at runtime those are still instance members of real objects, and can, for example, implement interfaces: interface Factory { fun create(): T } class MyClass { companion object : Factory { override fun create(): MyClass = MyClass() } } val f: Factory = MyClass However, on the JVM you can have members of companion objects generated as real static methods and fields if you use the @JvmStatic annotation. See the Java interoperability section for more detail. Semantic difference between object expressions and declarations﻿ There is one important semantic difference between object expressions and object declarations: Object expressions are executed (and initialized) immediately, where they are used. Object declarations are initialized lazily, when accessed for the first time. A companion object is initialized when the corresponding class is loaded (resolved) that matches the semantics of a Java static initializer. 04_Functions Functions 方法声明 一个具有两个Int类型的参数和一个Int类型的返回值的函数： fun sum(a: Int, b: Int): Int { return a + b } 一个方法的主体也可以使用表达式，返回值程序自行推定： fun sum(a: Int, b: Int) = a + b 可以没有返回值也可以不定义返回值类型，直接省略到例子一中的\":Int\" 默认参数 方法参数可以指定默认值，调用方法的时候可以跳过有默认值的参数： fun read( b: ByteArray, off: Int = 0, len: Int = b.size, ) { /*...*/ } 重写的方法始终使用基方法的默认参数，重写具有默认参数值的方法时，必须从签名中省略默认参数值： open class A { open fun foo(i: Int = 10) { /*...*/ } } class B : A() { override fun foo(i: Int) { /*...*/ } // No default value is allowed. } 如果默认参数位于没有默认值的参数之前，则只能通过使用命名参数调用函数来使用默认值： fun foo( bar: Int = 0, baz: Int, ) { /*...*/ } foo(baz = 1) // The default value bar = 0 is used 如果默认参数后面的最后一个参数是 lambda，则可以将其作为命名参数传递或在括号外传递：？？？？？？？？？？？看不懂？？？？？？？？？？？？ fun foo( bar: Int = 0, baz: Int = 1, qux: () -> Unit, ) { /*...*/ } foo(1) { println(\"hello\") } // Uses the default value baz = 1 foo(qux = { println(\"hello\") }) // Uses both default values bar = 0 and baz = 1 foo { println(\"hello\") } // Uses both default values bar = 0 and baz = 1 空类型安全 可以为空的类型和不可以为空的类型 Kotlin 中 NPE （NullPointerException）的唯一可能原因是： 直接调用 throw NullPointerException() 使用!!运算符 与初始化相关的数据不一致，例如： 构造函数中可用的未初始化的this在某处传递和使用（“泄漏this”）。 父类构造函数调用一个开放成员，该成员在派生类中未初始化。 与Java的交互操作： 尝试访问平台类型的空引用的成员; 用于 Java 互操作的泛型类型的可空性问题。例如，一段 Java 代码可能会将 null 添加到 Kotlin MutableList 中，因此需要一个 MutableList 来处理它。 外部 Java 代码导致的其他问题。 在 Kotlin 中，类型系统区分可以保存 null 的引用（可为空的引用）和不能保存 null 的引用（非空引用）。例如，字符串类型的常规变量不能保存 null： var a: String = \"abc\" // Regular initialization means non-null by default a = null // compilation error 要允许空值，您可以通过编写 String？： var b: String? = \"abc\" // can be set to null b = null // ok print(b) 安全调用 访问可为空变量的属性的第二个选项是使用安全调用运算符 ？.： val a = \"Kotlin\" val b: String? = null println(b?.length) println(a?.length) // Unnecessary safe call Safe calls are useful in chains. bob?.department?.head?.name To perform a certain operation only for non-null values, you can use the safe call operator together with let: val listWithNulls: List = listOf(\"Kotlin\", null) for (item in listWithNulls) { item?.let { println(it) } // prints Kotlin and ignores null } A safe call can also be placed on the left side of an assignment. Then, if one of the receivers in the safe calls chain is null, the assignment is skipped and the expression on the right is not evaluated at all: // If either `person` or `person.department` is null, the function is not called: person?.department?.head = managersPool.getManager() Lambdas max(strings, { a, b -> a.length 上面的表达式等同于 fun compare(a: String, b: String): Boolean = a.length Lambda表达式的语法 val sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y } lambda 表达式始终由大括号括起来。 完整语法形式的参数声明位于大括号内，函数类型可选。 函数主体在 -> 之后。 如果 lambda 的推断返回类型不是 Unit，则 lambda 函数主体中的最后一个（或可能是单个）表达式将被视为返回值。 如果所有的可选项都不启用，那么lambda表达式会看起来像下面这样： val sum = { x: Int, y: Int -> x + y } Passing trailing lambdas﻿ 根据 Kotlin 约定，如果函数的最后一个参数是函数，那么作为相应参数传递的 lambda 表达式可以放在括号之外： val product = items.fold(1) { acc, e -> acc * e } 如果 lambda 是该调用中的唯一参数，则可以完全省略括号： run { println(\"...\") } it：单个参数的隐式名称 lambda 表达式只有一个参数是很常见的。 如果编译器可以在没有任何参数的情况下解析签名，则不需要声明该参数，并且可以省略 ->。该参数将在名称 it 下隐式声明： ints.filter { it > 0 } // this literal is of type '(it: Int) -> Boolean' lambda的返回值 您可以使用限定的返回语法从 lambda 显式返回值。否则，将隐式返回最后一个表达式的值。 因此，以下两个代码段是等效的： ints.filter { val shouldFilter = it > 0 shouldFilter } ints.filter { val shouldFilter = it > 0 return@filter shouldFilter } 此约定以及将 lambda 表达式传递到括号外，允许使用 LINQ 样式（链式调用）的代码： strings.filter { it.length == 5 }.sortedBy { it }.map { it.uppercase() } 未使用变量的下划线 如果未使用 lambda 参数，则可以放置下划线而不是其名称： map.forEach { (_, value) -> println(\"$value!\") } Destructuring in lambdas﻿ Destructuring in lambdas is described as a part of destructuring declarations. 匿名函数 上面的 lambda 表达式语法缺少一件事 - 指定函数返回类型的能力。在大多数情况下，这是不必要的，因为可以自动推断返回类型。但是，如果确实需要显式指定它，则可以使用替代语法：匿名函数。 fun(x: Int, y: Int): Int = x + y 匿名函数看起来非常类似于常规函数声明，只是省略了它的名称。它的主体可以是表达式（如上所示）或块： fun(x: Int, y: Int): Int { return x + y } 参数和返回类型的指定方式与常规函数的指定方式相同，但如果可以从上下文中推断参数类型，则可以省略这些参数类型： ints.filter(fun(item) = item > 0) 匿名函数的返回类型推断的工作方式与普通函数类似：对于具有表达式主体的匿名函数，返回类型是自动推断的，但对于具有块体的匿名函数，必须显式指定（或假定为 Unit）。 将匿名函数作为参数传递时，请将它们放在括号内。允许您将函数保留在括号外的速记语法仅适用于 lambda 表达式。 lambda 表达式和匿名函数之间的另一个区别是非本地返回的行为。不带标签的 return 语句始终从使用 fun 关键字声明的函数返回。这意味着 lambda 表达式中的返回将从封闭函数返回，而匿名函数内的返回将从匿名函数本身返回。 闭包 lambda 表达式或匿名函数（以及本地函数和对象表达式）可以访问其闭包，其中包括在外部作用域中声明的变量。闭包中捕获的变量可以在 lambda 中修改： var sum = 0 ints.filter { it > 0 }.forEach { sum += it } print(sum) 带接收器的函数文本 带有接收器的函数类型，例如 A.（B） -> C，可以使用特殊形式的函数文字 - 带有接收器的函数文字进行实例化。 如上所述，Kotlin 提供了在提供接收器对象的同时调用带有接收器的函数类型的实例的能力。 在函数文本的主体中，传递给调用的接收器对象成为隐式 this，以便无需任何其他限定符即可访问该接收器对象的成员，或使用 this 表达式访问接收器对象。 此行为类似于扩展函数的行为，扩展函数还允许您访问函数体内接收器对象的成员。 下面是一个带有接收器及其类型的函数文本的示例，其中在接收器对象上调用 plus： val sum: Int.(Int) -> Int = { other -> plus(other) } 匿名函数语法允许您直接指定函数文本的接收器类型。如果您需要使用 receiver 声明函数类型的变量，然后稍后使用它，这会很有用。 val sum = fun Int.(other: Int): Int = this + other 当可以从上下文推断接收器类型时，Lambda 表达式可以用作带有接收器的函数文本。它们使用的最重要示例之一是类型安全的构建器： class HTML { fun body() { ... } } fun html(init: HTML.() -> Unit): HTML { val html = HTML() // create the receiver object html.init() // pass the receiver object to the lambda return html } html { // lambda with receiver begins here body() // calling a method on the receiver object } Operator overloading﻿ Kotlin allows you to provide custom implementations for the predefined set of operators on types. These operators have predefined symbolic representation (like + or *) and precedence. To implement an operator, provide a member function or an extension function with a specific name for the corresponding type. This type becomes the left-hand side type for binary operations and the argument type for the unary ones. To overload an operator, mark the corresponding function with the operator modifier: interface IndexedContainer { operator fun get(index: Int) } When overriding your operator overloads, you can omit operator: class OrdersList: IndexedContainer { override fun get(index: Int) { /*...*/ } } Unary operations﻿ Unary prefix operators﻿ Expression Translated to +a a.unaryPlus() -a a.unaryMinus() !a a.not() This table says that when the compiler processes, for example, an expression +a, it performs the following steps: Determines the type of a, let it be T. Looks up a function unaryPlus() with the operator modifier and no parameters for the receiver T, that means a member function or an extension function. If the function is absent or ambiguous, it is a compilation error. If the function is present and its return type is R, the expression +a has type R. These operations, as well as all the others, are optimized for basic types and do not introduce overhead of function calls for them. As an example, here's how you can overload the unary minus operator: data class Point(val x: Int, val y: Int) operator fun Point.unaryMinus() = Point(-x, -y) val point = Point(10, 20) fun main() { println(-point) // prints \"Point(x=-10, y=-20)\" } Increments and decrements﻿ Expression Translated to a++ a.inc() + see below a-- a.dec() + see below The inc() and dec() functions must return a value, which will be assigned to the variable on which the ++ or -- operation was used. They shouldn't mutate the object on which the inc or dec was invoked. The compiler performs the following steps for resolution of an operator in the postfix form, for example a++: Determines the type of a, let it be T. Looks up a function inc() with the operator modifier and no parameters, applicable to the receiver of type T. Checks that the return type of the function is a subtype of T. The effect of computing the expression is: Store the initial value of a to a temporary storage a0. Assign the result of a0.inc() to a. Return a0 as the result of the expression. For a-- the steps are completely analogous. For the prefix forms ++a and --a resolution works the same way, and the effect is: Assign the result of a.inc() to a. Return the new value of a as a result of the expression. Binary operations﻿ Arithmetic operators﻿ Expression Translated to a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.rem(b) a..b a.rangeTo(b) For the operations in this table, the compiler just resolves the expression in the Translated to column. Below is an example Counter class that starts at a given value and can be incremented using the overloaded + operator: data class Counter(val dayIndex: Int) { operator fun plus(increment: Int): Counter { return Counter(dayIndex + increment) } } in operator﻿ Expression Translated to a in b b.contains(a) a !in b !b.contains(a) For in and !in the procedure is the same, but the order of arguments is reversed. Indexed access operator﻿ Expression Translated to a[i] a.get(i) a[i, j] a.get(i, j) a[i_1, ..., i_n] a.get(i_1, ..., i_n) a[i] = b a.set(i, b) a[i, j] = b a.set(i, j, b) a[i_1, ..., i_n] = b a.set(i_1, ..., i_n, b) Square brackets are translated to calls to get and set with appropriate numbers of arguments. invoke operator﻿ Expression Translated to a() a.invoke() a(i) a.invoke(i) a(i, j) a.invoke(i, j) a(i_1, ..., i_n) a.invoke(i_1, ..., i_n) Parentheses are translated to calls to invoke with appropriate number of arguments. Augmented assignments﻿ Expression Translated to a += b a.plusAssign(b) a -= b a.minusAssign(b) a *= b a.timesAssign(b) a /= b a.divAssign(b) a %= b a.remAssign(b) For the assignment operations, for example a += b, the compiler performs the following steps: If the function from the right column is available: If the corresponding binary function (that means plus() for plusAssign()) is available too, a is a mutable variable, and the return type of plus is a subtype of the type of a, report an error (ambiguity). Make sure its return type is Unit, and report an error otherwise. Generate code for a.plusAssign(b). Otherwise, try to generate code for a = a + b (this includes a type check: the type of a + b must be a subtype of a). Assignments are NOT expressions in Kotlin. Equality and inequality operators﻿ Expression Translated to a == b a?.equals(b) ?: (b === null) a != b !(a?.equals(b) ?: (b === null)) These operators only work with the function equals(other: Any?): Boolean, which can be overridden to provide custom equality check implementation. Any other function with the same name (like equals(other: Foo)) will not be called. === and !== (identity checks) are not overloadable, so no conventions exist for them. The == operation is special: it is translated to a complex expression that screens for null's. null == null is always true, and x == null for a non-null x is always false and won't invoke x.equals(). Comparison operators﻿ Expression Translated to a > b a.compareTo(b) > 0 a a.compareTo(b) a >= b a.compareTo(b) >= 0 a a.compareTo(b) All comparisons are translated into calls to compareTo, that is required to return Int. Property delegation operators﻿ provideDelegate, getValue and setValue operator functions are described in Delegated properties. Infix calls for named functions﻿ You can simulate custom infix operations by using infix function calls. 05_StandardLibrary Collections Ranges and progressions﻿ Kotlin lets you easily create ranges of values using the rangeTo() function from the kotlin.ranges package and its operator form ... Usually, rangeTo() is complemented by in or !in functions. if (i in 1..4) { // equivalent of i >= 1 && i Integral type ranges (IntRange, LongRange, CharRange) have an extra feature: they can be iterated over. These ranges are also progressions of the corresponding integral types. Such ranges are generally used for iteration in for loops. for (i in 1..4) print(i) To iterate numbers in reverse order, use the downTo function instead of ... for (i in 4 downTo 1) print(i) It is also possible to iterate over numbers with an arbitrary step (not necessarily 1). This is done via the step function. for (i in 1..8 step 2) print(i) println() for (i in 8 downTo 1 step 2) print(i) To iterate a number range which does not include its end element, use the until function: for (i in 1 until 10) { // i in 1 until 10, excluding 10 print(i) } Range﻿ A range defines a closed interval in the mathematical sense: it is defined by its two endpoint values which are both included in the range. Ranges are defined for comparable types: having an order, you can define whether an arbitrary instance is in the range between two given instances. The main operation on ranges is contains, which is usually used in the form of in and !in operators. To create a range for your class, call the rangeTo() function on the range start value and provide the end value as an argument. rangeTo() is often called in its operator form ... val versionRange = Version(1, 11)..Version(1, 30) println(Version(0, 9) in versionRange) println(Version(1, 20) in versionRange) Progression﻿ As shown in the examples above, the ranges of integral types, such as Int, Long, and Char, can be treated as arithmetic progressions of them. In Kotlin, these progressions are defined by special types: IntProgression, LongProgression, and CharProgression. Progressions have three essential properties: the first element, the last element, and a non-zero step. The first element is first, subsequent elements are the previous element plus a step. Iteration over a progression with a positive step is equivalent to an indexed for loop in Java/JavaScript. for (int i = first; i When you create a progression implicitly by iterating a range, this progression's first and last elements are the range's endpoints, and the step is 1. for (i in 1..10) print(i) To define a custom progression step, use the step function on a range. for (i in 1..8 step 2) print(i) The last element of the progression is calculated this way: For a positive step: the maximum value not greater than the end value such that (last - first) % step == 0. For a negative step: the minimum value not less than the end value such that (last - first) % step == 0. Thus, the last element is not always the same as the specified end value. for (i in 1..9 step 3) print(i) // the last element is 7 To create a progression for iterating in reverse order, use downTo instead of .. when defining the range for it. for (i in 4 downTo 1) print(i) If you already have a progression, you can iterate it in reverse order with the reversed function: for (i in (1..4).reversed()) print(i) Progressions implement Iterable, where N is Int, Long, or Char respectively, so you can use them in various collection functions like map, filter, and other. println((1..10).filter { it % 2 == 0 }) No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Kotlin/Kotlin-StandardLibrary.html":{"url":"03_语言/Kotlin/Kotlin-StandardLibrary.html","title":"Kotlin-standardlibrary","keywords":"","body":"Collections Overview The Kotlin Standard Library provides a comprehensive set of tools for managing collections – groups of a variable number of items (possibly zero) that are significant to the problem being solved and are commonly operated on. Collections are a common concept for most programming languages, so if you're familiar with, for example, Java or Python collections, you can skip this introduction and proceed to the detailed sections. A collection usually contains a number of objects (this number may also be zero) of the same type. Objects in a collection are called elements or items. For example, all the students in a department form a collection that can be used to calculate their average age. The following collection types are relevant for Kotlin: List is an ordered collection with access to elements by indices – integer numbers that reflect their position. Elements can occur more than once in a list. An example of a list is a telephone number: it's a group of digits, their order is important, and they can repeat. Set is a collection of unique elements. It reflects the mathematical abstraction of set: a group of objects without repetitions. Generally, the order of set elements has no significance. For example, the numbers on lottery tickets form a set: they are unique, and their order is not important. Map (or dictionary) is a set of key-value pairs. Keys are unique, and each of them maps to exactly one value. The values can be duplicates. Maps are useful for storing logical connections between objects, for example, an employee's ID and their position. Kotlin lets you manipulate collections independently of the exact type of objects stored in them. In other words, you add a String to a list of Strings the same way as you would do with Ints or a user-defined class. So, the Kotlin Standard Library offers generic interfaces, classes, and functions for creating, populating, and managing collections of any type. The collection interfaces and related functions are located in the kotlin.collections package. Let's get an overview of its contents. Collection types﻿ The Kotlin Standard Library provides implementations for basic collection types: sets, lists, and maps. A pair of interfaces represent each collection type: A read-only interface that provides operations for accessing collection elements. A mutable interface that extends the corresponding read-only interface with write operations: adding, removing, and updating its elements. Note that altering a mutable collection doesn't require it to be a var: write operations modify the same mutable collection object, so the reference doesn't change. Although, if you try to reassign a val collection, you'll get a compilation error. val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\") numbers.add(\"five\") // this is OK println(numbers) //numbers = mutableListOf(\"six\", \"seven\") // compilation error The read-only collection types are covariant. This means that, if a Rectangle class inherits from Shape, you can use a List anywhere the List is required. In other words, the collection types have the same subtyping relationship as the element types. Maps are covariant on the value type, but not on the key type. In turn, mutable collections aren't covariant; otherwise, this would lead to runtime failures. If MutableList was a subtype of MutableList, you could insert other Shape inheritors (for example, Circle) into it, thus violating its Rectangle type argument. Below is a diagram of the Kotlin collection interfaces: Let's walk through the interfaces and their implementations. To learn about Collection, read the section below. To learn about List, Set, and Map, you can either read the corresponding sections or watch a video by Sebastian Aigner, Kotlin Developer Advocate: Collection﻿ Collection is the root of the collection hierarchy. This interface represents the common behavior of a read-only collection: retrieving size, checking item membership, and so on. Collection inherits from the Iterable interface that defines the operations for iterating elements. You can use Collection as a parameter of a function that applies to different collection types. For more specific cases, use the Collection's inheritors: List and Set. fun printAll(strings: Collection) { for(s in strings) print(\"$s \") println() } fun main() { val stringList = listOf(\"one\", \"two\", \"one\") printAll(stringList) val stringSet = setOf(\"one\", \"two\", \"three\") printAll(stringSet) } MutableCollection is a Collection with write operations, such as add and remove. fun List.getShortWordsTo(shortWords: MutableList, maxLength: Int) { this.filterTo(shortWords) { it.length () words.getShortWordsTo(shortWords, 3) println(shortWords) } List﻿ List stores elements in a specified order and provides indexed access to them. Indices start from zero – the index of the first element – and go to lastIndex which is the (list.size - 1). val numbers = listOf(\"one\", \"two\", \"three\", \"four\") println(\"Number of elements: ${numbers.size}\") println(\"Third element: ${numbers.get(2)}\") println(\"Fourth element: ${numbers[3]}\") println(\"Index of element \\\"two\\\" ${numbers.indexOf(\"two\")}\") List elements (including nulls) can duplicate: a list can contain any number of equal objects or occurrences of a single object. Two lists are considered equal if they have the same sizes and structurally equal elements at the same positions. val bob = Person(\"Bob\", 31) val people = listOf(Person(\"Adam\", 20), bob, bob) val people2 = listOf(Person(\"Adam\", 20), Person(\"Bob\", 31), bob) println(people == people2) bob.age = 32 println(people == people2) MutableList is a List with list-specific write operations, for example, to add or remove an element at a specific position. val numbers = mutableListOf(1, 2, 3, 4) numbers.add(5) numbers.removeAt(1) numbers[0] = 0 numbers.shuffle() println(numbers) As you see, in some aspects lists are very similar to arrays. However, there is one important difference: an array's size is defined upon initialization and is never changed; in turn, a list doesn't have a predefined size; a list's size can be changed as a result of write operations: adding, updating, or removing elements. In Kotlin, the default implementation of MutableList is ArrayList which you can think of as a resizable array. Set﻿ Set stores unique elements; their order is generally undefined. null elements are unique as well: a Set can contain only one null. Two sets are equal if they have the same size, and for each element of a set there is an equal element in the other set. val numbers = setOf(1, 2, 3, 4) println(\"Number of elements: ${numbers.size}\") if (numbers.contains(1)) println(\"1 is in the set\") val numbersBackwards = setOf(4, 3, 2, 1) println(\"The sets are equal: ${numbers == numbersBackwards}\") MutableSet is a Set with write operations from MutableCollection. The default implementation of MutableSet – LinkedHashSet – preserves the order of elements insertion. Hence, the functions that rely on the order, such as first() or last(), return predictable results on such sets. val numbers = setOf(1, 2, 3, 4) // LinkedHashSet is the default implementation val numbersBackwards = setOf(4, 3, 2, 1) println(numbers.first() == numbersBackwards.first()) println(numbers.first() == numbersBackwards.last()) An alternative implementation – HashSet – says nothing about the elements order, so calling such functions on it returns unpredictable results. However, HashSet requires less memory to store the same number of elements. Map﻿ Map is not an inheritor of the Collection interface; however, it's a Kotlin collection type as well. A Map stores key-value pairs (or entries); keys are unique, but different keys can be paired with equal values. The Map interface provides specific functions, such as access to value by key, searching keys and values, and so on. val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1) println(\"All keys: ${numbersMap.keys}\") println(\"All values: ${numbersMap.values}\") if (\"key2\" in numbersMap) println(\"Value by key \\\"key2\\\": ${numbersMap[\"key2\"]}\") if (1 in numbersMap.values) println(\"The value 1 is in the map\") if (numbersMap.containsValue(1)) println(\"The value 1 is in the map\") // same as previous Two maps containing the equal pairs are equal regardless of the pair order. val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1) val anotherMap = mapOf(\"key2\" to 2, \"key1\" to 1, \"key4\" to 1, \"key3\" to 3) println(\"The maps are equal: ${numbersMap == anotherMap}\") MutableMap is a Map with map write operations, for example, you can add a new key-value pair or update the value associated with the given key. val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2) numbersMap.put(\"three\", 3) numbersMap[\"one\"] = 11 println(numbersMap) The default implementation of MutableMap – LinkedHashMap – preserves the order of elements insertion when iterating the map. In turn, an alternative implementation – HashMap – says nothing about the elements order. Collection operations overview﻿ The Kotlin standard library offers a broad variety of functions for performing operations on collections. This includes simple operations, such as getting or adding elements, as well as more complex ones including search, sorting, filtering, transformations, and so on. Extension and member functions﻿ Collection operations are declared in the standard library in two ways: member functions of collection interfaces and extension functions. Member functions define operations that are essential for a collection type. For example, Collection contains the function isEmpty() for checking its emptiness; List contains get() for index access to elements, and so on. When you create your own implementations of collection interfaces, you must implement their member functions. To make the creation of new implementations easier, use the skeletal implementations of collection interfaces from the standard library: AbstractCollection, AbstractList, AbstractSet, AbstractMap, and their mutable counterparts. Other collection operations are declared as extension functions. These are filtering, transformation, ordering, and other collection processing functions. Common operations﻿ Common operations are available for both read-only and mutable collections. Common operations fall into these groups: Transformations Filtering plus and minus operators Grouping Retrieving collection parts Retrieving single elements Ordering Aggregate operations Operations described on these pages return their results without affecting the original collection. For example, a filtering operation produces a new collection that contains all the elements matching the filtering predicate. Results of such operations should be either stored in variables, or used in some other way, for example, passed in other functions. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") numbers.filter { it.length > 3 } // nothing happens with `numbers`, result is lost println(\"numbers are still $numbers\") val longerThan3 = numbers.filter { it.length > 3 } // result is stored in `longerThan3` println(\"numbers longer than 3 chars are $longerThan3\") For certain collection operations, there is an option to specify the destination object. Destination is a mutable collection to which the function appends its resulting items instead of returning them in a new object. For performing operations with destinations, there are separate functions with the To postfix in their names, for example, filterTo() instead of filter() or associateTo() instead of associate(). These functions take the destination collection as an additional parameter. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") val filterResults = mutableListOf() //destination object numbers.filterTo(filterResults) { it.length > 3 } numbers.filterIndexedTo(filterResults) { index, _ -> index == 0 } println(filterResults) // contains results of both operations For convenience, these functions return the destination collection back, so you can create it right in the corresponding argument of the function call: // filter numbers right into a new hash set, // thus eliminating duplicates in the result val result = numbers.mapTo(HashSet()) { it.length } println(\"distinct item lengths are $result\") Functions with destination are available for filtering, association, grouping, flattening, and other operations. For the complete list of destination operations see the Kotlin collections reference. Write operations﻿ For mutable collections, there are also write operations that change the collection state. Such operations include adding, removing, and updating elements. Write operations are listed in the Write operations and corresponding sections of List-specific operations and Map specific operations. For certain operations, there are pairs of functions for performing the same operation: one applies the operation in-place and the other returns the result as a separate collection. For example, sort() sorts a mutable collection in-place, so its state changes; sorted() creates a new collection that contains the same elements in the sorted order. val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\") val sortedNumbers = numbers.sorted() println(numbers == sortedNumbers) // false numbers.sort() println(numbers == sortedNumbers) // true Collection transformation operations﻿ The Kotlin standard library provides a set of extension functions for collection transformations. These functions build new collections from existing ones based on the transformation rules provided. In this page, we'll give an overview of the available collection transformation functions. Map﻿ The mapping transformation creates a collection from the results of a function on the elements of another collection. The basic mapping function is map(). It applies the given lambda function to each subsequent element and returns the list of the lambda results. The order of results is the same as the original order of elements. To apply a transformation that additionally uses the element index as an argument, use mapIndexed(). val numbers = setOf(1, 2, 3) println(numbers.map { it * 3 }) println(numbers.mapIndexed { idx, value -> value * idx }) If the transformation produces null on certain elements, you can filter out the nulls from the result collection by calling the mapNotNull() function instead of map(), or mapIndexedNotNull() instead of mapIndexed(). val numbers = setOf(1, 2, 3) println(numbers.mapNotNull { if ( it == 2) null else it * 3 }) println(numbers.mapIndexedNotNull { idx, value -> if (idx == 0) null else value * idx }) When transforming maps, you have two options: transform keys leaving values unchanged and vice versa. To apply a given transformation to keys, use mapKeys(); in turn, mapValues() transforms values. Both functions use the transformations that take a map entry as an argument, so you can operate both its key and value. val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11) println(numbersMap.mapKeys { it.key.uppercase() }) println(numbersMap.mapValues { it.value + it.key.length }) Zip﻿ Zipping transformation is building pairs from elements with the same positions in both collections. In the Kotlin standard library, this is done by the zip() extension function. When called on a collection or an array with another collection (or array) as an argument, zip() returns the List of Pair objects. The elements of the receiver collection are the first elements in these pairs. If the collections have different sizes, the result of the zip() is the smaller size; the last elements of the larger collection are not included in the result. zip() can also be called in the infix form a zip b. val colors = listOf(\"red\", \"brown\", \"grey\") val animals = listOf(\"fox\", \"bear\", \"wolf\") println(colors zip animals) val twoAnimals = listOf(\"fox\", \"bear\") println(colors.zip(twoAnimals)) -------------------------------------------------------------------- [(red, fox), (brown, bear), (grey, wolf)] [(red, fox), (brown, bear)] You can also call zip() with a transformation function that takes two parameters: the receiver element and the argument element. In this case, the result List contains the return values of the transformation function called on pairs of the receiver and the argument elements with the same positions. val colors = listOf(\"red\", \"brown\", \"grey\") val animals = listOf(\"fox\", \"bear\", \"wolf\") println(colors.zip(animals) { color, animal -> \"The ${animal.replaceFirstChar { it.uppercase() }} is $color\"}) ----------------------------------------------------------------- [The Fox is red, The Bear is brown, The Wolf is grey] When you have a List of Pairs, you can do the reverse transformation – unzipping – that builds two lists from these pairs: The first list contains the first elements of each Pair in the original list. The second list contains the second elements. To unzip a list of pairs, call unzip(). val numberPairs = listOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"four\" to 4) println(numberPairs.unzip()) --------------------------------------------------------------- ([one, two, three, four], [1, 2, 3, 4]) Associate﻿ Association transformations allow building maps from the collection elements and certain values associated with them. In different association types, the elements can be either keys or values in the association map. The basic association function associateWith() creates a Map in which the elements of the original collection are keys, and values are produced from them by the given transformation function. If two elements are equal, only the last one remains in the map. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") println(numbers.associateWith { it.length }) --------------------------------------------------- {one=3, two=3, three=5, four=4} For building maps with collection elements as values, there is the function associateBy(). It takes a function that returns a key based on an element's value. If two elements' keys are equal, only the last one remains in the map. associateBy() can also be called with a value transformation function. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") println(numbers.associateBy { it.first().uppercaseChar() }) println(numbers.associateBy(keySelector = { it.first().uppercaseChar() }, valueTransform = { it.length })) ------------------------------------------------------------- {O=one, T=three, F=four} {O=3, T=5, F=4} Another way to build maps in which both keys and values are somehow produced from collection elements is the function associate(). It takes a lambda function that returns a Pair: the key and the value of the corresponding map entry. Note that associate() produces short-living Pair objects which may affect the performance. Thus, associate() should be used when the performance isn't critical or it's more preferable than other options. An example of the latter is when a key and the corresponding value are produced from an element together. val names = listOf(\"Alice Adams\", \"Brian Brown\", \"Clara Campbell\") println(names.associate { name -> parseFullName(name).let { it.lastName to it.firstName } }) ----------------------------------------------------------------- {Adams=Alice, Brown=Brian, Campbell=Clara} Here we call a transform function on an element first, and then build a pair from the properties of that function's result. Flatten﻿ If you operate nested collections, you may find the standard library functions that provide flat access to nested collection elements useful. The first function is flatten(). You can call it on a collection of collections, for example, a List of Sets. The function returns a single List of all the elements of the nested collections. val numberSets = listOf(setOf(1, 2, 3), setOf(4, 5, 6), setOf(1, 2)) println(numberSets.flatten()) ---------------------------------------- [1, 2, 3, 4, 5, 6, 1, 2] Another function – flatMap() provides a flexible way to process nested collections. It takes a function that maps a collection element to another collection. As a result, flatMap() returns a single list of its return values on all the elements. So, flatMap() behaves as a subsequent call of map() (with a collection as a mapping result) and flatten(). val containers = listOf( StringContainer(listOf(\"one\", \"two\", \"three\")), StringContainer(listOf(\"four\", \"five\", \"six\")), StringContainer(listOf(\"seven\", \"eight\")) ) println(containers.flatMap { it.values }) ----------------------------------------------- [one, two, three, four, five, six, seven, eight] String representation﻿ If you need to retrieve the collection content in a readable format, use functions that transform the collections to strings: joinToString() and joinTo(). joinToString() builds a single String from the collection elements based on the provided arguments. joinTo() does the same but appends the result to the given Appendable object. When called with the default arguments, the functions return the result similar to calling toString() on the collection: a String of elements' string representations separated by commas with spaces. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") println(numbers) println(numbers.joinToString()) val listString = StringBuffer(\"The list of numbers: \") numbers.joinTo(listString) println(listString) ------------------------------------------------------------ [one, two, three, four] one, two, three, four The list of numbers: one, two, three, four To build a custom string representation, you can specify its parameters in function arguments separator, prefix, and postfix. The resulting string will start with the prefix and end with the postfix. The separator will come after each element except the last. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") println(numbers.joinToString(separator = \" | \", prefix = \"start: \", postfix = \": end\")) ----------------------------------------------- start: one | two | three | four: end For bigger collections, you may want to specify the limit – a number of elements that will be included into result. If the collection size exceeds the limit, all the other elements will be replaced with a single value of the truncated argument. val numbers = (1..100).toList() println(numbers.joinToString(limit = 10, truncated = \"\")) ---------------------------------------------------------- 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, Finally, to customize the representation of elements themselves, provide the transform function. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") println(numbers.joinToString { \"Element: ${it.uppercase()}\"}) -------------------------------------------------------------- Element: ONE, Element: TWO, Element: THREE, Element: FOUR Filtering collections﻿ Edit page Last modified: 15 February 2023 Filtering is one of the most popular tasks in collection processing. In Kotlin, filtering conditions are defined by predicates – lambda functions that take a collection element and return a boolean value: true means that the given element matches the predicate, false means the opposite. The standard library contains a group of extension functions that let you filter collections in a single call. These functions leave the original collection unchanged, so they are available for both mutable and read-only collections. To operate the filtering result, you should assign it to a variable or chain the functions after filtering. Filter by predicate﻿ The basic filtering function is filter(). When called with a predicate, filter() returns the collection elements that match it. For both List and Set, the resulting collection is a List, for Map it's a Map as well. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") val longerThan3 = numbers.filter { it.length > 3 } println(longerThan3) val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11) val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10} println(filteredMap) Open in Playground → Target: JVMRunning on v.1.8.10 The predicates in filter() can only check the values of the elements. If you want to use element positions in the filter, use filterIndexed(). It takes a predicate with two arguments: the index and the value of an element. To filter collections by negative conditions, use filterNot(). It returns a list of elements for which the predicate yields false. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") val filteredIdx = numbers.filterIndexed { index, s -> (index != 0) && (s.length Open in Playground → Target: JVMRunning on v.1.8.10 There are also functions that narrow the element type by filtering elements of a given type: filterIsInstance() returns collection elements of a given type. Being called on a List, filterIsInstance() returns a List, thus allowing you to call functions of the T type on its items. val numbers = listOf(null, 1, \"two\", 3.0, \"four\") println(\"All String elements in upper case:\") numbers.filterIsInstance().forEach { println(it.uppercase()) } Open in Playground → Target: JVMRunning on v.1.8.10 filterNotNull() returns all non-null elements. Being called on a List, filterNotNull() returns a List, thus allowing you to treat the elements as non-null objects. val numbers = listOf(null, \"one\", \"two\", null) numbers.filterNotNull().forEach { println(it.length) // length is unavailable for nullable Strings } Open in Playground → Target: JVMRunning on v.1.8.10 Partition﻿ Another filtering function – partition() – filters a collection by a predicate and keeps the elements that don't match it in a separate list. So, you have a Pair of Lists as a return value: the first list containing elements that match the predicate and the second one containing everything else from the original collection. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") val (match, rest) = numbers.partition { it.length > 3 } println(match) println(rest) Open in Playground → Target: JVMRunning on v.1.8.10 Test predicates﻿ Finally, there are functions that simply test a predicate against collection elements: any() returns true if at least one element matches the given predicate. none() returns true if none of the elements match the given predicate. all() returns true if all elements match the given predicate. Note that all() returns true when called with any valid predicate on an empty collection. Such behavior is known in logic as vacuous truth. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") println(numbers.any { it.endsWith(\"e\") }) println(numbers.none { it.endsWith(\"a\") }) println(numbers.all { it.endsWith(\"e\") }) println(emptyList().all { it > 5 }) // vacuous truth Open in Playground → Target: JVMRunning on v.1.8.10 any() and none() can also be used without a predicate: in this case they just check the collection emptiness. any() returns true if there are elements and false if there aren't; none() does the opposite. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") val empty = emptyList() println(numbers.any()) println(empty.any()) println(numbers.none()) println(empty.none()) Open in Playground → Ordering﻿ The order of elements is an important aspect of certain collection types. For example, two lists of the same elements are not equal if their elements are ordered differently. In Kotlin, the orders of objects can be defined in several ways. First, there is natural order. It is defined for implementations of the Comparable interface. Natural order is used for sorting them when no other order is specified. Most built-in types are comparable: Numeric types use the traditional numerical order: 1 is greater than 0; -3.4f is greater than -5f, and so on. Char and String use the lexicographical order: b is greater than a; world is greater than hello. To define a natural order for a user-defined type, make the type an implementer of Comparable. This requires implementing the compareTo() function. compareTo() must take another object of the same type as an argument and return an integer value showing which object is greater: Positive values show that the receiver object is greater. Negative values show that it's less than the argument. Zero shows that the objects are equal. Below is a class for ordering versions that consist of the major and the minor part. class Version(val major: Int, val minor: Int): Comparable { override fun compareTo(other: Version): Int = when { this.major != other.major -> this.major compareTo other.major // compareTo() in the infix form this.minor != other.minor -> this.minor compareTo other.minor else -> 0 } } fun main() { println(Version(1, 2) > Version(1, 3)) println(Version(2, 0) > Version(1, 5)) } Custom orders let you sort instances of any type in a way you like. Particularly, you can define an order for non-comparable objects or define an order other than natural for a comparable type. To define a custom order for a type, create a Comparator for it. Comparator contains the compare() function: it takes two instances of a class and returns the integer result of the comparison between them. The result is interpreted in the same way as the result of a compareTo() as is described above. val lengthComparator = Comparator { str1: String, str2: String -> str1.length - str2.length } println(listOf(\"aaa\", \"bb\", \"c\").sortedWith(lengthComparator)) Having the lengthComparator, you are able to arrange strings by their length instead of the default corder. A shorter way to define a Comparator is the compareBy() function from the standard library. compareBy() takes a lambda function that produces a Comparable value from an instance and defines the custom order as the natural order of the produced values. With compareBy(), the length comparator from the example above looks like this: println(listOf(\"aaa\", \"bb\", \"c\").sortedWith(compareBy { it.length })) The Kotlin collections package provides functions for sorting collections in natural, custom, and even random orders. On this page, we'll describe sorting functions that apply to read-only collections. These functions return their result as a new collection containing the elements of the original collection in the requested order. To learn about functions for sorting mutable collections in place, see the List-specific operations. Natural order﻿ The basic functions sorted() and sortedDescending() return elements of a collection sorted into ascending and descending sequence according to their natural order. These functions apply to collections of Comparable elements. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") println(\"Sorted ascending: ${numbers.sorted()}\") println(\"Sorted descending: ${numbers.sortedDescending()}\") Custom orders﻿ For sorting in custom orders or sorting non-comparable objects, there are the functions sortedBy() and sortedByDescending(). They take a selector function that maps collection elements to Comparable values and sort the collection in natural order of that values. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") val sortedNumbers = numbers.sortedBy { it.length } println(\"Sorted by length ascending: $sortedNumbers\") val sortedByLast = numbers.sortedByDescending { it.last() } println(\"Sorted by the last letter descending: $sortedByLast\") To define a custom order for the collection sorting, you can provide your own Comparator. To do this, call the sortedWith() function passing in your Comparator. With this function, sorting strings by their length looks like this: val numbers = listOf(\"one\", \"two\", \"three\", \"four\") println(\"Sorted by length ascending: ${numbers.sortedWith(compareBy { it.length })}\") Reverse order﻿ You can retrieve the collection in the reversed order using the reversed() function. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") println(numbers.reversed()) reversed() returns a new collection with the copies of the elements. So, if you change the original collection later, this won't affect the previously obtained results of reversed(). Another reversing function - asReversed() returns a reversed view of the same collection instance, so it may be more lightweight and preferable than reversed() if the original list is not going to change. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") val reversedNumbers = numbers.asReversed() println(reversedNumbers) If the original list is mutable, all its changes reflect in its reversed views and vice versa. val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\") val reversedNumbers = numbers.asReversed() println(reversedNumbers) numbers.add(\"five\") println(reversedNumbers) However, if the mutability of the list is unknown or the source is not a list at all, reversed() is more preferable since its result is a copy that won't change in the future. Random order﻿ Finally, there is a function that returns a new List containing the collection elements in a random order - shuffled(). You can call it without arguments or with a Random object. val numbers = listOf(\"one\", \"two\", \"three\", \"four\") println(numbers.shuffled()) No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/PHP语法简述.html":{"url":"03_语言/PHP语法简述.html","title":"Php语法简述","keywords":"","body":"PHP是一种常用于Web开发的服务器端脚本语言，具有简单易学、功能强大的特点。下面我会简要介绍一些PHP的基础语法。 1. PHP脚本结构 PHP代码通常被写在标签之间，以下是一个简单的PHP示例： 在上面的代码中，和?>标记表示PHP代码的开始和结束，而echo是用于输出字符串的语句。 2. 变量 在PHP中，变量以$符号开头，后面跟变量名。变量名可以由字母、数字和下划线组成，但不能以数字开头。 3. 数据类型 PHP支持多种数据类型，包括： 字符串：例如 \"Hello\" 整数：例如 123 浮点数：例如 3.14 布尔值：true 或 false 数组：可以存储多个值 对象：面向对象编程的类实例 4. 数组 PHP中的数组有两种类型：索引数组和关联数组。 索引数组：使用数字索引访问数组元素。 关联数组：使用字符串作为键来访问数组元素。 \"John\", \"age\" => 25); echo $person[\"name\"]; // 输出 \"John\" ?> 5. 条件语句 PHP支持常见的条件语句，如if、else、elseif。 = 18) { echo \"Adult\"; } else { echo \"Minor\"; } ?> 6. 循环 PHP提供多种循环结构，如for、while、foreach。 for循环： \"; } ?> foreach循环（用于遍历数组）： \"; } ?> 7. 函数 PHP允许你定义自己的函数，使用function关键字。 8. 表单数据 PHP常与HTML结合，处理表单提交的数据。例如，接收通过POST方式提交的数据： 9. 超全局变量 PHP提供一些预定义的全局变量，例如： $_GET：用于获取URL中的查询字符串参数。 $_POST：用于获取通过POST方法提交的表单数据。 $_SESSION：用于存储会话数据。 $_COOKIE：用于存储和获取cookie数据。 10. 文件操作 PHP支持文件操作，例如读取、写入、删除文件。 11. 面向对象 PHP也支持面向对象编程，使用class和object。 name = $name; } function greet() { return \"Hello, \" . $this->name; } } $person = new Person(\"John\"); echo $person->greet(); // 输出 \"Hello, John\" ?> 12. 错误处理 PHP提供了错误处理机制，使用try-catch来捕获异常。 getMessage(); } ?> 这些是PHP的基本语法要点，涵盖了变量、数据类型、控制结构、函数等内容。希望能帮助你理解PHP的基础。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Python/datetime的使用.html":{"url":"03_语言/Python/datetime的使用.html","title":"Datetime的使用","keywords":"","body":"datetime是Python处理日期和时间的标准库。 获取当前日期和时间 我们先看如何获取当前日期和时间： >>> from datetime import datetime >>> now = datetime.now() # 获取当前datetime >>> print(now) 2015-05-18 16:28:07.198690 >>> print(type(now)) 注意到datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。 如果仅导入import datetime，则必须引用全名datetime.datetime。 datetime.now()返回当前日期和时间，其类型是datetime。 获取指定日期和时间 要指定某个日期和时间，我们直接用参数构造一个datetime： >>> from datetime import datetime >>> dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime >>> print(dt) 2015-04-19 12:20:00 datetime转换为timestamp 在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp。 你可以认为： timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00 对应的北京时间是： timestamp = 0 = 1970-1-1 08:00:00 UTC+8:00 可见timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。 把一个datetime类型转换为timestamp只需要简单调用timestamp()方法： >>> from datetime import datetime >>> dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime >>> dt.timestamp() # 把datetime转换为timestamp 1429417200.0 注意Python的timestamp是一个浮点数，整数位表示秒。 某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。 timestamp转换为datetime 要把timestamp转换为datetime，使用datetime提供的fromtimestamp()方法： >>> from datetime import datetime >>> t = 1429417200.0 >>> print(datetime.fromtimestamp(t)) 2015-04-19 12:20:00 注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。 本地时间是指当前操作系统设定的时区。例如北京时区是东8区，则本地时间： 2015-04-19 12:20:00 实际上就是UTC+8:00时区的时间： 2015-04-19 12:20:00 UTC+8:00 而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是： 2015-04-19 04:20:00 UTC+0:00 timestamp也可以直接被转换到UTC标准时区的时间： >>> from datetime import datetime >>> t = 1429417200.0 >>> print(datetime.fromtimestamp(t)) # 本地时间 2015-04-19 12:20:00 >>> print(datetime.utcfromtimestamp(t)) # UTC时间 2015-04-19 04:20:00 str转换为datetime 很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过datetime.strptime()实现，需要一个日期和时间的格式化字符串： >>> from datetime import datetime >>> cday = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S') >>> print(cday) 2015-06-01 18:19:59 字符串'%Y-%m-%d %H:%M:%S'规定了日期和时间部分的格式。详细的说明请参考Python文档。 注意转换后的datetime是没有时区信息的。 datetime转换为str 如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的，同样需要一个日期和时间的格式化字符串： >>> from datetime import datetime >>> now = datetime.now() >>> print(now.strftime('%a, %b %d %H:%M')) Mon, May 05 16:28 datetime加减 对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类： >>> from datetime import datetime, timedelta >>> now = datetime.now() >>> now datetime.datetime(2015, 5, 18, 16, 57, 3, 540997) >>> now + timedelta(hours=10) datetime.datetime(2015, 5, 19, 2, 57, 3, 540997) >>> now - timedelta(days=1) datetime.datetime(2015, 5, 17, 16, 57, 3, 540997) >>> now + timedelta(days=2, hours=12) datetime.datetime(2015, 5, 21, 4, 57, 3, 540997) 可见，使用timedelta你可以很容易地算出前几天和后几天的时刻。 本地时间转换为UTC时间 本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。 一个datetime类型有一个时区属性tzinfo，但是默认为None，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区： >>> from datetime import datetime, timedelta, timezone >>> tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00 >>> now = datetime.now() >>> now datetime.datetime(2015, 5, 18, 17, 2, 10, 871012) >>> dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00 >>> dt datetime.datetime(2015, 5, 18, 17, 2, 10, 871012, tzinfo=datetime.timezone(datetime.timedelta(0, 28800))) 如果系统时区恰好是UTC+8:00，那么上述代码就是正确的，否则，不能强制设置为UTC+8:00时区。 时区转换 我们可以先通过utcnow()拿到当前的UTC时间，再转换为任意时区的时间： # 拿到UTC时间，并强制设置时区为UTC+0:00: >>> utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc) >>> print(utc_dt) 2015-05-18 09:05:12.377316+00:00 # astimezone()将转换时区为北京时间: >>> bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8))) >>> print(bj_dt) 2015-05-18 17:05:12.377316+08:00 # astimezone()将转换时区为东京时间: >>> tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9))) >>> print(tokyo_dt) 2015-05-18 18:05:12.377316+09:00 # astimezone()将bj_dt转换时区为东京时间: >>> tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=9))) >>> print(tokyo_dt2) 2015-05-18 18:05:12.377316+09:00 时区转换的关键在于，拿到一个datetime时，要获知其正确的时区，然后强制设置时区，作为基准时间。 利用带时区的datetime，通过astimezone()方法，可以转换到任意时区。 注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的datetime都可以正确转换，例如上述bj_dt到tokyo_dt的转换。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Python/Playwright.html":{"url":"03_语言/Python/Playwright.html","title":"Playwright","keywords":"","body":"Browser 对应一个浏览器实例（Chromium、Firefox或WebKit），Playwright脚本以启动浏览器实例开始，以关闭浏览器结束。浏览器实例可以在headless或者 headful模式下启动。一个 Browser 可以包含多个 BrowserContext。 BrowserContext Playwright为每个测试创建一个浏览器上下文，即BrowserContext，浏览器上下文相当于一个全新的浏览器配置文件，提供了完全的测试隔离，并且零开销。创建一个新的浏览器上下文只需要几毫秒，每个上下文都有自己的Cookie、浏览器存储和浏览历史记录。浏览器上下文允许同时打开多个页面并与之交互，每个页面都有自己单独的状态，一个 BrowserContext 可以包含多个 Page。 Page 页面指的是浏览器上下文中的单个选项卡或弹出窗口。在Page中主要完成与页面元素交互，一个 Page 可以包含多个 Frame Frame 每个页面有一个主框架（page.MainFrame()）,也可以有多个子框架，由 iframe 标签创建产生。在playwright中，无需切换iframe，可以直接定位元素（这点要比selenium方便很多）。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Python/Python使用中遇到的问题解决.html":{"url":"03_语言/Python/Python使用中遇到的问题解决.html","title":"Python使用中遇到的问题解决","keywords":"","body":"可以运行包含中文的.py文件，但输出中文时会显示一个方形中间一个问号 相关链接：https://blog.csdn.net/qq_15971883/article/details/108572801 解决方案1：用git-bash运行python文件，并在最前面加上PYTHONIOENCODING=utf-8 如： PYTHONIOENCODING=utf-8 python hello.py 解决方案2：在python脚本中添加如下代码： import sys import codecs sys.stdout = codecs.getwriter(\"utf-8\")(sys.stdout.detach()) No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Python/Python打包.html":{"url":"03_语言/Python/Python打包.html","title":"Python打包","keywords":"","body":"命令参数 基本参数 参数 功能说明 -F, --onefile 将所有文件（脚本、依赖库等）打包成一个单独的可执行文件。 -D, --onedir 将可执行文件和依赖文件打包成一个文件夹（默认）。 --name NAME 指定生成的可执行文件的名称（默认是脚本名称）。 --distpath DIR 指定生成的打包文件输出路径（默认是 dist/）。 --workpath DIR 指定临时工作目录（默认是 build/）。 --specpath DIR 指定 .spec 文件的存储路径（默认是当前目录）。 --noconfirm 覆盖输出目录而不提示确认。 --clean 清理上一次生成的临时文件。 附加依赖和模块 参数 功能说明 --add-data SRC;DEST 添加非代码文件（如配置文件、资源文件等），格式为 SRC;DEST（路径分隔符在 Windows 使用分号 ;，在其他系统使用冒号 :）。 --add-binary SRC;DEST 添加二进制文件，格式与 --add-data 相同。 --hidden-import MODULENAME 手动指定需要打包的模块，避免自动检测时漏掉某些动态导入的模块。 --exclude-module MODULENAME 指定不需要打包的模块（如测试用的模块）。 --collect-submodules MODULENAME 收集并打包指定模块的所有子模块。 优化和兼容 参数 功能说明 --key KEY 为加密的 Python 字节码设置密钥（实验性）。 --upx-dir DIR 指定 UPX（可执行文件压缩工具）的路径，用于进一步压缩可执行文件（需要安装 UPX）。 --noupx 禁用 UPX 压缩。 --ascii 强制以 ASCII 格式生成控制台输出文件（对于非 UTF-8 环境有用）。 --debug 生成带调试符号的可执行文件（便于调试问题）。 日志和信息 参数 功能说明 --log-level LEVEL 设置日志级别（DEBUG、INFO、WARN、ERROR）。 --version-file FILE 使用指定的版本信息文件（Windows 下 resource_version_info.rc 文件）。 高级参数 参数 功能说明 --specpath DIR 指定生成的 .spec 文件路径。 --no-embed-manifest 不嵌入 manifest 文件到可执行文件中。 --strip 在可用的情况下，移除二进制文件的符号表（减小文件体积，但可能影响调试）。 --noupx 禁用 UPX 压缩以防止兼容性问题。 生成的目录与文件解析 /build 构建日志等 /dist 生成的.exe文件默认放置路径 .spec pyinstaller的配置文件 跨平台 在windows平台上打包的程序只能在windows上使用 在linux平台上打包的程序只能在linux上使用 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Python/Python方法注释.html":{"url":"03_语言/Python/Python方法注释.html","title":"Python方法注释","keywords":"","body":"方法的头部注释，可以参考下面的模板（ChatGPT生成的写得挺好的） def delete_release_note(owner, repo, release_id, token): \"\"\" Delete a GitHub release by release_id. Parameters: - owner (str): GitHub username or organization name. - repo (str): Repository name. - release_id (int): ID of the release to delete. - token (str): GitHub personal access token for authentication. Returns: - bool: True if deletion is successful, False otherwise. \"\"\" url = f\"https://api.github.com/repos/{GITHUB_OWNER}/{repo}/releases/{release_id}\" headers = { \"Authorization\": f\"token {token}\", \"Accept\": \"application/vnd.github.v3+json\", } response = requests.delete(url, headers=headers) if response.status_code == 204: print(f\"Release with ID {release_id} deleted successfully.\") return True else: print(f\"Failed to delete release with ID {release_id}.\") return False No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Python/Python简明教程.html":{"url":"03_语言/Python/Python简明教程.html","title":"Python简明教程","keywords":"","body":"C1 基本语法 0.基本数据类型 Python 2 在 Python 2 中，int 和 long 是两种不同的类型： int 是固定大小的整数类型，通常是 32 位或 64 位，取决于操作系统和编译器。 long 是可以表示任意大小的整数类型，只要内存允许。长整数以 L 或 l 结尾。 Python 3 自 Python 3 开始，int 类型已经包含了 long 类型的功能，不再有单独的 long 类型。 int 类型可以处理任意大小的整数，只要内存允许。 1. 字符串 1.1 引号 单引号和双引号中的字符串完全相同 你可以使用三引号 ——（\"\"\" 或 '''）指定多行字符串。可以在三引号中自由地使用单引号和双引号。 '''This is a multi-line string. This is the first line. This is the second line. \"What's your name?,\" I asked. He said \"Bond, James Bond.\" ''' 1.2 format方法 基本用法 age = 20 name = 'Swaroop' print('{0} was {1} years old when he wrote this book'.format(name, age)) print('Why is {0} playing with that python?'.format(name)) output： $ python str_format.py Swaroop was 20 years old when he wrote this book Why is Swaroop playing with that python? 高级用法 # 取十进制小数点后的精度为 3 ，得到的浮点数为 '0.333' print('{0:.3f}'.format(1.0/3)) # 填充下划线 (_) ，文本居中 # 将 '___hello___' 的宽度扩充为 11 print('{0:_^11}'.format('hello')) # 用基于关键字的方法打印显示 'Swaroop wrote A Byte of Python' print('{name} wrote {book}'.format(name='Swaroop', book='A Byte of Python')) output： 0.333 ___hello___ Swaroop wrote A Byte of Python 1.3 指定结尾 print 总是以一个不可见的 「新的一行」 字符（\\n）作为结尾，因此对 print 的重复调用将在每个单独的行上打印输出。为了防止这个换行符被打印输出，你可以指定它以一个空（即，什么都没有）作为 end： print('a', end='') print('b', end='') output: ab 1.4 转义序列 单引号 --> \\` 表示反斜杠本身 --> \\\\ 在字符串中，行末尾的单个反斜杠表示字符串在下一行中继续，但不添加换行符。例如： \"This is the first sentence.\\ This is the second sentence.\" 等价于： \"This is the first sentence. This is the second sentence.\" 1.5 原始字符串 如果你需要指定一些没有特殊处理（转义序列等）的字符串，那么你需要指定一个 原始 字符串，指定方法是在字符串前面加上 r 或者 R 。例如： r\"Newlines are indicated by \\n\" 在处理正则表达式时，我们一般使用原始字符串。否则，可能需要进行大量的反向操作。例如，可以用 '\\\\1' 或 r'\\1' 进行反向引用。 2. 对象 记住，在 Python 中，一切皆 对象 。这意味着一般情况下，在 Python 中，我们不会说「某物」而是说「对象」。 从某种意义上说，Python 的面向对象是非常纯粹的，因为一切皆对象，包括数字、字符串和函数。 3. 逻辑行和物理行 物理行是当你写程序的时候，你眼睛 看到 的行。逻辑行是 Python 看到 的一个程序语句。 如果你希望在单个物理行中编写更多的逻辑行，则必须使用分号 (;) 显式地指定此逻辑行 / 此语句的结尾。 i = 5 print(i) 等价于 i = 5; print(i); 等价于 i = 5; print(i); 等价于 i = 5; print(i) 强烈建议 你坚持 一行最多一个语句 ，不要使用分号。 有一行很长的代码，你可以使用反斜杠将其分解为多个物理行。 i =\\ 5 等价于： i = 5 有时候，有一种隐含的假设，你不需要使用反斜杠。在这种情况下，逻辑行有开始括号、开始方括号或者开始花括号，但是没有结束括号。我们称之为 隐式行连接 。 4. 缩进 空格在 Python 中非常重要。实际上， 行首的空格非常重要 。这就是所谓的 缩进 。逻辑行开头的前导空格（空格和制表符）用于确定逻辑行的缩进级别，然后用于确定语句的分组。 错误的缩进会导致报错 C2 运算符与表达式 1.运算符 ** 为 乘方 3**4 即 3*3*3*3 即81 // 为 除且取整 x 除以 y 并返回小于商的最大整数，注意，如果操作数之一为浮点数，则返回值必为浮点数。 13 // 3 得到 4 -13 // 3 得到 -5 9//1.81 得到 4.0 % 为 取模 返回作除法之后的余数。 13 % 3 得到 1 -25.5 % 2.25 得到 1.5 将数字位向左移动指定的位数。每个数字在内存中用位或二进制数（如 0 和 1 ）表示。 2 >> 为 右移 将数字按位向右移动指定的位数。 11 >> 1 得到 5 。 11 的二进制表示为 1011 ，将其右移一位后，得到 101 也就是十进制的 5 。 & 为 按位与 数字的按位与 5 & 3 得到 1 | 为 按位或 数字的按位或 5 | 3 得到 7 ^ 为 按位异或 数字的按位异或 5 ^ 3 得到 6 ~ 为 按位取反 x 按位取反是 -(x+1) ~5 得到 -6 not 为 布尔非 如果 x 为 True，它会返回 False。如果 x 为 False，它会返回 True。 x = True; not x 返回 False. and 为 布尔与 如果 x 为 False ， x and y 返回 False 。否则，返回 y 的值 由于 x 为 False ， x = False; y = True; x and y 返回 False 在这种情况下， Python 不会计算 y ，因为它知道 ‘与’ 表达式的左边为 False ，这就意味着整个表达式必定是 False。这就是所谓的短路计算。 or 为 布尔或 如果 x 为 True，它会返回真，否则返回 y 的值 x = True; y = False; x or y 返回 True。这里也用到了短路计算。 2.数学运算和赋值的快捷方式 a = 2 a = a * 3 简写为： a = 2 a *= 3 3.计算顺序 优先级（从小到大）： lambda ：Lambda 表达式 if - else ：条件表达式 or ：布尔或 and ：布尔与 not x ：布尔非 in, not in, is, is not, , >=, !=, == ：比较，包括成员资格测试和身份测试 | ：按位或 ^ ：按位异或 & ：按位与 > ：移位 +, - ：加减法 *, /, //, % ：乘除法，取整和取余 +x, -x, ~x ：正负号，按位非 ** ：求幂 x[index], x[index:index], x(arguments...), x.attribute ：订阅，切片，调用，属性引用 (expressions...), [expressions...], {key: value...}, {expressions...} ： 绑定或者元组显示，列表显示，字典显示，设置显示 一般而言，操作符从左到右进行关联。这意味着具有相同优先级的操作符按照从左到右的方式进行计算。 C3 控制流 if 语句 if {条件1}: # 新程序块的开始处 {语句1} {语句2} # 新程序块的结尾处 elif {条件2}: # 另一个程序块 {语句3} # 你可以在程序块中“为所欲为”——做任何你想做的事情 else: {语句4} # 如果上述两个条件都不满足，则会执行到这里 while 语句 while {继续条件，当条件不为True时执行下面的代码，所以如果第一次这里的条件为True并执行了下面的代码，代码执行的过程中需要能够改变这个继续条件为False，不然程序会一直执行下去}: {语句1} {语句2} else: {当不执行上面的代码时进入的语句块，可能第一次执行while条件为False直接进入这个语句块，也可能上面的代码执行多次后进入下面的语句块} for 循环 代码： for i in range(1, 5): print(i) else: print('The for loop is over') 输出： $ python for.py 1 2 3 4 The for loop is over break 语句 break语句是用来 中断 循环语句的，即直接停止循环语句的执行，就算循环条件没有变为 false或者序列没有迭代到最后一项。 continue 语句 continue 语句用来告诉 Python 跳过当前循环语句块中的其余部分，然后 继续 执行循环的下一个迭代。 C4 函数 global 语句 不在任何函数或类的定义内的变量也叫做程序的顶级 top level 变量。 如果你要在函数内给这种变量赋值，需要告诉 Python 这个变量并非本地变量，而是一个全局变量。 当函数没有同名变量时，程序会使用在函数外部定义的顶级变量，但是不应该这样做，因为读这段代码的人会不知道这个变量是在哪里定义的。 x = 50 def func(): global x print('x is', x) x = 2 print('Changed global x to', x) func() print('Value of x is', x) 输出： $ python function_global.py x is 50 Changed global x to 2 Value of x is 2 可以在一个 global 语句中同时指定多个全局变量，就像这样：global x, y, z。 默认参数值 让某些形参成为可选项，当用户没有指定这些形参的值时，使用默认值 形参的默认值必须是常数 只有形参列表末尾的参数才能指定默认值，即你不能在声明参数列表时先声明有默认值的形参，然后再声明没有默认值的形参 def say(message, times=1): print(message * times) say('Hello') say('World', 5) 输出： $ python function_default.py Hello WorldWorldWorldWorldWorld 关键字参数 给函数传递参数时使用参数的名字，可以不用位置来指定实参。 def func(a, b=5, c=10): print('a is', a, 'and b is', b, 'and c is', c) func(3, 7) func(25, c=24) func(c=50, a=100) 输出： $ python function_keyword.py a is 3 and b is 7 and c is 10 a is 25 and b is 5 and c is 24 a is 100 and b is 5 and c is 50 可变参数 可以使用星号 来定义一个能接收 任意个* 数参数的函数 def total(a=5, *numbers, **phonebook): print('a', a) # 遍历元组中的所有项 for single_item in numbers: print('single_item', single_item) # 遍历字典中的所有项 for first_part, second_part in phonebook.items(): print(first_part,second_part) print(total(10,1,2,3,Jack=1123,John=2231,Inge=1560)) 输出： $ python function_varargs.py a 10 single_item 1 single_item 2 single_item 3 Inge 1560 John 2231 Jack 1123 None 当我们声明一个带星号的参数 *param 时，从这个参数开始，之后的所有参数都会被收集进入一个名为 param 的元组中。 类似的，当我们定义了一个带两个星号的参数 **param 时，从这个参数开始，之后的所有参数都会被收入名为 param 的字典中。 return 语句 return 语句用于从一个函数 返回，即跳出这个函数。我们也可以从函数跳出时 返回一个值，返回值是可选的。 如果你的函数没有 return 语句，系统会自己在函数的结尾添加 return None 语句。你可以通过 print(some_function()) 来观察这一点，其中 some_function 函数没有 return 语句： def some_function(): pass 输出： >>> print(some_function()) None pass 语句在 Python 中用于表示一个空的语句块，通常用于占位。 文档字符串 ——DocStrings def print_max(x, y): '''Prints the maximum of two numbers. The two values must be integers.''' # 如果有必要，将参数转为整数 x = int(x) y = int(y) if x > y: print(x, 'is maximum') else: print(y, 'is maximum') print_max(3, 5) print(print_max.__doc__) 输出： $ python function_docstring.py 5 is maximum Prints the maximum of two numbers. The two values must be integers. 一个函数逻辑上第一行的字符串是这个函数的 DocStrings。模块 和 类 都有各自的 DocStrings。 DocStrings 的书写惯例是：首行首字母大写，结尾有句号；第二行为空行；第三行以后为详细的描述。 建议为所有的函数编写DocStrings，除了那些只有几行的平凡函数。 我们可以通过函数的 _doc_ 属性来访问它的 DocStrings。 help() 函数做的事情就是抓取对应函数的 _doc_ 属性，并以美观的方式打印出来。 自动化工具也可以以同样的方式从你的程序中提取文档。 C5 模块 编写模块的方式： 创建一个包含很多方法和变量并以 .py 为扩展的文件。 可以用 C 语言 来写模块。模块被编译好之后，使用标准 Python 解释器，就可在你的 Python 代码中调用这些模块。 引入模块的过程 Python 解释器会在它的 sys.path 变量中列出来的目录中寻找这个模块 如果模块被找到，则运行该模块主体中的语句，这个模块就会被设为 可用 供你使用。 注意，初始化在我们 第一次 引入这个模块时就会完成。 sys 模块中的 argv 变量可以通过点表示法，即 sys.argv 访问。它清晰地指出这个名字就是 sys 模块的一部分。这种访问方式的另一优点就是这个名字不会与你程序中的任何 argv 的变量发生冲突。 sys.path 是模块导入时要搜索的目录列表。我们可以看到 sys.path 的第一个字符串是空的，空字符串意味着当前目录也是 sys.path 的一部分，这与 PYTHONPATH 环境变量是相同的。这意味着你可以直接从当前目录下导入模块。不然你还需要把你要导入的模块放到 sys.path 中的一个目录里。 字节码文件 .pyc .pyc文件可以加快程序代码导入模块的过程，因为导入模块所必须的一部分操作已经被事先完成了。 这些 .pyc 文件一般会被创建在与它对应的 .py 文件相同的文件目录下。如果 Python 没有在该文件夹下写文件的权限，那么 .pyc 文件将不会被创建。 from..import 语句 如果你希望直接把 argv 变量导入到你的程序中（以避免每次都要键入 sys.），那么你就可以使用 from sys import argv 语句。 警告：原则上来说，还是要 避免 使用 from..import 语句，而是使用 import 语句。这是因为如果使用 import 语句的话，你的程序会避免出现命名冲突的问题，并且代码的可读性更高。 模块的 _name_ 每一个模块都有一个名称，在模块中我们可以通过判断语句来确定模块的名称。这在一种情形下特别有用：确定模块被导入了？还是在独立地运行。如之前提到过的，当模块第一次被导入的时候，模块的代码将被执行。我们可以通过这一点，让模块在被导入和独立运行时执行不同的操作。通过模块的 _name_ 属性可以实现这个功能。 if __name__ == '__main__': print('This program is being run by itself') else: print('I am being imported from another module') 输出： $ python module_using_name.py This program is being run by itself $ python >>> import module_using_name I am being imported from another module >>> 警告：记住，你应该避免使用 导入，比如像 from mymodule import 这样。 dir 函数 内置的 dir() 函数能以列表的形式返回某个对象定义的一系列标识符。如果这个对象是个模块，返回的列表中会包含模块内部所有的函数、类和变量。 这个函数接收一个可选的参数。当参数是模块名时，函数会返回对应模块的标识符列表。没有参数时则会返回当前模块的标识符列表。 $ python >>> import sys # 获取 sys 模块内所有属性的标识符 >>> dir(sys) ['__displayhook__', '__doc__', 'argv', 'builtin_module_names', 'version', 'version_info'] # 这里只列出了部分输出 # 获取当前模块内属性的标识符 >>> dir() ['__builtins__', '__doc__', '__name__', '__package__', 'sys'] # 创建一个新的变量 'a' >>> a = 5 >>> dir() ['__builtins__', '__doc__', '__name__', '__package__', 'sys', 'a'] # 删除变量 'a' >>> del a >>> dir() ['__builtins__', '__doc__', '__name__', '__package__', 'sys'] 注意 dir 函数对 任何 对象都有效。例如：dir(str) 会列出 str (String) 类的属性。 还有一个 vars() 函数，它有时能给你对象的属性和它们的值，但这个函数并不总是有效。 程序包 程序包就是一个装满模块的文件夹，它有一个特殊的 init.py 文件，这个文件告诉 Python 这个文件夹是特别的，因为它装着 Python 的模块。 让我们假设你想创建一个叫做 world 的程序包，它有很多子程序包 asia、africa 等。这些子程序包依次包含 india、madagascar 等模块。 以下是一种组织文件夹的方式： - / - world/ - __init__.py - asia/ - __init__.py - india/ - __init__.py - foo.py - africa/ - __init__.py - madagascar/ - __init__.py - bar.py C6 数据结构 python 中有四种内置的数据结构 list、tuple、dictionary、set List 列表 保存有序项集合的数据结构。 一旦创建了列表，你就可以在列表中增加，删除或者搜索列表中的项 。 # 这是我的购物清单 shoplist = ['apple', 'mango', 'carrot', 'banana'] print('I have', len(shoplist), 'items to purchase.') print('These items are:', end=' ') for item in shoplist: print(item, end=' ') print('\\nI also have to buy rice.') shoplist.append('rice') print('My shopping list is now', shoplist) print('I will sort my list now') shoplist.sort() print('Sorted shopping list is', shoplist) print('The first item I will buy is', shoplist[0]) olditem = shoplist[0] del shoplist[0] print('I bought the', olditem) print('My shopping list is now', shoplist) 输出 $ python ds_using_list.py I have 4 items to purchase. These items are: apple mango carrot banana I also have to buy rice. My shopping list is now ['apple', 'mango', 'carrot', 'banana', 'rice'] I will sort my list now Sorted shopping list is ['apple', 'banana', 'carrot', 'mango', 'rice'] The first item I will buy is apple I bought the apple My shopping list is now ['banana', 'carrot', 'mango', 'rice'] Tuple 元组 将多个对象组合在一起，和字符串一样是 不可变的 ，即你不能修改元组。 # 尽管圆括号是可选的， # 我还是建议使用圆括号， # 来表示元组的开始和结束。 # 因为显式总比隐式要好。 zoo = ('python', 'elephant', 'penguin') print('Number of animals in the zoo is', len(zoo)) new_zoo = 'monkey', 'camel', zoo # parentheses not required but are a good idea print('Number of cages in the new zoo is', len(new_zoo)) print('All animals in new zoo are', new_zoo) print('Animals brought from old zoo are', new_zoo[2]) print('Last animal brought from old zoo is', new_zoo[2][2]) print('Number of animals in the new zoo is', len(new_zoo)-1+len(new_zoo[2])) 输出： $ python ds_using_tuple.py Number of animals in the zoo is 3 Number of cages in the new zoo is 3 All animals in new zoo are ('monkey', 'camel', ('python', 'elephant', 'penguin')) Animals brought from old zoo are ('python', 'elephant', 'penguin') Last animal brought from old zoo is penguin Number of animals in the new zoo is 5 包含0个项的元组 由一对空的圆括号构成，例如： myempty = () 包含1个项的元组 一对空的圆括号和第一项后面的一个逗号构成，例如： singleton = (2, ) Dict 字典 字典是一组键值对 键必须是唯一的 键值对不以任何形式排序 字典的键只能用不可变对象（比如字符串），字典的值不可变对象或者可变对象都可以使用。 # 'ab' 是 'a'ddress'b'ook 的缩写，意思是地址簿 ab = { 'Swaroop': 'swaroop@swaroopch.com', 'Larry': 'larry@wall.org', 'Matsumoto': 'matz@ruby-lang.org', 'Spammer': 'spammer@hotmail.com' } print(\"Swaroop's address is\", ab['Swaroop']) # 删除一个键值对 del ab['Spammer'] print('\\nThere are {} contacts in the address-book\\n'.format(len(ab))) for name, address in ab.items(): print('Contact {} at {}'.format(name, address)) # 添加一个键值对 ab['Guido'] = 'guido@python.org' if 'Guido' in ab: print(\"\\nGuido's address is\", ab['Guido']) 输出： $ python ds_using_dict.py Swaroop's address is swaroop@swaroopch.com There are 3 contacts in the address-book Contact Swaroop at swaroop@swaroopch.com Contact Matsumoto at matz@ruby-lang.org Contact Larry at larry@wall.org Guido's address is guido@python.org Seq 序列 列表，元组和字典都是序列的一种，但序列是什么，为什么它们这么特别呢？ 序列的主要特征是：成员测试 (例如：in 与 not in 表达式) 和 索引操作，这两种操作让我们可以直接从序列中提取特定的部分。 上面提到了三种序列：列表、元组和字典。它们还有另一种特殊的操作 —— 切片 ，切片操作让我们可以得到序列的一部分。 shoplist = ['apple', 'mango', 'carrot', 'banana'] name = 'swaroop' # 字符串索引 # print('Item 0 is', shoplist[0]) print('Item 1 is', shoplist[1]) print('Item 2 is', shoplist[2]) print('Item 3 is', shoplist[3]) print('Item -1 is', shoplist[-1]) # 返回最后一个元素 print('Item -2 is', shoplist[-2]) # 返回倒数第二个元素 print('Character 0 is', name[0]) # 列表切片 # # 数是可选的，冒号是必须的 # 冒号之前的第一个数表示切片开始的位置，冒号之后的第二个数表示切片到哪里终止。如果不指定第一个数，Python 会从序列首开始，不指定第二个数则到序列尾结束。 # 注意返回的切片从开始位置 开始，在结束位置之前 结束，即一个左闭右开区间。 print('Item 1 to 3 is', shoplist[1:3]) print('Item 2 to end is', shoplist[2:]) print('Item 1 to -1 is', shoplist[1:-1]) print('Item start to end is', shoplist[:]) # 字符串切片 # print('characters 1 to 3 is', name[1:3]) print('characters 2 to end is', name[2:]) print('characters 1 to -1 is', name[1:-1]) print('characters start to end is', name[:]) 输出： $ python ds_seq.py Item 0 is apple Item 1 is mango Item 2 is carrot Item 3 is banana Item -1 is banana Item -2 is carrot Character 0 is s Item 1 to 3 is ['mango', 'carrot'] Item 2 to end is ['carrot', 'banana'] Item 1 to -1 is ['mango', 'carrot'] Item start to end is ['apple', 'mango', 'carrot', 'banana'] characters 1 to 3 is wa characters 2 to end is aroop characters 1 to -1 is waroo characters start to end is swaroop 还可以使用第三个参数——步长 如果给负数-1，则会返回文本的反转 def reverse(text): return text[::-1] def is_palindrome(text): return text == reverse(text) something = input(\"Enter text: \") if is_palindrome(something): print(\"Yes, it is a palindrome\") else: print(\"No, it is not a palindrome\") 输出： $ python3 io_input.py Enter text: sir No, it is not a palindrome $ python3 io_input.py Enter text: madam Yes, it is a palindrome $ python3 io_input.py Enter text: racecar Yes, it is a palindrome Set 集合 集合（set）是简单对象的 无序的 集合（collection）。当对象在集合（collection）中的存在比对象在集合（collection）中的顺序或者比对象在集合（collection）中出现的次数更为重要时，我们就会用到集合（set）。 你可以使用集合（set）来测试成员资格，看看它是否是另一个集合（set）的子集，找到两个集合之间的交集，等等。 >>> bri = set(['brazil', 'russia', 'india']) >>> 'india' in bri True >>> 'usa' in bri False >>> bric = bri.copy() >>> bric.add('china') >>> bric.issuperset(bri) True >>> bri.remove('russia') >>> bri & bric # 或者是 bri.intersection(bric) {'brazil', 'india'} 在数学上， set 和 collection 的区别是是否具有互异性，即，包含的元素是否可以重复出现。set 中的元素具有互异性，而 collection 中的元素不具有互异性。 引用 当你创建了一个对象，并把它赋值给一个变量时，这个变量只是 引用 了这个对象，变量并不能代表对象自身！因此，你可以把变量名当作一个指针，它指向储存对象的那一块计算机内存。这称作 绑定 名称到对象。 print('Simple Assignment') shoplist = ['apple', 'mango', 'carrot', 'banana'] # mylist 只是指向同一个对象的另一个别名！ mylist = shoplist # 我买下了第一件商品，所以把它从列表中移除 del shoplist[0] print('shoplist is', shoplist) print('mylist is', mylist) # 注意到 shoplist 和 mylist 产生了同样的输出 # 输出的都是没有 'apple' 的相同列表 # 这验证了它们都指向着同一个对象 print('Copy by making a full slice') # 通过全切片来获得一个副本 mylist = shoplist[:] # 移除第一个元素 del mylist[0] print('shoplist is', shoplist) print('mylist is', mylist) # 注意到现在这两个列表有差异了 输出： $ python ds_reference.py Simple Assignment shoplist is ['mango', 'carrot', 'banana'] mylist is ['mango', 'carrot', 'banana'] Copy by making a full slice shoplist is ['mango', 'carrot', 'banana'] mylist is ['carrot', 'banana'] 更多字符串操作 # 这是一个字符串对象 name = 'Swaroop' if name.startswith('Swa'): print('Yes, the string starts with \"Swa\"') if 'a' in name: print('Yes, it contains the string \"a\"') if name.find('war') != -1: print('Yes, it contains the string \"war\"') delimiter = '_*_' mylist = ['Brazil', 'Russia', 'India', 'China'] print(delimiter.join(mylist)) 输出： $ python ds_str_methods.py Yes, the string starts with \"Swa\" Yes, it contains the string \"a\" Yes, it contains the string \"war\" Brazil_*_Russia_*_India_*_China C7 面向对象编程 关于 self 类的方法在入口参数表的开头必须有一个额外的形式参数，指向对象本身，约定它的名字叫做self。（可以起其他名字，但是强烈建议不要这样做） 类 class Person: pass # 一个空的语句块 p = Person() print(p) 输出： $ python oop_simplestclass.py 方法 class Person: def say_hi(self): print('Hello, how are you?') p = Person() p.say_hi() # 上面两行也可以写成下面这种形式 # Person().say_hi() 输出： $ python oop_method.py Hello, how are you? _init_ 方法 _init_ 方法将在类的对象被初始化（也就是创建）的时候自动的调用。这个方法将按照你的想法 初始化 对象（通过给对象传递初始值）。 class Person: def __init__(self, name): self.name = name def say_hi(self): print('Hello, my name is', self.name) p = Person('Swaroop') p.say_hi() # 上面两行也可以写成下面这种形式 # Person('Swaroop').say_hi() 输出： $ python oop_init.py Hello, my name is Swaroop 类和对象中的变量 域的类型 类变量：属于类。 对象变量：属于对象（实例）。 类变量 共享性：类变量在同一个类的所有对象中共享。也就是说，类的所有实例都访问同一个变量。 访问方式：可以通过类名或者类的对象访问，例如：className.variableName或者self.__class__.variableName。 修改影响：如果一个对象修改了类变量，这个修改对所有这个类的对象都是可见的，因为它们共享同一份拷贝。 对象变量 独立性：对象变量是每个对象（实例）独有的。每个对象有自己的一份变量，它们之间不共享。 访问方式：通过对象自身访问，例如：self.variableName。 独立修改：修改一个对象的变量不会影响其他对象，因为每个对象有自己独立的变量。 定义类方法和静态方法 类方法（classmethod）：属于类的方法，可以使用@classmethod装饰器定义。 静态方法（staticmethod）：也属于类的方法，但不依赖类或实例，可以使用@staticmethod装饰器定义。 @classmethod #这是一个装饰器 def how_many(cls): \"\"\"显示当前人口数。\"\"\" print(\"We have {:d} robots.\".format(cls.population)) 装饰器可以被想象成为一个快捷的方式去调用一个包裹函数（一个包裹着另外一个函数的函数，因此可以在内部函数调用之前及之后做一些事情），因此使用 @classmethod 装饰器和如下调用等价： 所有的类成员都是公共的。只有一种情况除外：如果你使用 双下划线前缀 （例如 __privatevar ）时，Python 会使用命名粉碎规则 (name-mangling) 作用于这个变量，并使其变为私有变量。 相关链接：https://zhuanlan.zhihu.com/p/79280319 继承 class SchoolMember: '''代表了学校中的任何一个成员''' def __init__(self, name, age): self.name = name self.age = age print('(Initialized SchoolMember: {})'.format(self.name)) def tell(self): '''告诉我细节''' print('Name:\"{}\" Age:\"{}\"'.format(self.name, self.age), end=\" \") class Teacher(SchoolMember): '''表征一个老师''' def __init__(self, name, age, salary): SchoolMember.__init__(self, name, age) self.salary = salary print('(Initialized Teacher: {})'.format(self.name)) def tell(self): SchoolMember.tell(self) print('Salary: \"{:d}\"'.format(self.salary)) class Student(SchoolMember): '''表征一个学生''' def __init__(self, name, age, marks): SchoolMember.__init__(self, name, age) self.marks = marks print('(Initialized Student: {})'.format(self.name)) def tell(self): SchoolMember.tell(self) print('Marks: \"{:d}\"'.format(self.marks)) t = Teacher('Mrs. Shrividya', 40, 30000) s = Student('Swaroop', 25, 75) # 输出一个空行 print() members = [t, s] for member in members: # 所有的老师和学生都可用 member.tell() C8 输入与输出 文件 可以创建一个 file 类的对象来打开文件以供读写，使用 read, readline 或 write 中的恰当方法可以读取或写入文件。对文件的读写能力取决于你打开文件时选择的模式。当你处理完文件后，你可以使用 close 方法告诉 Python 你已经使用完文件了。 poem = '''\\ Programming is fun When the work is done if you wanna make your work also fun: use Python! ''' # 打开文件进行 'w'riting 写操作 f = open('poem.txt', 'w') # 将文本写入到文件 f.write(poem) # 关闭文件 f.close() # 如果没有指定文件打开方式 # 默认使用 'r'ead 读模式 f = open('poem.txt') while True: line = f.readline() # 零行意味着 EOF 文件结尾 if len(line) == 0: break # `line` 中已经自带换行了 # 因为它是从文件中读取出来的 print(line, end='') # 关闭文件 f.close() 输出： $ python3 io_using_file.py Programming is fun When the work is done if you wanna make your work also fun: use Python! Pickle import pickle # 这里我们将存储对象的文件的名称 shoplistfile = 'shoplist.data' # 要买的东西的清单 shoplist = ['apple', 'mango', 'carrot'] # 写入文件 f = open(shoplistfile, 'wb') # 将对象存储到文件 pickle.dump(shoplist, f) f.close() # 销毁 shoplist 变量 del shoplist # 从存储中读回 f = open(shoplistfile, 'rb') # 从文件加载对象 storedlist = pickle.load(f) print(storedlist) 输出： $ python io_pickle.py ['apple', 'mango', 'carrot'] C9 异常 错误 Error 编译器可以检查到的 异常 Exception 处理异常 try: text = input('Enter something --> ') except EOFError: print('Why did you do an EOF on me?') except KeyboardInterrupt: print('You cancelled the operation.') else: print('You entered {}'.format(text)) 输出： # 按下 ctrl + d $ python exceptions_handle.py Enter something --> Why did you do an EOF on me? # 按下 ctrl + c $ python exceptions_handle.py Enter something --> ^CYou cancelled the operation. $ python exceptions_handle.py Enter something --> No exceptions You entered No exceptions 引发异常 可以用 raise 语句 引发（ raise ） 异常，需要提供错误或异常的名字以及被 抛出（ thrown ） 的异常对象。 class ShortInputException(Exception): '''用户定义的异常对象''' def __init__(self, length, atleast): Exception.__init__(self) self.length = length self.atleast = atleast try: text = input('Enter something --> ') if len(text) Try … Finally import sys import time f = None try: f = open(\"poem.txt\") # 我们通常读取文件的语句 while True: line = f.readline() if len(line) == 0: break print(line, end='') sys.stdout.flush() print(\"Press ctrl+c now\") # 让程序保持运行一段时间 time.sleep(2) except IOError: print(\"Could not find file poem.txt\") except KeyboardInterrupt: print(\"!! You cancelled the reading from the file.\") finally: if f: f.close() print(\"(Cleaning up: Closed the file)\") 输出： $ python exceptions_finally.py Programming is fun Press ctrl+c now You cancelled the reading from the file. (Cleaning up: Closed the file) with 语句 with open(\"poem.txt\") as f: for line in f: print(line, end='') C10 标准库 sys模块 sys 模块有一个给出版本信息的 version_info tuple >>> import sys >>> sys.version_info sys.version_info(major=3, minor=6, micro=0, releaselevel='final', serial=0) >>> sys.version_info.major == 3 True logging 模块 如果你希望将一些调试消息或重要消息存储在某个地方，以便你可以检查你的程序是否按照预期运行，该怎么办？你怎样将这些信息「存在某地」，这可以用 logging 模块收集。 import os import platform import logging if platform.platform().startswith('Windows'): logging_file = os.path.join(os.getenv('HOMEDRIVE'), os.getenv('HOMEPATH'), 'test.log') else: logging_file = os.path.join(os.getenv('HOME'), 'test.log') print(\"Logging to\", logging_file) logging.basicConfig( level=logging.DEBUG, format='%(asctime)s : %(levelname)s : %(message)s', filename=logging_file, filemode='w', ) logging.debug(\"Start of the program\") logging.info(\"Doing something\") logging.warning(\"Dying now\") 输出： $ python stdlib_logging.py Logging to /Users/swa/test.log $ cat /Users/swa/test.log 2014-03-29 09:27:36,660 : DEBUG : Start of the program 2014-03-29 09:27:36,660 : INFO : Doing something 2014-03-29 09:27:36,660 : WARNING : Dying now 首先，我们查看 platform.platform() （查看 import platform; help(platform) 获得更多信息）返回的字符串来检查我们所用操作系统类型。如果是 Windows，我们找到要存储信息的主驱动器、用户根文件夹和文件名。把这三个部分放在一起，我们就得到了文件的完整位置。对于其他平台，我们只需要知道用户的主文件夹，就可以得到文件的完整位置。 我们使用 os.path.join() 函数组合路径的三个部分。 使用特殊函数而不仅仅是将字符串拼接到一起的原因是，这个函数将确保完整位置与操作系统预期的格式相同。注意：我们在这里使用的 join() 方法是 os 模块的一部分，它与我们在本书的其他地方使用的字符串方法 join() 不同。 C11 更多知识 传递元组 可以用于在函数中返回两个不同的值 >>> def get_error_details(): ... return (2, 'details') ... >>> errnum, errstr = get_error_details() >>> errnum 2 >>> errstr 'details' 请注意， a, b = 会将表达式的结果解析为两个值组成的元组。 这也意味着在 Python 中交换两个变量的最快方法是： >>> a = 5; b = 8 >>> a, b (5, 8) >>> a, b = b, a >>> a, b (8, 5) 魔术方法 _init_(self, ...) 在返回新创建可以使用的对象之前调用此方法。 _del_(self) 在对象被销毁之前调用（具有不可预测时机，所以避免使用它） _str_(self) 当我们使用 print 函数或使用 str() 时调用。 _lt_(self, other) 使用小于（ less than ）运算符（ 等） _getitem_(self, key) 使用 x[key] 索引操作时调用。 _len_(self) 当内置的 len() 函数用于序列对象时调用。 单个语句块 当语句块只包含一个语句，那么可以在条件语句或循环语句的同一行指定。 >>> flag = True >>> if flag: print('Yes') ... Yes Lambda 格式 lambda 语句用于创建新的函数对象。 基本上， lambda 采用一个参数，后跟一个表达式。 Lambda 成为函数的函数体。 新函数返回此表达式的值。 points = [{'x': 2, 'y': 3}, {'x': 4, 'y': 1}] points.sort(key=lambda i: i['y']) print(points) 输出： $ python more_lambda.py [{'y': 1, 'x': 4}, {'y': 3, 'x': 2}] 列表推导 列表推导用于从现有列表中导出新列表。 listone = [2, 3, 4] listtwo = [2*i for i in listone if i > 2] print(listtwo) 输出： $ python more_list_comprehension.py [6, 8] 在函数中接收元组和字典 有一种特殊的方法可以分别使用 或 * 前缀将参数作为元组或字典接收到函数中。 当在函数中使用可变数量的参数时，这很有用。 >>> def powersum(power, *args): ... '''返回每个参数指定幂次的总和。''' ... total = 0 ... for i in args: ... total += pow(i, power) ... return total ... >>> powersum(2, 3, 4) 25 >>> powersum(2, 10) 100 因为我们在 args 变量上有一个 前缀，所有传递给函数的额外参数都作为元组存储在 args 中。 如果使用了 * 前缀，那么额外的参数将被作为字典的键 / 值对。 assert 语句 assert 语句用于断言某值为 True 。 例如，如果您非常确定您正在使用的列表中至少有一个元素并且想要检查它，并且如果不是 True 则引发错误，那么 assert 语句在这种情况下是理想的。 当 assert 语句失败时，会引发 AssertionError 。 pop（） 方法删除并返回列表中的最后一项。 >>> mylist = ['item'] >>> assert len(mylist) >= 1 >>> mylist.pop() 'item' >>> assert len(mylist) >= 1 Traceback (most recent call last): File \"\", line 1, in AssertionError 装饰器 装饰器是用于包装函数的快捷方式。 这有助于一遍又一遍地使用相同的代码『包装』功能。 例如，我为自己创建了一个 retry 装饰器，我能应用于任何函数，如果在运行期间抛出任何异常，则会再次重试，直到最多 5 次并且每次重试之间有间隔。 这对于你尝试向远程计算机进行网络连接的情况特别有用： from time import sleep from functools import wraps import logging logging.basicConfig() log = logging.getLogger(\"retry\") def retry(f): @wraps(f) def wrapper_function(*args, **kwargs): MAX_ATTEMPTS = 5 for attempt in range(1, MAX_ATTEMPTS + 1): try: return f(*args, **kwargs) except: log.exception(\"Attempt %s/%s failed : %s\", attempt, MAX_ATTEMPTS, (args, kwargs)) sleep(10 * attempt) log.critical(\"All %s attempts failed : %s\", MAX_ATTEMPTS, (args, kwargs)) return wrapper_function counter = 0 @retry def save_to_database(arg): print(\"Write to a database or make a network call or etc.\") print(\"This will be automatically retried if exception is thrown.\") global counter counter += 1 # 这将在第一次调用中抛出异常 # 并且在第二次调用中工作正常（即重试） if counter 输出： $ python more_decorator.py Write to a database or make a network call or etc. This will be automatically retried if exception is thrown. ERROR:retry:Attempt 1/5 failed : (('Some bad value',), {}) Traceback (most recent call last): File \"more_decorator.py\", line 14, in wrapper_function return f(*args, **kwargs) File \"more_decorator.py\", line 39, in save_to_database raise ValueError(arg) ValueError: Some bad value Write to a database or make a network call or etc. This will be automatically retried if exception is thrown. No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Python/python装饰器.html":{"url":"03_语言/Python/python装饰器.html","title":"Python装饰器","keywords":"","body":"装饰器 装饰器实际上就是为了给某程序增添功能，但该程序已经上线或已经被使用，那么就不能大批量的修改源代码，这样是不科学的也是不现实的，因为就产生了装饰器，使得其满足： 不能修改被装饰的函数的源代码 不能修改被装饰的函数的调用方式 满足1、2的情况下给程序增添功能 那么根据需求，同时满足了这三点原则，这才是我们的目的。因为，下面我们从解决这三点原则入手来理解装饰器。 等等，我要在需求之前先说装饰器的原则组成： 这个式子是贯穿装饰器的灵魂所在！ 需求的实现 假设有代码: improt time def test(): time.sleep(2) print(\"test is running!\") test() 很显然，这段代码运行的结果一定是：等待约2秒后，输出 test is running 那么要求在满足三原则的基础上，给程序添加统计运行时间（2 second）功能 在行动之前，我们先来看一下文章开头提到的原因1（关于函数“变量”（或“变量”函数）的理解） 函数“变量”（或“变量”函数） 假设有代码： x = 1 y = x def test1(): print(\"Do something\") test2 = lambda x:x*2 很显然，函数和变量是一样的，都是“一个名字对应内存地址中的一些内容” 那么根据这样的原则，我们就可以理解两个事情： test1表示的是函数的内存地址 test1()就是调用对在test1这个地址的内容，即函数 如果这两个问题可以理解，那么我们就可以进入到下一个原因(关于高阶函数的理解) 高阶函数 那么对于高阶函数的形式可以有两种： 把一个函数名当作实参传给另外一个函数（“实参高阶函数”） 返回值中包含函数名（“返回值高阶函数”） 那么这里面所说的函数名，实际上就是函数的地址，也可以认为是函数的一个标签而已，并不是调用，是个名词。如果可以把函数名当做实参，那么也就是说可以把函数传递到另一个函数，然后在另一个函数里面做一些操作，根据这些分析来看，这岂不是满足了装饰器三原则中的第一条，即不修改源代码而增加功能。那我们看来一下具体的做法： 还是针对上面那段代码： improt time def test(): time.sleep(2) print(\"test is running!\") def deco(func): start = time.time() func() #2 stop = time.time() print(stop-start) deco(test) #1 我们来看一下这段代码，在#1处，我们把test当作实参传递给形参func，即func=test。注意，这里传递的是地址，也就是此时func也指向了之前test所定义的那个函数体，可以说在deco()内部，func就是test。在#2处，把函数名后面加上括号，就是对函数的调用（执行它）。因此，这段代码运行结果是： test is running! the run time is 3.0009405612945557 我们看到似乎是达到了需求，即执行了源程序，同时也附加了计时功能，但是这只满足了原则1（不能修改被装饰的函数的源代码），但这修改了调用方式。假设不修改调用方式，那么在这样的程序中，被装饰函数就无法传递到另一个装饰函数中去。 那么再思考，如果不修改调用方式，就是一定要有test()这条语句，那么就用到了第二种高阶函数，即返回值中包含函数名 如下代码： improt time def test(): time.sleep(2) print(\"test is running!\") def deco(func): print(func) return func t = deco(test) #3 #t()#4 test() 我们看这段代码，在#3处，将test传入deco()，在deco()里面操作之后，最后返回了func，并赋值给t。因此这里test => func => t，都是一样的函数体。最后在#4处保留了原来的函数调用方式。 看到这里显然会有些困惑，我们的需求不是要计算函数的运行时间么，怎么改成输出函数地址了。是因为，单独采用第二种高阶函数（返回值中包含函数名）的方式，并且保留原函数调用方式，是无法计时的。如果在deco()里计时，显然会执行一次，而外面已经调用了test()(？？？)，会重复执行。这里只是为了说明第二种高阶函数的思想，下面才真的进入重头戏。 嵌套函数 嵌套函数指的是在函数内部定义一个函数，而不是调用，如： def func1(): def func2(): pass 而不是 def func1(): func2() 另外还有一个题外话，函数只能调用和它同级别以及上级的变量或函数。也就是说：里面的能调用和它缩进一样的和他外部的，而内部的是无法调用的。 那么我们再回到我们之前的那个需求，想要统计程序运行时间，并且满足三原则。 代码： improt time def timer(func) #5 def deco(): start = time.time() func() stop = time.time() print(stop-start) return deco test = timer(test) #6 def test(): time.sleep(2) print(\"test is running!\") test() #7 这段代码可能会有些困惑，怎么忽然多了这么多，暂且先接受它，分析一下再来说为什么是这样。 首先，在#6处，把test作为参数传递给了timer()，此时，在timer()内部，func = test，接下来，定义了一个deco()函数，当并未调用，只是在内存中保存了，并且标签为deco。在timer()函数的最后返回deco()的地址deco。 然后再把deco赋值给了test，那么此时test已经不是原来的test了，也就是test原来的那些函数体的标签换掉了，换成了deco。那么在#7处调用的实际上是deco()。 那么这段代码在本质上是修改了调用函数，但在表面上并未修改调用方式，而且实现了附加功能。 那么通俗一点的理解就是： 把函数看成是盒子，test是小盒子，deco是中盒子，timer是大盒子。程序中，把小盒子test传递到大盒子temer中的中盒子deco，然后再把中盒子deco拿出来，打开看看（调用） 这样做的原因是： 我们要保留test()，还要统计时间，而test()只能调用一次（调用两次运行结果会改变，不满足），再根据函数即“变量”，那么就可以通过函数的方式来回闭包。于是乎，就想到了，把test传递到某个函数，而这个函数内恰巧内嵌了一个内函数，再根据内嵌函数的作用域（可以访问同级及以上，内嵌函数可以访问外部参数），把test包在这个内函数当中，一起返回，最后调用这个返回的函数。而test传递进入之后，再被包裹出来，显然test函数没有弄丢（在包裹里），那么外面剩下的这个test标签正好可以替代这个包裹（内含test()）。 至此，一切皆合，大功告成，单只差一步。 真正的装饰器 根据以上分析，装饰器在装饰时，需要在每个函数前面加上： test = timer(test) 显然有些麻烦，Python提供了一种语法糖，即： @timer 这两句是等价的，只要在函数前加上这句，就可以实现装饰作用。 以上为无参形式 装饰有参函数 improt time def timer(func) def deco(): start = time.time() func() stop = time.time() print(stop-start) return deco @timer def test(parameter): #8 time.sleep(2) print(\"test is running!\") test() 对于一个实际问题，往往是有参数的，如果要在#8处，给被修饰函数加上参数，显然这段程序会报错的。错误原因是test()在调用的时候缺少了一个位置参数的。而我们知道test = func = deco，因此test()=func()=deco() ,那么当test(parameter)有参数时，就必须给func()和deco()也加上参数，为了使程序更加有扩展性，因此在装饰器中的deco()和func()，加如了可变参数agrs和 *kwargs。 完整代码如下： improt time def timer(func) def deco(*args, **kwargs): start = time.time() func(*args, **kwargs) stop = time.time() print(stop-start) return deco @timer def test(parameter): #8 time.sleep(2) print(\"test is running!\") test() 那么我们再考虑个问题，如果原函数test()的结果有返回值呢？比如： def test(parameter): time.sleep(2) print(\"test is running!\") return \"Returned value\" 那么面对这样的函数，如果用上面的代码来装饰，最后一行的test()实际上调用的是deco()。有人可能会问，func()不就是test()么，怎么没返回值呢？ 其实是有返回值的，但是返回值返回到deco()的内部，而不是test()即deco()的返回值，那么就需要再返回func()的值，因此就是： def timer(func) def deco(*args, **kwargs): start = time.time() res = func(*args, **kwargs)#9 stop = time.time() print(stop-start) return res#10 return deco 其中，#9的值在#10处返回。 完整程序为： improt time def timer(func) def deco(*args, **kwargs): start = time.time() res = func(*args, **kwargs) stop = time.time() print(stop-start) return res return deco @timer def test(parameter): #8 time.sleep(2) print(\"test is running!\") return \"Returned value\" test() 带参数的装饰器 又增加了一个需求，一个装饰器，对不同的函数有不同的装饰。那么就需要知道对哪个函数采取哪种装饰。因此，就需要装饰器带一个参数来标记一下。例如： @decorator(parameter = value) 比如有两个函数： def task1(): time.sleep(2) print(\"in the task1\") def task2(): time.sleep(2) print(\"in the task2\") task1() task2() 要对这两个函数分别统计运行时间，但是要求统计之后输出： the task1/task2 run time is : 2.00…… 于是就要构造一个装饰器timer，并且需要告诉装饰器哪个是task1，哪个是task2，也就是要这样： @timer(parameter='task1') # def task1(): time.sleep(2) print(\"in the task1\") @timer(parameter='task2') # def task2(): time.sleep(2) print(\"in the task2\") task1() task2() 那么方法有了，但是我们需要考虑如何把这个parameter参数传递到装饰器中，我们以往的装饰器，都是传递函数名字进去，而这次，多了一个参数，要怎么做呢？ 于是，就想到再加一层函数来接受参数，根据嵌套函数的概念，要想执行内函数，就要先执行外函数，才能调用到内函数，那么就有： def timer(parameter): # print(\"in the auth :\", parameter) def outer_deco(func): # print(\"in the outer_wrapper:\", parameter) def deco(*args, **kwargs): return deco return outer_deco 首先timer(parameter)，接收参数parameter=’task1/2’，而@timer(parameter)也恰巧带了括号，那么就会执行这个函数， 那么就是相当于： timer = timer(parameter) task1 = timer(task1) 后面的运行就和一般的装饰器一样了： import time def timer(parameter): def outer_wrapper(func): def wrapper(*args, **kwargs): if parameter == 'task1': start = time.time() func(*args, **kwargs) stop = time.time() print(\"the task1 run time is :\", stop - start) elif parameter == 'task2': start = time.time() func(*args, **kwargs) stop = time.time() print(\"the task2 run time is :\", stop - start) return wrapper return outer_wrapper @timer(parameter='task1') def task1(): time.sleep(2) print(\"in the task1\") @timer(parameter='task2') def task2(): time.sleep(2) print(\"in the task2\") task1() task2() 至此，装饰器的全部内容结束。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Python/Python详细教程.html":{"url":"03_语言/Python/Python详细教程.html","title":"Python详细教程","keywords":"","body":"Python基础 数据类型和变量 整数 浮点数 字符串 r' '内的内容不转义 >>> text = \"/QtDemo/ToolsList\\_ _pycache_lstart.cpython-36.pyc \\r\\n\" >>> print(text) /QtDemo/ToolsList\\__pycache__lstart.cpython-36.pyc >>> text = r\"/QtDemo/ToolsList\\_pycache_\\start.cpython-36.pyc \\r\\n\" >>> print(text) /QtDemo/ToolsList\\__pycache__\\start.cpython-36.pyc lrin 注释 # 单行注释 ``` 多行注释 ``` \"\"\" 多行注释 \"\"\" 字符串和编码 字符编码 ASCII(1个字节) GB2312(ASCII+中文) Unicode(2个字节，ASCII+各国语言) UTF-8(1-6个字节英文1常见中文3，ASCII+各国语言，节省空间常用于保存文件或网络传输数据) 字符串 ord()&&chr() >>> ord('a') 97 >>> chr(97) a 用十六进制写str >>> '\\u4e2d\\u6587' '中文' 用二进制保存字符串 字符串保存到磁盘或在网络上传输时，需要将str转换为以字节为单位的bytes 如：x = b'ABC' >>> 'ABC'.encode('ascii') b'ABC' >>> '中文'.encode('utf-8')#无法显示为ASCII的字节用\\x..表示 b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' >>> b'ABC'.decode('ascii') 'ABC' >>> b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8') '中文' >>> b'\\xe4\\xb8\\xad\\xff'.decode('utf-8', errors='ignore') '中' 计算长度 len('')计算字符数 len(b'')计算字节数 正则表达式 匹配规则 匹配字符类型 \\d匹配数字 \\w匹配一个字母或数字 \\s匹配空白字符 匹配字符数量 *表示任意个字符(包括0个) +表示至少一个字符 ?表示0-1个字符 {n}表示n个字符 {n,m}表示n-m个字符 匹配个别字符 []表示范围 A|B可以匹配A或B (P|p)ython 匹配位置 ^表示行的开头 $表示行的结束 匹配方式 \\d+采用贪婪匹配 \\d+?采用非贪婪匹配 使用方式 采用re模块 #re.match 返回match对象 >>> import re >>> re.match(r'^\\d{3}\\-\\d{3,8}$', '010-12345') >>> re.match(r'^\\d{3}\\-\\d{3,8}$', '010 12345') #切分字符串 >>> re.split(r'[\\s\\,]+', 'a,b, c d') ['a', 'b', 'c', 'd'] #分组 >>> m = re.match(r'^(\\d{3})-(\\d{3,8})$', '010-12345') >>> m >>> m.group(0) '010-12345' >>> m.group(1) '010' >>> m.group(2) '12345' #编译 >>> import re >>> re_telephone = re.compile(r'^(\\d{3})-(\\d{3,8})$') >>> re_telephone.match('010-12345').groups() ('010', '12345') >>> re_telephone.match('010-8086').groups() ('010', '8086') 使用List和Tuple List pop()删除list末尾的元素 pop(i)删除指定位置的元素 list里面的元素的数据类型可以不同 Tuple tuple一旦初始化不能更改，是指向不变，如果里面有list，list的内容是可变的。 定义空的tuple：tuple() 定义一个元素的tuple：(x,) 使用dict和set Dict 一个key只能对应一个value d.get(key,#value)可以返回None，或者自己指定的value d.pop(key) dict内部存放的顺序和key放入的顺序是没有关系的 key必须是不可变对象 Set 一组不重复key的集合，但不存储value。 s=set([1,2,3]) s.add(4) s.remove(4) s1&s2 s1|s2 函数 调用函数 定义函数 import math def move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny >>> x, y = move(100, 100, 60, math.pi / 6) >>> print(x, y) 151.96152422706632 70.0 函数的参数 位置参数 最普通的那种 默认参数 定义函数的时候给参数指定一个值。 必选参数在前，默认参数在后 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。 可变参数 def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum >>> calc([1, 2, 3]) 14 >>> calc((1, 3, 5, 7)) 84 >>> calc(1, 2) 5 >>> calc() 0 关键字参数 def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) >>> person('Michael', 30) name: Michael age: 30 other: {} >>> person('Bob', 35, city='Beijing') name: Bob age: 35 other: {'city': 'Beijing'} >>> person('Adam', 45, gender='M', job='Engineer') name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'} >>> extra = {'city': 'Beijing', 'job': 'Engineer'} >>> person('Jack', 24, **extra) name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'} def person(name, age, *, city, job): print(name, age, city, job)#只接受city和job作为关键字参数 >>> person('Jack', 24, city='Beijing', job='Engineer')#如果没有传入参数名，调用将报错 Jack 24 Beijing Engineer 高级特性 切片 >>> L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack'] >>> L[-2:] ['Bob', 'Jack'] >>> L[-2:-1] ['Bob'] >>> L = list(range(100)) >>> L[::5] [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] >>> L[:] [0, 1, 2, 3, ..., 99] 迭代 列表生成式 >>> [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] >>> [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] >>> [m + n for m in 'ABC' for n in 'XYZ'] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] >>> import os # 导入os模块，模块的概念后面讲到 >>> [d for d in os.listdir('.')] # os.listdir可以列出文件和目录 ['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode'] >>> L = ['Hello', 'World', 'IBM', 'Apple'] >>> [s.lower() for s in L] ['hello', 'world', 'ibm', 'apple'] >>> d = {'x': 'A', 'y': 'B', 'z': 'C' } >>> [k + '=' + v for k, v in d.items()] ['y=B', 'x=A', 'z=C'] 生成器 一边循环一边计算的机制 >>> g = (x * x for x in range(10)) >>> g at 0x1022ef630> >>> next(g) 0 >>> next(g) 1 >>> next(g) 4 >>> next(g) 9 >>> next(g) 16 >>> next(g) 25 >>> next(g) 36 >>> next(g) 49 >>> next(g) 64 >>> next(g) 81 >>> next(g) Traceback (most recent call last): File \"\", line 1, in StopIteration >>> g = (x * x for x in range(10)) >>> for n in g: ... print(n) ... 0 1 4 9 16 25 36 49 64 81 def fib(max): n, a, b = 0, 0, 1 while n >> g = fib(6) >>> while True: ... try: ... x = next(g) ... print('g:', x) ... except StopIteration as e: ... print('Generator return value:', e.value) ... break 迭代器 可以直接作用于for循环的数据类型 集合数据类型：list、tuple、dict、set、str generator，包括生成器和带yield的generator function ```python from collections import Iterable isinstance([], Iterable) True isinstance({}, Iterable) True isinstance('abc', Iterable) True isinstance((x for x in range(10)), Iterable) True isinstance(100, Iterable) False from collections import Iterator isinstance((x for x in range(10)), Iterator) True isinstance([], Iterator) False isinstance({}, Iterator) False isinstance('abc', Iterator) False isinstance(iter([]), Iterator) True isinstance(iter('abc'), Iterator) True ``` 函数式编程 高阶函数 把一个函数名当作实参传给另外一个函数(“实参高阶函数”) 返回值中包含函数名(“返回值高阶函数”) 那么这里面所说的函数名，实际上就是函数的地址。 map/reduce >>> def f(x): ... return x * x ... >>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) >>> list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] >>> from functools import reduce >>> def fn(x, y): ... return x * 10 + y ... >>> reduce(fn, [1, 3, 5, 7, 9]) 13579 from functools import reduce DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9} def char2num(s): return DIGITS[s] def str2int(s): return reduce(lambda x, y: x * 10 + y, map(char2num, s)) filter def is_odd(n): return n % 2 == 1 list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) # 结果: [1, 5, 9, 15] sorted >>> sorted([36, 5, -12, 9, -21]) [-21, -12, 5, 9, 36] >>> sorted([36, 5, -12, 9, -21], key=abs) [5, 9, -12, -21, 36] >>> sorted(['bob', 'about', 'Zoo', 'Credit']) ['Credit', 'Zoo', 'about', 'bob'] >>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower) ['about', 'bob', 'Credit', 'Zoo'] >>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True) ['Zoo', 'Credit', 'bob', 'about'] 嵌套函数 嵌套函数指的是在函数内部定义一个函数，而不是调用，如： def func1(): def func2(): pass 而不是 def func1(): func2() 函数只能调用和它同级别以及上级的变量或函数。也就是说：里面的能调用和它缩进一样的和他外部的，而内部的是无法调用的。 返回函数 def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum >>> f = lazy_sum(1, 3, 5, 7, 9) >>> f .sum at 0x101c6ed90> >>> f() 25 >>> f1 = lazy_sum(1, 3, 5, 7, 9) >>> f2 = lazy_sum(1, 3, 5, 7, 9) >>> f1==f2 False def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fs >>> f1, f2, f3 = count() >>> f1() 9 >>> f2() 9 >>> f3() 9 def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs >>> f1, f2, f3 = count() >>> f1() 1 >>> f2() 4 >>> f3() 9 匿名函数 当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。 在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数： >>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])) [1, 4, 9, 16, 25, 36, 49, 64, 81] 通过对比可以看出，匿名函数lambda x: x * x实际上就是： def f(x): return x * x 关键字lambda表示匿名函数，冒号前面的x表示函数参数。 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。 用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数： >>> f = lambda x: x * x >>> f at 0x101c6ef28> >>> f(5) 25 同样，也可以把匿名函数作为返回值返回，比如： def build(x, y): return lambda: x * x + y * y 装饰器 装饰器实际上就是为了给某程序增添功能，但该程序已经上线或已经被使用，那么就不能大批量的修改源代码，这样是不科学的也是不现实的，因为就产生了装饰器，使得其满足： 不能修改被装饰的函数的源代码 不能修改被装饰的函数的调用方式 满足1、2的情况下给程序增添功能 装饰器的原则组成： 装饰器的详叙在python装饰器.md中 函数对象有一个name属性，可以拿到函数的名字 f.name def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper @log #相当于执行语句now=log(now) def now(): print('2015-3-25') >>> now() call now(): 2015-3-25 #原来的now()函数仍存在，只是同名的now变量指向了新的函数，于是调用now()将执行新函数 def log(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator @log('execute') def now(): print('2015-3-25') >>> now() execute now(): 2015-3-25 >>> now.__name__ 'wrapper' #因为返回的wrapper()函数的名字就是'wrapper'，所以需要把原始函数的__name__等属性复制到wrapper函数中，否则，有些依赖函数签名的代码执行就会出错。 偏函数 import functools def log(func): @functools.wraps(func) def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper import functools def log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator #加入的参数作为**kw >>> import functools >>> int2 = functools.partial(int, base=2) >>> int2('1000000') 64 >>> int2('1010101') 85 #加入的参数作为*args max2 = functools.partial(max, 10) tips:函数“变量”(或“变量”函数) 假设有代码： x = 1 y = x def test1(): print(\"Do something\") test2 = lambda x:x*2 很显然，函数和变量是一样的，都是“一个名字对应内存地址中的一些内容” 那么根据这样的原则，我们就可以理解两个事情： test1表示的是函数的内存地址 test1()就是调用对在test1这个地址的内容，即函数 模块 包 (目录结构) mycompany ├─ init.py#本身就是一个模块，模块名是mycompany.xyz ├─ abc.py └─ xyz.py mycompany ├─ web │ ├─ init.py │ ├─ utils.py │ └─ www.py ├─ init.py ├─ abc.py └─ xyz.py 包头 #!/usr/bin/env python3 # -*- coding: utf-8 -*- ' a test module '#任何模块代码的第一个字符串都被视为模块的文档注释 __author__ = 'Michael Liao' 变量的作用域 xxx可以直接被引用但有特殊用途 _xxx / __xxx 不应该被直接引用模块搜索路径 >>> import sys >>> sys.path ['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', ..., '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages'] >>> import sys >>> sys.path.append('/Users/michael/my_py_scripts')#添加系统包路径 面对对象编程 可以访问的实例变量属性 class Student(object): def __init__(self, name, score): self.name = name self.score = score >>> bart = Student('Bart Simpson', 59) >>> bart.name 'Bart Simpson' >>> bart.score 59 不可以访问的实例变量属性 class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) 继承 隐形继承：在父类中获得了方法，则在子类都可以自动获得这个功能 重写方法：想重写子类的方法且有效覆盖父类中的方法，只需要在子类中定义一个同名的方法 ```python之前或之后改变父类： class parent(object): def altered(self): print \"PARENT altered()\" class Child(Parent): def altered(self): print \"CHILD,BEFORE PARENT altered()\" super(Child,self).altered() print \"CHILD,AFTER PARENT altered()\" dad.altered() PARENT altered() son.altered CHILD,BEFORE PARENT altered() PARENT altered() CHILD,AFTER PARENT altered() ``` 包含 class Other(object): def override(self): print \"OTHER override()\" def implicit(self): print \"OTHER implicit()\" def altered(self): print \"OTHER altered()\" class Child(object): def __init__(self): self.other = Other() def implicit(self): self.other.implicit() def override(self): print \"CHILD override()\" def altered(self): print \"CHILD, BEFORE OTHER altered()\" self.other.altered() print \"CHILD, AFTER OTHER altered()\" >>> son = Child() >>> son.implicit() OTHER implicit() >>> son.override() CHILD override() >>> son.altered() CHILD, BEFORE OTHER altered() OTHER altered() CHILD, AFTER OTHER altered() 如何选择继承和包含? 将代码封装为模块，这样就可以在许多不同的地方或情况使用。 不惜一切代价避免多重继承，因为它太复杂太不可靠。如果你必须要使用它，那么一定要知道类的层次结构，并花时间找到每一个类是从哪里来的。 只有当有明显相关的可重用的代码，且在一个共同概念下时，可以使用继承。 type()&&isinstance()&&dir() >>> dir('ABC') ['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill'] >>> class MyObject(object): ... def __init__(self): ... self.x = 9 ... def power(self): ... return self.x * self.x ... >>> obj = MyObject() >>> hasattr(obj, 'x') # 有属性'x'吗？ True >>> obj.x 9 >>> hasattr(obj, 'y') # 有属性'y'吗？ False >>> setattr(obj, 'y', 19) # 设置一个属性'y' >>> hasattr(obj, 'y') # 有属性'y'吗？ True >>> getattr(obj, 'y') # 获取属性'y' 19 >>> obj.y # 获取属性'y' 19 >>> getattr(obj, 'z') # 获取属性'z' Traceback (most recent call last): File \"\", line 1, in AttributeError: 'MyObject' object has no attribute 'z' >>> getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404 404 >>> hasattr(obj, 'power') # 有属性'power'吗？ True >>> getattr(obj, 'power') # 获取属性'power' > >>> fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn >>> fn # fn指向obj.power > >>> fn() # 调用fn()与调用obj.power()是一样的 81 面对对象高级编程 动态定义属性 class Student(object): pass >>> s = Student() >>> s.name = 'Michael' # 动态给实例绑定一个属性 >>> print(s.name) Michael 动态定义方法 >>> def set_age(self, age): # 定义一个函数作为实例方法 ... self.age = age ... >>> from types import MethodType >>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法 >>> s.set_age(25) # 调用实例方法 >>> s.age # 测试结果 25 #对一个实例绑定的方法对其他的实例不起作用 >>> def set_score(self, score): ... self.score = score ... >>> Student.set_score = set_score ```###使用__slots__ ```python class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称 >>> s = Student() # 创建新的实例 >>> s.name = 'Michael' # 绑定属性'name' >>> s.age = 25 # 绑定属性'age' >>> s.score = 99 # 绑定属性'score' Traceback (most recent call last): File \"\", line 1, in AttributeError: 'Student' object has no attribute 'score' #__slots__只对当前类实例起作用，对继承的子类不起作用 #除非在子类中也定义__slots__，这样子类实例允许定义的属性就是自身的__slots__加上父类的__slots__ 使用@property class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value 100: raise ValueError('score must between 0 ~ 100!') self._score = value >>> s = Student() >>> s.score = 60 # OK，实际转化为s.set_score(60) >>> s.score # OK，实际转化为s.get_score() 60 >>> s.score = 9999 Traceback (most recent call last): ... ValueError: score must between 0 ~ 100! #还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性： 多重继承(在java里不能多重继承) class MyTCPServer(TCPServer, ForkingMixIn): pass #不需要复杂庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类 init中使用super() class Child(Parent): def __init__(self,stuff): self.stuff = stuff supe(Child,self).__init__() ``` 不惜一切代价避免多重继承，因为它太复杂太不可靠。如果你必须要使用它，那么一定要知道类的层次结构，并花时间找到每一个类是从哪里来的。 定制类 self参数 https://blog.csdn.net/CLHugh/article/details/75000104 _str_ >>> class Student(object): ... def __init__(self, name): ... self.name = name ... def __str__(self): ... return 'Student object (name: %s)' % self.name ... >>> print(Student('Michael'))#调用__str__() Student object (name: Michael) class Student(object): def __init__(self, name): self.name = name def __str__(self): return 'Student object (name=%s)' % self.name __repr__ = __str__ >>> s = Student('Michael')#调用__repr__()，用于测试 >>> s _iter_ class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b # 计算下一个值 if self.a > 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 >>> for n in Fib(): ... print(n) ... 1 1 2 3 5 ... 46368 75025 _getitem_ class Fib(object): def __getitem__(self, n): a, b = 1, 1 for x in range(n): a, b = b, a + b return a >>> f = Fib() >>> f[0] 1 >>> f[1] 1 >>> f[2] 2 >>> f[3] 3 >>> f[10] 89 >>> f[100] 573147844013817084101 class Fib(object): def __getitem__(self, n): if isinstance(n, int): # n是索引 a, b = 1, 1 for x in range(n): a, b = b, a + b return a if isinstance(n, slice): # n是切片 start = n.start stop = n.stop if start is None: start = 0 a, b = 1, 1 L = [] for x in range(stop): if x >= start: L.append(a) a, b = b, a + b return L >>> f = Fib() >>> f[0:5] [1, 1, 2, 3, 5] >>> f[:10] [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] _setitem_ 把对象视作list或dict来对集合赋值 _delitem_ 删除某个元素 _getattr_ class Student(object): def __getattr__(self, attr): if attr=='age': return lambda: 25 raise AttributeError('\\'Student\\' object has no attribute \\'%s\\'' % attr) #在没有找到属性时，会调用__getattr__，默认返回None。要让class只响应特定的几个属性，我们要按照约定抛出AttributeError错误。 class Chain(object): def __init__(self, path=''): self._path = path def __getattr__(self, path): return Chain('%s/%s' % (self._path, path)) def __str__(self): return self._path __repr__ = __str__ >>> Chain().status.user.timeline.list '/status/user/timeline/list' 无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！ _call_ 对实例自身进行调用 class Student(object): def __init__(self, name): self.name = name def __call__(self): print('My name is %s.' % self.name) >>> s = Student('Michael') >>> s() # self参数不要传入 My name is Michael. >>> callable(Student()) True >>> callable(max) True >>> callable([1, 2, 3]) False >>> callable(None) False >>> callable('str') False import() 函数功能用于动态的导入模块，主要用于反射或者延迟加载模块。 import(module)相当于import module 如果一个模块经常变化就可以使用 import__() 来动态载入。 语法： __import__(name[, globals[, locals[, fromlist[, level]]]]) 使用枚举类 from enum import Enum Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')) for name, member in Month.__members__.items(): print(name, '=>', member, ',', member.value) from enum import Enum, unique @unique #装饰器保证没有重复值 class Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 >>> day1 = Weekday.Mon >>> print(day1) Weekday.Mon >>> print(Weekday.Tue) Weekday.Tue >>> print(Weekday['Tue']) Weekday.Tue >>> print(Weekday.Tue.value) 2 >>> print(day1 == Weekday.Mon) True >>> print(day1 == Weekday.Tue) False >>> print(Weekday(1)) Weekday.Mon >>> print(day1 == Weekday(1)) True >>> Weekday(7) Traceback (most recent call last): ... ValueError: 7 is not a valid Weekday >>> for name, member in Weekday.__members__.items(): ... print(name, '=>', member) ... Sun => Weekday.Sun Mon => Weekday.Mon Tue => Weekday.Tue Wed => Weekday.Wed Thu => Weekday.Thu Fri => Weekday.Fri Sat => Weekday.Sat 使用元类 type() type()需要依次传入3个参数 class的名称 继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法； class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上 >>> from hello import Hello >>> h = Hello() >>> h.hello() Hello, world. >>> print(type(Hello)) >>> print(type(h)) >>> def fn(self, name='world'): # 先定义函数 ... print('Hello, %s.' % name) ... >>> Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class >>> h = Hello() >>> h.hello() Hello, world. >>> print(type(Hello)) >>> print(type(h)) metaclass # metaclass是类的模板，所以必须从`type`类型派生： class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs) class MyList(list, metaclass=ListMetaclass): pass new()方法接收到的参数依次是： 当前准备创建的类的对象； 类的名字； 类继承的父类集合； 类的方法集合 class Field(object): def __init__(self, name, column_type): self.name = name self.column_type = column_type def __str__(self): return '' % (self.__class__.__name__, self.name) class StringField(Field): def __init__(self, name): super(StringField, self).__init__(name, 'varchar(100)') class IntegerField(Field): def __init__(self, name): super(IntegerField, self).__init__(name, 'bigint') class ModelMetaclass(type): def __new__(cls, name, bases, attrs): if name=='Model': return type.__new__(cls, name, bases, attrs) print('Found model: %s' % name) mappings = dict() for k, v in attrs.items(): if isinstance(v, Field): print('Found mapping: %s ==> %s' % (k, v)) mappings[k] = v for k in mappings.keys(): attrs.pop(k) attrs['__mappings__'] = mappings #保存属性和列的映射关系 attrs['__table__'] = name # 假设表名和类名一致 return type.__new__(cls, name, bases, attrs) class Model(dict, metaclass=ModelMetaclass): def __init__(self, **kw): super(Model, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r\"'Model' object has no attribute '%s'\" % key) def __setattr__(self, key, value): self[key] = value def save(self): fields = [] params = [] args = [] for k, v in self.__mappings__.items(): fields.append(v.name) params.append('?') args.append(getattr(self, k, None)) sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(params)) print('SQL: %s' % sql) print('ARGS: %s' % str(args)) class User(Model): #定义类的属性到列的映射： id = IntegerField('id') name = StringField('username') email = StringField('email') password = StringField('password') #创建一个实例：u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd') #保存到数据库：u.save() 实际中需要通过metaclass修改类定义的。ORM(Obeject Relational Mapping)即对象-关系映射，就是把关系数据库的一行映射为一个对象，一个类对应一个表。 父类Model和属性类型StringField、IntegerField是由ORM框架提供的。 当用户定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找metaclass，如果没有找到，就继续在父类Model中查找metaclass，找到了，就使用Model中定义的metaclass的ModelMetaclass来创建User类，也就是说，metaclass可以隐式地继承到子类，但子类自己却感觉不到。 在ModelMetaclass中，一共做了几件事情： 排除掉对Model类的修改； 在当前类(比如User)中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个mappings的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误(实例的属性会遮盖类的同名属性) 把表名保存到table中，这里简化表名默认为类名。 在Model类中，就可以定义各种操作数据库的方法，比如save()，delete()，find()，update等 我们实现了save()方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出INSERT语句。 常用内建模块 datetime 生成datetime from datetime import datetime now=datetime.now()#type:datetime dt=datetime(2015,4,19,12,20)#构造了一个时间 生成timestamp timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00 timestamp = 0 = 1970-1-1 08:00:00 UTC+8:00 全球各地的计算机在任意时间的timestamp都是一样的 form datetime import datetime dt = datetime(2015,4,19,12,20) dt.timestamp()#1429417200.0 一个浮点数 #java和javascript使用整数表示毫秒数，需要/1000 datetime.fromtimestamp(t)#将timestamp转换为datetime(本地时间) datetime.utcfromtimestamp(t)#UTC时间 str转换datetime form datetime import datetime cday = datetime.strptime('2015-6-1 18:19:59','%Y-%m-%d %H:%M:%S') now=datetime.now() now.strftime('%a,%b %d %H:%M')#Mon, May 05 16:28 datetime 加减 from datetime import datetime,timedelta now=datetime.now() now+timedelta(hours=10) now-timedelta(days=1) now+timedelta(days=2,hours=12) collections namedtuple 创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素 from collections import namedtuple point = namedtuple('Point',['x','y']) p = point(1,2) #p.x==1#p.y==2 isinstance(p,Point)#true isinstance(p,tuple)#true deque 使用list按索引访问数据快，但插入和删除元素很慢，因为list是线性存储，数据量大的时候，插入和删除效率很低。 deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈 deque除了实现list的append()和pop()外，还支持appendleft和popleft() >>> from collections import deque >>> q = deque(['a', 'b', 'c']) >>> q.append('x') >>> q.appendleft('y') >>> q deque(['y', 'a', 'b', 'c', 'x']) defaultdict 使用dict时，如果引用的key不存在，会抛出KeyError。如果希望key不存在，返回一个默认值，就可以用defaultdict： 默认值是调用函数返回的，而函数在创建defaultdict对象时传入 >>> from collections import defaultdict >>> dd = defaultdict(lambda: 'N/A') >>> dd['key1'] = 'abc' >>> dd['key1'] # key1存在 'abc' >>> dd['key2'] # key2不存在，返回默认值 'N/A' OrderedDict 使用dict时，key是无序的。如果要保持key的顺序，可以用OrderedDict >>> from collections import OrderedDict >>> d = dict([('a', 1), ('b', 2), ('c', 3)]) >>> d # dict的Key是无序的 {'a': 1, 'c': 3, 'b': 2} >>> od = OrderedDict([('a', 1), ('b', 2), ('c', 3)]) >>> od # OrderedDict的Key是有序的 OrderedDict([('a', 1), ('b', 2), ('c', 3)]) OrderedDict可以实现一个FIFO(先进先出)的dict，当容量超出限制时，先删除最早添加的Key from collections import OrderedDict class LastUpdatedOrderedDict(OrderedDict): def __init__(self, capacity): super(LastUpdatedOrderedDict, self).__init__() self._capacity = capacity def __setitem__(self, key, value):#新添或更新数据内容 containsKey = 1 if key in self else 0#判断是新添还是更新 if len(self) - containsKey >= self._capacity:#超出容量限制 last = self.popitem(last=False) print('remove:', last) if containsKey: del self[key] print('set:', (key, value)) else: print('add:', (key, value)) OrderedDict.__setitem__(self, key, value) ChainMap ChainMap可以把一组dict串起来并组成一个逻辑上的dict。ChainMap本身也是一个dict，但是查找时，会按照顺序在内部的dict依次查找。 from collections import ChainMap import os, argparse # 构造缺省参数: defaults = { 'color': 'red', 'user': 'guest' } # 构造命令行参数: parser = argparse.ArgumentParser() parser.add_argument('-u', '--user') parser.add_argument('-c', '--color') namespace = parser.parse_args() command_line_args = { k: v for k, v in vars(namespace).items() if v } # 组合成ChainMap: combined = ChainMap(command_line_args, os.environ, defaults) # 打印参数: print('color=%s' % combined['color']) print('user=%s' % combined['user']) 没有任何参数时，打印出默认参数： $ python3 use_chainmap.py color=red user=guest 当传入命令行参数时，优先使用命令行参数： $ python3 use_chainmap.py -u bob color=red user=bob 同时传入命令行参数和环境变量，命令行参数的优先级较高： $ user=admin color=green python3 use_chainmap.py -u bob color=green user=bob Counter >>> from collections import Counter >>> c = Counter() >>> for ch in 'programming': ... c[ch] = c[ch] + 1 ... >>> c Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1}) base 64 一种用64个字符来表示任意二进制数据的方法 base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33% 如果要编码的二进制数据不是3的倍数，最后剩下的字节用\\x00字节在末尾补足，再在编码的末尾加上1/2个=号，表示补了多少字节，解码的时候会自动去掉。 >>> import base64 >>> base64.b64encode(b'binary\\x00string') b'YmluYXJ5AHN0cmluZw==' >>> base64.b64decode(b'YmluYXJ5AHN0cmluZw==') b'binary\\x00string' 标准的base64编码后可能出现字符+和/，在URL中不能直接作为参数，所以又有一种\"url safe\"的base64编码，其实就是把+和/分别变成-和_： >>> base64.b64encode(b'i\\xb7\\x1d\\xfb\\xef\\xff') b'abcd++//' >>> base64.urlsafe_b64encode(b'i\\xb7\\x1d\\xfb\\xef\\xff') b'abcd--__' >>> base64.urlsafe_b64decode('abcd--__') b'i\\xb7\\x1d\\xfb\\xef\\xff' 由于=字符可能出现在base64里，但=用在URL、Cookie里面可能造成歧义，所以很多Base64编码后会把=去掉。 解码时自动加上=使base64字符串的长度为4的倍数 struct pack 把任意数据类型变成bytes >>> import struct >>> struct.pack('>I', 10240099) b'\\x00\\x9c@c' pack的第一个参数是处理指令，'>I'的意思是：'>'表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数 unpack 把bytes变成相应的数据类型: >>> struct.unpack('>IH', b'\\xf0\\xf0\\xf0\\xf0\\x80\\x80') (4042322160, 32896) '>HI'：后面的bytes一次变为I：4字节无符号整数，和H：2字节无符号整数 hashlib 很多很多内容-->固定长度的字符串，根据内容改变 应用于文章防伪、密码加密 import hashlib md5 = hashlib.md5() md5.update('how to use md5 in python hashlib?'.encode('utf-8')) print(md5.hexdigest()) #d26a53750bc40b38b65a520292f69306 import hashlib md5 = hashlib.md5() md5.update('how to use md5 in '.encode('utf-8')) md5.update('python hashlib?'.encode('utf-8')) print(md5.hexdigest()) hmac hmac:keyed-hashing for message authentication eg. md5(message + salt) >>> import hmac >>> message = b'Hello, world!' >>> key = b'secret' >>> h = hmac.new(key, message, digestmod='MD5') >>> # 如果消息很长，可以多次调用h.update(msg) >>> h.hexdigest() 'fa4ee7d173f2d97ee79022d1a7355bcf' itertools 提供了有用的用于操作迭代对象的函数 >>> import itertools >>> natuals = itertools.count(1) >>> for n in natuals: ... print(n) ... 1 2 3 ... >>> import itertools >>> cs = itertools.cycle('ABC') # 注意字符串也是序列的一种 >>> for c in cs: ... print(c) ... 'A' 'B' 'C' 'A' 'B' 'C' ... >>> ns = itertools.repeat('A', 3) >>> for n in ns: ... print(n) ... A A A >>> natuals = itertools.count(1) >>> ns = itertools.takewhile(lambda x: x >> list(ns) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> for c in itertools.chain('ABC', 'XYZ'): ... print(c) # 迭代效果：'A' 'B' 'C' 'X' 'Y' 'Z' >>> for key, group in itertools.groupby('AAABBBCCAAA'): ... print(key, list(group)) ... A ['A', 'A', 'A'] B ['B', 'B', 'B'] C ['C', 'C'] A ['A', 'A', 'A'] >>> for key, group in itertools.groupby('AaaBBbcCAAa', lambda c: c.upper()): ... print(key, list(group)) ... A ['A', 'a', 'a'] B ['B', 'B', 'b'] C ['c', 'C'] A ['A', 'A', 'a'] contextlib @contextmanager 自己写的资源对象用于with语句需要编写enter exit两个方法 python标准库中的contextlib提供了更简单的写法 from contextlib import contextmanager class Query(object): def __init__(self, name): self.name = name def query(self): print('Query info about %s...' % self.name) @contextmanager def create_query(name): print('Begin') q = Query(name) yield q print('End') @contextmanager这个decorator接受一个generator用yield语句把with...as var把变量输出出去，然后，with语句就可以正常工作了。 with create_query('Bob') as q: q.query() 我们希望某段代码执行前后自动执行特定代码，也可以用@contextmanager实现 @contextmanager def tag(name): print(\"\" % name) yield print(\"\" % name) with tag(\"h1\"): print(\"hello\") print(\"world\") \"\"\" hello world \"\"\" with语句首先执行yield之前的语句，因此打印出 yield调用会执行with语句内部的所有语句，因此打印出hello和world 最后执行yield之后的语句，打印出 @closing 如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。例如，用with语句使用urlopen()； from contextlib import closing from urlib.request import urlopen with closing(urlopen('https://www.python.org')) as page: for line in page: print(line) closing也是一个经过@contextmanager装饰的generator，这个generator编写起来很简单： @contextmanager def closing(thing): try: yield thing finally: thing.close() urllib GET urllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP响应: from urllib import request with request.urlopen('https://api.douban.com/v2/book/2129650') as f: data = f.read() print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', data.decode('utf-8')) #HTTP响应的头和JSON数据： Status: 200 OK Server: nginx Date: Tue, 26 May 2015 10:02:27 GMT Content-Type: application/json; charset=utf-8 Content-Length: 2049 Connection: close Expires: Sun, 1 Jan 2006 01:00:00 GMT Pragma: no-cache Cache-Control: must-revalidate, no-cache, private X-DAE-Node: pidl1 Data: {\"rating\":{\"max\":10,\"numRaters\":16,\"average\":\"7.4\",\"min\":0},\"subtitle\":\"\",\"author\":[\"qing\"],\"pubdate\":\"2007-6\",...} 模拟浏览器发送GET请求，需要使用request对象，通过往request对象添加HTTP头，我们就可以把请求伪装成浏览器。 from urllib import request req = request.Request('http://www.douban.com/') req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25') with request.urlopen(req) as f: print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', f.read().decode('utf-8')) ... ... POST 需要把参数data以bytes的形式传入 from urllib import request, parse print('Login to weibo.cn...') email = input('Email: ') passwd = input('Password: ') login_data = parse.urlencode([ ('username', email), ('password', passwd), ('entry', 'mweibo'), ('client_id', ''), ('savestate', '1'), ('ec', ''), ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&r=http%3A%2F%2Fm.weibo.cn%2F') ]) req = request.Request('https://passport.weibo.cn/sso/login') req.add_header('Origin', 'https://passport.weibo.cn') req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25') req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&res=wel&wm=3349&r=http%3A%2F%2Fm.weibo.cn%2F') with request.urlopen(req, data=login_data.encode('utf-8')) as f: print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', f.read().decode('utf-8')) #登录成功 Status: 200 OK Server: nginx/1.2.0 ... Set-Cookie: SSOLoginState=1432620126; path=/; domain=weibo.cn ... Data: {\"retcode\":20000000,\"msg\":\"\",\"data\":{...,\"uid\":\"1658384301\"}} #登录失败 ... Data: {\"retcode\":50011015,\"msg\":\"\\u7528\\u6237\\u540d\\u6216\\u5bc6\\u7801\\u9519\\u8bef\",\"data\":{\"username\":\"example@python.org\",\"errline\":536}} Handler #通过一个proxy去访问网站 proxy_handler = urllib.request.ProxyHandler({'http': 'http://www.example.com:3128/'}) proxy_auth_handler = urllib.request.ProxyBasicAuthHandler() proxy_auth_handler.add_password('realm', 'host', 'username', 'password') opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler) with opener.open('http://www.example.com/login.html') as f: pass xml DOM vs. SAX DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。 SAX是流模式，边读边解析，占用内存小，解析快，缺点是需要自己处理事件。 优先考虑SAX，因为DOM很占内存 SAX的使用： 使用SAX解析XML需要准备好start_element,end_element和char_data三个函数。 例如解析python会产生3个事件 start_element事件，在读取时； char_data事件，在读取python时； end_element事件，在读取时 from xml.parsers.expat import ParserCreate class DefaultSaxHandler(object): def start_element(self, name, attrs): print('sax:start_element: %s, attrs: %s' % (name, str(attrs))) def end_element(self, name): print('sax:end_element: %s' % name) def char_data(self, text): print('sax:char_data: %s' % text) xml = r''' Python Ruby ''' handler = DefaultSaxHandler() parser = ParserCreate() parser.StartElementHandler = handler.start_element parser.EndElementHandler = handler.end_element parser.CharacterDataHandler = handler.char_data parser.Parse(xml) #读取一大段字符串时，CharacterDataHandler可能被多次调用，所以需要自己保存起来，在EndElementHandler里面再合并 - 生成XML L = [] L.append(r'') L.append(r'') L.append(encode('some & data')) L.append(r'') return ''.join(L) HtmlParser from html.parser import HTMLParser from html.entities import name2codepoint class MyHTMLParser(HTMLParser): def handle_starttag(self, tag, attrs): print('' % tag) def handle_endtag(self, tag): print('' % tag) def handle_startendtag(self, tag, attrs): print('' % tag) def handle_data(self, data): print(data) def handle_comment(self, data): print('') def handle_entityref(self, name): print('&%s;' % name) def handle_charref(self, name): print('&#%s;' % name) parser = MyHTMLParser() parser.feed(''' Some html HTML&nbsp;tutorial...END ''') feed()方法可以多次调用，就是说可以分次把HTML字符塞进去、 特殊字符有两种，一种是英文表示的&nbsp；一种是数字表示的Ӓ这两种字符都可以通过Parser解析出来。 常用第三方模块 Pillow 图像缩放 from PIL import Image # 打开一个jpg图像文件，注意是当前路径: im = Image.open('test.jpg') # 获得图像尺寸: w, h = im.size print('Original image size: %sx%s' % (w, h)) # 缩放到50%: im.thumbnail((w//2, h//2)) print('Resize image to: %sx%s' % (w//2, h//2)) # 把缩放后的图像用jpeg格式保存: im.save('thumbnail.jpg', 'jpeg') 模糊操作 from PIL import Image, ImageFilter # 打开一个jpg图像文件，注意是当前路径: im = Image.open('test.jpg') # 应用模糊滤镜: im2 = im.filter(ImageFilter.BLUR) im2.save('blur.jpg', 'jpeg') 绘图 from PIL import Image, ImageDraw, ImageFont, ImageFilter import random # 随机字母: def rndChar(): return chr(random.randint(65, 90)) # 随机颜色1: def rndColor(): return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255)) # 随机颜色2: def rndColor2(): return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127)) # 240 x 60: width = 60 * 4 height = 60 image = Image.new('RGB', (width, height), (255, 255, 255)) # 创建Font对象: font = ImageFont.truetype('Arial.ttf', 36) # 创建Draw对象: draw = ImageDraw.Draw(image) # 填充每个像素: for x in range(width): for y in range(height): draw.point((x, y), fill=rndColor()) # 输出文字: for t in range(4): draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2()) # 模糊: image = image.filter(ImageFilter.BLUR) image.save('code.jpg', 'jpeg') requests 通过GET访问页面 >>> import requests >>> r = requests.get('https://www.douban.com/') # 豆瓣首页 >>> r.status_code 200 >>> r.text r.text '\\n\\n\\n 对于带参数的URL ，传入一个dict作为params参数(不确定个数的参数) >>> r = requests.get('https://www.douban.com/search', params={'q': 'python', 'cat': '1001'}) >>> r.url # 实际请求的URL 'https://www.douban.com/search?q=python&cat=1001' 无论响应是文本还是二进制内容，我们都可以用content属性获得bytes对象 >>> r.content b'\\n\\n\\n\\n...' request对于特定类型的响应，例如JSON，可以直接获取: >>> r = requests.get('https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20weather.forecast%20where%20woeid%20%3D%202151330&format=json') >>> r.json() {'query': {'count': 1, 'created': '2017-11-17T07:14:12Z', ... 需要传入HTTP Header时，我们传入一个dict作为headers参数 >>> r = requests.get('https://www.douban.com/', headers={'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit'}) >>> r.text '\\n\\n\\n\\n 豆瓣(手机版)...' 要发送POST请求，只需要把get()方法变成post()，然后传入data参数作为POST请求的数据: >>> r = requests.post('https://accounts.douban.com/login', data={'form_email': 'abc@example.com', 'form_password': '123456'}) requests默认使用application/x-www-form-urlencoded对POST数据编码，如果要传递JSON数据，可以直接传入json参数 params = {'key': 'value'} r = requests.post(url, json=params) #内部自动序列化为JSON 类似的，上传文件需要更复杂的编码格式，但是requests把它简化成files参数: >>> upload_files = {'file': open('report.xls', 'rb')} >>> r = requests.post(url, files=upload_files) 在读取文件时，务必使用'rb'模式，这样获取的bytes长度才是文件的长度。 把post()方法替换为put(),delete()等，就可以以PUT或DELETE方式请求资源、 除了能轻松获取响应内容外，requests对获取HTTP响应的其他信息也非常简单。例如，获取响应头: >>> r.headers {Content-Type': 'text/html; charset=utf-8', 'Transfer-Encoding': 'chunked', 'Content-Encoding': 'gzip', ...} >>> r.headers['Content-Type'] 'text/html; charset=utf-8' requests对cookie做了特殊处理，使我们不必解析cookie就可以轻松获取指定的cookie >>> r.cookies['ts'] 'example_cookie_12345' 要在请求中传入cookie，只需准备一个dict传入cookies参数 >>> cs = {'token': '12345', 'status': 'working'} >>> r = requests.get(url, cookies=cs) 最后，要指定超时，传入以秒为单位的timeout参数 >>> r = requests.get(url, timeout=2.5) # 2.5秒后超时 chardet 猜测编码的模块 >>> chardet.detect(b'Hello, world!') {'encoding': 'ascii', 'confidence': 1.0, 'language': ''} >>> data = '离离原上草，一岁一枯荣'.encode('gbk') >>> chardet.detect(data) {'encoding': 'GB2312', 'confidence': 0.7407407407407407, 'language': 'Chinese'} psutil 实现系统监控，可以跨平台使用，支持Linux/Unix/OSX/Windows等 获取CPU信息 >>> import psutil >>> psutil.cpu_count() # CPU逻辑数量 4 >>> psutil.cpu_count(logical=False) # CPU物理核心 2 # 2说明是双核超线程, 4则是4核非超线程 统计CPU的用户/系统/空闲时间 >>> psutil.cpu_times() scputimes(user=10963.31, nice=0.0, system=5138.67, idle=356102.45) 实现类似top命令的CPU使用率，每秒刷新一次，累计10次: >>> for x in range(10): ... psutil.cpu_percent(interval=1, percpu=True) ... [14.0, 4.0, 4.0, 4.0] [12.0, 3.0, 4.0, 3.0] [8.0, 4.0, 3.0, 4.0] [12.0, 3.0, 3.0, 3.0] [18.8, 5.1, 5.9, 5.0] [10.9, 5.0, 4.0, 3.0] [12.0, 5.0, 4.0, 5.0] [15.0, 5.0, 4.0, 4.0] [19.0, 5.0, 5.0, 4.0] [9.0, 3.0, 2.0, 3.0] 使用psutil获取物理内存和交换内存信息，分别使用: >>> psutil.virtual_memory() svmem(total=8589934592, available=2866520064, percent=66.6, used=7201386496, free=216178688, active=3342192640, inactive=2650341376, wired=1208852480) >>> psutil.swap_memory() sswap(total=1073741824, used=150732800, free=923009024, percent=14.0, sin=10705981440, sout=40353792) 返回的是字节为单位的整数，可以看到总内存大小是8589934592 = 8 GB，已用7201386496 = 6.7 GB，使用了66.6%。 而交换区大小是1073741824 = 1 GB。 获取磁盘信息 可以通过psutil获取磁盘分区、磁盘使用率和磁盘IO信息: >>> psutil.disk_partitions() # 磁盘分区信息 [sdiskpart(device='/dev/disk1', mountpoint='/', fstype='hfs', opts='rw,local,rootfs,dovolfs,journaled,multilabel')] >>> psutil.disk_usage('/') # 磁盘使用情况 sdiskusage(total=998982549504, used=390880133120, free=607840272384, percent=39.1) >>> psutil.disk_io_counters() # 磁盘IO sdiskio(read_count=988513, write_count=274457, read_bytes=14856830464, write_bytes=17509420032, read_time=2228966, write_time=1618405) 可以看到，磁盘'/'的总容量是998982549504 = 930 GB，使用了39.1%。文件格式是HFS，opts中包含rw表示可读写，journaled表示支持日志。 获取网络信息 >>> psutil.net_io_counters() # 获取网络读写字节／包的个数 snetio(bytes_sent=3885744870, bytes_recv=10357676702, packets_sent=10613069, packets_recv=10423357, errin=0, errout=0, dropin=0, dropout=0) >>> psutil.net_if_addrs() # 获取网络接口信息 { 'lo0': [snic(family=, address='127.0.0.1', netmask='255.0.0.0'), ...], 'en1': [snic(family=, address='10.0.1.80', netmask='255.255.255.0'), ...], 'en0': [...], 'en2': [...], 'bridge0': [...] } >>> psutil.net_if_stats() # 获取网络接口状态 { 'lo0': snicstats(isup=True, duplex=, speed=0, mtu=16384), 'en0': snicstats(isup=True, duplex=, speed=0, mtu=1500), 'en1': snicstats(...), 'en2': snicstats(...), 'bridge0': snicstats(...) } 获取当前网络连接信息 >>> psutil.net_connections() Traceback (most recent call last): ... PermissionError: [Errno 1] Operation not permitted During handling of the above exception, another exception occurred: Traceback (most recent call last): ... psutil.AccessDenied: psutil.AccessDenied (pid=3847) 你可能会得到一个AccessDenied错误，原因是psutil获取信息也是要走系统接口，而获取网络连接信息需要root权限，这种情况下，可以退出Python交互环境，用sudo重新启动： $ sudo python3 Password: ****** Python 3.6.3 ... on darwin Type \"help\", ... for more information. >>> import psutil >>> psutil.net_connections() [ sconn(fd=83, family=, type=1, laddr=addr(ip='::127.0.0.1', port=62911), raddr=addr(ip='::127.0.0.1', port=3306), status='ESTABLISHED', pid=3725), sconn(fd=84, family=, type=1, laddr=addr(ip='::127.0.0.1', port=62905), raddr=addr(ip='::127.0.0.1', port=3306), status='ESTABLISHED', pid=3725), sconn(fd=93, family=, type=1, laddr=addr(ip='::', port=8080), raddr=(), status='LISTEN', pid=3725), sconn(fd=103, family=, type=1, laddr=addr(ip='::127.0.0.1', port=62918), raddr=addr(ip='::127.0.0.1', port=3306), status='ESTABLISHED', pid=3725), sconn(fd=105, family=, type=1, ..., pid=3725), sconn(fd=106, family=, type=1, ..., pid=3725), sconn(fd=107, family=, type=1, ..., pid=3725), ... sconn(fd=27, family=, type=2, ..., pid=1) ] 获取进程信息 >>> psutil.pids() # 所有进程ID [3865, 3864, 3863, 3856, 3855, 3853, 3776, ..., 45, 44, 1, 0] >>> p = psutil.Process(3776) # 获取指定进程ID=3776，其实就是当前Python交互环境 >>> p.name() # 进程名称 'python3.6' >>> p.exe() # 进程exe路径 '/Users/michael/anaconda3/bin/python3.6' >>> p.cwd() # 进程工作目录 '/Users/michael' >>> p.cmdline() # 进程启动的命令行 ['python3'] >>> p.ppid() # 父进程ID 3765 >>> p.parent() # 父进程 >>> p.children() # 子进程列表 [] >>> p.status() # 进程状态 'running' >>> p.username() # 进程用户名 'michael' >>> p.create_time() # 进程创建时间 1511052731.120333 >>> p.terminal() # 进程终端 '/dev/ttys002' >>> p.cpu_times() # 进程使用的CPU时间 pcputimes(user=0.081150144, system=0.053269812, children_user=0.0, children_system=0.0) >>> p.memory_info() # 进程使用的内存 pmem(rss=8310784, vms=2481725440, pfaults=3207, pageins=18) >>> p.open_files() # 进程打开的文件 [] >>> p.connections() # 进程相关网络连接 [] >>> p.num_threads() # 进程的线程数量 1 >>> p.threads() # 所有线程信息 [pthread(id=1, user_time=0.090318, system_time=0.062736)] >>> p.environ() # 进程环境变量 {'SHELL': '/bin/bash', 'PATH': '/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:...', 'PWD': '/Users/michael', 'LANG': 'zh_CN.UTF-8', ...} >>> p.terminate() # 结束进程 Terminated: 15 自己把自己结束了 和获取网络连接类似，获取一个root用户的进程需要root权限，启动Python交互环境或者.py文件时，需要sudo权限 psutil还提供了一个test()函数，可以模拟出ps命令的效果： $ sudo python3 Password: ****** Python 3.6.3 ... on darwin Type \"help\", ... for more information. >>> import psutil >>> psutil.test() USER PID %MEM VSZ RSS TTY START TIME COMMAND root 0 24.0 74270628 2016380 ? Nov18 40:51 kernel_task root 1 0.1 2494140 9484 ? Nov18 01:39 launchd root 44 0.4 2519872 36404 ? Nov18 02:02 UserEventAgent root 45 ? 2474032 1516 ? Nov18 00:14 syslogd root 47 0.1 2504768 8912 ? Nov18 00:03 kextd root 48 0.1 2505544 4720 ? Nov18 00:19 fseventsd _appleeven 52 0.1 2499748 5024 ? Nov18 00:00 appleeventsd root 53 0.1 2500592 6132 ? Nov18 00:02 configd ... 进程和线程 多进程 fork() Unix/Linux系统下 fork()调用时，操作系统自动把当前进程(父进程)复制了一份(子进程)，然后分别在父进程和子进程内返回 一个父进程可以fork出很多子进程。因此父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID ```python import os print('Process (%s) start...' % os.getpid()) Only works on Unix/Linux/Mac: pid = os.fork() if pid == 0: print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid())) else: print('I (%s) just created a child process (%s).' % (os.getpid(), pid)) Process (876) start... I (876) just created a child process (877). I am child process (877) and my parent is 876. ### multiprocessing win下可以使用 ```python from multiprocessing import Process import os # 子进程要执行的代码 def run_proc(name): print('Run child process %s (%s)...' % (name, os.getpid())) if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Process(target=run_proc, args=('test',))#创建process实例 print('Child process will start.') p.start()#用start()启动 p.join()#等待子进程结束后再继续往下运行，通常用于进程间的同步 print('Child process end.') Parent process 928. Process will start. Run child process test (929)... Process end. pool 如果要启动大量的子进程，可以使用进程池的方式批量创建子进程 from multiprocessing import Pool import os, time, random def long_time_task(name): print('Run task %s (%s)...' % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print('Task %s runs %0.2f seconds.' % (name, (end - start))) if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Pool(4) for i in range(5): p.apply_async(long_time_task, args=(i,)) print('Waiting for all subprocesses done...') p.close()#之后不能继续添加新的process了 p.join() print('All subprocesses done.') Parent process 669. Waiting for all subprocesses done... Run task 0 (671)... Run task 1 (672)... Run task 2 (673)... Run task 3 (674)... Task 2 runs 0.14 seconds. Run task 4 (673)... #pool的默认大小在老师电脑上是4，即同时可以执行4个线程。如果改成p=pool(5)，就可以同时跑5个进程 Task 1 runs 0.27 seconds. Task 3 runs 0.86 seconds. Task 0 runs 1.41 seconds. Task 4 runs 1.91 seconds. All subprocesses done. 子进程 import subprocess print('$ nslookup www.python.org') r = subprocess.call(['nslookup', 'www.python.org']) #和在命令行中直接运行nslookup www.python.org是一样的。 print('Exit code:', r) $ nslookup www.python.org Server: 192.168.19.4 Address: 192.168.19.4#53 Non-authoritative answer: www.python.org canonical name = python.map.fastly.net. Name: python.map.fastly.net Address: 199.27.79.223 Exit code: 0 import subprocess print('$ nslookup') p = subprocess.Popen(['nslookup'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) output, err = p.communicate(b'set q=mx\\npython.org\\nexit\\n')# 输入 print(output.decode('utf-8')) print('Exit code:', p.returncode) #手动输入： set q=mx python.org exit $ nslookup Server: 192.168.19.4 Address: 192.168.19.4#53 Non-authoritative answer: python.org mail exchanger = 50 mail.python.org. Authoritative answers can be found from: mail.python.org internet address = 82.94.164.166 mail.python.org has AAAA address 2001:888:2000:d::a6 Exit code: 0 进程间通信 from multiprocessing import Process, Queue import os, time, random # 写数据进程执行的代码: def write(q): print('Process to write: %s' % os.getpid()) for value in ['A', 'B', 'C']: print('Put %s to queue...' % value) q.put(value) time.sleep(random.random()) # 读数据进程执行的代码: def read(q): print('Process to read: %s' % os.getpid()) while True: value = q.get(True) print('Get %s from queue.' % value) if __name__=='__main__': # 父进程创建Queue，并传给各个子进程： q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw，写入: pw.start() # 启动子进程pr，读取: pr.start() # 等待pw结束: pw.join() # pr进程里是死循环，无法等待其结束，只能强行终止: pr.terminate() Process to write: 50563 Put A to queue... Process to read: 50564 Get A from queue. Put B to queue... Get B from queue. Put C to queue... Get C from queue. 多线程 Python的标准库提供了两个模块，_thread(低级模块)和threading(高级模块)，一般只需要使用threading 启动一个线程就是把一个函数传入并创建thread实例，然后调用start()开始执行。 ```python import time, threading 新线程执行的代码: def loop(): print('thread %s is running...' % threading.current_thread().name) n = 0 while n >> %s' % (threading.current_thread().name, n)) time.sleep(1) print('thread %s ended.' % threading.current_thread().name) print('thread %s is running...' % threading.current_thread().name) t = threading.Thread(target=loop, name='LoopThread') t.start() t.join() print('thread %s ended.' % threading.current_thread().name) thread MainThread is running...#主线程 thread LoopThread is running...#如果不起名字，Python自动命名为Thread-1 Thread-2 thread LoopThread >>> 1 thread LoopThread >>> 2 thread LoopThread >>> 3 thread LoopThread >>> 4 thread LoopThread >>> 5 thread LoopThread ended. thread MainThread ended. ### Lock ```python balance = 0 lock = threading.Lock() def run_thread(n): for i in range(100000): # 先要获取锁: lock.acquire() try: # 放心地改吧: change_it(n) finally: # 改完了一定要释放锁: lock.release() 多核CPU Python是不能跑满多核CPU的 详情自己查 ThreadLocal ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。 import threading # 创建全局ThreadLocal对象: local_school = threading.local() def process_student(): # 获取当前线程关联的student: std = local_school.student print('Hello, %s (in %s)' % (std, threading.current_thread().name)) def process_thread(name): # 绑定ThreadLocal的student: local_school.student = name process_student() t1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A') t2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B') t1.start() t2.start() t1.join() t2.join() Hello, Alice (in Thread-A) Hello, Bob (in Thread-B) 进程 vs. 线程 计算密集型：用C语言 IO密集型：用脚本语言(Python) 异步IO 异步IO可以用单进程单线程模型来执行多任务(事件驱动模型) Python中单线程的异步编程模型称为协程 分布式进程 Thread和Process优选Process，因为更稳定且可以分布到多台机器上 multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程分布到多台机器上 # task_master.py import random, time, queue from multiprocessing.managers import BaseManager # 发送任务的队列: task_queue = queue.Queue() # 接收结果的队列: result_queue = queue.Queue() # 从BaseManager继承的QueueManager: class QueueManager(BaseManager): pass # 把两个Queue都注册到网络上, callable参数关联了Queue对象: QueueManager.register('get_task_queue', callable=lambda: task_queue) QueueManager.register('get_result_queue', callable=lambda: result_queue) # 绑定端口5000, 设置验证码'abc': manager = QueueManager(address=('', 5000), authkey=b'abc') # 启动Queue: manager.start() # 获得通过网络访问的Queue对象: task = manager.get_task_queue() result = manager.get_result_queue() # 放几个任务进去: for i in range(10): n = random.randint(0, 10000) print('Put task %d...' % n) task.put(n) # 从result队列读取结果: print('Try get results...') for i in range(10): r = result.get(timeout=10) print('Result: %s' % r) # 关闭: manager.shutdown() print('master exit.') # task_worker.py import time, sys, queue from multiprocessing.managers import BaseManager # 创建类似的QueueManager: class QueueManager(BaseManager): pass # 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字: QueueManager.register('get_task_queue') QueueManager.register('get_result_queue') # 连接到服务器，也就是运行task_master.py的机器: server_addr = '127.0.0.1' print('Connect to server %s...' % server_addr) # 端口和验证码注意保持与task_master.py设置的完全一致: m = QueueManager(address=(server_addr, 5000), authkey=b'abc') # 从网络连接: m.connect() # 获取Queue的对象: task = m.get_task_queue() result = m.get_result_queue() # 从task队列取任务,并把结果写入result队列: for i in range(10): try: n = task.get(timeout=1) print('run task %d * %d...' % (n, n)) r = '%d * %d = %d' % (n, n, n*n) time.sleep(1) result.put(r) except Queue.Empty: print('task queue is empty.') # 处理结束: print('worker exit.') $ python3 task_master.py Put task 3411... Put task 1605... Put task 1398... Put task 4729... Put task 5300... Put task 7471... Put task 68... Put task 4219... Put task 339... Put task 7866... Try get results... $ python3 task_worker.py Connect to server 127.0.0.1... run task 3411 * 3411... run task 1605 * 1605... run task 1398 * 1398... run task 4729 * 4729... run task 5300 * 5300... run task 7471 * 7471... run task 68 * 68... run task 4219 * 4219... run task 339 * 339... run task 7866 * 7866... worker exit. #task_master.py会继续打印出结果 Result: 3411 * 3411 = 11634921 Result: 1605 * 1605 = 2576025 Result: 1398 * 1398 = 1954404 Result: 4729 * 4729 = 22363441 Result: 5300 * 5300 = 28090000 Result: 7471 * 7471 = 55815841 Result: 68 * 68 = 4624 Result: 4219 * 4219 = 17799961 Result: 339 * 339 = 114921 Result: 7866 * 7866 = 61873956 IO编程 文件读写 读文件 try: f = open('/path/to/file', 'r') print(f.read()) finally: if f: f.close() with open('/path/to/file', 'r') as f: print(f.read()) for line in f.readlines():#或者调用read(size) print(line.strip()) # 把末尾的'\\n'删掉 file-like Object 像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等。file-like Object不要求从特定类继承，只要写个read()方法就行 二进制文件 用'rb'模式打开文件 >>> f = open('/Users/michael/test.jpg', 'rb') >>> f.read() b'\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...' #十六进制表示的字节 字符编码 >>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk') >>> f.read() '测试' >>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore') ###写文件 要记得用f.close()不然写不进去 ```python with open('/Users/michael/test.txt', 'w') as f: f.write('Hello, world!') StringIO和BytesIO StirngIO 在内存中读写str >>> from io import StringIO >>> f = StringIO() >>> f.write('hello') 5 >>> f.write(' ') 1 >>> f.write('world!') 6 >>> print(f.getvalue()) hello world! >>> from io import StringIO >>> f = StringIO('Hello!\\nHi!\\nGoodbye!') >>> while True: ... s = f.readline() ... if s == '': ... break ... print(s.strip()) ... Hello! Hi! Goodbye! BytesIO 在内存中读写二进制数据 >>> from io import BytesIO >>> f = BytesIO() >>> f.write('中文'.encode('utf-8')) 6 >>> print(f.getvalue()) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' >>> from io import BytesIO >>> f = BytesIO(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87') >>> f.read() b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 操作文件和目录 >>> import os >>> os.name # 操作系统类型 'posix' # 系统为Linux/Unix/Mac OS X 如果是nt就是Windows系统 >>> os.uname() # 获取详细的系统信息 posix.uname_result(sysname='Darwin', nodename='MichaelMacPro.local', release='14.3.0', version='Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64', machine='x86_64') >>> os.environ # 环境变量 environ({'VERSIONER_PYTHON_PREFER_32_BIT': 'no', 'TERM_PROGRAM_VERSION': '326', 'LOGNAME': 'michael', 'USER': 'michael', 'PATH': '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin', ...}) >>> os.environ.get('PATH')# 获取某个环境变量的值 '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin' >>> os.environ.get('x', 'default') 'default' # 查看当前目录的绝对路径: >>> os.path.abspath('.') '/Users/michael' # 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来: >>> os.path.join('/Users/michael', 'testdir') #不要直接相加字符串 '/Users/michael/testdir' # 然后创建一个目录: >>> os.mkdir('/Users/michael/testdir') # 删掉一个目录: >>> os.rmdir('/Users/michael/testdir') >>> os.path.split('/Users/michael/testdir/file.txt') ('/Users/michael/testdir', 'file.txt') >>> os.path.splitext('/path/to/file.txt') ('/path/to/file', '.txt') # 对文件重命名: >>> os.rename('test.txt', 'test.py') # 删掉文件: >>> os.remove('test.py') shutil模块中有复制文件的函数，算是os模块的补充 编写一个程序，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出相对路径。 def search(filename, path = os.curdir): #遍历当前目录里面的所有文件和文件夹 for x in os.listdir(path): #获取每个文件和文件夹的路径 xPath = os.path.join(path, x) #判断是文件还是文件夹（目录） if os.path.isdir(xPath): #如果是文件夹（目录），则继续查找（这里使用了递归！不过递归有个缺点，如果目录深度太大，容易造成内存溢出） search(filename, xPath) elif x.find(filename) != -1: #如果是文件，并且包含指定文件名，则打印其文件相对路径 print('found: %s' % os.path.relpath(xPath)) 序列化 pickle 把变量从内存中变成可存储或传输的过程称之为序列化(pickling)；把变量内容从序列化的对象重新读到内存里称之为反序列化(unpickling) pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object：>>> import pickle >>> d = dict(name='Bob', age=20, score=88) >>> pickle.dumps(d) >>> f = open('dump.txt', 'wb') >>> pickle.dump(d, f) >>> f.close() b'\\x80\\x03}q\\x00(X\\x03\\x00\\x00\\x00ageq\\x01K\\x14X\\x05\\x00\\x00\\x00scoreq\\x02KXX\\x04\\x00\\x00\\x00nameq\\x03X\\x03\\x00\\x00\\x00Bobq\\x04u.' 当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象。 >>> f = open('dump.txt', 'rb') >>> d = pickle.load(f) >>> f.close() >>> d {'age': 20, 'score': 88, 'name': 'Bob'} JSON 在不同的编程语言之间传递对象必须要对象序列化为标准格式(JSON XML)。JSON更快，表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。 JSON即标准的javascript语言的对象 标准编码为UTF-8 |JSON类型|Python类型| |-----------|------------| |{}|dict| |[]|list| |\"string\"|str| |1234.56|int或float| |true/false|True/False| |null|None|>>> import json >>> d = dict(name='Bob', age=20, score=88) >>> json.dumps(d) '{\"age\": 20, \"score\": 88, \"name\": \"Bob\"}' >>> json_str = '{\"age\": 20, \"score\": 88, \"name\": \"Bob\"}' >>> json.loads(json_str) {'age': 20, 'score': 88, 'name': 'Bob'} JSON 进阶 ```python import json class Student(object): def init(self, name, age, score): self.name = name self.age = age self.score = score def student2dict(std): return { 'name': std.name, 'age': std.age, 'score': std.score } s = Student('Bob', 20, 88) print(json.dumps(s, default=student2dict)) {\"age\": 20, \"name\": \"Bob\", \"score\": 88} print(json.dumps(s, default=lambda obj: obj.dict)) ``` Virtualenv 即为一个应用创建一套“隔离”的Python运行环境 创建目录Mac:~ michael$ mkdir myproject Mac:~ michael$ cd myproject/ Mac:myproject michael$ 创建一个独立的Python运行环境，命名为venvMac:myproject michael$ virtualenv --no-site-packages venv #已经安装到系统Python的第三方包不会复制过来 Using base prefix '/usr/local/.../Python.framework/Versions/3.4' New python executable in venv/bin/python3.4 Also creating executable in venv/bin/python Installing setuptools, pip, wheel...done. 用source进入该环境Mac:myproject michael$ source venv/bin/activate (venv)Mac:myproject michael$ 安装第三方包(venv)Mac:myproject michael$ pip install jinja2 ... Successfully installed jinja2-2.7.3 markupsafe-0.23 (venv)Mac:myproject michael$ python myapp.py ... 退出venv环境(venv)Mac:myproject michael$ deactivate Mac:myproject michael$ 错误、调试和测试 bug：程序编写问题 用户输入问题：检查用户输入 异常：比如写入文件时，磁盘满了，比如从网络抓取数据，网络断了。 错误处理 try: print('try...') r = 10 / int('a') print('result:', r) except ValueError as e: print('ValueError:', e) except ZeroDivisionError as e: print('ZeroDivisionError:', e) finally: print('finally...') print('END') 注意父类错误包括所有的子类 # err_raise.py class FooError(ValueError): pass def foo(s): n = int(s) if n==0: raise FooError('invalid value: %s' % s) return 10 / n foo('0') 调试 assert logging import logging s = '0' n = int(s) logging.info('n = %d' % n) print(10 / n) pdb 以参数-m pdb启动后，pdb定位到下一步要执行的代码-> s='0'。输入命令1来查看代码。 $ python -m pdb err.py > /Users/michael/Github/learn-python3/samples/debug/err.py(2)() -> s = '0' (Pdb) l 1 # err.py 2 -> s = '0' 3 n = int(s) 4 print(10 / n) 输入命令n可以单步执行代码 (Pdb) n > /Users/michael/Github/learn-python3/samples/debug/err.py(3)() -> n = int(s) (Pdb) n > /Users/michael/Github/learn-python3/samples/debug/err.py(4)() -> print(10 / n) 任何时候都可以输入命令p 变量名来查看变量 (Pdb) p s '0' (Pdb) p n 0 输入命令q结束调试 (Pdb) q pdb.set_trace()设置断点 # err.py import pdb s = '0' n = int(s) pdb.set_trace() # 运行到这里会自动暂停 print(10 / n) 单元测试 class Dict(dict): def __init__(self, **kw): super().__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r\"'Dict' object has no attribute '%s'\" % key) def __setattr__(self, key, value): self[key] = value import unittest from mydict import Dict class TestDict(unittest.TestCase): def test_init(self): d = Dict(a=1, b='test') self.assertEqual(d.a, 1) self.assertEqual(d.b, 'test') self.assertTrue(isinstance(d, dict)) def test_key(self): d = Dict() d['key'] = 'value' self.assertEqual(d.key, 'value') def test_attr(self): d = Dict() d.key = 'value' self.assertTrue('key' in d) self.assertEqual(d['key'], 'value') def test_keyerror(self): d = Dict() with self.assertRaises(KeyError): value = d['empty'] def test_attrerror(self): d = Dict() with self.assertRaises(AttributeError): value = d.empty if __name__ == '__main__': unittest.main() $ python -m unittest mydict_test ..... ---------------------------------------------------------------------- Ran 5 tests in 0.000s OK 以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。 class TestDict(unittest.TestCase): def setUp(self): print('setUp...') def tearDown(self): print('tearDown...') 常见用法：测试时打开/关闭数据库 文档测试 mydict2.py class Dict(dict): ''' Simple dict but also support access as x.y style. >>> d1 = Dict() >>> d1['x'] = 100 >>> d1.x 100 >>> d1.y = 200 >>> d1['y'] 200 >>> d2 = Dict(a=1, b=2, c='3') >>> d2.c '3' >>> d2['empty'] Traceback (most recent call last): ... KeyError: 'empty' >>> d2.empty Traceback (most recent call last): ... AttributeError: 'Dict' object has no attribute 'empty' ''' def __init__(self, **kw): super(Dict, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r\"'Dict' object has no attribute '%s'\" % key) def __setattr__(self, key, value): self[key] = value if __name__=='__main__': import doctest doctest.testmod() 什么输出也没有说明doctest运行是正确的。doctest运行错误时 $ python mydict2.py ********************************************************************** File \"/Users/michael/Github/learn-python3/samples/debug/mydict2.py\", line 10, in __main__.Dict Failed example: d1.x Exception raised: Traceback (most recent call last): ... AttributeError: 'Dict' object has no attribute 'x' ********************************************************************** File \"/Users/michael/Github/learn-python3/samples/debug/mydict2.py\", line 16, in __main__.Dict Failed example: d2.c Exception raised: Traceback (most recent call last): ... AttributeError: 'Dict' object has no attribute 'c' ********************************************************************** 1 items had failures: 2 of 9 in __main__.Dict ***Test Failed*** 2 failures. 当模块正常导入时，doctest不会被执行，只有在命令行直接运行时，才执行doctest。 图形化界面 Python常用的图形界面第三方库： TK(Python自带的库) wxWidgets Qt GTK GUI中，每个Button、Label、输入框等，都是一个Widget。Frame则是可以容纳其他Widget的Widegt，所有Widget组合起来就是一棵树 from tkinter import * class Application(Frame): def __init__(self, master=None): Frame.__init__(self, master) self.pack()#把widget加入到父容器中，并实现布局 #pack()是最简单的布局，grid()可以实现更复杂的布局。 self.createWidgets() def createWidgets(self): self.helloLabel = Label(self, text='Hello, world!') self.helloLabel.pack() self.quitButton = Button(self, text='Quit', command=self.quit) self.quitButton.pack() >>> app = Application() # 设置窗口标题: >>> app.master.title('Hello World') # 主消息循环: >>> app.mainloop() from tkinter import * import tkinter.messagebox as messagebox class Application(Frame): def __init__(self, master=None): Frame.__init__(self, master) self.pack() self.createWidgets() def createWidgets(self): self.nameInput = Entry(self) self.nameInput.pack() self.alertButton = Button(self, text='Hello', command=self.hello) self.alertButton.pack() def hello(self): name = self.nameInput.get() or 'world' messagebox.showinfo('Message', 'Hello, %s' % name) >>> app = Application() # 设置窗口标题: >>> app.master.title('Hello World') # 主消息循环: >>> app.mainloop() 网络编程 TCP/IP简介 计算机地址 互联网上每个计算机的唯一标示就是IP地址 如果一台计算机同时接入到两个或更多网络，比如路由器，它就会有两个或多个IP地址。IP地址对应的实际上是计算机的网络接口，通常是网卡。IP协议 负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之前经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证按顺序到达。TCP协议 TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。 许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。 一个TCP报文除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。 端口有什么作用？在两台计算机通信时，只发IP地址是不够的，因为同一台计算机上跑着多个网络程序。一个TCP报文来了之后，到底是交给浏览器还是QQ，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号。 一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口。TCP编程 Socket是网络编程的抽象概念，通常我们用一个socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。客户端 创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。 ```python导入socket库: import socket 创建一个socket: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 建立连接: s.connect(('www.sina.com.cn', 80)) 创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议，这样，一个Socket对象就创建成功，但是还没有建立连接。 客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。新浪网站的IP地址可以用域名www.sina.com.cn自动转换到IP地址，但是怎么知道新浪服务器的端口号呢？ 答案是作为服务器，提供什么样的服务，端口号就必须固定下来。由于我们想要访问网页，因此新浪提供网页服务的服务器必须把端口号固定在80端口，因为80端口是Web服务的标准端口。其他服务都有对应的标准端口号，例如SMTP服务是25端口，FTP服务是21端口，等等。端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。 因此，我们连接新浪服务器的代码如下： ```python s.connect(('www.sina.com.cn', 80)) 注意参数是一个tuple，包含地址和端口号。 建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容： # 发送数据: s.send(b'GET / HTTP/1.1\\r\\nHost: www.sina.com.cn\\r\\nConnection: close\\r\\n\\r\\n') TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。 发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪服务器返回的数据了： # 接收数据: buffer = [] while True: # 每次最多接收1k字节: d = s.recv(1024) if d: buffer.append(d) else: break data = b''.join(buffer) 接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。 当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了： # 关闭连接: s.close() 接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件： header, html = data.split(b'\\r\\n\\r\\n', 1) print(header.decode('utf-8')) # 把接收的数据写入文件: with open('sina.html', 'wb') as f: f.write(html) 现在，只需要在浏览器中打开这个sina.html文件，就可以看到新浪的首页了。 服务器 和客户端编程相比，服务器编程就要复杂一些。 服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。 所以，服务器会打开固定端口(比如80)监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。 但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。 我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上Hello再发回去。 首先，创建一个基于IPv4和TCP协议的Socket： s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。 端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号。请注意，小于1024的端口号必须要有管理员权限才能绑定： # 监听端口: s.bind(('127.0.0.1', 9999)) 紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量： s.listen(5) print('Waiting for connection...') 接下来，服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接: while True: # 接受一个新连接: sock, addr = s.accept() # 创建新线程来处理TCP连接: t = threading.Thread(target=tcplink, args=(sock, addr)) t.start() 每个连接都必须创建新线程(或进程)来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接： def tcplink(sock, addr): print('Accept new connection from %s:%s...' % addr) sock.send(b'Welcome!') while True: data = sock.recv(1024) time.sleep(1) if not data or data.decode('utf-8') == 'exit': break sock.send(('Hello, %s!' % data.decode('utf-8')).encode('utf-8')) sock.close() print('Connection from %s:%s closed.' % addr) 连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上Hello再发送给客户端。如果客户端发送了exit字符串，就直接关闭连接。 要测试这个服务器程序，我们还需要编写一个客户端程序： s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 建立连接: s.connect(('127.0.0.1', 9999)) # 接收欢迎消息: print(s.recv(1024).decode('utf-8')) for data in [b'Michael', b'Tracy', b'Sarah']: # 发送数据: s.send(data) print(s.recv(1024).decode('utf-8')) s.send(b'exit') s.close() 我们需要打开两个命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了： 需要注意的是，客户端程序运行完毕就退出了，而服务器程序会永远运行下去，必须按Ctrl+C退出程序。 UCP编程 TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。 使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。 虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。 我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口： s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 绑定端口: s.bind(('127.0.0.1', 9999)) 创建Socket时，SOCK_DGRAM指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用listen()方法，而是直接接收来自任何客户端的数据： print('Bind UDP on 9999...') while True: # 接收数据: data, addr = s.recvfrom(1024) print('Received from %s:%s.' % addr) s.sendto(b'Hello, %s!' % data, addr) recvfrom()方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用sendto()就可以把数据用UDP发给客户端。 注意这里省掉了多线程，因为这个例子很简单。 客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用connect()，直接通过sendto()给服务器发数据： s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) for data in [b'Michael', b'Tracy', b'Sarah']: # 发送数据: s.sendto(data, ('127.0.0.1', 9999)) # 接收数据: print(s.recv(1024).decode('utf-8')) s.close() 从服务器接收数据仍然调用recv()方法。 仍然用两个命令行分别启动服务器和客户端测试，结果如下： 异步IO 异步IO：当遇到IO操作时，代码只负责发出IO请求，不等待IO结果，然后直接结束本轮消息处理，进入下一轮消息处理过程。当IO操作完成后，将收到一条‘IO完成’的消息，处理该消息时就可以直接获取IO操作结果。 协程：子程序调用总是通过栈，一个入口，一次返回。协程在执行过程中，子程序内部可中断，转而执行别的子程序。优势：不用线程切换；不需要多线程的锁机制。 ```python def consumer(): r = '' while True: n = yield r if not n: return print('[CONSUMER] Consuming %s...' % n) r = '200 OK' def produce(c): c.send(None) n = 0 while n c = consumer() produce(c) [PRODUCER] Producing 1... [CONSUMER] Consuming 1... [PRODUCER] Consumer return: 200 OK [PRODUCER] Producing 2... [CONSUMER] Consuming 2... [PRODUCER] Consumer return: 200 OK [PRODUCER] Producing 3... [CONSUMER] Consuming 3... [PRODUCER] Consumer return: 200 OK [PRODUCER] Producing 4... [CONSUMER] Consuming 4... [PRODUCER] Consumer return: 200 OK [PRODUCER] Producing 5... [CONSUMER] Consuming 5... [PRODUCER] Consumer return: 200 OK send()是制定上一次挂起结果的返回值 ### asyncio ```python import asyncio @asyncio.coroutine def hello(): print(\"Hello world!\") # 异步调用asyncio.sleep(1): r = yield from asyncio.sleep(1) print(\"Hello again!\") # 获取EventLoop: >>>loop = asyncio.get_event_loop() # 执行coroutine >>>loop.run_until_complete(hello()) >>>loop.close() hello()会首先打印出Hello world!，然后，yield from语法可以让我们方便地调用另一个generator。由于asyncio.sleep()也是一个coroutine，所以线程不会等待asyncio.sleep()，而是直接中断并执行下一个消息循环。当asyncio.sleep()返回时，线程就可以从yield from拿到返回值(此处是None)，然后接着执行下一行语句。 import threading import asyncio @asyncio.coroutine def hello(): print('Hello world! (%s)' % threading.currentThread()) yield from asyncio.sleep(1) print('Hello again! (%s)' % threading.currentThread()) >>>loop = asyncio.get_event_loop() >>>tasks = [hello(), hello()] >>>loop.run_until_complete(asyncio.wait(tasks)) >>>loop.close() Hello world! () Hello world! () (暂停约1秒) Hello again! () Hello again! () import asyncio @asyncio.coroutine def wget(host): print('wget %s...' % host) connect = asyncio.open_connection(host, 80) reader, writer = yield from connect header = 'GET / HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % host writer.write(header.encode('utf-8')) yield from writer.drain() while True: line = yield from reader.readline() if line == b'\\r\\n': break print('%s header > %s' % (host, line.decode('utf-8').rstrip())) # Ignore the body, close the socket writer.close() >>>loop = asyncio.get_event_loop() >>>tasks = [wget(host) for host in ['www.sina.com.cn', 'www.sohu.com', 'www.163.com']] >>>loop.run_until_complete(asyncio.wait(tasks)) >>>loop.close() wget www.sohu.com... wget www.sina.com.cn... wget www.163.com... (等待一段时间) (打印出sohu的header) www.sohu.com header > HTTP/1.1 200 OK www.sohu.com header > Content-Type: text/html ... (打印出sina的header) www.sina.com.cn header > HTTP/1.1 200 OK www.sina.com.cn header > Date: Wed, 20 May 2015 04:56:33 GMT ... (打印出163的header) www.163.com header > HTTP/1.0 302 Moved Temporarily www.163.com header > Server: Cdn Cache Server V2.0 ... async/await 针对coroutine的新语法，两步替换： 把@asyncio.coroutine替换为async 把yield from替换为await ```python @asyncio.coroutine def hello(): print(\"Hello world!\") r = yield from asyncio.sleep(1) print(\"Hello again!\") async def hello(): print(\"Hello world!\") r = await asyncio.sleep(1) print(\"Hello again!\") ### aiohttp aiohttp是基于asyncio实现的HTTP框架。 ```python import asyncio from aiohttp import web async def index(request): await asyncio.sleep(0.5) return web.Response(body=b'Index') async def hello(request): await asyncio.sleep(0.5) text = 'hello, %s!' % request.match_info['name'] return web.Response(body=text.encode('utf-8')) async def init(loop): app = web.Application(loop=loop) app.router.add_route('GET', '/', index) app.router.add_route('GET', '/hello/{name}', hello) srv = await loop.create_server(app.make_handler(), '127.0.0.1', 8000) print('Server started at http://127.0.0.1:8000...') return srv >>> loop = asyncio.get_event_loop() >>> loop.run_until_complete(init(loop)) >>>loop.run_forever() #aiohttp的初始化函数init()也是一个coroutine，loop.create_server()则利用asyncio创建TCP服务 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Python/添加路径到sys.path.html":{"url":"03_语言/Python/添加路径到sys.path.html","title":"添加路径到sys.path","keywords":"","body":"在 Python 中，有时需要添加额外的目录路径到 sys.path，以便 Python 能够导入那些目录中的模块。这可以通过临时或永久的方式来实现。 1. 临时添加路径 使用 sys.path.append() 方法可以临时将新路径添加到 sys.path。 示例代码： import sys new_path = '/path/to/your/directory' sys.path.append(new_path) 这种方法只在当前运行的 Python 程序中有效，程序结束后路径不再存在。 2.永久添加路径 修改环境变量： 对于 Windows，您可以添加环境变量 PYTHONPATH，将您想要添加的路径作为它的值。 对于 Linux 或 macOS，您可以在 .bashrc 或 .bash_profile 文件中添加 export PYTHONPATH=\"/path/to/your/directory:$PYTHONPATH\"。 这样做的好处是，这些路径会在任何时候运行 Python 程序时都被自动添加到 sys.path。 在 Python 启动文件中添加： 您可以修改 Python 的启动文件（如 sitecustomize.py 或 usercustomize.py），在其中添加 sys.path.append(\"/path/to/your/directory\")。 这些文件通常位于 site-packages 目录中。如果不存在这样的文件，您可以创建一个。 使用 .pth 文件： 在 Python 的 site-packages 目录中创建一个 .pth 文件（例如 my_paths.pth），然后在文件中添加您想要的路径，每行一个路径。 Python 会在启动时自动读取这些 .pth 文件并将这些路径添加到 sys.path。 每种方法都有其适用的场景。选择哪种方法取决于您的具体需求和环境配置。例如，如果您正在使用虚拟环境，可能会更倾向于修改该环境的 site-packages 目录，而不是设置全局的 PYTHONPATH 环境变量。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/Rust/Rust.html":{"url":"03_语言/Rust/Rust.html","title":"Rust","keywords":"","body":"介绍 Rust的主要特性：运行快、防止段错误、保证线程安全 特性1：运行快 Rust是一种静态类型的编译性语言，类似C++。编译型语言，无须大规模的运行时(runtime)支持，也没有自动内存回收(GC)机制 特性2：防止段错误 1、什么叫做段错误？ 一个进程在执行的时候，它所占用的内存的虚拟地址空间一般被分割成好几个区域，我们称为“段”，进程中的每个段通过硬件MMU映射到真正的物理空间；在这个映射过程中，我们还可以给不同的段设置不同的访问权限，比如代码段只读不写； 进程在执行过程中，如果违反了这些权限，CPU就会直接尝试一个硬件异常；硬件异常会被操作系统内核处理，一般内存会向对应的进程发送一条信号；如果没有实现自己特殊的信号处理函数，默认这个进程会直接退出；如果操作系统打开了core dump功能，在进程退出时操作系统会把它当时的内存状态，寄存器状态以及各种相关信息保存到一个文件中，供用户以后调试使用 2、什么会引起内存不安全？ 访问未定义内存会引起不可知错误 空指针：解引用空指针是不安全的，会引起段错误。这块地址空间一般是受保护的。 野指针: 野指针就是未初始化的指针，指针可能会指向受保护的区域 悬浮指针：悬浮指针是指内存空间在被释放了之后继续使用，和野指针一样，会读写不属于这个指针的内存 非法释放: 同一个指针释放两次 缓冲区溢出: 指针访问越界，会读取或者修改临近内存空间的值 执行非法指针: 如果一个函数指针不是准确的指向一个函数地址，那么调用这个函数指针会导致一段随机数据被当中指令来执行，非常危险 使用未初始化内存 数据竞争: 并发时针对同一块内存同时读写，没有同步 类似空指针、野指针等绝不会在Rust中产生，因为Rust禁用所有裸指针，而且取消了空值，通过引用和借用这一方式替代。 3、Rust不需要手动管理内存： 在Rust之前其他编程语言管理内存的方式有两种： 比如Jave和Python的方式无非是使用垃圾回收算法(GC)，垃圾回收算法一定会有运行时和垃圾回收时的停顿，不适合系统编程。 C++手工管理内存，手工管理内存可能会出现内存泄漏和悬停指针之类的问题。 Rust通过生命周期和所有权特性，就可以实现内存的自动回收， 特性3：保证线程安全 参考：https://zhuanlan.zhihu.com/p/138394529 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/为什么汇编语言不可移植，但C可以.html":{"url":"03_语言/为什么汇编语言不可移植，但C可以.html","title":"为什么汇编语言不可移植，但c可以","keywords":"","body":"汇编语言不可移植，主要是因为它是直接与硬件架构挂钩的。以下是汇编语言不可移植性的主要原因： 硬件架构特定性： 指令集依赖性：汇编语言的指令集是特定于某种处理器架构的。例如，x86架构的汇编指令与ARM架构的汇编指令完全不同。因此，针对一种处理器编写的汇编代码无法在另一种处理器上运行。 寄存器和内存模型：不同处理器有不同的寄存器集合和内存模型。汇编代码需要直接操作这些寄存器和内存，因此这些代码也无法在不同的硬件架构间通用。 硬件资源管理： 硬件接口：汇编代码通常直接操作硬件资源，例如输入输出端口、中断处理器等。这些硬件接口在不同架构上是不同的，因此相关代码不能跨平台使用。 缺乏抽象层： 低级操作：汇编语言直接控制硬件，没有提供任何形式的抽象层。高级语言通过编译器和标准库提供了一层抽象，使得相同的源代码可以在不同平台上编译和运行。汇编语言则完全依赖于具体的硬件，导致代码的不可移植性。 依赖硬件特性： 特定硬件特性：一些汇编代码依赖于特定硬件特性，比如特定的指令优化或特定的硬件功能。这些特性在不同硬件平台上可能不存在或表现不同，从而影响代码的移植性。 操作系统接口差异： 系统调用：汇编语言需要直接调用操作系统提供的系统调用（syscalls），而不同操作系统有不同的系统调用接口和约定。这意味着，针对一个操作系统编写的汇编代码无法直接在另一个操作系统上运行。 C语言之所以能做到不依赖于特定的硬件架构，是因为它通过以下几个关键机制和设计原则实现了硬件无关性： 编译器的作用： 编译器的中间层：C语言代码被编译器翻译成与特定硬件架构相关的机器代码。编译器负责将高层次的C语言代码转换为适合目标硬件的指令集。每种硬件平台都有相应的编译器或编译器后端来生成对应的机器代码。 标准库的抽象： 标准库：C语言提供了标准库（例如stdio.h, stdlib.h等），这些库函数实现了常用的操作，例如输入输出、内存管理、字符串操作等。这些库函数在不同平台上都有各自的实现，用户在代码中调用这些库函数时不需要关心底层的实现细节，编译器会链接到适用于目标平台的标准库实现。 抽象的语言特性： 高层次的语言特性：C语言提供了高级的编程特性，例如变量、函数、控制结构（如if语句、循环等），这些特性都是与硬件无关的。程序员通过这些高层次的特性编写代码，而不是直接操作硬件。 标准化： C标准：C语言有严格的标准（如C89, C99, C11等），这些标准规定了C语言的语法、语义和标准库函数的行为。标准化确保了C语言代码的可移植性，因为不同平台的编译器都遵循相同的标准，保证了同一份代码在不同平台上的行为一致性。 预处理器和宏： 预处理器指令：C语言的预处理器（例如#include, #define等）允许编写跨平台的代码。通过条件编译（#ifdef, #ifndef等），程序员可以在同一份代码中包含特定平台的实现细节，从而在不同平台上编译和运行。 抽象的硬件接口： 硬件抽象：虽然C语言可以嵌入汇编代码直接操作硬件，但通常情况下，程序员通过操作系统提供的API来进行硬件操作。这些API提供了对底层硬件的抽象，使得C语言程序不必直接面对硬件细节。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"03_语言/琐碎的Coding规则.html":{"url":"03_语言/琐碎的Coding规则.html","title":"琐碎的coding规则","keywords":"","body":"switch的case中请默认追加default语句即使是空语句，default也需要添加break else需要写花括号 常量.equals(变量) TextUtils.isEmpty(String变量) 用ArrayList.isEmpty() 而不是size(ArrayList) == 0 链式调用时每次调用新换一行 0~num-1的循环比 1~num的循环更有效率 在 CPU 级别，比较 i 通过一个条件表达式标识2~12，2 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/":{"url":"04_Android/","title":"代码测试","keywords":"","body":"04_android No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/Airtest.html":{"url":"04_Android/代码测试/Airtest.html","title":"Airtest","keywords":"","body":"介绍：Airtest是一个跨平台的、基于图像识别的UI自动化测试框架。（网易游戏开发） 特点： 脚本由Python编写 输入截图，利用图像识别匹配截图，进行操作 有Airtest IDE，类似于AndroidStudio的布局Design窗口，一定程度上可以脱离代码编写自动化脚本。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/Calabash的功能和特点.html":{"url":"04_Android/代码测试/Calabash的功能和特点.html","title":"Calabash的功能和特点","keywords":"","body":"介绍 Calabash 是一个自动化测试框架 它可以测试iOS 和 Android ,以及Hybrid App 同时支持模拟器和真机测试。 Calabash支持Cucumber。(Cucumber是一个能够理解用普通语言描述的测试用例，支持BDD（行为驱动开发）的自动化测试工具，用Ruby编写，支持Java和 .Net等多种开发语言。) 更多的功能 查找视图 query(uiquery, *args) 可以根据坐标（coordinates）、类、content-description等查找视图元素（appium也可以） irb(main):002:0> query(\"button index:1\") => [{\"id\"=>\"save\", \"enabled\"=>true, \"contentDescription\"=>nil, \"class\"=>\"android.widget.Button\", \"text\"=>\"Save\", \"rect\"=>{\"center_y\"=>724.0, \"center_x\"=>645.5, \"height\"=>64, \"y\"=>692, \"width\"=>71, \"x\"=>610}, \"description\"=>\"android.widget.Button{4267b4a0 VFED..C. ........ 497,243-568,307 #7f070023 app:id/save}\"}] 视图会被表示为一个ruby哈希表，因此可以查看key值 irb(main):003:0> query(\"button index:1\").first.keys => [\"id\", \"enabled\", \"contentDescription\", \"class\", \"text\", \"rect\", \"description\"] *args 参数可以向查询到的结果执行方法。注意查询到的结果是APP内的Java代码，执行完成后会返回到Ruby脚本中。下面的代码获得了页面中button的文本（猜测） irb(main):005:0> query(\"button\", \"text\") => [\"Optional Settings\", \"Save\", \"Cancel\", \"Get a free blog at WordPress.com\"] 下面的代码获得了页面中button的文本的长度（猜测） irb(main):007:0> query(\"button\", \"text\", \"length\") => [17, 4, 6, 32] 下面的代码获得了页面中button的文本的小写版本 irb(main):008:0> query(\"button\", \"text\", \"toLowerCase\") => [\"optional settings\", \"save\", \"cancel\", \"get a free blog at wordpress.com\"] 甚至还可以设置页面中元素的文本 irb(main):033:0> query(\"edittext index:1\", setText:\"1234\") => [\"\"] ruby 1.8 irb(main):034:0> query(\"edittext index:1\", :setText => \"1234\") => [\"\"] 等待 等待某个元素出现、等待某个元素不出现等。 SP操作 读取、写入、清除SharedPreferences No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/RanoreX.html":{"url":"04_Android/代码测试/RanoreX.html","title":"Ranorex","keywords":"","body":"介绍：一个付费的UI自动化测试框架 特点： 免代码，录制动作然后播放、验证操作。 可以撰写C#脚本 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/Robotium介绍.html":{"url":"04_Android/代码测试/Robotium介绍.html","title":"Robotium介绍","keywords":"","body":"大差不差也就是查找控件、模拟手势操作那一套。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/":{"url":"04_Android/代码测试/","title":"Ui测试","keywords":"","body":"代码测试 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/UI测试/Appium.html":{"url":"04_Android/代码测试/UI测试/Appium.html","title":"Appium","keywords":"","body":"搭建 1.安装nodejs 2.安装android的sdk包 3.安装java的jdk 4.安装appium-desktop 5.安装python client pip install Appium-Python-Client 介绍 测试对象 Native apps（本地应用）：使用iOS、Android、Windows SDKs开发的APP Mobile web apps（网络移动应用）：使用手机浏览器（iOS上的Safari、安卓上的Chrome或者内置浏览器）访问的web app Hybrid apps（混合模式移动应用）：使用WebView访问网页内容的APP 测试平台 iOS、Android、Windows 因为Appium的跨平台特性，使得在不同平台上的测试代码可以重复利用。 Appium的理念 CS架构 Appium本质上是一个暴露了REST API的服务器，这种C/S架构可以让测试脚本以任何语言写成，也可以将测试脚本与搭载Appium的服务器分离到两个不同的主机 会话Session 自动化测试需要在会话中进行，客户端初始化会话需要首先构建一个叫做'Desired Capabilities'的JSON对象，然后将这个json对象发送到appium服务器，服务器会返回一个session id用于发送测试命令。 Desired Capabilities 定义会话的一套键值对属性，可以区分会话的平台（安卓/苹果） Appium 和 Appium-Desktop的区别： Appium-Desktop比Appium多了GUI，可以看到设备界面和视图层级，Appium使用命令行启动。 Desired Capabilities常用属性： platformName：\"Android\" //Andorid/iOS/Windows platformVersion：\"12\" //代表S deviceName：\"BRAVIA_AE_M6L\" //设备名称，查看设备配置文件可以看到 app：\"/path/to/the/downloaded/ApiDemos-debug.apk\" //可以指定希望进行自动化测试的app路径 appPackage：\"com.qing.testapp\" //指定需要自动化的app包名 appActivity：\".MainActivity\" //指定需要启动的Activity automationName: \"UiAutomator2\" //指定自动化测试驱动，有UiAutomator和UiAutomator2 Appium 的技术架构 iOS: Apple’s UIAutomation Android 4.2+: Google’s UiAutomator Android 2.3+: Google’s Instrumentation. (Instrumentation support is provided by bundling a separate project, Selendroid) Android 4.2 于2012年发布，TestAutomation源码中AndroidUIAutomationService > src 部分应该是4.2以前用于插桩的代码，现在有了UiAutomator不再需要插桩，UiAutomator应该是由Appium Server安装的。 命令 Status 获取远程终端状态确认是否可以连接 Execute Mobile Command Execute a native mobile command 可用命令：https://github.com/appium/appium-uiautomator2-driver#platform-specific-extensions Session 创建会话 结束会话 获取Session的Desired Capabilities 回退到上一步网页（只能用于Web上下文） 截屏 获取页面源 Web上下文中得到当前窗口的HTML源文件，本地应用上下文中获取视图层次的XML文件 是由Appium遍历App的层次然后创建一个XML文件，所以会花费很长时间。 Timeouts 设置超时 为某项操作设置可以执行的最长时间，超时则中止。 设置隐藏等待时间 当驱动在页面上寻找元素时，会拉取页面直到找到元素或者超过隐藏等待时间，如果不设置隐藏等待时间，则其默认为0ms。 设置脚本超时 设置Execute Async命令执行的异步脚本的超时时间 Orientation 获取方向 获取当前设备/浏览器的方向 设置方向 设置当前设备/浏览器的方向 Geolocation 获取当前的地理位置 设置当前的地理位置 Logs Get available log types 获取可用的log类型 Get Logs 获取给定日志类型的日志。每次请求后都会重置日志缓冲区 Events Log event 在Appium服务器内存储自定义事件 Get event 获取Appium服务器内存储的自定义事件 Settings Update Device Settings 更新当前设备的设置 Retrieve Device Settings 获取当前设备的设置 Execute Driver Script 在当前会话中执行WebdriverIO脚本 Device Activity Start Activity 开启一个Activity Get Current Activity 获取当前Activity Get Current Package 获得当前的安卓包名 APP Install App 安装App Is App Installed 某个App是否已安装 Launch App 运行Session中定义的需要进行测试的App 如果待测应用（AUT）已关闭或后台运行，它将启动它；如果AUT已经打开，它将让其在后台运行之后再重新启动它。 Background App 将当前正在运行的app设置为在后台运行 需传入希望app在后台运行的时间 经过上面传入的时间后，app会重新启动 Close App 关闭Session中定义的需要进行测试的App Reset App 关闭Session中定义的需要进行测试的App后重新启动 Remove App 从当前设备中卸载一个APP Active App 打开某个应用程序 Terminate App 对应ActiveApp，关闭某个应用程序 Close App只能关闭Session指定的App，Terminate App可以关闭用Active App打开的应用 Get App State 获取设备上给定应用的状态 driver.query_app_state('com.apple.Preferences') 状态码 含义 0 not installed. 1 not running. 2 running in background or suspended. 3 running in background. 4 running in foreground. Get App Strings ？？？实在看不懂 End Test Coverage 获取测试覆盖率数据 Clipboard（剪切板） Get Clipboard 获取系统剪切板的内容 Set Clipboard 设置系统剪切板的内容 Emulator Emulate power state 模拟连接的模拟器上的电源状态更改（只能用于模拟器，关闭或打开电源） Emulate power capacity 在连接的模拟器上模拟电源容量变化。 Files Push File Pop File Push Folder Interaction Shake 摇晃手机 Lock 锁屏 Unlock 启屏 Is Locked 确认是否已经锁屏 Rotate 旋转屏幕 Keys Press keycode 按下keycode Long press keycode 长按keycode Hide Keyboard 隐藏键盘 Is Keyboard Shown 确认键盘是否已经打开 Network Toggle Airplane Mode 打开或关闭飞行模式 Toggle Data 打开或关闭数据服务？？ 不可用于安卓API21及以上，因为需要系统级或特权权限 Toggle WiFi 打开或关闭wifi 不可用于Android Q及以上 Toggle Location Services 打开或关闭地理位置服务 Send SMS 发送短信 只能用于模拟器 GSM Call 打电话 只能用于模拟器 GSM Signal 设置GMS信号强度 只能用于模拟器 GSM Voice 设置GMS语音状态？ 只能用于模拟器 Network speed 设置网速 只能用于模拟器 Performance Data Get Performance Data 返回支持读取的系统状态信息，如 CPU、内存、网络流量和电池 需要自己指定获取哪一项 Performance Data Types 返回支持读取的系统状态的信息类型，如 CPU、内存、网络流量和电池 Screen Recording 开始屏幕录制 停止屏幕录制 Perform Touch ID 仅限于IOS应用 System Open Notifications 打开安卓通知栏，仅限模拟器 Get System Bars 检索状态和导航栏的可见性和边界信息 Get System Time 获得设备上的系统时间 Get Display Density 获得当前安卓设备的dpi Authentication Finger Print 通过在受支持的模拟器上使用指纹扫描对用户进行身份验证。 Element Find Element 在页面上寻找一个元素 Find Elements 在页面上寻找多个元素 Appium定位控件的方式： 1.id定位：通过uiautomatorviewer.bat工具看到的对象id 2.name定位：指控件的text属性 3.class name定位：指控件的类，比如Button的class属性是android.widget.Button 4.XPath定位：(WebDriver提供) driver.findElement(By.xpath(\"//android.view.ViewGroup/android.widget.Button\")) driver.findElement(By.xpath(\"//android.widget.Button[contains(@text,'7')]\")).click() driver.findElement(By.xpath(\"//android.widget.Button[contains(@content-desc,'times')]\")).click() driver.findElement(By.xpath(\"//android.widget.Button[contains(@text,'7')]\")).click() driver.findElement(By.xpath(\"//android.widget.Button[contains(@content-desc,'equals')]\")).click() 5.Accessibility ID定位：（Appium拓展的方法）找到元素的contentDescription属性 driver.findElementByAccessibilityId(\"plus\").click(); 6.android uiautomator定位：（Appium拓展的方法） 一个元素的任意属性都可以通过android uiautomator方法来进行定位，但要保证这种定位方式的唯一性。 driver.findElementByAndroidUIAutomator(\"new UiSelector().text(\\\"clr\\\")\").click(); driver.findElementByAndroidUIAutomator(\"new UiSelector().text(\\\"8\\\")\").click(); driver.findElementByAndroidUIAutomator(\"new UiSelector().description(\\\"plus\\\")\").click(); driver.findElementByAndroidUIAutomator(\"new UiSelector().text(\\\"5\\\")\").click(); driver.findElementByAndroidUIAutomator(\"new UiSelector().description(\\\"equals\\\")\").click(); 定位元素： el ` `=` `driver.findElementByXPath(` `\"//android.widget.LinearLayout[1]/android.widget.FrameLayout/android.widget.ListView/android.widget.TextView[contains(@index,0)]\"` `); ` `assertThat(el.getText(),equalTo(` `\"note2\"` `)); Actions Click 点击控件 Send Keys 向元素发送一系列击键，比如向EditText发送一个字符串作为输入 Clear Clear an element's value，？是不是也是清空EditText？？ Attributes Text 获取控件可见的文本 Name 指tag名称 Attribute 获得控件的某项属性 需指定属性名称 [checkable, checked, {class,className}, clickable, {content-desc,contentDescription}, enabled, focusable, focused, {long-clickable,longClickable}, package, password, {resource-id,resourceId}, scrollable, selection-start, selection-end, selected, {text,name}, bounds, displayed, contentSize] Selected 确定一个表单或者类表单控件是否已被选中8 Enabled 确定元素当前是否已启用 Displayed 确定一个元素是否正在展示 Location 确定一个元素在屏幕或页面中的坐标 Size 确定一个元素的像素大小 Rect 获取元素的维度和坐标 CSS Property 查询 Web 元素的经过计算的 CSS 属性的值 Location in View 在元素滚动到视图中后确定元素在屏幕上的位置（主要是内部命令，并非所有客户端都支持） Other Submit 提交表单元素 Active Element 激活当前会话中的一个元素 Equals Element 比较两个元素的id是否相同 Context Get Context 获得Appium正在运行的上下文 Get All Contexts 获取所有可用于自动化的上下文 Set Context 设置要自动化的上下文 Interactions Mouse Move To 将鼠标移动特定元素的偏移量 actions = ActionChains(driver) actions.move_to(element, 10, 10) actions.perform() Click 在当前鼠标坐标处点击鼠标的任意按钮 actions = ActionChains(driver) actions.move_to_element(element) actions.click() actions.perform() Double Click 双击当前鼠标坐标（moveTo设置的） actions = ActionChains(driver) actions.move_to_element(element) actions.double_click() actions.perform() Button Down 在当前鼠标坐标处单击并按住鼠标左键 Button Up 释放先前按住的鼠标按钮 Touch Single Tap 在支持触摸的设备上单击一下 Double Tap 使用手指运动事件双击触摸屏 Move 手指在屏幕上移动 from appium.webdriver.common.touch_action import TouchAction # ... actions = TouchAction(driver) actions.tap_and_hold(element) actions.move_to(element, 50, 50) actions.perform() Touch Down 手指在屏幕上下滑 from appium.webdriver.common.touch_action import TouchAction # ... actions = TouchAction(driver) actions.tap_and_hold(element) actions.move(50, 50) actions.perform() Touch Up 手指在屏幕上上滑 from appium.webdriver.common.touch_action import TouchAction # ... actions = TouchAction(driver) actions.tap_and_hold(20, 20) actions.release(50, 50) actions.perform() Long Press 使用手指运动事件长按触摸屏 from appium.webdriver.common.touch_action import TouchAction # ... actions = TouchAction(driver) actions.long_press(element) actions.perform() Scroll 使用基于手指的运动事件在触摸屏上滚动 from appium.webdriver.common.touch_action import TouchAction # ... actions = TouchAction(driver) actions.scroll_from_element(element, 10, 100) actions.scroll(10, 100) actions.perform() Flick 使用手指运动事件在触摸屏上轻拂 from appium.webdriver.common.touch_action import TouchAction # ... actions = TouchAction(driver) actions.flick_element(element, 1, 10, 10) actions.perform() Multi Touch Perform 执行多点触控操作序列 from appium.webdriver.common.touch_action import TouchAction from appium.webdriver.common.multi_action import MultiAction # ... a1 = TouchAction() a1.press(10, 20) a1.move_to(10, 200) a1.release() a2 = TouchAction() a2.press(10, 10) a2.move_to(10, 100) a2.release() ma = MultiAction(self.driver) ma.add(a1, a2) ma.perform() Touch Perform 执行触摸操作序列 from appium.webdriver.common.touch_action import TouchAction // ... actions = TouchAction(driver) actions.tap_and_hold(20, 20) actions.move_to(10, 100) actions.release() actions.perform() W3C Actions 执行一个或多个键盘和指针（触摸、鼠标、触笔）操作链 from selenium.webdriver.common.action_chains import ActionChains element = driver.find_element_by_accessibility_id(\"elId\") actions = ActionChains(driver) actions.move_to_element(element) actions.click(hidden_submenu) actions.perform() Web 网络应用才会用到的功能 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/UI测试/Espresso.html":{"url":"04_Android/代码测试/UI测试/Espresso.html","title":"Espresso","keywords":"","body":"wiki： https://developer.android.google.cn/training/testing/espresso?hl=en 介绍 Espresso需要在Android Studio里编写代码，只能测试单个应用程序 API No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/压力测试/Monkey.html":{"url":"04_Android/代码测试/压力测试/Monkey.html","title":"Monkey","keywords":"","body":"简介 Android SDK 中附带的一个工具 原理：利用socket通讯（Android客户端和服务端以TCP/UDP方法）来模拟用户的按键输入、触摸屏输入、手势输入等，并把它们发送给系统。同时，Monkey还对测试中的系统进行监测，对下列三种情况进行特殊处理（自动停止）。 如果限定了Monkey运行在一个或几个特定的包上，那么它会检测试图转到其他包的操作，并对其进行阻止。 如果应用程序崩溃或接收到任何失控异常，Monkey将停止并报错 如果应用程序产生了应用程序不响应(anr)的错误，Monkey将会停止并报错 相关位置 Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是：/system/framework/monkey.jar； Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中的存放路径是：/system/bin/monkey； 参数 帮助 -help adb shell monkey -help 基础参数 -v 指定日志级别，Level 0-2。 Level 0 级别最低，仅提供启动提示、测试完成和最终结果等少量信息。 Level 1 提供较为详细的测试信息，如逐个发送到Activity的事件。 Level 2 提供更加详细的测试信息，如测试中被选中或未被选中的Activity。 日志级别 Level 0 示例： adb shell monkey -p com.htc.Weather -v 100 日志级别 Level 1 示例： adb shell monkey -p com.htc.Weather -v -v 100 日志级别 Level 2 示例： adb shell monkey -p com.htc.Weather -v -v -v 100 -v要在事件数目前面 -S \\ 伪随机数生成器的seed值，如果用相同的seed值再次运行monkey，它将生成相同的事件序列，对9个事件分配相同的百分比。 -throttle 用于指定用户操作（即事件）间的时延，单位是毫秒；如果不指定这个参数，monkey会尽可能快的生成和发送消息。 adb shell monkey -p com.sf.DarkCalculator –-throttle 1000 -v 100 -p 用此参数指定一个或多个包（即App） 如果不指定此参数，Monkey会允许系统启动所有页面上的Activities eg.指定一个包： adb shell monkey -p com.example.sellclientapp 100 com.example.sellclientapp为包名，100是事件计数（即让monkey程序模拟100次随机用户事件） eg.指定多个包： adb shell monkey -p com.htc.Weather -p com.htc.pdfreader 100 -c \\ 如果指定了一个或更多的category，Monkey会允许系统参观指定目录下列出的Activity。 如果不指定任何的目录，Monkey会选中在目录Intent.CATEGORY_LANUCHER或者Intent.CATEGORY_MONKEY列出的Activity 发送的事件类型 选项 含义 --pct-touch 点击事件（屏幕某点的一组down-up事件） --pct-motion 滑动事件（由屏幕上某处的一鞥down事件，一系列的伪随机事件和一个up事件组成） --pct-pinchzoom 缩放事件 --pct-trackball 轨迹球事件（由一个或几个随机的移动组成，有时还伴随有点击） --pct-rotation 屏幕旋转事件 --pct-nav 基本导航事件（由来自方向输入设备的up/down/left/right组成） --pct-majornav 主要导航事件（如5-way键盘的中间按键、回退按键、菜单按键，通常引发图形界面中的动作） --pct-syskeys 系统按键事件百分比（Home、Back、Start、Call、StartCall、EndCall、音量控制键） --pct-appswitch Activity启动事件 --pct-flip 键盘唤出隐藏事件 --pct-anyevent 其他事件 *各事件类型的百分比总数不能超过100% adb shell monkey -p com.sf.DarkCalculator --pct-touch 50 --pct-motion 50 1000 触摸事件50%，滑动事件50%，事件总数1000 调试选项 选项 含义 --hprof 指定该项后在事件序列发送前后会立即生成分析报告 —— 一般建议指定该项 --ignore-crashes 即使应用程序崩溃，Monkey依然会发送事件到系统，直到事件数目达到目标值 --ignore-timeouts 即使应用程序发生ANR，Monkey依然继续发送事件到系统，直到事件数目达到目标值 --ignore-security-exceptions 即使应用程序发生安全异常，如要启动一个Activity但没有相应的权限时，Monkey依然继续发送事件到系统，直到事件数目达到目标值。 --ignore-native-crashes 忽略本地方法崩溃 --kill-process-after-error 发生错误后直接杀掉进程 --monitor-native-crashes 跟踪本地方法的崩溃问题 --dbg-no-events 初始化启动的activity，但是不产生任何事件 --wait-dbg 直到连接了调试器才执行monkey测试 其他 为测试分配一个专用的端口号，不过这个命令只能输出跳转的信息及有错误时输出信息； adb shell monkey -p com.package --port 端口号 -v 输出到d:\\monkeyScreenLog.log adb shell monkey -p http://com.tencent.XXX(替换包名) --throttle 500 --ignore-crashes--ignore-timeouts --ignore-security-exceptions --ignore-native-crashes -v -v -v 1000000 > d:\\monkeyScreenLog.log 日志定位问题 搜索关键字：Fatal、Crash、ANR、Exception -c： activity必须至少包含一个指定的category，才能被启动，否则启动不了  No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/本地UT/Jacoco.html":{"url":"04_Android/代码测试/本地UT/Jacoco.html","title":"Jacoco","keywords":"","body":"介绍 JaCoCo is a free code coverage library for Java, which has been created by the EclEmma team based on the lessons learned from using and integration existing libraries for many years. important features: Coverage analysis of instructions (C0), branches (C1), lines, methods, types and cyclomatic complexity. Based on Java byte code and therefore works also without source files. JaCoCo supports two ways class instrumentation: on the fly with using Java Agent and offline when classes are prepared during build phase. wiki： https://www.jacoco.org/jacoco/trunk/doc/ 使用 配置 android studio gradle jacoco config: for instrumented unit test, you can only add the following option into build.gradle to enable jacoco codecovarage; buildTypes { debug { testCoverageEnabled true } } then you can run the gradle task'createDebugCoverageReport' to generate the code coverage report after resync the project. for local unit test: add “apply plugin: \"jacoco\" into build.gradle add the gradle task which type is 'JacocoReport' to generate the local unit test code coverage JacocoReport Task(gradle task) after exec local unit test, the code coverage data will be collected into *.exec files then we can call JacocoReport to generate the code coverage report(html) the exec file location: module/build/jacoco/testDebugUnitTest.exec module/jacoco.exec // the unit test didn't generate this somtimes, now we didn't now why About the samples please refer to the p20,p21 following is on the fly mode jacoco config: following is on the offline mode jacoco config: the mainSrc,javDebugTree,kotlinDebugTree is same as on the fly mode config jacoco instrumentation types On-the-fly instrumentation: 用一个新的class loader，然后在执行class文件的过程中加入类似的输出代码。 在应用启动时加入jacoco agent进行插桩，在开发、测试人员使用应用期间实时地进行代码覆盖率分析。相信很多的java项目开发人员并不会去写单元测试代码的，因此覆盖率统计就要把手工测试或接口测试覆盖的情况作为重要依据，显然在线模式更符合实际需求。 One of the main benefits of JaCoCo is the Java agent, which instruments classes on-the-fly. This simplifies code coverage analysis a lot as no pre-instrumentation and classpath tweaking is required. However, there can be situations where on-the-fly instrumentation is not suitable, for example: Runtime environments that do not support Java agents. Deployments where it is not possible to configure JVM options. Bytecode needs to be converted for another VM like the Android Dalvik VM. Conflicts with other agents that do dynamic classfile transformation. So there is a big issue when test some powermock test. PowerMock instruments classes and Javassist is used to modify classes. The main issue is that Javassist reads classes from disk and all JaCoCo changes are disappeared. As result zero code coverage for classes which are loaded by PowerMock class loader. refer uri:https://github.com/powermock/powermock/wiki/Code-coverage-with-JaCoCo Offline Instrumentation: 先对class文件加入代码再运行 in this mode, you must pre-instruments classes in build process. At runtime the pre-instrumented classes needs be on the classpath instead of the original classes. In addition jacocoagent.jar must be put on the classpath. refer uri:https://www.jacoco.org/jacoco/trunk/doc/offline.html In this mode, it can solve the conflict with PowerMock No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/本地UT/Junit.html":{"url":"04_Android/代码测试/本地UT/Junit.html","title":"Junit","keywords":"","body":"介绍 xUnit：一套基于测试驱动开发的测试框架，包括了 PythonUint、CppUnit、Junit，分别是 Python、C++、Java的测试框架 Junit：Java的面向程序员的测试框架，基于xUnit实现 wiki：https://junit.org/junit4 使用 导入依赖 app/build 下导包 dependencies { // JUnit 4 framework testImplementation 'junit:junit:4.13.2' // AndroidJUnitRunner testImplementation 'androidx.test:runner:1.2.0' // some rules for example ActivityTestRule testImplementation 'androidx.test:rules:1.2.0' // ext class for junit testImplementation 'androidx.test.ext:junit:1.1.1' testImplementation 'androidx.test.ext:truth:1.2.0' } //前面是 testImplementation 使用Junit5：https://blog.csdn.net/yihanss/article/details/125809714 基本使用，断言方法 先准备好 原类（被测试类） 注意，被测试的方法是要用 public 修饰，不然调用不到 如下，下面就是几个简单的计算方法 public class Calculator { public int add(int a,int b) { return a + b; } public int subtract(int a,int b) { return a - b; } public int multiply(int a,int b) { return a * b; } public int divide(int a,int b) { return a / b; } } 鼠标光标移至 被测试类名 处，快捷键：Alt + Enter -> 选择 create Test （或者 右击 -> go to -> Test），然后进行选择一些类的方法、存放路径等信息，完成即可生成 测试类。测试类名是以 Test 作为后缀的，接下来就可以进行一些测试操作了。 关于 测试类 存放的位置 AS已经自动帮我们创建好了，如下： app/src ├── androidTestjava (仪器化单元测试、UI测试) ├── main/java (业务代码) └── test/java (本地单元测试) 然后编写测试方法，使用 @Test 进行注解，都是 public void 且 无参数 的方法，这里编写测试方法有快捷键：Alt + Insert 即可选择自动生成测试方法等 方法名与原类中的方法名一致，或以 test 为前缀进行命名 使用 Assert 类中的静态方法 assertXxx() 进行测试，又称为断言方法 下面代码中使用的是 assertEquals() 方法，比较实际值（调用 被测试方法的结果）与 期望值（你认为的值）是否相同。相同，Run 通过；不同，控制台提示错误信息（很明显的提示你） 跑程序的时候可以选择是跑一个类（即全部的测试方法），还是指定的方法 public class CalculatorTest { private static final String TAG = \"TAG\"; private Calculator calculator = new Calculator(); @Before public void setUp() throws Exception { // Log.d(TAG,\"执行：setUp()\"); } @After public void tearDown() throws Exception { // Log.d(TAG,\"执行：tearDown()\"); } @Test public void add() { assertEquals(6,calculator.add(3,3)); } ··· @Test public void divide() { assertEquals(3,calculator.divide(9,3)); } } 测试套件 测试套件就是组织测试类一起运行 写一个空类作为测试套件的入口类 使用 @RunWith 注解入口类，指明测试运行器为 Suite 类 Suite 是一个标准运行程序，允许您手动构建包含来自多个类的测试的套件 作用就是改变测试运行器 使用 @Suite.SuiteClasses 注解入口类，并以数组的形式指明测试类 这里，数组的先后顺序会影响进行测试的先后顺序 按顺序依次执行方法，一个测试类的方法执行完之后才会执行下一个测试类的方法 //测试套件：入口类 @RunWith(Suite.class) @Suite.SuiteClasses({Test1Test.class,Test2Test.class}) public class Test { } //测试套件：测试类一 public class Test1Test { @Test public void add() { assertEquals(5,new Test1().add(2,3)); System.out.println(\"测试类Test1Test执行add()方法\"); } @Test public void subtract() { assertEquals(5,new Test1().subtract(5,0)); System.out.println(\"测试类Test1Test执行subtract()方法\"); } } //测试套件：测试类二 public class Test2Test { @Test public void add() { assertEquals(5,new Test2().add(2,3)); System.out.println(\"测试类Test2Test执行add()方法\"); } @Test public void subtract() { assertEquals(5,new Test2().subtract(6,1)); System.out.println(\"测试类Test2Test执行subtract()方法\"); } } 参数化测试 参数化测试允许开发人员使用 不同的值 反复运行 同一个测试 和方法传值类似，一个方法可以调用多次，每次传递不同的值 但是测试方法并没有参数，所以提供了这样一个参数化测试来实现 使用如下 使用 @RunWith 注解测试类，并指定属性值为 Parameterized.class Parameterized是实现参数化测试的标准运行程序。运行参数化的测试类时，将为测试方法和测试数据元素的叉积创建实例。 然后就是定义你的测试方法所需要的参数值，（期望值 + 断言方法里调用的方法所需的参数值） 再编写一个构造方法，使用 @Parameterized.Parameters 进行注解，在构造方法中对定义的变量进行赋值 再定义一个 public static 修饰的方法，返回值为 Collection<>，可以指定类型参数（推荐），也可以不指定 在这个方法中定义一个二维数组（一维数组不够），然后使用 Arrays.asList() 方法将数组转换为 List集合，然后返回即可 这里二维数组的元素就是你要进行测试的值 至此，就可以正常的进行测试了 @RunWith(Parameterized.class) public class ParamTestTest { private int expected = 0; private int input1 = 0; private int input2 = 0; @Parameterized.Parameters public static Collection t() { return Arrays.asList(new Object[][]{ {5,2,3}, {11,5,6} }); } public ParamTestTest(int expected, int input1, int input2) { this.expected = expected; this.input1 = input1; this.input2 = input2; } @Test public void add() { assertEquals(expected,new ParamTest().add(input1,input2)); } } 分类测试 所谓分类测试，就是将测试代码中的方法进行分类，然后根据类别来选择该跑什么类别的方法，当然，这个时候同一类别的方法肯定是都会执行的 主要是 @Category 注解的使用，还包含：@RunWith、@SuiteClasses、@IncludeCategory 这几个注解一起使用 一共需要的类数量：原类 + 测试类 + 作标识符的类 + 最后运行的类 原类：提供方法进行测试 测试类：方法使用 @Category 注解，指明属性值（为类别的标识符），别忘了 @Test 作标识符的类：就是几个空类 最后运行的类：空类 + 注解 使用 @RunWith 注解，并指定属性值为 Categories 类 使用 @Categories.IncludeCategory 注解，并指明属性值为你要进行测试的 标识符的类 使用 @Suite.SuiteClasses 注解，并指明属性值为测试类 最后就可以运行了 如下： //原类 public class CategoryTest { public int add(int a,int b) { return a + b; } public int subtract(int a,int b) { return a - b; } public int secondPower(int a) { return a * a; } public int theThirdPower(int a) { return a * a * a; } } //测试类 public class CategoryTestTest { @Category(BaseOperations.class) @Test public void add() { assertEquals(5,new CategoryTest().add(2,3)); } @Category(BaseOperations.class) @Test public void subtract() { assertEquals(5,new CategoryTest().subtract(6,1)); } @Category(PowerOperations.class) @Test public void secondPower() { assertEquals(4,new CategoryTest().secondPower(2)); } @Category(PowerOperations.class) @Test public void theThirdPower() { assertEquals(8,new CategoryTest().theThirdPower(2)); } } //作标识符进行判断种类的类（这里就是两种，幂运算，基本运算） public class PowerOperations { //这个代表幂运算类的方法标识符 } public class BaseOperations { //这个代表基本运算的方法标识符 } //最后运行的类 @RunWith(Categories.class) @Categories.IncludeCategory(BaseOperations.class) @Suite.SuiteClasses(CategoryTestTest.class) public class Operations { } 假设测试 使用 assumeXxx（假设方法）进行判断，假设的条件是否成立，不成立则终止测试 Assume类中有很多的假设方法，可以自行查看，都有注释的 @Test public void testAssumptions() { //假设进入testAssumptions时，变量i的值为10，如果该假设不满足，程序不会执行assumeThat后面的语句 assumeThat( i, is(10) ); //如果之前的假设成立，会打印\"assumption is true!\"到控制台，否则直接调出，执行下一个测试用例函数 System.out.println( \"assumption is true!\" ); } 断言方法 断言方法都有很多的重载形式，这里讲讲含义就行了，具体可以自行查看 断言方法都来自 Assert 类，都是 static public 的 不满足断言方法，则会抛出：AssertionError assertArrayEquals 断言两个对象数组相等 assertEquals 断言两个对象相等 assertNotEquals() 断言两个对象不相等 assertNull() 断言一个对象为空 assertNotNull() 断言一个对象不为空 assertSame() 断言两个对象引用相同的对象 assertNotSame() 断言两个对象没有引用同一对象 assertThat() 断言实际值是否满足指定的条件，与 Matcher 一起使用，Matcher 指定条件 详细看后面的讲解 assumeThat 假设满足指定的条件，如果不满足，测试停止 Assume类中有很多的假设方法 assertTrue() 断言条件为真 assertFalse() 断言条件为假 assertThat与CoreMatchers 断言实际值是否满足指定的条件，与 Matcher 一起使用 这种断言方法一共两种重载形式： //第一个参数：reason 为断言失败时的输出信息 //第二个参数：actual 为断言的值或对象 //第三个参数：matcher 为断言的匹配器，里面的逻辑决定了 给定的 actual对象满不满足断言 public static void assertThat(String reason, T actual, Matcher matcher) { MatcherAssert.assertThat(reason, actual, matcher); } public static void assertThat(T actual, Matcher matcher) { assertThat(\"\", actual, matcher); } 在 CoreMatchers类中组织了所有JUnit内置的Matcher（匹配的方法），调用其任意一个方法都会创建一个与方法名字相关的Matcher 下面的匹配并没有全部讲解完，具体请自行进入 org.hamcrest.CoreMatchers 类中查看 assertThat 上面我们所用到的一些基本的断言，如果我们没有设置失败时的输出信息，那么在断言失败时只会抛出AssertionError，无法知道到底是哪一部分出错。而assertThat就帮我们解决了这一点。它的可读性更好。 assertThat(T actual, Matcher matcher); assertThat(String reason, T actual, Matcher matcher); 其中reason为断言失败时的输出信息，actual为断言的值，matcher为断言的匹配器。 常用的匹配器整理： 匹配器 说明 例子 is 断言参数等于后面给出的匹配表达式 assertThat(5, is (5)); not 断言参数不等于后面给出的匹配表达式 assertThat(5, not(6)); equalTo 断言参数相等 assertThat(30, equalTo(30)); equalToIgnoringCase 断言字符串相等忽略大小写 assertThat(“Ab”, equalToIgnoringCase(“ab”)); containsString 断言字符串包含某字符串 assertThat(“abc”, containsString(“bc”)); startsWith 断言字符串以某字符串开始 assertThat(“abc”, startsWith(“a”)); endsWith 断言字符串以某字符串结束 assertThat(“abc”, endsWith(“c”)); nullValue 断言参数的值为null assertThat(null, nullValue()); notNullValue 断言参数的值不为null assertThat(“abc”, notNullValue()); greaterThan 断言参数大于 assertThat(4, greaterThan(3)); lessThan 断言参数小于 assertThat(4, lessThan(6)); greaterThanOrEqualTo 断言参数大于等于 assertThat(4, greaterThanOrEqualTo(3)); closeTo 断言浮点型数在某一范围内 assertThat(4.0, closeTo(2.6, 4.3)); allOf 断言符合所有条件，相当于&& assertThat(4,allOf(greaterThan(3), lessThan(6))); anyOf 断言符合某一条件，相当于或 assertThat(4,anyOf(greaterThan(9), lessThan(6))); hasKey 断言Map集合含有此键 assertThat(map, hasKey(“key”)); hasValue 断言Map集合含有此值 assertThat(map, hasValue(value)); hasItem 断言迭代对象含有此元素 assertThat(list, hasItem(element)); 当然了匹配器也是可以自定义的。这里我自定义一个字符串是否是手机号码的匹配器来演示一下。 只需要继承BaseMatcher抽象类，实现matches与describeTo方法，代码如下： public class IsMobilePhoneMatcher extends BaseMatcher { /** * 进行断言判定，返回true则断言成功，否则断言失败 */ @Override public boolean matches(Object item) { if (item == null) { return false; } Pattern pattern = Pattern.compile(\"(1|861)(3|5|7|8)\\\\d{9}$*\"); Matcher matcher = pattern.matcher((String) item); return matcher.find(); } /** * 给期待断言成功的对象增加描述 */ @Override public void describeTo(Description description) { description.appendText(\"预计此字符串是手机号码！\"); } /** * 给断言失败的对象增加描述 */ @Override public void describeMismatch(Object item, Description description) { description.appendText(item.toString() + \"不是手机号码！\"); } } 字符串相关匹配符 containsString 匹配符表明如果测试的字符串testedString包含子字符串\"developerWorks\"则测试通过 assertThat(testedString, containsString(\"developerWorks\")); endsWith 匹配符表明如果测试的字符串testedString以子字符串\"developerWorks\"结尾则测试通过 assertThat(testedString, endsWith(\"developerWorks\")); startsWith 匹配符表明如果测试的字符串testedString以子字符串\"developerWorks\"开始则测试通过 assertThat(testedString, startsWith(\"developerWorks\")); equalTo 匹配符表明如果测试的testedValue等于expectedValue则测试通过，equalTo可以测试数值之间，字符串之间和对象之间是否相等，相当于Object的equals方法 assertThat(testedValue, equalTo(expectedValue)); collection相关匹配符 hasItem 匹配符表明如果测试的迭代对象 iterableObject 含有元素 “element” 项则测试通过 assertThat(iterableObject, hasItem(\"element\")); 自定义 Matcher 首先，大家要去看看 Matcher 这个接口与 BaseMatcher 这个实现类，就几个方法，比较简单，都写着有注释 看完就知道我们自定义的 Matcher 应该去继承的是 BaseMatcher 这个类，而不是 Matcher 这个类 使用： 创建一个类继承 BaseMatcher 类，然后重写两个方法：matche()、describeTo()，根据自己的需求去实现 然后就可以在测试方法中使用了 //IsRichardMatcher这个类是我实现的Matcher类 assertThat(user,new IsRichardMatcher()); 注解 @Test 将一个普通方法修饰为测试方法 限时测试，异常捕获 指定异常，以使测试方法在 当且仅当方法抛出 指定类的异常 时才成功，没有抛异常则会失败 //在 @Test 中指定了 断言异常，运行时不会出现错误 @Test(expected = AssertionError.class) public void add() { assertEquals(6,calculator.add(3,1)); System.out.println(\"测试方法：add() 执行\"); } 以毫秒为单位 指定超时时间，超时则失败 超过指定的时间会中断方法，并抛出异常 @Test(timeout = 3000) public void subtract() { assertEquals(20,calculator.subtract(30,10)); System.out.println(\"测试方法：subtract() 执行\"); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } @Ignore 在测试中测试运行器会忽略被 @Ignore 注解的方法，可以指定属性值（比如说为什么被忽略） 一般用于测试方法还没有准备好，或者方法太耗时之类 @Ignore(\"暂时不需要测试这个方法，所以进行忽略\") @Test public void multiply() { assertEquals(10,calculator.multiply(2,5)); System.out.println(\"测试方法：multiply() 执行\"); } @RunWith 可以更改运行测试器 如果一个类使用了@RunWith，或者一个类的父类使用了@RunWith，JUnit将调用其引用的类，以在该类中运行测试，而不是使用JUnit内置的运行器。 JUnit 4中的套件是使用RunWith和一个名为Suite的自定义运行程序构建的 一般在测试套件的时候使用 @BeforeClass 在所有测试开始之前执行一次，必须为 static 修饰 用于做一些耗时的初始化工作(如: 连接数据库) @BeforeClass public static void setUpBeforeClass() throws Exception { System.out.println(\"BeforeClass执行\"); } @AfterClass 在所有测试结束之后执行一次，必须为 static 修饰 用于清理数据(如: 断开数据连接) @AfterClass public static void tearDownAfterClass() throws Exception { System.out.println(\"AfterClass执行\"); } @Before 在每个测试方法运行前执行一次 用于准备测试环境(如: 初始化类，读输入流等)，在一个测试类中，每个@Test方法的执行都会触发一次调用 @Before public void setUp() throws Exception { System.out.println(\"Before执行\"); } @After 在每个测试方法运行结束后执行一次 这个方法在每个测试之后执行，用于清理测试环境数据，在一个测试类中，每个@Test方法的执行都会触发一次调用 @After public void tearDown() throws Exception { System.out.println(\"After执行\"); } @Run 还记得一开始我们在@Before与@After注解的方法中加入”测试开始”的提示信息吗？假如我们一直需要这样的提示，那是不是需要每次在测试类中去实现它。这样就会比较麻烦。这时你就可以使用@Rule来解决这个问题，它甚至比@Before与@After还要强大。 自定义@Rule很简单，就是实现TestRule 接口，实现apply方法。代码如下： public class MyRule implements TestRule { public class MyRule implements TestRule { @Override public Statement apply(final Statement base, final Description description) { return new Statement() { @Override public void evaluate() throws Throwable { // evaluate前执行方法相当于@Before String methodName = description.getMethodName(); // 获取测试方法的名字 System.out.println(methodName + \"测试开始！\"); base.evaluate(); // 运行的测试方法 // evaluate后执行方法相当于@After System.out.println(methodName + \"测试结束！\"); } }; } } 我们使用一下我们自定义的MyRule，效果如图： @FixMethodOrder 修饰类，使得该测试类中的所有测试方法都按照方法名的字母顺序执行，属性值有三个 指定形式：@FixMethodOrder(MethodSorters.NAME_ASCENDING)，MethodSorters是一个枚举类，下面的三个值都是它的枚举常量 DEFAULT 以确定但不可预测的顺序对测试方法进行排序，默认值 JVM 将测试方法按JVM返回的顺序保留，请注意，JVM的运行顺序可能会有所不同 NAME_ASCENDING 根据 方法名称 按字典名称 对测试方法进行排序，升序 @FixMethodOrder(MethodSorters.NAME_ASCENDING) public class CalculatorTest { ··· @Test public void divide() { assertEquals(3,calculator.divide(9,3)); System.out.println(\"测试方法：divide() 执行\"); } } 13.Junit 运行流程 下面是打印出来的信息，代码很简单就贴出来了 在开发中，BeforeClass、AfterClass注解的方法是 static 的 BeforeClass执行（类加载） Before执行 测试方法：subtract() 执行 After执行 Before执行 测试方法：divide() 执行 After执行 Before执行 测试方法：add() 执行 After执行 Before执行 测试方法：multiply() 执行 After执行 AfterClass执行 可以很明显的看出执行顺序： BeforeClass -> Before -> 测试方法 -> After -> AfterClass，如果有多个测试方法，那么重复： Before -> 测试方法 -> After 这段流程 14.使用中可能出现的 Bug 在测试方法中打 Log，出现错误：java.lang.RuntimeException: Method d in android.util.Log not mocked. a. 先仔细想一想，文章的一开始说了什么呀 b. 就是 Junit 可以隔离 Android 框架呀 @Before public void setUp() throws Exception { Log.d(TAG,\"执行：setUp()\"); //在此使用 Log } 原因： Log类是android sdk的api,用Junit做单元测试，只能用纯java API，否则会报错 这里就如果要使用 Log 就得自己创建一个 Log 类了，然后编写方法，如下： public class Log { public static int d(String tag, String msg) { System.out.println(\"DEBUG: \" + tag + \": \" + msg); return 0; } public static int i(String tag, String msg) { System.out.println(\"INFO: \" + tag + \": \" + msg); return 0; } public static int w(String tag, String msg) { System.out.println(\"WARN: \" + tag + \": \" + msg); return 0; } public static int e(String tag, String msg) { System.out.println(\"ERROR: \" + tag + \": \" + msg); return 0; } // add other methods if required... } No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/本地UT/Mockito.html":{"url":"04_Android/代码测试/本地UT/Mockito.html","title":"Mockito","keywords":"","body":"介绍 在实际的单元测试中，我们测试的类之间会有或多或少的耦合，导致我们无法顺利的进行测试，这时我们就可以使用Mockito，Mockito库能够Mock（我喜欢理解为模拟）对象，替换我们原先依赖的真实对象，这样我们就可以避免外部的影响，只测试本类，得到更准确的结果。 Mockito框架不支持mock匿名类、final类、static方法、private方法。而PowerMock框架解决了这些问题。 Mockito 2.x 增加的限制： 需要 Java 6+ 不能 mock 静态方法 不能 mock 构造器 不能 mock equals() hashCode() Mockito定义并依赖基于这些方法的具体实现，重新定义它们可能会破坏Mockito。 只有在Obgenesis支持的虚拟机上才能进行 mock 。 Objenesis是一个小的Java库，它可以实例化一个特定类的新对象。 绝大多数的虚拟机都满足这个条件。 通过外部类在外部类中监视真实方法的真实实现是不可能的，但这种情况极为罕见。 使用 添加库依赖 dependencies { testImplementation 'org.mockito:mockito-core:2.28.2' } 四种Mock方法 普通方法 public class MockitoTest { @Test public void testIsNotNull(){ Person mPerson = mock(Person.class); // 注解方法 public class MockitoAnnotationsTest { @Mock // 运行器方法(结合JUnit框架) @RunWith(MockitoJUnitRunner.class) // MockitoRule方法(结合JUnit框架) public class MockitoRuleTest { @Mock // 常用打桩方法 因为Mock出的对象中非void方法都将返回默认值，比如int方法将返回0，对象方法将返回null等，而void方法将什么都不做。“打桩”顾名思义就是将我们Mock出的对象进行操作，比如提供模拟的返回值等，给Mock打基础。 方法名 方法描述 thenReturn(T value) 设置要返回的值 thenThrow(Throwable… throwables) 设置要抛出的异常 thenAnswer(Answer answer) 对结果进行拦截 doReturn(Object toBeReturned) 提前设置要返回的值 doThrow(Throwable… toBeThrown) 提前设置要抛出的异常 doAnswer(Answer answer) 提前对结果进行拦截 doCallRealMethod() 调用某一个方法的真实实现 doNothing() 设置void方法什么也不做 注意： 如果使用doReturn等打桩方法时，语义为：以什么结果返回，当执行什么方法时。这个两者的区别就是我们熟悉的while与do while。这类方法主要是为了应对无法使用thenReturn等方法的场景（比如方法为void），可读性来说thenReturn这类更好。 常用验证方法 前面所说的都是状态测试，但是如果不关心返回结果，而是关心方法有否被正确的参数调用过，这时候就应该使用验证方法了。从概念上讲，就是和状态测试所不同的“行为测试”了。 verify(T mock)验证发生的某些行为 。 方法名 方法描述 after(long millis) 在给定的时间后进行验证 timeout(long millis) 验证方法执行是否超时 atLeast(int minNumberOfInvocations) 至少进行n次验证 atMost(int maxNumberOfInvocations) 至多进行n次验证 description(String description) 验证失败时输出的内容 times(int wantedNumberOfInvocations) 验证调用方法的次数 never() 验证交互没有发生,相当于times(0) only() 验证方法只被调用一次，相当于times(1) 使用的代码如下： @Test public void testPersonVerifyAfter(){ when(mPerson.getAge()).thenReturn(18); //延时1s验证 System.out.println(mPerson.getAge()); System.out.println(System.currentTimeMillis()); verify(mPerson, after(1000)).getAge(); System.out.println(System.currentTimeMillis()); verify(mPerson, atLeast(2)).getAge(); } @Test public void testPersonVerifyAtLeast(){ mPerson.getAge(); mPerson.getAge(); //至少验证2次 verify(mPerson, atLeast(2)).getAge(); } @Test public void testPersonVerifyAtMost(){ mPerson.getAge(); //至多验证2次 verify(mPerson, atMost(2)).getAge(); } @Test public void testPersonVerifyTimes(){ mPerson.getAge(); mPerson.getAge(); //验证方法调用2次 verify(mPerson, times(2)).getAge(); } @Test public void testPersonVerifyTimes(){ mPerson.getAge(); mPerson.getAge(); //验证方法在100ms超时前调用2次 verify(mPerson, timeout(100).times(2)).getAge(); } 常用参数匹配器 方法名 方法描述 anyObject() 匹配任何对象 any(Class type) 与anyObject()一样 any() 与anyObject()一样 anyBoolean() 匹配任何boolean和非空Boolean anyByte() 匹配任何byte和非空Byte anyCollection() 匹配任何非空Collection anyDouble() 匹配任何double和非空Double anyFloat() 匹配任何float和非空Float anyInt() 匹配任何int和非空Integer anyList() 匹配任何非空List anyLong() 匹配任何long和非空Long anyMap() 匹配任何非空Map anyString() 匹配任何非空String contains(String substring) 参数包含给定的substring字符串 argThat(ArgumentMatcher matcher) 创建自定义的参数匹配模式 示例代码： @Test public void testPersonAny(){ when(mPerson.eat(any(String.class))).thenReturn(\"米饭\"); //或 //when(mPerson.eat(anyString())).thenReturn(\"米饭\"); //输出米饭 System.out.println(mPerson.eat(\"面条\")); } @Test public void testPersonContains(){ when(mPerson.eat(contains(\"面\"))).thenReturn(\"面条\"); //输出面条 System.out.println(mPerson.eat(\"面\")); } @Test public void testPersonArgThat(){ //自定义输入字符长度为偶数时，输出面条。 when(mPerson.eat(argThat(new ArgumentMatcher() { @Override public boolean matches(String argument) { return argument.length() % 2 == 0; } }))).thenReturn(\"面条\"); //输出面条 System.out.println(mPerson.eat(\"1234\")); } 其它方法 方法名 方法描述 reset(T … mocks) 重置Mock spy(Class classToSpy) 实现调用真实对象的实现 inOrder(Object… mocks) 验证执行顺序 @InjectMocks注解 自动将模拟对象注入到被测试对象中 1.Spy的创建与mock一样，使用的例子如下： public class MockitoSpyTest { @Spy Person mPerson; @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); @Test public void testIsNotNull(){ assertNotNull(mPerson); } @Test public void testPersonSpy(){ //输出11 System.out.print(mPerson.getAge()); } } 2.inOrder使用代码及测试结果： 3.@InjectMocks: 创建一个实例，这个实例需要的参数用@Mock（或@Spy）注解创建的注入到该实例中。 public class Home { private Person mPerson; public Home(Person person) { mPerson = person; } public String getMaster(){ return mPerson.getName(); } } No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/本地UT/PowerMock.html":{"url":"04_Android/代码测试/本地UT/PowerMock.html","title":"Powermock","keywords":"","body":"介绍 wiki： https://github.com/mockito/mockito/wiki https://github.com/powermock/powermock/wiki 1.什么是PowerMock PowerMock是一个Java单元测试模拟框架，用于解决测试问题,它是在其他的单元测试模拟框架的基础上做出了拓展。通过提供定制的类加载器以及一些字节码篡改技巧的应用，PowerMock实现了对静态方法，构造方法、私有方法以及final方法的模拟支持。 PowerMock支持JUnit和TestNG，扩展了EasyMock和Mockito框架，增加了mock static、final方法的功能。 举个例子，你在使用Junit进行单元测试时，并不想让测试数据进入数据库，怎么办？这个时候就可以使用PowerMock，拦截数据库操作，并模拟返回参数。 2.Mock底层原理 Mockito原理： 底层使用了动态代理，用到了CGLIB。因此需要被mock的对象，Mockito都会生成一个子类继承该类，代理的对象会代替真实的对象进行执行。子类会覆盖父类。而static 修饰的方法不能被覆盖（也就是不能被重写）。这也就是为什么final修饰的类，private 方法，static 方法不可以被Mock的原因 PowerMock原理： javassist是一个修改java字节码的工具包，objenesis是一个绕过构造方法来实例化一个对象的工具包。由此看来，PowerMock的本质是通过修改字节码来实现对静态和final等方法的mock的。 当某个测试方法被注解@PrepareForTest标注以后，在运行测试用例时，会创建一个新的org.powermock.core.classloader.MockClassLoader实例，然后加载该测试用例使用到的类（系统类除外）。 PowerMock会根据你的mock要求，去修改写在注解@PrepareForTest里的class文件（当前测试类会自动加入注解中），以满足特殊的mock需求。例如：去除final方法的final标识，在静态方法的最前面加入自己的虚拟实现等。 如果需要mock的是系统类的final方法和静态方法，PowerMock不会直接修改系统类的class文件，而是修改调用系统类的class文件，以满足mock需求。 3.应用场景 在现实的软件开发中，我们经常需要协同其他的同事一起来完成某个模块的动能开发，当我们需要测试的模块依赖于其他模块无法进行单元测试的时候，此时该模块的质量风险就有两个，第一是你所负责的代码，第二是你所依赖的代码。 当你没有办法在很快的时间协调到资源，那么你负责的代码不具备单元测试环境没有办法进行测试，可能存在很大的风险，这个时候如何测试你的代码，就需要用到mock。 使用 1.添加依赖 dependencies { testImplementation 'org.powermock:powermock-module-junit4:2.0.5' testImplementation 'org.powermock:powermock-module-junit4-rule:2.0.5' testImplementation 'org.powermock:powermock-api-mockito2:2.0.5' testImplementation 'org.powermock:powermock-clasloading-xstream:2.0.5' } 2.配置 (1)PowerMock Configuration This configuration is applied to all test classes that in the classpath. You may enable the configuration by creating by adding this file to the classpath: org/powermock/extensions/configuration.properties for example: powermock.global-ignore=\"org.myproject.*\" Multiple packages/classes can be specified using comma: powermock.global-ignore=\"org.myproject.*\",\"org.3rdpatproject.SomeClass\" (2)Global @PowerMockIgnore By default PowerMock loads all classes with its MockClassLoader. The classloader loads and modified all classes except: system classes. They are deferred to system classloader classes located in packages that are specified as ignored. you can ignore classes in PowerMock Configuration or use @PowerMockIgnore annotation in class level and method level (3)Bypass encapsulation: Use Whitebox.setInternalState(..) to set a non-public member of an instance or class. Use Whitebox.getInternalState(..) to get a non-public member of an instance or class. Use Whitebox.invokeMethod(..) to invoke a non-public method of an instance or class. Use Whitebox.invokeConstructor(..) to create an instance of a class with a private constructor. (4)Suppressing Unwanted Behavior: Sometimes you want or even need to suppress the behavior of certain constructors, methods or static initializers in order to unit test your own code for detail:please refer to the uri: https://github.com/powermock/powermock/wiki/Suppress-Unwanted-Behavior (5)Test Listeners: Test listeners can be used to get events from the test framework such as when a test method starts and ends and the result of a test execution. Use the @RunWith(PowerMockRunner.class) annotation at the class-level of the test case. Use the @PowerMockListener({Listener1.class, Listener2.class}) annotation at the class-level of the test case. (6)Mocking system classes please see : https://github.com/powermock/powermock/wiki/Mock-System (7)Using PowerMock with Mockito https://github.com/powermock/powermock/wiki/Mockito 3.使用 (1)mock静态方法 @RunWith(PowerMockRunner.class) public class PowerMockitoStaticMethodTest { @Test @PrepareForTest({Banana.class}) public void testStaticMethod() { PowerMockito.mockStatic(Banana.class); // 首先使用PowerMock必须加注解@PrepareForTest和@RunWith(PowerMockRunner.class)。注解@PrepareForTest里写的是静态方法所在的类。 如果我们要更改类的私有static常量，比如修改Banana中的COLOR。 @Test @PrepareForTest({Banana.class}) public void testChangeColor() { Whitebox.setInternalState(Banana.class, \"COLOR\", \"红色的\"); Assert.assertEquals(\"红色的\", Banana.getColor()); } (2)mock私有方法 @RunWith(PowerMockRunner.class) public class PowerMockitoPrivateMethodTest { @Test @PrepareForTest({Banana.class}) public void testPrivateMethod() throws Exception { Banana mBanana = PowerMockito.mock(Banana.class); PowerMockito.when(mBanana.getBananaInfo()).thenCallRealMethod(); PowerMockito.when(mBanana, \"flavor\").thenReturn(\"苦苦的\"); Assert.assertEquals(\"苦苦的黄色的\", mBanana.getBananaInfo()); //验证flavor是否调用了一次 PowerMockito.verifyPrivate(mBanana).invoke(\"flavor\"); } } 我们通过mock私有方法flavor，使得之前的“甜甜的”变为了“苦苦的”。当然我们也可以跳过私有方法，代码如下： @Test @PrepareForTest({Banana.class}) public void skipPrivateMethod() { Banana mBanana = new Banana(); //跳过flavor方法 PowerMockito.suppress(PowerMockito.method(Banana.class, \"flavor\")); Assert.assertEquals(\"null黄色的\", mBanana.getBananaInfo()); } 因为跳过了flavor方法，最终输出结果为“null黄色的”。 如果我们要更改更改父类私有变量，比如修改Fruit中的fruit。 @Test @PrepareForTest({Banana.class}) public void testChangeParentPrivate() throws Exception { Banana mBanana = new Banana(); MemberModifier.field(Banana.class, \"fruit\").set(mBanana, \"蔬菜\"); Assert.assertEquals(\"蔬菜\", mBanana.getFruit()); } 上面的方法不成功，另一种方法： musicSearchWorker.setCommand(new JSONObject(COMMAND_SONG)); Whitebox.invokeMethod(musicSearchWorker, \"parseCommand\"); (3)mock final 方法 @RunWith(PowerMockRunner.class) public class PowerMockitoFinalMethodTest { @Test @PrepareForTest({Banana.class}) public void testFinalMethod() throws Exception { Banana mBanana = PowerMockito.mock(Banana.class); PowerMockito.when(mBanana.isLike()).thenReturn(false); Assert.assertFalse(mBanana.isLike()); } } 使用方法和使用mockito一样，但是我们通过PowerMock，成功修改了isLike方法的返回值。 (4)mock构造方法 @Test @PrepareForTest({Banana.class}) public void testNewClass() throws Exception { Banana mBanana = PowerMockito.mock(Banana.class); PowerMockito.when(mBanana.getBananaInfo()).thenReturn(\"大香蕉\"); //如果new新对象，则返回这个上面设置的这个对象 PowerMockito.whenNew(Banana.class).withNoArguments().thenReturn(mBanana); //new新的对象 Banana newBanana = new Banana(); Assert.assertEquals(\"大香蕉\", newBanana.getBananaInfo()); } whenNew 方法的意思是之后 new 这个对象时，返回某个被 Mock 的对象而不是让真的 new 新的对象。如果构造方法有参数，可以在withNoArguments方法中传入。 (5)其他 上面我们有说到使用PowerMock就必须加@RunWith(PowerMockRunner.class)，但是我们毕竟有时会使用多个测试框架，可能@RunWith会占用。这时我们可以使用@Rule。代码如下： @Rule public PowerMockRule rule = new PowerMockRule(); 记住使用这种方法需要加入依赖： testCompile \"org.powermock:powermock-module-junit4-rule:1.7.3\" testCompile \"org.powermock:powermock-classloading-xstream:1.7.3\" @PowerMockIgnore用于忽略mock的类，常见的写法是： @PowerMockIgnore({ \"org.mockito.*\", \"org.robolectric.*\", \"android.*\" }) 忽略android的相关类，因为我们使用Robolectric处理了。 忽略Mockito和Robolectric的相关类，因为我们不应该mock它们自己。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/本地UT/Robolectric.html":{"url":"04_Android/代码测试/本地UT/Robolectric.html","title":"Robolectric","keywords":"","body":"介绍 实现了一套JVM能运行的Android SDK，从而能够脱离Android环境进行测试 wiki： http://robolectric.org/ 依赖库 dependencies{ testImplementation 'androidx.text:core:1.2.0' testImplementation 'org.robolectric:robolectric:4.3.1' } 配置 方法 robolectric.properties 包级的配置 @Config 类级、方法级的配置（运行时） 优先级： @Config会覆盖robolectric.properties中的配置 方法级的配置会覆盖类级的配置 robolectric.properties File: To configure all Robolectric tests within a package or group of packages, create a file named robolectric.properties in the appropriate package. location:src/test/resources example: # src/test/resources/com/mycompany/app/robolectric.properties sdk=18 shadows=my.package.ShadowFoo,my.package.ShadowBar Build System Integration: Starting with Robolectric 3.3, the test runner will look for a file named /com/android/tools/test_config.properties on the classpath. If it is found, it will be used to provide the default manifest, resource, and asset locations for tests, without the need to specify @Config(constants=BuildConfig.class) or @Config(manifest=\"...\", res=\"...\", assets=\"...\") in your tests. Keys in the file: android_merged_manifest: Full path to the project’s merged AndroidManifest.xml file. android_merged_resources: Full path to the project’s merged resources. android_merged_assets: Full path to the project’s merged assets. android_custom_package: Java packagename for the applications R class. androidresource_apk: Path to a resources.ap file that contains binary resources and XML files produced by aapt tool, as well as merged assets. @Config配置 可以通过@Config注解来配置Robolectric运行时的行为。这个注解可以用来注释类和方法，如果类和方法同时使用了@Config，那么方法的设置会覆盖类的设置。如果你有很多测试类都采用同样的配置，那么你可以创建一个基类，通过@Config注解配置该基类，那么其他子类都能共享该配置。 配置 Constants 使用@RunWith(RobolectricTestRunner.class)时，必须要指定@Config(constants = BuildConfig.class)，这样它会从build/intermediates/目录下找到manifest、assets、resource等目录并加载相应的资源。 @Config(constants = BuildConfig.class) 配置 SDK 级别 By default, Robolectric will run your code against the targetSdkVersion specified in your manifest. If you want to test your code under a different SDK, you can specify the SDK using the sdk, minSdk and maxSdk config properties. @Config(sdk = 23) 配置 Application Robolectric will attempt to create an instance of your Application class as specified in the manifest. If you want to provide a custom implementation, you can specify it by setting: @Config(application = BaseApplication.class) 配置 resource、assets、manifest路径 前面介绍配置constants属性时，Robolectric会自动加载build/intermediates目录下的资源文件，可以使用以下配置使Robolectric加载特定的资源文件。 @Config(assetDir = \"some/build/path/assert\", resourceDir = \"some/build/path/resourceDir\", manifest = \"some/build/path/AndroidManifest.xml) 这里的路径很容易令人迷惑，必须要说明几点： 如果使用了@Config(constants = BuildConfig.class)，资源文件的路径会固定为build目录。避免constants配置与自定义manifest配置一起使用，否则后者配置会不生效。 manifest设置的目录base于Unit Test Config里面的”Working Directory” resourceDir、assetDir的目录base于manifest的父目录。 @Config(manifest = \"src/test/AndroidManifest.xml\", assetDir = \"assetDir\") @Test public void testConfigAssetDir() { Application app = RuntimeEnvironment.application; try { InputStream inputStream = app.getAssets().open(\"test.txt\"); int length = inputStream.available(); byte[] buffer = new byte[length]; inputStream.read(buffer); inputStream.close(); String txt = new String(buffer); System.out.println(txt); inputStream.close(); } catch (IOException e){ e.printStackTrace(); } } 自定义manifest目录示意图 该例子配置了一个指定的AndroidManifest.xml文件以及assets文件目录，测试程序读取assets里test.txt文件内容并打印出来。manifest的相对路径就是“UnitTest”工程里的“app”模块所在的文件路径，assetDir的相对路径就是AndroidManifest.xml文件的父目录路径。 配置 限定符 下面的没懂 You can explicitly configure the set of resource qualifiers in effect for a test; @Test @Config(qualifiers = \"fr-rFR-w360dp-h640dp-xhdpi\") 限定符表： Property Calculated value (if unspecified) Default Other rules MCC and MNC None. None Language, region, and script (locale) None. en-rUS Layout direction The locale’s layout direction. ldltr Smallest width The smaller of width and height sw320dp Width If screen size is specified, the corresponding width as declared here. w320dp If screen orientation is specified, width and height will be swapped as appropriate. Height If screen size is specified, the corresponding height as declared here. If screen aspect is specified as long, the height is increased by 25%. h470dp If screen orientation is specified, width and height will be swapped as appropriate. Screen size If height and width are specified, the corresponding screen size as declared here. normal Screen aspect If width and height are specified, long will be used if the ratio of height to width is at least 1.75. notlong Round screen If UI mode is watch then round. notround Wide color gamut None. nowidecg High dynamic range None. lowdr Screen orientation If width and height are specified, port or land as appropriate. port UI mode None. normal, except this property isn’t included in the qualifier list. Night mode None. notnight Screen pixel density None. mdpi Touchscreen type None. finger Keyboard availability None. keyssoft Primary text input method None. nokeys Navigation key availability None. navhidden Primary non-touch navigation method None. nonav Platform version The SDK level currently active. Need not be specified. 使用 例子 //通过注解设置测试类的TestRunner @RunWith(RobolectricTestRunner.class) @Config(constants = BuildConfig.class) public class MainActivityTest { @Test public void testClickBtnShouldStartSampleActivity() { MainActivity mainActivity = Robolectric.setupActivity(MainActivity.class); mainActivity.findViewById(R.id.btn_main).performClick(); Intent expectedIntent = new Intent(mainActivity, RobolectricSampleActivity.class); Intent actualIntent = shadowOf(mainActivity).getNextStartedActivity(); Assert.assertEquals(expectedIntent.getComponent(), actualIntent.getComponent()); } } Activity 生命周期 在各个生命周期回调中修改Button的文本内容 public class MainActivity extends Activity { Button mBtn; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mBtn = (Button) findViewById(R.id.btn_main); mBtn.setText(\"onCreate\"); mBtn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this, RobolectricSampleActivity.class); startActivity(intent); } }); } @Override protected void onStart() { super.onStart(); mBtn.setText(\"onStart\"); } @Override protected void onResume() { super.onResume(); mBtn.setText(\"onResume\"); } @Override protected void onPause() { super.onPause(); mBtn.setText(\"onPause\"); } @Override protected void onStop() { super.onStop(); mBtn.setText(\"onStop\"); } @Override protected void onDestroy() { super.onDestroy(); mBtn.setText(\"onDestroy\"); } } 测试代码如下： @Test public void testActivityLifeCycle() { ActivityController controller = Robolectric.buildActivity(MainActivity.class); //会调用Activity的onCreate()方法 controller.create(); Button btn = (Button) controller.get().findViewById(R.id.btn_main); System.out.println(btn.getText().toString()); controller.start(); System.out.println(btn.getText().toString()); controller.resume(); System.out.println(btn.getText().toString()); controller.pause(); System.out.println(btn.getText().toString()); controller.stop(); System.out.println(btn.getText().toString()); controller.destroy(); System.out.println(btn.getText().toString()); } 控制台打印结果如下所示： onCreate onStart onResume onPause onStop onDestroy setupActivity()与buildActivity() 前面的示例中看到有2种创建Activity的方式： //直接创建一个Activity，创建后的Activity会经历onCreate()->onStart()-onResume()这几个生命周期 MainActivity mainActivity = Robolectric.setupActivity(MainActivity.class); //创建一个ActivityController，然后需要自己手动控制Activity的生命周期 ActivityController controller = Robolectric.buildActivity(MainActivity.class); 这2种方式有什么差别呢，查看setupActivity()的源码可以看到： //实际上是调用了buildActivity()来创建Activity public static T setupActivity(Class activityClass) { return buildActivity(activityClass).setup().get(); } //这里手动控制了Activity的生命周期create()->start()->resume() public ActivityController setup() { return create().start().postCreate(null).resume().visible(); } Toast //点击button弹出toast信息 mBtn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Toast.makeText(MainActivity.this, \"toast sample\", Toast.LENGTH_SHORT).show(); } }); @Test public void testToast() { MainActivity activity = Robolectric.setupActivity(MainActivity.class); Button btn = (Button) activity.findViewById(R.id.btn_main); btn.performClick(); Assert.assertNotNull(ShadowToast.getLatestToast()); Assert.assertEquals(\"toast sample\", ShadowToast.getTextOfLatestToast()); } Dialog @Test public void testDialog() { MainActivity activity = Robolectric.setupActivity(MainActivity.class); Button btn = (Button) activity.findViewById(R.id.btn_main); btn.performClick(); Assert.assertNotNull(ShadowAlertDialog.getLatestAlertDialog()); } 资源文件 @Test public void testApplication() { Application app = RuntimeEnvironment.application; Context shadow = ShadowApplication.getInstance().getApplicationContext(); Assert.assertSame(shadow, app); System.out.println(shadow.getResources().getString(R.string.app_name)); } Fragment @Test public void testFragment() { TestFragment fragment = new TestFragment(); //该方法会添加Fragment到Activity中 SupportFragmentTestUtil.startFragment(fragment); Assert.assertThat(fragment.getView(), CoreMatchers.notNullValue()); } 日志输出 使用ShadowLog Shadow 顾名思义就是影子类，Robolectric定义了很多shadow class，用来修改或者扩展Android OS中类的行为。当一个Android中的类被实例化时，Robolectric会去寻找对应的影子类，如果找到了则会创建一个影子对象并与之相关联。每当Android类中的一个方法被调用时，Robolectric会保证其影子类中相应的方法会被先调用。这对所有的方法都适用，包括static和final类型的方法。 Shadows.shadowOf(...); 通过该方法几乎可以获取大部分Android类的shadow class，例如： @Test public void testShadow() { MainActivity activity = Robolectric.setupActivity(MainActivity.class); Button btn = (Button) activity.findViewById(R.id.btn_main); ShadowActivity shadowActivity = Shadows.shadowOf(activity); ShadowTextView shadowTextView = Shadows.shadowOf(btn); } Shadow Classes public class Company { public void welcome() { System.out.println(\"method called in Company.\"); } public void sayHello() { System.out.println(\"say hello in Company.\"); } } //通过@Implements注解来声明shadow类 @Implements(Company.class) public class ShadowCompany { //通过@Implementation注解来标记shadow方法，此方法声明必须与原Company中的方法声明一致 @Implementation public void welcome() { System.out.println(\"method called in ShadowCompany.\"); } } Shadows.shadowOf()方法不能作用于自定义shadow class，为了使Robolectric能够识别自定义shadow类，需要采用@Config注解，如下所示： //通过shadows配置自定义的shadow class @Config(shadows = {ShadowCompany.class}) @Test public void testShadow() { Company company = new Company(); company.welcome(); company.sayHello(); } 执行该测试方法，控制台打印结果如下： method called in ShadowCompany. say hello in Company. 从以上控制台打印结果中可以看到，welcome()方法实际执行的是ShadowCompany中的方法。 Shadowing Constructors 如果需要对构造函数进行shadow，必须实现constructor方法，并且该方法的参数必须与构造函数的参数一样。我们稍微修改前面的Company类以及ShadowCompany类，对其构造函数进行shadow。 public class Company { private String name; //构造函数有一个参数name public Company(String name) { this.name = name; System.out.println(\"company constructor\"); } public void welcome() { System.out.println(\"method called in Company.\"); } public void sayHello() { System.out.println(\"say hello in Company.\"); } } @Implements(Company.class) public class ShadowCompany { //必须实现该方法，参数与构造函数参数一样 public void __constructor__(String name) { System.out.println(\"constructor in shadow class.\"); } @Implementation public void welcome() { System.out.println(\"method called in ShadowCompany.\"); } } 这个时候再执行测试代码，返回结果如下，可以看到Company的构造函数并没有执行。 constructor in shadow class. method called in ShadowCompany. say hello in Company. Getting access to the real instance 有时shadow类需要使用它们关联的真实对象，可以通过@RealObject注解声明一个属性来实现。 @Implements(Company.class) public class ShadowCompany { //Robolectric会自动设置真实的关联对象 @RealObject private Company company; @Implementation public void welcome() { System.out.println(\"method called in ShadowCompany.\" + company.getName()); } } 自定义shadow要点 @Implements注解指定需要对哪个类进行shadow； @Implementation指定需要对哪个方法进行替换； 使用constructor来对构造器进行替换； @RealObject来引用真实的关联对象； Robolectric的参数化测试 前面介绍JUnit4的时候讲到，JUnit4中有个叫Parameterized的test runner，能够实现参数化测试，同样Robolectric也提供了同样的功能。 @RunWith(ParameterizedRobolectricTestRunner.class) @Config(constants = BuildConfig.class, sdk = 23) public class ParameterizedTest { @ParameterizedRobolectricTestRunner.Parameters public static List data() { return Arrays.asList(new Integer[][] { {1, 1}, {2, 2}, {3, 3}, {4, 4} }); } private int i; private int j; public ParameterizedTest(int i, int j) { this.i = i; this.j = j; } @Test public void testParameter() { System.out.println(\"parameter is \" + i + \", \" + j); } } 运行结果如下： parameter is 1, 1 parameter is 2, 2 parameter is 3, 3 parameter is 4, 4 内容更新 1.Robolectric配置 首先升级Robolectric的依赖至最新： testImplementation \"org.robolectric:robolectric:4.3.1\" 在根目录的gradle.properties文件中添加： android.enableUnitTestBinaryResources=true 之前的配置中，需要通过@Config注解指定constants = BuildConfig.class，也可指定sdk的版本信息： @RunWith(RobolectricTestRunner.class) @Config(constants = BuildConfig.class, sdk = 23) public class MainActivityTest { } 在4.0开始的版本中，默认不需要指定constants = BuildConfig.class，constants配置也被移除，所以默认可以去除@Config的这行固定配置。 如果要指定sdk版本的话，可以在src/test/resources目录下创建一个名为robolectric.properties的文件在你所要生效的包名下。其中更深的包中的值覆盖更浅的包中的值。当测试类或方法有@Config注释，这些注释覆盖属性文件中的任何配置。具体如下图所示： 这样相比之前的方式确实友好很多。详细配置及其他用法可以参看官方文档。 2.Robolecture与AndroidX 随着AndroidX的到来，Android官方也提供了相应的测试框架。 testImplementation 'androidx.test:core:1.2.0' testImplementation 'androidx.fragment:fragment-testing:1.1.0' // AndroidJUnitRunner and JUnit Rules testImplementation 'androidx.test:runner:1.2.0' testImplementation 'androidx.test:rules:1.2.0' // Assertions testImplementation 'androidx.test.ext:junit:1.1.1' testImplementation 'androidx.test.ext:truth:1.2.0' testImplementation 'com.google.truth:truth:1.0' Robolectric在4.0开始也支持了官方测试库，并推荐使用它们。 变更有以下几个方面： 使用AndroidJUnit4代替RobolectricTestRunner: // 之前 @RunWith(RobolectricTestRunner.class) public class MainActivityTest { } // 现在 @RunWith(AndroidJUnit4.class) public class MainActivityTest { } 之前使用RuntimeEnvironment.application可以获取到Application，现在推荐使用getApplicationContext方法获取。 import androidx.test.core.app.ApplicationProvider.getApplicationContext @Test public void testResources() { Application application = getApplicationContext(); String appName = application.getString(R.string.app_name); assertEquals(\"AndroidUT\", appName); } 获取Activity方式调整。之前的方式是直接通过setupActivity或者buildActivity方法获取： MainActivity activity = Robolectric.setupActivity(MainActivity.class); // 或者 ActivityController controller = Robolectric.buildActivity(MainActivity.class); MainActivity activity = controller.get(); 现在： @RunWith(AndroidJUnit4.class) public class MainActivityTest { @Rule public ActivityTestRule activityRule = new ActivityTestRule<>(MainActivity.class); private MainActivity mainActivity; @Before public void setUp(){ mainActivity = activityRule.getActivity(); // 或者 ActivityScenario scenario = ActivityScenario.launch(MainActivity.class); scenario.moveToState(Lifecycle.State.CREATED); scenario.onActivity(activity -> { mainActivity = activity; }); } } Fragment 获取方式大同小异，不过要注意添加testImplementation 'androidx.fragment:fragment-testing:1.1.0'依赖。 @Test public void testFragment() { FragmentScenario scenario = FragmentScenario.launch(SampleFragment.class); scenario.onFragment(fragment -> assertNotNull(fragment.getView())); } 对于官方测试库的详细使用可以查看Android的官方文档 3.AssertJ-Android 之前有提到AssertJ-Android这个库，它是AssertJ的拓展，便于我们断言Android View。 由于AndroidX的到来，这个库也就不太适用于未来。官方也觉得他并不是一个好的方式，所以暂停了维护。推荐我们使用Google的truth。并且truth这个库也内置在官方的测试框架里面。它和AssertJ很相似，有兴趣的可以了解一下。 这里我暂时没有使用truth，只是用 AssertJ的方式替换了 AssertJ-Android。仅仅是个人习惯问题。 之前的方式： import static org.assertj.android.api.Assertions.assertThat; @Test public void testView() { // Button是否可见 assertThat(mJumpBtn).isVisible(); // LinearLayout 方向，子View数量 assertThat(mRoot) .isVertical() .hasChildCount(4); // CheckBox是否未选中 assertThat(checkBox).isNotChecked(); } } 修改后： import static org.assertj.core.api.Assertions.assertThat; @Test public void testView() { // AssertJ-Android (已不在维护)，这里就是用普通方法实现 // Button是否可见 assertThat(mJumpBtn.getVisibility()).isEqualTo(View.VISIBLE); // LinearLayout 方向，子View数量 assertThat(mRoot.getOrientation()).isEqualTo(LinearLayout.VERTICAL); assertThat(mRoot.getChildCount()).isEqualTo(4); // CheckBox是否未选中 assertThat(checkBox.isChecked()).isEqualTo(false); } 4.当前依赖版本 以下是当前项目所用到的测试框架的依赖版本： //junit testImplementation 'junit:junit:4.12' //mockito testImplementation \"org.mockito:mockito-core:3.1.0\" //powermock testImplementation \"org.powermock:powermock-module-junit4:2.0.2\" testImplementation \"org.powermock:powermock-module-junit4-rule:2.0.2\" testImplementation \"org.powermock:powermock-api-mockito2:2.0.2\" testImplementation \"org.powermock:powermock-classloading-xstream:2.0.2\" //robolectric testImplementation \"org.robolectric:robolectric:4.3.1\" //AssertJ testImplementation 'org.assertj:assertj-core:3.13.2' // AndroidX所需 testImplementation 'androidx.test:core:1.2.0' testImplementation 'androidx.fragment:fragment-testing:1.1.0' // AndroidJUnitRunner and JUnit Rules testImplementation 'androidx.test:runner:1.2.0' testImplementation 'androidx.test:rules:1.2.0' // Assertions testImplementation 'androidx.test.ext:junit:1.1.1' testImplementation 'androidx.test.ext:truth:1.2.0' testImplementation 'com.google.truth:truth:1.0' 最后我将修改后的代码也已经同步到了Github上，master分支是使用support 28.0依赖库的，androidx部分的改动放在了androidx分支上，便于大家查阅。 内容暂时就这么多。后面如果新的改动，我也会更新在这篇博客当中。 2020.01.16更新： 更新gradle至3.x以后，原本的存放class文件目录发生了改变。所以使用jacoco时，需要修改指定的类文件夹(检查的覆盖类)地址： /intermediates/classes/debug 修改为： /intermediates/javac/debug/compileDebugJavaWithJavac/classes 其他 Robolectric的局限性 不支持JNI调用。凡是涉及到JNI调用的方法，都不能使用Robolectric来进行单元测试。对于复杂的应用，或多或少都会有JNI调用，可行的方案是设置一个全局变量来控制是否加载so库。 Test Runner config(Robolectric + PowerMock) framework corresponding test runner rule Mock MockitoJUnitRunner MockitoJUnit.rule() PowerMock PowerMockRunner PowerMockRule Robolectric RobolectricTestRunner -- RunWith can only have one item, we can use AndroidJUnit4 to delegate RobolectricTestRunner and add rule PowerMockRule to implement Robolectric + PowerMock Espresso & Robolectric Espresso不适用于本地单元测试（Local Unit Test）。Espresso是一个用于编写UI自动化测试的框架，它旨在模拟用户与应用程序交互的行为。它需要一个运行的设备或模拟器，并且与实际的应用程序进行交互。 Since Robolectric 4.0, Espresso APIs are now supported in Robolectric tests. the Espresso detail:please refer to https://developer.android.google.cn/training/testing/espresso?hl=en simple usages in robolectric test: @RunWith(AndroidJUnit4::class) class FragmentTest{ @Test fun testEventFragment(){ val fragmentArgs = Bundle() val factory = MyFragmentFactory() val scenario = launchFragmentInContainer(fragmentArgs,factory) onView(withId(R.id.text)).check(matches(withText(\"Hello World\"))) } } No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/本地UT/RulesOfUnitTests.html":{"url":"04_Android/代码测试/本地UT/RulesOfUnitTests.html","title":"Rulesofunittests","keywords":"","body":"1. Test One Thing at a Time in Isolation 每个Test case 只测试一种情况，只应该依赖于Mocks和Stubs，不应该依赖于其他测试的结果甚至网络。 2. Follow the AAA Rule: Arrange, Act, Assert Arrange: Set variables, fields, and properties to enable the test to be run, as well as define the expected result. Act: Call the method that you are testing. Assert: Call the testing framework to verify that the result of your “Act” is what was expected. 3. Write Simple “Fastball-Down-the-Middle” Tests First 首先设计最简单的TestCase，可以清晰地体现程序的功能和结构的，然后才开始测试程序的边界与异常 4. Test Across Boundaries 设计一些跨越边界的Case，比如在对日期或时间的程序进行测试时，设计时间跳转的Case。设计一些可能使你的程序Fail或者表现异常的Case 5. If You Can, Test the Entire Spectrum 如果可能的话，测试程序功能中所有的可能性。 6. If Possible, Cover Every Code Path 如果可能的话，覆盖每一条程序语句/分支，最好能使用UT覆盖率工具检查查看 7. Write Tests That Reveal a Bug, Then Fix It 如果在编写测试中发现了Bug，那么就修复这个Bug，同时这个测试能够成为一个更好的回归（Regression）测试Case，以便之后快速定位这个Bug 8. Make Each Test Independent 合理地运用SetUp和TearDown，确保每个TestCase都可以独立地运行 9. Name Your Tests Clearly and Don’t Be Afraid of Long Names 为每条测试Case起明确清晰的名字，不要担心过长的名字。 名字可以参考：TestDivisionWhenNumPositiveDenomNegative、DivisionByZeroShouldThrowException 10. Test That Every Raised Exception Is Raised 编写测试确保你的代码引发的每个异常确实在适当的情况下被引发。 11. Avoid the Use of Assert.IsTrue 不要这样写-->Assert.IsTrue(Expected = Actual); 改成这样-->Assert.AreEqual(Expected, Actual) 12. Constantly Run Your Tests 一边编写新代码，一边跑测试Case 13. Run Your Tests as Part of Every Automated Build 将UT Case包含在自动化集成中，如果test fail，应该立即修复 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/本地UT/ut-问题解决.html":{"url":"04_Android/代码测试/本地UT/ut-问题解决.html","title":"Ut-问题解决","keywords":"","body":"【如何获得静态内部类中定义的变量值】 // 先拿到静态内部类 Class screenParaClass = Class.forName(\"com.sony.dtv.search.commandprocessor.MediaControlWorker$ScreenPara\"); // 然后用Whitebox.getInternalState获得静态内部类的成员值 assertEquals(Whitebox.getInternalState(screenParaClass, \"ACTION_SCREEN\"), action); No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/概念/Android本地测试.html":{"url":"04_Android/代码测试/概念/Android本地测试.html","title":"Android本地测试","keywords":"","body":"框架选择 如果您的测试对 Android 框架有依赖性（特别是与框架建立复杂互动的测试），最好使用 Robolectric 添加框架依赖项。 如果您的测试对 Android 框架的依赖性极小，或者如果测试仅取决于您自己的对象，可以使用诸如 Mockito 之类的模拟框架添加模拟依赖项。 设置测试环境 本地单元测试的源文件存储在 module-name/src/test/java/ 中。当您创建新项目时，此目录已存在。 您还需要为项目配置测试依赖项，以使用 JUnit 4 框架提供的标准 API。如果您的测试需要与 Android 依赖项互动，请添加 Robolectric 或 Mockito 库以简化您的本地单元测试。 导入依赖项： dependencies { // Required -- JUnit 4 framework testImplementation 'junit:junit:4.13.2' // Optional -- Robolectric environment testImplementation 'androidx.text:core:1.2.0' testImplementation 'org.robolectric:robolectric:4.3.1' // Optional -- Mockito framework testImplementation 'org.mockito:mockito-core:2.28.2' // Optional -- PowerMock framework testImplementation 'org.powermock:powermock-module-junit4:2.0.5' testImplementation 'org.powermock:powermock-module-junit4-rule:2.0.5' testImplementation 'org.powermock:powermock-api-mockito2:2.0.5' testImplementation 'org.powermock:powermock-clasloading-xstream:2.0.5' // Optional -- AndroidJUnitRunner testImplementation 'androidx.test:runner:1.2.0' // Optional -- some rules for example ActivityTestRule testImplementation 'androidx.test:rules:1.2.0' // Optional -- ext class for junit testImplementation 'androidx.test.ext:junit:1.1.1' testImplementation 'androidx.test.ext:truth:1.2.0' // Optional google test assertions framework testImplementation 'com.google.truth:truth:0.42' // Optional espresso:ui test framework testImplementation 'androidx.test.espresso:espresso-core:3.2.0' } 在build.gradle增加测试选项 android { ... testOptions { unitTests.includeAndroidResources = true } } 规则 TestName: makes the current test name available inside test methods. ActivityScenarioRule: 在测试开始前启动Activity，测试结束后关闭Activity PowerMockRule：apply power mock method proxy Mock与Stub Stub，也即“桩”，即某个程序模块还未准备好时，编写的向外呈现模块主要特性的替代。 Mock，模拟对象的各种性质，返回值等的一个虚假的对象。 stub对象可以用来替代某些东西：比如外部的设备，需要交互的服务，尤其是这些可以替代的东西还未准备就绪，这个时候可以通过stub来模拟它们的存在，使得开发不被阻塞住。换句话说，stub是架构设计中的一个组件，用来隔离一些未就绪的东西（但同时这些未就绪的东西也可能是系统的一个变化点） 而mock对象的使用场景被限制在单元测试里，由于被测模块很可能还需要访问数据库，访问远程接口，或者调用其他模块的方法，很难满足被测对象的接口需求（或者精确的控制被测对象的行为）这个时候可以通过mock对象来模拟被测模块所依赖的一切东西，包括Stub。 是的，你没看错，mock可以用来模拟Stub。因为Stub不会写的太复杂，一般来说只能反映被替代对象的主要特性，这个时候可以在单元测试里构造mock对象所有可能的返回值，从而驱动被测模块控制流的走向，提高单元测试的语句覆盖率。 FAQ 1.How to write a ui test: please refer to the espresso and robolectric https://developer.android.google.cn/training/testing/espresso?hl=en http://robolectric.org/androidx_test/ 2.How to get application object AlbumApplication albumApp= ApplicationProvider.getApplicationContext(); //launch a fragment in a empty activity FragmentScenario.launchInContainer(AbstractAlbumFragmentSubClass.class, null, ​ R.style.Theme_AlbumLeanback, myFragmentFactory); 3.How to launch a activity @Rule public ActivityScenarioRule hostActivityActivityScenarioRule = new ActivityScenarioRule<>(BrowseHostFragmentTest.HostActivity.class); 4.How to declare a test only activity in a library module add a Manifest file in module /src/test folder refer to the right 5.How to declare a test only activity in a application module solution1://robolectric issue workaround In order to use test-only activities, you can create a test support gradle project which contains the test activity and declares it in its manifest, then add a testImplementation dependency to that project. For detail please refer to https://github.com/robolectric/robolectric/pull/4736 solution2://add the test activity into debug apk you can create a test support library which contain the test activity and declares it in its manifest and add it as debugImplementation dependency to the app module for example, the following test code will lanch a EmptyFragmentActivity which is a test only activity. mScenario = FragmentScenario.launchInContainer(HeaderMenuFragment.class); You should use the following dependence in build.gradle debugImplementation 'androidx.fragment:fragment-testing:1.2.3' If you change debugImplementation into testImplementation, it will report the following error: java.lang.RuntimeException: Unable to resolve activity for Intent { act=android.intent. action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.sony.dtv. smartmediaapp/androidx.fragment.app.testing.FragmentScenario$EmptyFragmentActivity (has extras) } -- see https://github.com/robolectric/robolectric/pull/4736 for details 6.How to enable log in robolectric test? ShadowLog.stream = System.out; Issues when run robolectric tests on Android API 29 now strictly requires a Java9 runtime or newer. If you are seeing errors about unsupported Java version when running tests on API 29 via Android Studio; you can use the 'JRE' field in the Run Configuration dialog to configure a newer Java runtime. See https://developer.android.com/studio/run/rundebugconfig for more background. But we didn't know how to use java 8 to compile java code and use java 9 to run the unit test in gradle task'coverageInstrumentedTestsReport'. So We current disable the tests these require api 29. No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/概念/Android测试基本概念.html":{"url":"04_Android/代码测试/概念/Android测试基本概念.html","title":"Android测试基本概念","keywords":"","body":"代码测试 分类 按是否查看程序内部结构分为 黑盒测试（black-box testing）：只关心输入和输出的结果，黑盒测试分为功能测试和性能测试 白盒测试（white-box testing）：去研究里面的源代码和程序结构 按是否运行程序分为：静态测试、动态测试 静态测试（static testing）：是指不实际运行被测软件，而只是静态地检查程序代码、界面或文档可能存在的错误的过程。包括： 对于代码测试，主要是测试代码是否符合相应的标准和规范。 对于界面测试，主要测试软件的实际界面与需求中的说明是否相符。 对于文档测试，主要测试用户手册和需求说明是否真正符合用户的实际需求。 动态测试（dynamic testing）：是指实际运行被测程序，输入相应的测试数据，检查输出结果和预期结果是否相符的过程 按阶段划分： 单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。 桩模块（stud）是指模拟被测模块所调用的模块，驱动模块（driver）是指模拟被测模块的上级模块，驱动模块用来接收测试数据，启动被测模块并输出结果。 集成测试（integration testing），是单元测试的下一阶段，是指将通过测试的单元模块组装成系统或子系统，再进行测试，重点测试不同模块的接口部门。 集成测试就是用来检查各个单元模块结合到一起能否协同配合，正常运行。 系统测试（system testing），指的是将整个软件系统看做一个整体进行测试，包括对功能、性能，以及软件所运行的软硬件环境进行测试。 系统测试的主要依据是《系统需求规格说明书》文档 验收测试（acceptance testing），指的是在系统测试的后期，以用户测试为主，或有测试人员等质量保障人员共同参与的测试，它也是软件正式交给用户使用的最后一道工序 验收测试又分为a测试和beta测试，其中a测试指的是由用户、 测试人员、开发人员等共同参与的内部测试，而beta测试指的是内测后的公测，即完全交给最终用户测试、 单元测试 单元测试 是针对 程序的最小单元 来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。一个单元可能是单个程序、类、对象、方法等。 单元测试的分类： 本地测试(Local tests): 只在本地机器JVM上运行，以最小化执行时间，这种单元测试不依赖于Android框架，或者即使有依赖，也很方便使用模拟框架来模拟依赖，以达到隔离Android依赖的目的，模拟框架如google推荐的Mockito 仪器化测试(Instrumented tests): 在真机或模拟器上运行的单元测试，由于需要跑到设备上，比较慢，这些测试可以访问仪器（Android系统）信息，比如被测应用程序的上下文，一般地，依赖不太方便通过模拟框架模拟时采用这种方式 单元测试的测试内容： 列出想要测试覆盖的正常、异常情况，进行测试验证 性能测试，例如某个算法的耗时等等 注意： 这里提一句，测试用例用来达到也想要的结果，但对于逻辑错误无能为力 两种错误：断言方法报错，逻辑代码问题 为什么要使用单元测试： 减少bug 快速定位bug、减少调试时间 提高代码质量 放心重构 Android中的测试： 单元测试（Junit4、Mockito、PowerMockito、Robolectric） UI测试（Espresso、UI Automator） 压力测试（Monkey） 使用单元测试的时候注意进行依赖隔离 Android中的单元测试框架有很多，Junit，Mockito，Robolectric，PowerMockito No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/代码测试/踩坑记录.html":{"url":"04_Android/代码测试/踩坑记录.html","title":"踩坑记录","keywords":"","body":"踩坑记录 已解决的问题 Robolectirc4.3.1最高支持到SDK 29，但项目是31的 将Robolectric升级到4.7+ Robolectric升级到4.7+后，运行测试提示 Unsupported class file major version 59 查了一下是因为Robolectric 4.7+不支持JDK 15 ，但是项目用的是JDK 1.8 如果在gradle文件中配置不允许使用JDK15，还是继续报错 JDK改成了11，报错变为： Execution failed for task ':app:compileProdDebugUnitTestJavaWithJavac'. > Could not resolve all files for configuration ':app:prodDebugUnitTestCompileClasspath'. > Failed to transform bcprov-jdk15on-1.68.jar (org.bouncycastle:bcprov-jdk15on:1.68) to match attributes {artifactType=android-classes-jar, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-api}. > Execution failed for JetifyTransform: C:\\Users\\5109U25854\\.gradle\\caches\\modules-2\\files-2.1\\org.bouncycastle\\bcprov-jdk15on\\1.68\\46a080368d38b428d237a59458f9bc915222894d\\bcprov-jdk15on-1.68.jar. 找到相关的Issues Jetifier fails on bcprov-jdk15on-1.68.jar / Robolectric 4.6-alpha-2 #6521 https://github.com/robolectric/robolectric/issues/6521 Gradle版本改成最新的就解决了 Android Gradle Plugin Version 7.2.1 Gradle Version 7.3.3 使用Powermock调用到Method v in android.util.Log not mocked gradle里配置 android { // ... testOptions { unitTests.returnDefaultValues = true } } https://qiita.com/oxsoft/items/b12b7a6c17e92eb880cd Robolectric使用过程中无法Runtime下载某个库 下载地址：https://mvnrepository.com/artifact/org.robolectric/ 我的例子里找不到的库是org.robolectric:android-all-instrumented:12-robolectric-7732740-i4，替换成自己找不到的 .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; ERROR: Failed to fetch maven artifact org.robolectric:android-all-instrumented:12-robolectric-7732740-i4 java.util.concurrent.ExecutionException: java.net.ConnectException: Connection timed out: connect at com.google.common.util.concurrent.AbstractFuture.getDoneValue(AbstractFuture.java:588) at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:567) at com.google.common.util.concurrent.AbstractFuture$TrustedFuture.get(AbstractFuture.java:113) at org.robolectric.internal.dependency.MavenArtifactFetcher.fetchArtifact(MavenArtifactFetcher.java:121) at org.robolectric.internal.dependency.MavenDependencyResolver.lambda$getLocalArtifactUrls$0(MavenDependencyResolver.java:93) at org.robolectric.internal.dependency.MavenDependencyResolver.whileLocked(MavenDependencyResolver.java:113) at org.robolectric.internal.dependency.MavenDependencyResolver.getLocalArtifactUrls(MavenDependencyResolver.java:88) at org.robolectric.internal.dependency.MavenDependencyResolver.getLocalArtifactUrls(MavenDependencyResolver.java:78) at org.robolectric.internal.dependency.MavenDependencyResolver.getLocalArtifactUrl(MavenDependencyResolver.java:129) at org.robolectric.plugins.LegacyDependencyResolver.getLocalArtifactUrl(LegacyDependencyResolver.java:89) at org.robolectric.plugins.DefaultSdkProvider$DefaultSdk.getJarPath(DefaultSdkProvider.java:148) at org.robolectric.internal.AndroidSandbox$SdkSandboxClassLoader.(AndroidSandbox.java:128) at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490) at org.robolectric.util.inject.Injector.inject(Injector.java:250) at org.robolectric.util.inject.Injector.lambda$memoized$1(Injector.java:232) at org.robolectric.util.inject.Injector$MemoizingProvider.get(Injector.java:498) at org.robolectric.util.inject.Injector.getInstanceInternal(Injector.java:224) at org.robolectric.util.inject.Injector.resolveDependencies(Injector.java:296) at org.robolectric.util.inject.Injector.inject(Injector.java:248) unitTests.all { systemProperty 'robolectric.offline', 'true' systemProperty 'robolectric.dependency.dir',这里替换成下载到本地的库路径' } UnitTest JSONObject shows null 这个问题的解决方式： testImplementation \"org.json:json:20180813\" 相关问答： https://stackoverflow.com/questions/33595931/unittest-jsonobject-shows-null 找不到bcprov库 在gradle.properties 里面加上一条 android.jetifier.blacklist=bcprov org.mockito.exceptions.misusing.NotAMockException: Argument should be a mock, but is: class java.lang.Class 版本兼容问题，powermock的版本改成2.0.2，mockito2.25.0可以解决 https://github.com/powermock/powermock/issues/992 暂时不明的问题 Robolectric的@Config注解里少了constants属性 no native-lib in java.library.path 可能是工程需要载入.so库导致的 https://www.51cto.com/article/523303.html no native-lib in java.library.path: [F:\\.dev\\JAVA\\openjdk-11.0.0.1\\bin, C:\\Windows\\Sun\\Java\\bin, C:\\Windows\\system32, C:\\Windows, C:\\Windows\\system32, C:\\Windows, C:\\Windows\\System32\\Wbem, C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\, C:\\Windows\\System32\\OpenSSH\\, F:\\Git\\cmd, F:\\.dev\\JAVA\\openjdk-11.0.0.1\\bin, F:\\.dev\\JAVA\\openjdk-11.0.0.1\\lib, F:\\.dev\\SDK\\platform-tools, F:\\.dev\\PYTHON, C:\\Users\\5109U25854\\AppData\\Local\\Microsoft\\WindowsApps, ., F:\\Microsoft VS Code\\bin, .] java.lang.UnsatisfiedLinkError: no native-lib in java.library.path: [F:\\.dev\\JAVA\\openjdk-11.0.0.1\\bin, C:\\Windows\\Sun\\Java\\bin, C:\\Windows\\system32, C:\\Windows, C:\\Windows\\system32, C:\\Windows, C:\\Windows\\System32\\Wbem, C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\, C:\\Windows\\System32\\OpenSSH\\, F:\\Git\\cmd, F:\\.dev\\JAVA\\openjdk-11.0.0.1\\bin, F:\\.dev\\JAVA\\openjdk-11.0.0.1\\lib, F:\\.dev\\SDK\\platform-tools, F:\\.dev\\PYTHON, C:\\Users\\5109U25854\\AppData\\Local\\Microsoft\\WindowsApps, ., F:\\Microsoft VS Code\\bin, .] at java.base/java.lang.ClassLoader.loadLibrary(ClassLoader.java:2660) at java.base/java.lang.Runtime.loadLibrary0(Runtime.java:829) at java.base/java.lang.System.loadLibrary(System.java:1880) at com.sony.dtv.search.utils.TencentApiKey.(TencentApiKey.java:12) at com.sony.dtv.search.app.QsbApplicationWrapper.onCreate(QsbApplicationWrapper.java:75) at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1211) at org.robolectric.android.internal.RoboMonitoringInstrumentation.callApplicationOnCreate(RoboMonitoringInstrumentation.java:135) at org.robolectric.android.internal.AndroidTestEnvironment.lambda$installAndCreateApplication$2(AndroidTestEnvironment.java:374) at org.robolectric.util.PerfStatsCollector.measure(PerfStatsCollector.java:86) at org.robolectric.android.internal.AndroidTestEnvironment.installAndCreateApplication(AndroidTestEnvironment.java:372) at org.robolectric.android.internal.AndroidTestEnvironment.lambda$createApplicationSupplier$0(AndroidTestEnvironment.java:251) at org.robolectric.util.PerfStatsCollector.measure(PerfStatsCollector.java:53) at org.robolectric.android.internal.AndroidTestEnvironment.lambda$createApplicationSupplier$1(AndroidTestEnvironment.java:248) at com.google.common.base.Suppliers$NonSerializableMemoizingSupplier.get(Suppliers.java:183) at org.robolectric.RuntimeEnvironment.getApplication(RuntimeEnvironment.java:79) at org.robolectric.android.internal.AndroidTestEnvironment.setUpApplicationState(AndroidTestEnvironment.java:216) at org.robolectric.RobolectricTestRunner.beforeTest(RobolectricTestRunner.java:340) at org.robolectric.internal.SandboxTestRunner$2.lambda$evaluate$2(SandboxTestRunner.java:281) at org.robolectric.internal.bytecode.Sandbox.lambda$runOnMainThread$0(Sandbox.java:99) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at java.base/java.lang.Thread.run(Thread.java:834) PowerMockito.verifyStatic(ToastUtil.class,VerificationModeFactory.times(1)); 报错 Argument passed to verify() is of type Class and is not a mock! Make sure you place the parenthesis correctly! See the examples of correct verifications: verify(mock).someMethod(); verify(mock, times(10)).someMethod(); verify(mock, atLeastOnce()).someMethod(); org.mockito.exceptions.misusing.NotAMockException: Argument passed to verify() is of type Class and is not a mock! Make sure you place the parenthesis correctly! See the examples of correct verifications: verify(mock).someMethod(); verify(mock, times(10)).someMethod(); verify(mock, atLeastOnce()).someMethod(); at com.sony.dtv.search.commandprocessor.MusicSearchWorkerTest.testAssembleUri(MusicSearchWorkerTest.java:189) at app//org.junit.internal.runners.TestMethod.invoke(TestMethod.java:68) at app//org.junit.internal.runners.MethodRoadie$2.run(MethodRoadie.java:89) at app//org.junit.internal.runners.MethodRoadie.runBeforesThenTestThenAfters(MethodRoadie.java:97) at app//org.junit.internal.runners.MethodRoadie.runTest(MethodRoadie.java:87) at app//org.junit.internal.runners.MethodRoadie.run(MethodRoadie.java:50) at app//org.junit.internal.runners.ClassRoadie.runUnprotected(ClassRoadie.java:34) at app//org.junit.internal.runners.ClassRoadie.runProtected(ClassRoadie.java:44) at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.runTestClass(JUnitTestClassExecutor.java:110) at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:58) at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:38) at org.gradle.api.internal.tasks.testing.junit.AbstractJUnitTestClassProcessor.processTestClass(AbstractJUnitTestClassProcessor.java:62) at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) at org.gradle.api.internal.tasks.testing.worker.TestWorker$2.run(TestWorker.java:176) at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129) at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100) at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60) at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56) at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:133) at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:71) at app//worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69) at app//worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74) No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/Android问题.html":{"url":"04_Android/应用层/Android问题.html","title":"Android问题","keywords":"","body":"ContentProvider实现原理 介绍Binder机制 匿名共享内存，使用场景 如何自定义View，如果要实现一个转盘圆形的View，需要重写View中的哪些方法？(onLayout,onMeasure,onDraw) Socket和LocalSocket Android里跨进程传递数据的几种方案。 1.Bundle，在安卓中不同的应用运行在不同的进程中。通过Intent启动其他应用的组件Activity、Service、Receiver时，可以将数据存储在Bundle中，然后设置在Intent中。 2.系统文件，如SP。 3.ContentProvidert提供数据分享的接口：ContentResolver 4.跨进程Messenger 6.AIDL TextView怎么改变局部颜色 SpannableString、HTML Android中Handler声明非静态对象会发出警告，为什么，非得是静态的？(Memory Leak) 广播注册后不解除注册会有什么问题？(内存泄露) 属性动画(Property Animation)和补间动画(Tween Animation)的区别，为什么在3.0之后引入属性动画(官方解释：调用简单) Android里的LRU算法原理 BrocastReceive里面可不可以执行耗时操作? Service onBindService 和startService 启动的区别 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/":{"url":"04_Android/应用层/","title":"Sdk","keywords":"","body":"应用层 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/":{"url":"04_Android/应用层/SDK/","title":"2-1.应用层-基础与源码","keywords":"","body":"Sdk No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-1.应用层-基础与源码/Activity.html":{"url":"04_Android/应用层/SDK/2-1.应用层-基础与源码/Activity.html","title":"Activity","keywords":"","body":"创建 step1 创建类继承自AppCompactActivity（Tv中使用继承自Activity） step2 在manifest中注册 可以直接在类中利用快捷键进行注册 也可以在manifest文件中注册 tips activity内部有intent-filter代表主入口,可以让多个activity都有主入口的intent-filter,系统中会有两个入口指向同一个app AppCompatActivity和Activity的区别 AppCompatActivity相对于Activity的主要的两点变化； 1：主界面带有toolbar的标题栏； 2：theme主题只能用android:theme=”@style/AppTheme （appTheme主题或者其子类），而不能用android:style。 否则会提示错误： Caused by: java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity. https://blog.csdn.net/today_work/article/details/79300181 四种启动模式 设置启动模式: method1 在manifest中设置launchMode属性 method2 代码设置 CLEAR_TASK代表清除栈 CLEAR_TOP代表清除栈顶 NEW_TASK代表创建新栈 标准启动模式(standard)(默认) 每次激活Activity时都会创建Activity，并放入任务栈中。 如果启动此Activity的Intent中没有设置FLAG_ACTIVITY_NEW_TASK标志, 则这个Activity与启动他的Activity在同一个Task中。\"launchMode\"设置为\"standard\"的Activity可以被实例化多次, 可以在Task中的任何位置, 对于一个新的Intent请求就会实例化一次. 使用场景：Standard 模式是系统默认的启动模式，一般我们 app 中大部分页面都是由该模式的页面构成的，比较常见的场景是：社交应用中，点击查看用户A信息->查看用户A粉丝->在粉丝中挑选查看用户B信息->查看用户A粉丝... 这种情况下一般我们需要保留用户操作 Activity 栈的页面所有执行顺序。 顶部复用模式(singleTop) 如果在任务的栈顶正好存在该Activity的实例， 就重用该实例，而不会创建新的Activity对象，不过它会调用onNewIntent()方法。如果栈顶部不存在就会创建新的实例并放入栈顶(即使栈中已经存在该Activity实例，只要不在栈顶，都会创建实例)。 如果启动此Activity的Intent中没有设置FLAG_ACTIVITY_NEW_TASK标志, 则这个Activity与启动他的Activity在同一个Task中。\"launchMode\"设置为\"singleTop\"的Activity可以被实例化多次, 可以在Task中的任何位置, 对于一个新的Intent请求如果在Task栈顶, 则会用栈顶的Activity响应Intent请求,而不会重新实例化对象接收请求, 如果没有在栈顶, 则会实例化一个新的对象接收Intent请求. 使用场景：防止用户多次点击导致同一个activity在顶部多次重复；SingleTop 模式一般常见于社交应用中的通知栏行为功能，例如：App 用户收到几条好友请求的推送消息，需要用户点击推送通知进入到请求者个人信息页，将信息页设置为 SingleTop 模式就可以增强复用性。 单一任务模式(singleTask) 如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移除栈。如果栈中不存在该实例，将会创建新的实例放入栈中。 和singleTop在名字上即可看出区别，即singleTop每次只检测当前栈顶的Activity是否是我们需要请求创建的，而singleTask则会检测栈中全部的Activity对象，从上向下，如果检测到是我们所请求的则会消灭此Activity对象上面的对象，直接把检测到的我们需要的Activity置为栈顶。 \"launchMode\"设置为\"singleTask\"的Activity总是在栈底, 只能被实例化一次, 它允许其它Activity压入\"singleTask\"的Activity所在的Task栈,如果有新的Intent请求有此标志的Activity, 则系统会清除有此标志的Task栈中的全部Activity,并把此Activity显示出来。 使用场景：SingleTask 模式一般用作应用的首页，例如浏览器主页，用户可能从多个应用启动浏览器，但主界面仅仅启动一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 单例模式(singleInstance ) 在一个新栈中创建该Activity实例，并让多个应用共享该Activity实例。一旦这种模式的Activity实例存在于某个栈中，任何应用再激活这个Activity时都会重用该栈中的实例，其效果相当于多个应用程序共享一个应用，不管谁激活该Activity都会进入同一个应用中。此启动模式和我们使用的浏览器工作原理类似，在多个程序中访问浏览器时，如果当前浏览器没有打开，则打开浏览器，否则会在当前打开的浏览器中访问。此模式会节省大量的系统资源，因为他能保证要请求的Activity对象在当前的栈中只存在一个。 \"launchMode\"设置为\"singleInstance\"的Activity总是在栈底, 只能被实例化一次, 不允许其它的Activity压入\"singleInstance\"的Activity所在Task栈, 即整个Task栈中只能有这么一个Activity. 使用场景：SingleInstance 模式常应用于独立栈操作的应用，如闹钟的提醒页面，当你在A应用中看视频时，闹钟响了，你点击闹钟提醒通知后进入提醒详情页面，然后点击返回就再次回到A的视频页面，这样就不会过多干扰到用户先前的操作了。 生命周期 流程案例 正常启动:onCreate -> onStart -> onResume；正常退出:onPause -> onStop -> onDestory 已经处于前台的Activity,点击主页按钮离开当前Activity:onPause -> onStop；回到Activity:onRestart -> onStart -> onResume Activity不可操作(如:息屏、打开了其他Activity,而应用被强行杀死了),再回到Activity:onCreate -> onStart -> onResume 当启动另一个Activity时,当前Activity:onPause -> onStop,当点击返回按钮使另一个Activity退出时,当前Activity:onRestart -> onStart -> onResume，当前Activity回调onPause后便会开始SecondActivity的启动操作 普通对话框对生命周期没有任何影响 如果有个Activity伪装成对话框模式,那么它启动时,之前的Activity:onPause,\"对话框\"消失后,onResume再次回到前台 注意事项: 不要在MainActivity的onPause()中做耗时操作,可以把处理放到onStop,否则会影响SecondActivity的启动速度 onAttachedToWindow()/onDetachedFromWindow() 适用于View附加到Window后/View从Window分离后 此时View还未经过测量和绘制 调用顺序 onResume -> onAttachedToWindow(还未经过测量和绘制) -> onWindowsFocuesChanged(hasFocus:true时已经经过测量和绘制) -> onDetachedFromWindow() -> onPause 一般使用场景是初始化/释放重量级资源 参考：https://www.cnblogs.com/liushilin/p/11099856.html onNewIntent() 前提:ActivityA已经启动过,处于当前应用的Activity任务栈中; 当ActivityA的LaunchMode为Standard时： 由于每次启动ActivityA都是启动新的实例，和原来启动的没关系，所以不会调用原来ActivityA的onNewIntent方法 当ActivityA的LaunchMode为SingleTop时： 如果ActivityA在栈顶,且现在要再启动ActivityA，这时会调用onNewIntent()方法 ，生命周期顺序为： onCreate—>onStart—>onResume—onPause—>onNewIntent—>onResume 当ActivityA的LaunchMode为SingleInstance,SingleTask： 如果ActivityA已经在任务栈中，再次启动ActivityA，那么此时会调用onNewIntent()方法，生命周期调用顺序为： onPause—>跳转其它页面—>onCreate—>onStart—>onResume—onPause—>跳转A—>onNewIntent—>onRestart—>onStart—>onResume 总的来说，只对SingleTop(且位于栈顶)，SingleTask和SingleInstance(且已经在任务栈中存在实例)的情况下，再次启动它们时才会调用，即只对startActivity有效，对仅仅从后台切换到前台而不再次启动的情形，不会触发onNewIntent。 onActivityResult()（Deprecated） 待跳转的Activity启动模式错误： standard与singletop模式是会在跳转后的Activity finish后执行onActivityResult，而singletask和singleinstance模式是在startActivityforresult后立即执行onActivityResult； startActivityforresult（）的第二个参数requestCode必须>=0,而且 @param requestCode If >= 0, this code will be returned in* onActivityResult() when the activity exits. 横竖屏切换 应用程序的界面从横向变为纵向或从纵向变为横向时，将会回调以下生命周期方法： onPause(): 在活动完全不可见时调用，这是在切换屏幕方向时会发生的。在该方法内您可以暂停正在进行的操作，例如暂停视频播放。 onSaveInstanceState(Bundle outState): 在活动被销毁之前调用，用于保存当前活动的状态信息，例如滚动位置、文本框中的文本等。 onStop(): 在活动不可见时调用，用于释放资源或停止一些操作。 onDestroy(): 在活动被销毁之前调用，用于释放资源或停止一些操作。 onCreate(Bundle savedInstanceState): 当活动被重新创建时，例如在屏幕方向变化后，该方法会被调用。您可以使用 savedInstanceState 参数来恢复保存的状态信息。 onStart(): 在活动变得可见时调用，您可以在此处开始一些操作或恢复之前暂停的操作。 onResume(): 在活动准备好与用户进行交互时调用，例如在屏幕方向变化后。在此方法内您可以恢复之前暂停的操作。 Activity启动方式 显式启动 隐式启动 ①启动系统Activity ②启动普通Activity 传递内容 使用Intent的putExtra传递 第一个Activity中 //创建意图对象 Intent intent = new Intent(this,TwoActivity.class); //设置传递键值对 intent.putExtra(\"data\",str); //激活意图 startActivity(intent); 第二个Activity中 // 获取意图对象 Intent intent = getIntent(); //获取传递的值 String str = intent.getStringExtra(\"data\"); //设置值 tv.setText(str); 使用Intent的Bundle传递 第一个Activity中 //创建意图对象 Intent intent = new Intent(MainActivity.this,TwoActivity.class); //用数据捆传递数据 Bundle bundle = new Bundle(); bundle.putString(\"data\", str); //把数据捆设置改意图 intent.putExtra(\"bun\", bundle); //激活意图 startActivity(intent); 第二个Activity //获取Bundle Intent intent = getIntent(); Bundle bundle = intent.getBundleExtra(\"bun\"); String str = bundle.getString(\"data\"); tv.setText(str); 使用序列化对象Seriazable 工具类 import java.io.Serializable; class DataBean implements Serializable { private String name; private String sex; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } 第一个Activity //创建意图 Intent intent = new Intent(MainActivity.this,TwoActivity.class); DataBean bean = new DataBean(); //通过set方法把数据保存到DataBean对象中 bean.setName(\"啦啦\"); bean.setSex(\"男\"); intent.putExtra(\"key\", bean); startActivity(intent); 第二个Activity Intent intent = getIntent(); //反序列化数据对象 Serializable se = intent.getSerializableExtra(\"key\"); if(se instanceof DataBean){ //获取到携带数据的DataBean对象db DataBean db = (DataBean) se; tv.setText(db.getName()+\"===\"+db.getSex()); } No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-1.应用层-基础与源码/AndroidManifest.html":{"url":"04_Android/应用层/SDK/2-1.应用层-基础与源码/AndroidManifest.html","title":"Androidmanifest","keywords":"","body":"meta-data 基本用法：存储全局信息 定义在等标签外部，在标签内部 可以保存boolean、int、String、float AndroidManifest.xml中 读取 Application ai = getPackageManager().getApplicationInfo(getPackageName(),PackageManager.GET_META_DATA); Bundle bundle = ai.metaData; String myApiKey = bundle.getString(\"my_test_metagadata\"); Lib和API的使用 有时使用库或者api的时候需要定义meta-data 比如使用GooglePlayService的时候需要定义版本才能使用 配置Activity 有时Activity需要传递参数以正确配置 这种情况meta-data标签需要被放置在内部 try{ ActivityInfo ai = getPackageManager().getActivityInfo(this.getComponentName(),PackageManager.GET_META_DATA); Bundle bundle = ai.metaData; if(bundle!=null){ String apiKey = bundle.getString(\"apikey\"); Log.d(this.getClass().getSimpleName(),\"apiKey = \"+apiKey); } }catch(PackageManager.NameNotFoundException e){ Utilties.log(this.getClass().getSimpleName(),\"Fail to load meta-data, NameNotFound: \"+e.getMessage()); }catch(NullPointerException e){ Log.e(this.getClass().getSimpleName(),\"Failed to load meta-data,Null Pointer: \"+e.getMessage()); } Android usage: Intents are great example for that - If you want to pass data in intents it has to be primitive because Android only have pre-build metadata about those kind of objects. (String and integer have different binary structure that the system know how to work with). Intents also allow you to build your own metadata to your custom objects via the Parcel class (this process of manually build you own metadata called marshalling) No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-1.应用层-基础与源码/Application.html":{"url":"04_Android/应用层/SDK/2-1.应用层-基础与源码/Application.html","title":"Application","keywords":"","body":"Application 作用 Application对象全局可访问，且全程陪同应用进程。所以特别适合完成以下任务: 共享全局状态 初始化全应用所需的服务 回调函数 Application对象由Android系统管理，它的回调函数都运行于U线程。 onCreate onConfigurationChanged 比如语言变更和屏幕方向改变 onLowMemory Application对象vs.静态单例 静态单例模块化程度更好 Application就是一个context，所以有访问资源的能力>静态单例可以接受context参数 Application对象能接收系统回调，自动知悉系统环境变化> Application对象的生命周期由系统控制 如果单例能实现需求就用单例 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-1.应用层-基础与源码/Broadcast.html":{"url":"04_Android/应用层/SDK/2-1.应用层-基础与源码/Broadcast.html","title":"Broadcast","keywords":"","body":"阅读： https://blog.csdn.net/qq_43667625/article/details/109704482 广播分类： 标准广播：会被所有接收器同时接收到。 有序广播：先被优先级高的接收器接收到，响应完成后再传递给之后的广播，如果中途被接收器截断，后续的接收器就无法接收到广播。 广播接收器的注册： 静态注册：在AndroidManifest中注册，消耗更多资源，开机广播需要使用静态注册。 有些比较消耗资源的广播是无法静态注册的 //屏幕亮起 android.intent.action.SCREEN_ON //屏幕熄灭 android.intent.action.SCREEN_OFF //电量变化 android.intent.action.BATTERY_CHANGED //屏幕方向，设备信息发生改变 android.intent.action.CONFIGURATION_CHANGED //时间改变（每分钟发送一次） android.intent.action.TIME_TICK //加在application标签中间 动态注册：在代码中注册，更加灵活。 自定义广播接收器 --> 创建广播接收器并addAction --> 注册广播接收器 --> ... --> 注销广播接收器 发送广播： 动态注册： 标准广播：直接用sendBroadcast发送intent 有序广播： 为接收器的intentFilter调用setPriority设置优先级 使用sendOrderedBroadcast方法发送广播 接收器调用abortBroadcast()可以截断广播 静态注册：发送广播之前需要为intent调用setPackageName指定接收的应用，使其变成显式广播（Android8.0之后，静态注册的接收器无法接收到隐式广播） 本地广播： 获取本地广播其实例localBroadcastManager = LocalBroadcastManager.getInstance(this); 注册/注销接收器 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-1.应用层-基础与源码/Context.html":{"url":"04_Android/应用层/SDK/2-1.应用层-基础与源码/Context.html","title":"Context","keywords":"","body":"Context是什么 context贯穿在我开发过程的方方面面，但我始终不知道这个context到底有什么用？为什么要这个对象？我们首先来看官方对于Context类的注释 vbnet代码解读复制代码/** * Interface to global information about an application environment. This is * an abstract class whose implementation is provided by * the Android system. It * allows access to application-specific resources and classes, as well as * up-calls for application-level operations such as launching activities, * broadcasting and receiving intents, etc. */ public abstract class Context { } Context最重要的作用就是获取全局消息、访问系统资源、调用应用程序级的操作。 Context如何生成 在程序启动的过程中，AMS会把一个“凭证”通过跨进程通信给到我们的应用程序，我们的程序会把这个“凭证”封装成context，并提供一系列的接口，这样我们的程序也就可以很方便地访问系统资源了。 这样做的好处：系统可以对应用程序级的操作进行调控，限制各种情景下的权限，同时也可以防止恶意攻击 Context是应用程序与系统之间沟通的桥梁，是应用程序访问系统资源的接口，同时也是系统给应用程序的一张“权限凭证”。有了context，一个Java类才可以被称之为组件 Context的继承关系 最顶层是Context抽象类，他定义了一系列与系统交汇的接口。ContextWrapper继承自Context，但是并没有真正实现Context中的接口，而是把接口的实现都托管给ContextImpl，ContextImpl是Context接口的真正实现者，从AMS拿来的“凭证”也是封装到了ContextImpl中，然后赋值给ContextWrapper，这里运用到了一种模式：装饰者模式。Application和Service都继承自ContextWrapper，那么他们也就拥有Context的接口方法且本身即是context，方便开发者的使用。Activity比较特殊，因为它是有界面的，所以他需要一个主题：Theme，ContextThemeWrapper在ContextWrapper的基础上增加与主题相关的操作 这样设计的优点： Activity等可以更加方便地使用context，可以把自身当成context来使用，遇到需要context的接口直接把自身传进去即可。 运用装饰者模式，向外屏蔽ContextImpl的内部逻辑，同时当需要更改ContextImpl的逻辑实现，ContextWrapper的逻辑几乎不需要更改。 更方便地扩展不同情景下的逻辑。如service和activity，情景不同，需要的接口方法也不同，但是与系统交互的接口是相同的，使用装饰者模式可以拓展出很多的功能，同时只需要把ContextImpl对象赋值进去即可。 源码阅读 Application中Context的创建过程 进入ActivityThread类的performLaunchActivity方法 private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) { r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); } ComponentName component = r.intent.getComponent(); if (component == null) { component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); } if (r.activityInfo.targetActivity != null) { component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); } ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try { java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(isProtectedComponent(r.activityInfo), appContext.getAttributionSource()); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( \"Unable to instantiate activity \" + component + \": \" + e.toString(), e); } } try { //创建Application Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, \"Performing launch of \" + r); if (localLOGV) Slog.v( TAG, r + \": app=\" + app + \", appName=\" + app.getPackageName() + \", pkg=\" + r.packageInfo.getPackageName() + \", comp=\" + r.intent.getComponent().toShortString() + \", dir=\" + r.packageInfo.getAppDir()); if (activity != null) { CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mConfigurationController.getCompatConfiguration()); if (r.overrideConfig != null) { config.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Launching activity \" + r.activityInfo.name + \" with config \" + config); Window window = null; if (r.mPendingRemoveWindow != null && r.mPreserveWindow) { window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; } // application context. appContext.getResources().addLoaders( app.getResources().getLoaders().toArray(new ResourcesLoader[0])); appContext.setOuterContext(activity); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken, r.shareableActivityToken); if (customIntent != null) { activity.mIntent = customIntent; } r.lastNonConfigurationInstances = null; checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) { activity.setTheme(theme); } if (r.mActivityOptions != null) { activity.mPendingOptions = r.mActivityOptions; r.mActivityOptions = null; } activity.mLaunchedFromBubble = r.mLaunchedFromBubble; activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onCreate()\"); } r.activity = activity; mLastReportedWindowingMode.put(activity.getActivityToken(), config.windowConfiguration.getWindowingMode()); } r.setState(ON_CREATE); synchronized (mResourcesManager) { mActivities.put(r.token, r); } } catch (SuperNotCalledException e) { throw e; } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( \"Unable to start activity \" + component + \": \" + e.toString(), e); } } return activity; } 进入 r.packageInfo.makeApplication的内部 public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) { //如果存在则直接返回 if (mApplication != null) { return mApplication; } Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"makeApplication\"); Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) { appClass = \"android.app.Application\"; } try { final java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(\"android\")) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"initializeJavaContextClassLoader\"); initializeJavaContextClassLoader(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); } // Rewrite the R 'constants' for all library apks. SparseArray packageIdentifiers = getAssets().getAssignedPackageIdentifiers( false, false); for (int i = 0, n = packageIdentifiers.size(); i 进入Instrumentation类的callApplicationOnCreate方法 public void callApplicationOnCreate(Application app) { app.onCreate(); } 进入newApplication方法 public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException { Application app = getFactory(context.getPackageName()) .instantiateApplication(cl, className); app.attach(context); return app; } 进入instantiateApplication方法 public @NonNull Application instantiateApplication(@NonNull ClassLoader cl, @NonNull String className) throws InstantiationException, IllegalAccessException, ClassNotFoundException { return (Application) cl.loadClass(className).newInstance(); } 通过ClassLoader创建application实例。 进入Application类的attach方法中 java代码解读复制代码@UnsupportedAppUsage /* package */ final void attach(Context context) { attachBaseContext(context); mLoadedApk = ContextImpl.getImpl(context).mPackageInfo; } 进入attachBaseContext方法中 csharp代码解读复制代码protected void attachBaseContext(Context base) { if (mBase != null) { throw new IllegalStateException(\"Base context already set\"); } mBase = base; } 这里的context是在makeApplication方法中通过ContextImpl.createAppContext创建的，所以是一个ContextImpl类型的Context。到此application获取context的过程大致走了一遍 Activity中Context的创建过程 进入ActivityThread类中的performLaunchActivity方法 scss代码解读复制代码private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) { r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); } ComponentName component = r.intent.getComponent(); if (component == null) { component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); } if (r.activityInfo.targetActivity != null) { component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); } //创建一个ContextImpl对象 ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try { java.lang.ClassLoader cl = appContext.getClassLoader(); //创建activity对象 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(isProtectedComponent(r.activityInfo), appContext.getAttributionSource()); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( \"Unable to instantiate activity \" + component + \": \" + e.toString(), e); } } try { Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, \"Performing launch of \" + r); if (localLOGV) Slog.v( TAG, r + \": app=\" + app + \", appName=\" + app.getPackageName() + \", pkg=\" + r.packageInfo.getPackageName() + \", comp=\" + r.intent.getComponent().toShortString() + \", dir=\" + r.packageInfo.getAppDir()); if (activity != null) { CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mConfigurationController.getCompatConfiguration()); if (r.overrideConfig != null) { config.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Launching activity \" + r.activityInfo.name + \" with config \" + config); Window window = null; if (r.mPendingRemoveWindow != null && r.mPreserveWindow) { window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; } // Activity resources must be initialized with the same loaders as the // application context. appContext.getResources().addLoaders( app.getResources().getLoaders().toArray(new ResourcesLoader[0])); //将activity赋值给appContext的mOuterContext，这样我们可以通过ContextImpl来调用activity中的方法和变量 appContext.setOuterContext(activity); //appContext传入activity中 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken, r.shareableActivityToken); if (customIntent != null) { activity.mIntent = customIntent; } r.lastNonConfigurationInstances = null; checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) { activity.setTheme(theme); } if (r.mActivityOptions != null) { activity.mPendingOptions = r.mActivityOptions; r.mActivityOptions = null; } activity.mLaunchedFromBubble = r.mLaunchedFromBubble; activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onCreate()\"); } r.activity = activity; mLastReportedWindowingMode.put(activity.getActivityToken(), config.windowConfiguration.getWindowingMode()); } r.setState(ON_CREATE); // updatePendingActivityConfiguration() reads from mActivities to update // ActivityClientRecord which runs in a different thread. Protect modifications to // mActivities to avoid race. synchronized (mResourcesManager) { mActivities.put(r.token, r); } } catch (SuperNotCalledException e) { throw e; } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( \"Unable to start activity \" + component + \": \" + e.toString(), e); } } return activity; } 进入activity类中的attach方法 final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken, IBinder shareableActivityToken) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); //mWindow的初始化 mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(mWindowControllerCallback); //设置mWindow的回调。 mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) { mWindow.setSoftInputMode(info.softInputMode); } if (info.uiOptions != 0) { mWindow.setUiOptions(info.uiOptions); } mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mAssistToken = assistToken; mShareableActivityToken = shareableActivityToken; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; if (voiceInteractor != null) { if (lastNonConfigurationInstances != null) { mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor; } else { mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this, Looper.myLooper()); } } //给mWindow设置WindowManager mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) { mWindow.setContainer(mParent.getWindow()); } //Window中刚才设置的WindowManager获取出来赋值给Activity中的成员变量`mWindowManager` mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; mWindow.setColorMode(info.colorMode); mWindow.setPreferMinimalPostProcessing( (info.flags & ActivityInfo.FLAG_PREFER_MINIMAL_POST_PROCESSING) != 0); setAutofillOptions(application.getAutofillOptions()); setContentCaptureOptions(application.getContentCaptureOptions()); } 进入attachBaseContext方法 @Override protected void attachBaseContext(Context newBase) { super.attachBaseContext(newBase); if (newBase != null) { newBase.setAutofillClient(this); newBase.setContentCaptureOptions(getContentCaptureOptions()); } } 进入ContextThemeWrapper类中的attachBaseContext @Override protected void attachBaseContext(Context newBase) { super.attachBaseContext(newBase); } 进入ContextWrapper类中的attachBaseContext方法 protected void attachBaseContext(Context base) { if (mBase != null) { throw new IllegalStateException(\"Base context already set\"); } mBase = base; } activity.attachBaseContext,内部代码如下, 而super.attachBaseContext(newBase) 会根据继承关系一直调用到ContextWrapper, 然后将ContextImpl类型的Context传进去，赋值给mBase。 到此Activity中Context创建过程到此结束 Service中context的创建过程 进入Activity类中的handleCreateService方法中 private void handleCreateService(CreateServiceData data) { unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try { if (localLOGV) Slog.v(TAG, \"Creating service \" + data.info.name); Application app = packageInfo.makeApplication(false, mInstrumentation); final java.lang.ClassLoader cl; if (data.info.splitName != null) { cl = packageInfo.getSplitClassLoader(data.info.splitName); } else { cl = packageInfo.getClassLoader(); } //创建service对象 service = packageInfo.getAppFactory() .instantiateService(cl, data.info.name, data.intent); //创建ContextImpl对象 ContextImpl context = ContextImpl.getImpl(service .createServiceBaseContext(this, packageInfo)); if (data.info.splitName != null) { context = (ContextImpl) context.createContextForSplit(data.info.splitName); } if (data.info.attributionTags != null && data.info.attributionTags.length > 0) { final String attributionTag = data.info.attributionTags[0]; context = (ContextImpl) context.createAttributionContext(attributionTag); } context.getResources().addLoaders( app.getResources().getLoaders().toArray(new ResourcesLoader[0])); //将service赋值给ContextImpl类中的mOuterContext变量 context.setOuterContext(service); //将创建的context传入service中 service.attach(context, this, data.info.name, data.token, app, ActivityManager.getService()); // 调用service的onCreate方法 service.onCreate(); mServicesData.put(data.token, data); mServices.put(data.token, service); try { ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } catch (Exception e) { if (!mInstrumentation.onException(service, e)) { throw new RuntimeException( \"Unable to create service \" + data.info.name + \": \" + e.toString(), e); } } } 进入service类中的attach方法 public final void attach( Context context, ActivityThread thread, String className, IBinder token, Application application, Object activityManager) { attachBaseContext(context); mThread = thread; // NOTE: unused - remove? mClassName = className; mToken = token; mApplication = application; mActivityManager = (IActivityManager)activityManager; mStartCompatibility = getApplicationInfo().targetSdkVersion 进入attachBaseContext方法 @Override protected void attachBaseContext(Context newBase) { super.attachBaseContext(newBase); if (newBase != null) { newBase.setContentCaptureOptions(getContentCaptureOptions()); } } Service类型的ContextImpl赋值给了ContextWrapper中的mBase变量，这样我们调用ContextWrapper中的方法实际就是调用mBase这个真正的ContextImpl中的方法。 到此service创建context已经分析完成。 其他 getApplication()和getApplicationContext()的区别？ getApplication方法仅仅限于Activity和Service中有，其它的类没有，那么如果其它的类想要获取Application的实例的话，就可以通过context.getApplicationContext来获取了，也就是说这个方法的使用范围更加大，便于使用而已。 不同Context的区别 1. Application Context 获取方式：通过getApplicationContext()。 生命周期：与整个应用程序的生命周期一致，只要应用在运行，Application Context就存在。 作用范围： 用于需要全局使用的场景，比如单例模式或跨组件通信。 创建与应用生命周期一致的资源，如长时间运行的服务或缓存。 特点： 独立于UI：与界面无关，不能直接操作UI（例如，弹出Dialog或更新Activity的视图）。 内存管理更安全：因为它的生命周期与应用一致，不会因Activity的销毁而泄露内存。 典型场景： 初始化全局状态或配置。 获取系统服务（如ConnectivityManager或LocationManager）。 使用SharedPreferences或文件系统。 2. Activity Context 获取方式：直接在Activity中使用this，或者通过Activity的引用。 生命周期：与Activity的生命周期一致，当Activity销毁时，Activity Context也会被回收。 作用范围：用于与当前Activity相关的操作，如加载布局、启动其他Activity、更新UI。 特点： 与UI强关联：可以操作界面元素，例如显示Toast或创建Dialog。 容易引起内存泄漏：如果在长生命周期对象（如Singleton或静态变量）中持有Activity Context，会阻止Activity被垃圾回收，导致内存泄漏。 3. Service Context 获取方式：在Service中直接使用this，或通过Context传递。 生命周期：与服务的生命周期一致。 特点： 类似于Application Context，但通常用于服务的特定操作。 无法操作UI，因为服务通常运行在后台线程中。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-1.应用层-基础与源码/Fragment.html":{"url":"04_Android/应用层/SDK/2-1.应用层-基础与源码/Fragment.html","title":"Fragment","keywords":"","body":"引入 建议用support包里的fragment，会不断更新，可以兼容到1.6 生命周期 状态解析 onAttach()：Fragment和Activity相关联时调用。可以通过该方法获取Activity引用，还可以通过getArguments()获取参数。 onCreate()：Fragment被创建时调用。 onCreateView()：创建Fragment的布局。 onActivityCreated()：当Activity完成onCreate()时调用。 onStart()：当Fragment可见时调用。 onResume()：当Fragment可见且可交互时调用。 onPause()：当Fragment不可交互但可见时调用。 onStop()：当Fragment不可见时调用。 onDestroyView()：当Fragment的UI从视图结构中移除时调用。 onDestroy()：销毁Fragment时调用。 onDetach()：当Fragment和Activity解除关联时调用 场景解析 当一个fragment被创建的时候，需调用以下生命周期方法：onAttach(), onCreate(), onCreateView(), onActivityCreated() 当这个fragment对用户可见的时候，需调用：onStart() ,onResume() 当这个fragment进入后台模式需调用：onPause()，onStop() 当这个fragment被销毁或者是持有它的Activity被销毁了，调用：onPause() ,onStop(), onDestroyView(), onDestroy()，onDetach() 使用 method1 静态加载 以标签的形式添加到Activity的布局当中。 method2 动态加载 FragmentManager：用来管理Activity中的fragment 使用： app包中使用getFragmentManager() v4包中getSupportFragmentManager() FragmentTransaction：事务,用来添加，移除，替换fragment 使用： FragmentTransaction transaction = fm.benginTransatcion();//开启一个事务 transaction.add();//往Activity中添加一个Fragment transaction.remove();//从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈，这个Fragment实例将会被销毁。 transaction.replace();//使用另一个Fragment替换当前的，实际上就是remove()然后add()的合体。 transaction.hide();//隐藏当前的Fragment，仅仅是设为不可见，并不会销毁。 transaction.show();//显示之前隐藏的Fragment。 transaction.commit();//提交一个事务。 transaction.detach();//会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护。 transaction.attach();//重建view视图，附加到UI上并显示。 注意： 在用Fragment的时候，可能会经常遇到这样Activity状态不一致：State loss这样的错误。主要是因为：commit方法一定要在Activity.onSaveInstance()之前调用。 比如：我在FragmentA中的EditText填了一些数据，当切换到FragmentB时，如果希望会到A还能看到数据，则适合你的就是hide和show；也就是说，希望保留用户操作的面板，你可以使用hide和show，当然了不要使劲在那new实例，进行下非null判断。 再比如：我不希望保留用户操作，你可以使用remove()，然后add()；或者使用replace()这个和remove,add是相同的效果。 remove和detach有一点细微的区别，在不考虑回退栈的情况下，remove会销毁整个Fragment实例，而detach则只是销毁其视图结构，实例并不会被销毁。那么二者怎么取舍使用呢？如果你的当前Activity一直存在，那么在不希望保留用户操作的时候，你可以优先使用detach。 示例 通信 ①fragment与fragment通信 不同的fragment，他们之间的通信要依靠activity来完成。我们可以把他看成Fragment->Activity->Fragment,因为两个乃至多个fragment是依附于同一个activity,所以完全可以通过把值传递到共同依附的Activity,然后通过Bundle传给另一个fragment。 方式一：先调用findFragmentById()方法根据id获得fragment的对象，然后调用fragment中的方法进行赋值. Code： manager.findFragmentById(); //根据ID来找到对应的Fragment实例，主要用在静态添加fragment的布局中，因为静态添加的fragment才会有ID. manager.findFragmentByTag();//根据TAG找到对应的Fragment实例，主要用于在动态添加的fragment中，根据TAG来找到fragment实例 manager.getFragments();//获取所有被add进Activity中的Fragment 注意： 直接在一个Fragment中调用另外一个Fragment的公开方法,前提是要先拿到另外一个Fragment的实例。 一般情况下，我们都是动态添加Fragment的，所以通过在add每个Fragment的时候，给每个Fragment设置个tag。 Example： ①Activity public class MainActivity extends FragmentActivity { private FragmentManager manager; private FragmentTransaction transaction; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /*获取manager*/ manager = this.getSupportFragmentManager(); /*创建事物*/ transaction = manager.beginTransaction(); /*创建leftFragment*/ LeftFragment leftFragment = new LeftFragment(); /*创建RightFragment*/ RightFragment rightFragment = new RightFragment(); /*通过事物把两个fragment分别添加到对应的容器中*/ transaction.add(R.id.left, leftFragment, \"left\"); transaction.add(R.id.right, rightFragment, \"right\"); /*提交事物*/ transaction.commit(); } } 在Activity创建的时候，添加上所有的fragment,并为每个fragment设置tag，这样才会在每个fragment中通过findFragmentByTag()时，不会出现空指针。 ②LeftFragment public class LeftFragment extends Fragment { private TextView mTvHome; private Button mBtn; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_home, null); mTvHome = view.findViewById(R.id.tv_home); mBtn = view.findViewById(R.id.btn_home); initView(); return view; } private void initView() { Bundle bundle = this.getArguments(); String home = bundle.getString(\"home\"); mTvHome.setText(home); mBtn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { RightFragment rightFragment = (RightFragment) getActivity().getSupportFragmentManager().findFragmentByTag(\"right\"); if (rightFragment == null) return; rightFragment .setTextView(\"right !!!!!!!!!!!!!!!\"); } }); } } ③RightFragment public class RightFragment extends Fragment { private TextView mTvCommunity; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_community, null); mTvCommunity=view.findViewById(R.id.tv_community); initView(); return view; } private void initView() { Bundle bundle = this.getArguments(); String community = bundle.getString(\"community\"); mTvCommunity.setText(community); } public void setTextView(String str){ mTvCommunity.setText(str); } } 这种方式是两个fragment直接通信的。（不推荐使用） 方式二：通过接口回调的方法实现两个fragment之间的通信 举例，比如点击MessageFragment的Button按钮，给CommunityFragment中的TextView传递数据。 我们就需要在MessageFragment中定义接口，并定义回调的方法，该方法的参数中传一个String的字符串。接着让附属Activity实现这个接口，并重写回调方法，也就得到到传过来的数据，然后通过findFragmentByTag()的方法获取要传给的CommunityFragment的实例。 Step： 在CommunityFragment中定义一个方法用来接收这个数据，然后用对象直接调用这个方法将参数传递给这个方法，就可以了。 在MessageFragment中定义接口，并定义回调的方法，该方法的参数中传一个String的字符串 ①MessageFragment public class MessageFragment extends Fragment { private TextView mTvMessage; MessageListener mListener; @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); //创建接口的子类对象 //获取当前Fragment所属的Activity,因为Activity实现了MessageListener接口，所以是MessageListener的子类 mListener= (MessageListener) getActivity(); } @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_message, null); mTvMessage = view.findViewById(R.id.tv_message); initView(); mListener.sendMessage(\"来自：MessageFragment的消息\"); return view; } private void initView() { Bundle arguments = this.getArguments(); String message = arguments.getString(\"message\"); mTvMessage.setText(message); } public interface MessageListener { void sendMessage(String message); } } ②AddFragmentActivity public class AddFragmentActivity extends FragmentActivity implements MessageFragment.MessageListener{ private FrameLayout mFrameLayout; private RadioGroup mRg; private RadioButton mRbHome; private RadioButton mRbCommunity; private RadioButton mRbMessage; private RadioButton mRbMe; private List mFragments = new ArrayList<>(); private HomeFragment homeFragment; private CommunityFragment communityFragment; private MessageFragment messageFragment; private MeFragment meFragment; private FragmentManager mSupportFragmentManager; private FragmentTransaction mTransaction; private TextView mTvMain; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_fragment); mFrameLayout = findViewById(R.id.frameLayout); mRg = findViewById(R.id.rg_main); mRbHome = findViewById(R.id.rb_home); mRbCommunity = findViewById(R.id.rb_community); mRbMessage = findViewById(R.id.rb_message); mRbMe = findViewById(R.id.rb_me); mTvMain=findViewById(R.id.tv_main); initView(); } private void initView() { mSupportFragmentManager = getSupportFragmentManager(); mTransaction = mSupportFragmentManager.beginTransaction(); //设置默认选中首页 mRg.check(R.id.rb_home); homeFragment = new HomeFragment(); //创建Bundle对象，并存储数据 Bundle bundle=new Bundle(); bundle.putString(\"home\",\"Home\"); homeFragment.setArguments(bundle); mFragments.add(homeFragment); hideOthersFragment(homeFragment, true,\"homefragment\"); mRg.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() { @Override public void onCheckedChanged(RadioGroup group, int checkedId) { switch (checkedId) { case R.id.rb_home: //首页 hideOthersFragment(homeFragment, false,\"homefragment\"); break; case R.id.rb_community: //发现 if (communityFragment == null) { communityFragment = new CommunityFragment(); Bundle bundle=new Bundle(); bundle.putString(\"community\",\"Community\"); communityFragment.setArguments(bundle); mFragments.add(communityFragment); hideOthersFragment(communityFragment, true,\"communityfragment\"); } else { hideOthersFragment(communityFragment, false,\"communityfragment\"); } communityFragment.sendMessage(new ICommuntyCallBack() { @Override public void getMessageFromCommunty(String community) { mTvMain.setText(community); } }); break; case R.id.rb_message: //信息 if (messageFragment == null) { messageFragment = new MessageFragment(); Bundle bundle=new Bundle(); bundle.putString(\"message\",\"Message\"); messageFragment.setArguments(bundle); mFragments.add(messageFragment); hideOthersFragment(messageFragment, true,\"messagefragment\"); } else { hideOthersFragment(messageFragment, false,\"messagefragment\"); } break; case R.id.rb_me: //我的 if (meFragment == null) { meFragment = new MeFragment(); Bundle bundle=new Bundle(); bundle.putString(\"me\",\"Me\"); meFragment.setArguments(bundle); mFragments.add(meFragment); hideOthersFragment(meFragment, true,\"mefragment\"); } else { hideOthersFragment(meFragment, false,\"mefragment\"); } meFragment.sendMessage(new IMeCallBack() { @Override public void getMessageFromMe(String me) { mTvMain.setText(me); } }); break; } } }); } private void hideOthersFragment(Fragment showFragment, boolean add,String tag) { mTransaction = mSupportFragmentManager.beginTransaction(); if (add) { mTransaction.add(R.id.frameLayout, showFragment,tag); } for (Fragment fragment : mFragments) { if (showFragment.equals(fragment)) { mTransaction.show(fragment); } else { mTransaction.hide(fragment); } } mTransaction.commit(); } @Override public void sendMessage(String message) { mTvMain.setText(message); CommunityFragment communityfragment = (CommunityFragment) mSupportFragmentManager.findFragmentByTag(\"communityfragment\"); communityfragment.setTextView(message); } 在CommunityFragment中定义一个方法用来接收数据 ③CommunityFragment public class CommunityFragment extends Fragment { private TextView mTvCommunity; public static final String TAG = \"CommunityFragment\"; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_community, null); mTvCommunity = view.findViewById(R.id.tv_community); initView(); return view; } private void initView() { Bundle bundle = this.getArguments(); String community = bundle.getString(\"community\"); // mTvCommunity.setText(community); } public void setTextView(String str) { //System.out.println(\"来自HomeFragment传过来的消息\" + str + \"//\"); // mTvCommunity.setText(str); //if (str == null) return; mTvCommunity.setText(str); } } 这样就实现了两个fragment之间的通信。 接口是我们常用的Fragment之间的通讯方式，通过一个主Activity作为通讯桥梁（谷歌官方声明：两个Fragment之间永远不要直接通讯），实现两个Fragment之间的通讯。 接口的方式是我们推荐的，但是，传统的接口方式会造成一些问题，如果主Activity实现了多个Fragment的通讯回调接口，那我们需要implements很多的接口，类中还要实现一大堆接口的方法，显得有点繁琐。 方式三：使用EventBus EventBus：使用方便，但其使用的是反射原理，会有稍微的延迟，并且他人维护不方便； static静态变量：使用方便，但是，每个static变量都会占用一块内存区，Android系统分配给每个App的内存是有限的（63M），过多很容易造成App内存溢出； 方式四：广播 广播Broadcast Receiver：Android的广播是有限制的，除了系统的广播外，其他的广播尽量少用。另外，广播会有延迟； ②Activity向Fragment传值 原理： 在activity中建一个bundle，把要传的值存入bundle，然后通过fragment的setArguments（bundle）传到fragment，在fragment中，用getArguments接收。 就动态添加fragment的例子，在添加每个fragment之前，使用Bundle传输数据给每个fragment。 ①Activity private void initView() { mSupportFragmentManager = getSupportFragmentManager(); mTransaction = mSupportFragmentManager.beginTransaction(); //设置默认选中首页 mRg.check(R.id.rb_home); homeFragment = new HomeFragment(); //创建Bundle对象，并存储数据 Bundle bundle=new Bundle(); bundle.putString(\"home\",\"Home\"); homeFragment.setArguments(bundle); mFragments.add(homeFragment); hideOthersFragment(homeFragment, true); mRg.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() { @Override public void onCheckedChanged(RadioGroup group, int checkedId) { switch (checkedId) { case R.id.rb_home: //首页 hideOthersFragment(homeFragment, false); break; case R.id.rb_community: //发现 if (communityFragment == null) { communityFragment = new CommunityFragment(); Bundle bundle=new Bundle(); bundle.putString(\"community\",\"Community\"); communityFragment.setArguments(bundle); mFragments.add(communityFragment); hideOthersFragment(communityFragment, true); } else { hideOthersFragment(communityFragment, false); } break; case R.id.rb_message: //信息 if (messageFragment == null) { messageFragment = new MessageFragment(); Bundle bundle=new Bundle(); bundle.putString(\"message\",\"Message\"); messageFragment.setArguments(bundle); mFragments.add(messageFragment); hideOthersFragment(messageFragment, true); } else { hideOthersFragment(messageFragment, false); } break; case R.id.rb_me: //我的 if (meFragment == null) { meFragment = new MeFragment(); Bundle bundle=new Bundle(); bundle.putString(\"me\",\"Me\"); meFragment.setArguments(bundle); mFragments.add(meFragment); hideOthersFragment(meFragment, true); } else { hideOthersFragment(meFragment, false); } break; } } }); } ②Fragment中 public class HomeFragment extends Fragment { private TextView mTvHome; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_home, null); mTvHome = view.findViewById(R.id.tv_home); initView(); return view; } private void initView() { Bundle bundle = this.getArguments(); String home = bundle.getString(\"home\"); mTvHome.setText(home); } } ③Fragment向Activity传值 首先定义一个接口： public interface IHomeCallBack { void getMessageFromHomeFragment(String home); } ①接着在Fragment中设置接口回调的方法： public class HomeFragment extends Fragment { private TextView mTvHome; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_home, null); mTvHome = view.findViewById(R.id.tv_home); initView(); return view; } private void initView() { Bundle bundle = this.getArguments(); String home = bundle.getString(\"home\"); mTvHome.setText(home); } //设置接口回调方法 public void sendMessage(IHomeCallBack iHomeCallBack){ iHomeCallBack.getMessageFromHomeFragment(\"我是来自HomeFragment的消息\"); } } ②最后在Activity中回调 public class AddFragmentActivity extends FragmentActivity { private FrameLayout mFrameLayout; private RadioGroup mRg; private RadioButton mRbHome; private RadioButton mRbCommunity; private RadioButton mRbMessage; private RadioButton mRbMe; private List mFragments = new ArrayList<>(); private HomeFragment homeFragment; private CommunityFragment communityFragment; private MessageFragment messageFragment; private MeFragment meFragment; private FragmentManager mSupportFragmentManager; private FragmentTransaction mTransaction; private TextView mTvMain; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_fragment); mFrameLayout = findViewById(R.id.frameLayout); mRg = findViewById(R.id.rg_main); mRbHome = findViewById(R.id.rb_home); mRbCommunity = findViewById(R.id.rb_community); mRbMessage = findViewById(R.id.rb_message); mRbMe = findViewById(R.id.rb_me); mTvMain=findViewById(R.id.tv_main); initView(); initData(); } private void initData() { homeFragment.sendMessage(new IHomeCallBack() { @Override public void getMessageFromHomeFragment(String home) { mTvMain.setText(home); } }); } private void initView() { mSupportFragmentManager = getSupportFragmentManager(); mTransaction = mSupportFragmentManager.beginTransaction(); //设置默认选中首页 mRg.check(R.id.rb_home); homeFragment = new HomeFragment(); //创建Bundle对象，并存储数据 Bundle bundle=new Bundle(); bundle.putString(\"home\",\"Home\"); homeFragment.setArguments(bundle); mFragments.add(homeFragment); hideOthersFragment(homeFragment, true); mRg.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() { @Override public void onCheckedChanged(RadioGroup group, int checkedId) { switch (checkedId) { case R.id.rb_home: //首页 hideOthersFragment(homeFragment, false); break; case R.id.rb_community: //发现 if (communityFragment == null) { communityFragment = new CommunityFragment(); Bundle bundle=new Bundle(); bundle.putString(\"community\",\"Community\"); communityFragment.setArguments(bundle); mFragments.add(communityFragment); hideOthersFragment(communityFragment, true); } else { hideOthersFragment(communityFragment, false); } communityFragment.sendMessage(new ICommuntyCallBack() { @Override public void getMessageFromCommunty(String community) { mTvMain.setText(community); } }); break; case R.id.rb_message: //信息 if (messageFragment == null) { messageFragment = new MessageFragment(); Bundle bundle=new Bundle(); bundle.putString(\"message\",\"Message\"); messageFragment.setArguments(bundle); mFragments.add(messageFragment); hideOthersFragment(messageFragment, true); } else { hideOthersFragment(messageFragment, false); } messageFragment.sendMessage(new IMessageCallBack() { @Override public void getMessageFromMessage(String message) { mTvMain.setText(message); } }); break; case R.id.rb_me: //我的 if (meFragment == null) { meFragment = new MeFragment(); Bundle bundle=new Bundle(); bundle.putString(\"me\",\"Me\"); meFragment.setArguments(bundle); mFragments.add(meFragment); hideOthersFragment(meFragment, true); } else { hideOthersFragment(meFragment, false); } meFragment.sendMessage(new IMeCallBack() { @Override public void getMessageFromMe(String me) { mTvMain.setText(me); } }); break; } } }); } private void hideOthersFragment(Fragment showFragment, boolean add) { mTransaction = mSupportFragmentManager.beginTransaction(); if (add) { mTransaction.add(R.id.frameLayout, showFragment); } for (Fragment fragment : mFragments) { if (showFragment.equals(fragment)) { mTransaction.show(fragment); } else { mTransaction.hide(fragment); } } mTransaction.commit(); } } 接口的回调还可以这么写： public class MessageFragment extends Fragment { private TextView mTvMessage; MessageListener mListener; @Override public void onAttach(Context context) { super.onAttach(context); //创建接口的子类对象 //获取当前Fragment所属的Activity,因为Activity实现了MessageListener接口，所以是MessageListener的子类 mListener= (MessageListener)context; } @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_message, null); mTvMessage = view.findViewById(R.id.tv_message); mListener.sendMessage(\"来自：MessageFragment的消息\"); return view; } public interface MessageListener { void sendMessage(String message); } } 然后让Fragment依附的activity实现这个接口，然后重写sendMessage()方法，这样我们就可以把数据传过来了。 这种方案应该是既能达到Fragment复用，又能达到很好的可维护性，并且性能也是杠杠的，所以说推荐使用。 其它 Fragment + ViewPager 懒加载 ViewPager：ViewPager是一个在Android平台上常用的视图容器，用于实现页面滑动切换效果。它允许用户通过左右滑动屏幕来浏览多个页面，类似于水平滚动的标签页或幻灯片展示。ViewPager通常与Fragment结合使用，每个页面都可以是一个独立的Fragment。 懒加载字面意思就是当需要的时候才会去加载，不需要就不要加载。 以前处理 Fragment 的懒加载，我们通常会在 Fragment 中处理 setUserVisibleHint + onHiddenChanged 这两个函数，而在 Androidx 模式下，我们可以使用 FragmentTransaction.setMaxLifecycle() 的方式来处理 Fragment 的懒加载。 fragment 生命周期： onAttach -> onCreate -> onCreateView -> onViewCreated -> onActivityCreated -> onStart -> onResume 一般在 onCreate方法中接收 bundle 中的数据，在 onCreateView 创建 view初始化 布局。在 onActivityCreated或者 onResume做懒加载 传统模式 package com.zhaoyanjun.mode1 import android.os.Bundle import androidx.fragment.app.Fragment import android.view.LayoutInflater import android.view.View import android.view.ViewGroup abstract class BaseFragment : Fragment() { /** * 用户是否可见 */ protected var mIsVisibleToUser = false /** * view是否创建 */ protected var mIsViewCreated = false /** * 是否是第一次加载 */ protected var mIsFirstLoad = false override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) mIsViewCreated = true if (mIsVisibleToUser) { firstLoad() } } /** * 懒加载模式下生效 */ fun firstLoad() { if (mIsFirstLoad) { return } mIsFirstLoad = true onFirstLoad() } /** * 懒加载的时候调用 */ open fun onFirstLoad() { } override fun setUserVisibleHint(isVisibleToUser: Boolean) { super.setUserVisibleHint(isVisibleToUser) mIsVisibleToUser = isVisibleToUser if (mIsVisibleToUser && mIsViewCreated) { firstLoad() } } override fun onDestroyView() { mIsVisibleToUser = false mIsViewCreated = false mIsFirstLoad = false super.onDestroyView() } } 使用 ： package com.zhaoyanjun.mode1 import android.os.Bundle import android.util.Log import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import android.widget.TextView import com.zhaoyanjun.R class ContentFragment : BaseFragment() { private var param1: String? = null private var rootView: View? = null private var nameTv: TextView? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) arguments?.let { param1 = it.getString(ARG_PARAM1) } } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { rootView = inflater.inflate(R.layout.fragment_content, container, false) nameTv = rootView?.findViewById(R.id.name) return rootView } //懒加载更新数据 override fun onFirstLoad() { super.onFirstLoad() //第一次加载 Log.d(\"zhaoyanjun-\", \"firstLoad index: $param1\") nameTv?.text = param1 } companion object { private const val ARG_PARAM1 = \"param1\" @JvmStatic fun newInstance(param1: String) = ContentFragment().apply { arguments = Bundle().apply { putString(ARG_PARAM1, param1) } } } } Androidx 在使用 Androidx 的时候，会发现 FragmentPagerAdapter(fragmentManager) 方法过时了 取而代之的是 两个参数的构造函数 。 public FragmentPagerAdapter(@NonNull FragmentManager fm, @Behavior int behavior) { mFragmentManager = fm; mBehavior = behavior; } mBehavior 有两个值：BEHAVIOR_SET_USER_VISIBLE_HINT 、BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT 。 默认情况下使用的是 BEHAVIOR_SET_USER_VISIBLE_HINT 从官方的注释声明中，我们能得到如下两条结论： 如果 behavior 的值为 BEHAVIOR_SET_USER_VISIBLE_HINT，那么当 Fragment 对用户的可见状态发生改变时，setUserVisibleHint 方法会被调用。 如果 behavior 的值为 BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT ，那么当前选中的 Fragment在 Lifecycle.State#RESUMED 状态 ，其他不可见的 Fragment 会被限制在Lifecycle.State#STARTED 状态。 所以我的的懒加载方案就呼之欲出了： package com.zhaoyanjun.mode2 import androidx.fragment.app.Fragment abstract class BaseFragment2 : Fragment() { private var isLoaded = false override fun onResume() { super.onResume() //增加了Fragment是否可见的判断 if (!isLoaded && !isHidden) { isLoaded = true onFirstLoad() } } override fun onDestroyView() { super.onDestroyView() isLoaded = false } open fun onFirstLoad() { } } 使用： class ContentFragment2 : BaseFragment2() { private var param1: String? = null private var rootView: View? = null private var nameTv: TextView? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) arguments?.let { param1 = it.getString(ARG_PARAM1) } } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { rootView = inflater.inflate(R.layout.fragment_content, container, false) nameTv = rootView?.findViewById(R.id.name) return rootView } override fun onFirstLoad() { super.onFirstLoad() //第一次加载 Log.d(\"zhaoyanjun-mode2 \", \"firstLoad index: $param1\") nameTv?.text = param1 } companion object { private const val ARG_PARAM1 = \"param1\" @JvmStatic fun newInstance(param1: String) = ContentFragment2().apply { arguments = Bundle().apply { putString(ARG_PARAM1, param1) } } } } No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-1.应用层-基础与源码/Intent.html":{"url":"04_Android/应用层/SDK/2-1.应用层-基础与源码/Intent.html","title":"Intent","keywords":"","body":"Intent是一种运行时绑定（runtime binding)机制，它能在程序运行的过程中连接两个不同的组件。通过Intent，程序可以向Android表达某种请求或者意愿，Android会根据意愿的内容选择适当的组件来响应。 组成： component(组件)：目的组件 action（动作）：用来表现意图的行动 category（类别）：用来表现动作的类别，或范畴 data（数据）：表示与动作要操纵的数据 type（数据类型）：对于data范例的描写 extras（扩展信息）：扩展信息 Flags（标志位）：期望这个意图的运行模式 Android官方定义Intent 是用于通过描述某个\"意图\"对象中执行的简单操作（如“查看地图”或“拍摄照片”）来启动另一应用中的某个 Activity。 这种 Intent 称作\"隐式\"Intent，因为它并不指定要启动的应用组件，而是指定一项\"操作\"并提供执行该操作所需的一些数据。 当调用 startActivity() 或 startActivityForResult()并向其传递隐式 Intent 时，系统会将Intent解析为可处理该 Intent 的应用并启动其对应的 Activity。 如果有多个应用可处理 Intent，系统会为用户显示一个对话框，供其选择要使用的应用。 注意：如果设备上没有可接收隐式 Intent 的应用，应用将在调用 startActivity() 时崩溃。如需事先验证是否存在可接收 Intent 的应用，需要对 Intent对象调用 resolveActivity()。如果结果为非空，则至少有一个应用能够处理该 Intent，并且可以安全调用 startActivity()，如果结果为空，则不应使用该 Intent。如有可能，应停用调用该 Intent 的功能。 注意：隐式Intent与显式Intent的区别：隐式Intent不指定意图的主体。 常见使用：https://www.jianshu.com/p/ac6efbc45a3e 1.相机 2.打开特定设置屏幕 3.撰写带附件的短信/彩信Broadcast 注册 静态注册：broadcast receiver广播接收者的注册分静态注册（在AndroidManifest文件中进行配置） 动态注册：通过代码动态创建并以调用Context.registerReceiver()的方式注册至系统 PendingIntent 认识 PendingIntent是对Intent的封装，但它不是立刻执行某个行为，而是满足某些条件或触发某些事件后才执行指定的行为 A组件 创建了一个 PendingIntent 的对象然后传给 B组件，B 在执行这个 PendingIntent 的 send 时候，它里面的 Intent 会被发送出去，而接受到这个 Intent 的 C 组件会认为是 A 发的。 B以A的权限和身份发送了这个Intent 即：PendingIntent将某个动作的触发时机交给其他应用；让那个应用代表自己去执行那个动作（权限都给他） 我们的 Activity 如果设置了 exported = false，其他应用如果使用 Intent 就访问不到这个 Activity，但是使用 PendingIntent 是可以的。 获取 关于PendingIntent的实例获取一般有以下五种方法，分别对应Activity、Broadcast、Service getActivity() 从系统 取得一个用于启动一个Activity的PendingIntent对象. getActivities() getBroadcast() 从系统取得一个用于向BroadcastReceiver的发送广播的PendingIntent对象. getService() 从系统取得一个 用于启动一个Service的PendingIntent对象. getForegroundService() 它们的参数都相同，都是四个：Context， requestCode, Intent, flags，分别对应上下文对象、请求码、请求意图用以指明启动类及数据传递、关键标志位。 前面三个参数共同标志一个行为的唯一性，而第四个参数flags： FLAG_CANCEL_CURRENT：如果当前系统中已经存在一个相同的PendingIntent对象，那么就将先将已有的PendingIntent取消，然后重新生成一个PendingIntent对象。 FLAG_NO_CREATE：如果当前系统中不存在相同的PendingIntent对象，系统将不会创建该PendingIntent对象而是直接返回null，如果之前设置过，这次就能获取到。 FLAG_ONE_SHOT：该PendingIntent只作用一次。在该PendingIntent对象通过send()方法触发过后，PendingIntent将自动调用cancel()进行销毁，那么如果你再调用send()方法的话，系统将会返回一个SendIntentException。 FLAG_UPDATE_CURRENT：如果系统中有一个和你描述的PendingIntent对等的PendingInent，那么系统将使用该PendingIntent对象，但是会使用新的Intent来更新之前PendingIntent中的Intent对象数据，例如更新Intent中的Extras 备注：两个PendingIntent对等是指它们的operation一样, 且其它们的Intent的action, data, categories, components和flags都一样。但是它们的Intent的Extra可以不一样 使用场景 关于PendingIntent的使用场景主要用于闹钟、通知、桌面部件。 大体的原理是: A应用希望让B应用帮忙触发一个行为，这是跨应用的通信，需要 Android 系统作为中间人，这里的中间人就是 ActivityManager。 A应用创建建 PendingIntent，在创建 PendingIntent 的过程中，向 ActivityManager 注册了这个 PendingIntent，所以，即使A应用死了，当它再次苏醒时，只要提供相同的参数，还是可以获取到之前那个 PendingIntent 的。当 A 将 PendingIntent 调用系统 API 比如 AlarmManager.set()，实际是将权限给了B应用，这时候， B应用可以根据参数信息，来从 ActivityManager 获取到 A 设置的 PendingIntent 七大属性 ComponentName 指定了ComponentName属性的Intent已经明确了它将要启动哪个组件，因此这种Intent被称为显式Intent，没有指定ComponentName属性的Intent被称为隐式Intent。隐式Intent没有明确要启动哪个组件，应用会根据Intent指定的规则去启动符合条件的组件。 Intent intent = new Intent(); ComponentName cName = new ComponentName(MainActivity.this,NextActivity.class); intent.setComponent(cName); startActivity(intent); //实际上，以上的写法都被简化为以下写法： Intent intent = new Intent(MainActivity.this,NextActivity.class); startActivity(intent); //也就是说，平时我们最常用的Intent页面跳转的写法就调用的是显式Intent。 此外，ComponentName属性可以实现一个app跳转到另一个app。 Intent intent = new Intent(); ComponentName cName = new ComponentName( \"com.steven.testasyncloader.sqlitedata\",\"com.steven.testasyncloader.sqlitedata.MainActivity\"); //其中两个参数的含义：第一个是要跳转到的app的包名，第二个参数是该包中的要跳转到app的页面的class intent.setComponent(cName); startActivity(intent); Action Action作为标识符，代表一个Intent，当一个Activity需要外部协助处理时，就会发出一个Intent，如果一个程序能完成相应功能，只要在intent-filter加上这个这个intent就可以了。 通常，Action、Category属性结合使用，定义这两个属性都是在配置文件的节点中。Intent通过定义Action属性（其实就是一段自定义的字符串），这样就可以把Intent与具体的某个Activity分离，实现了解耦。否则，每次跳转，都要写成类似new Intent(MainActivity.this,NextActivity.class)这样的形式，也就是说必须将要跳转的目标Activity的名字写出来，这样的编码其实是“硬编码”，并没有实现松耦合。调用Intent对象的setAction()方法实现页面跳转虽然略微复杂（需要在AndroidManifest.xml文件中配置），但是实现了解耦。 常用的Action属性常量： ACTION_MAIN：（android.intent.action.MAIN）Android程序入口//每个Android应用必须且只能包含一个此类型的Action声明。【如果设置多个，则哪个在前，执行哪个。】 ACTION_VIEW： （android.intent.action.VIEW） 显示指定数据。 ACTION_EDIT： （android.intent.action.EDIT） 编辑指定数据。 ACTION_DIAL： （android.intent.action.DIAL） 显示拨号面板。 ACTION_CALL： （android.intent.action.CALL） 直接呼叫Data中所带的号码。 ACTION_ANSWER： （android.intent.action.ANSWER） 接听来电。 ACTION_SEND： （android.intent.action.SEND） 向其他人发送数据（例如：彩信/email）。 ACTION_SENDTO： （android.intent.action.SENDTO） 向其他人发送短信。 ACTION_SEARCH： （android.intent.action.SEARCH） 执行搜索。 ACTION_GET_CONTENT： （android.intent.action.GET_CONTENT） 让用户选择数据，并返回所选数据。 Intent利用Action属性中的ACTION_GET_CONTENT获取返回值： //选择图片 requestCode 返回的标识 Intent intent = new Intent(); intent.setAction(Intent. ACTION_GET_CONTENT ); intent.setType( \"image/*\" ); Intent wrapperIntent = Intent.createChooser(intent, null); startActivityForResult(wrapperIntent, requestCode); //添加音频 Intent intent = new Intent(); intent.setAction(Intent. ACTION_GET_CONTENT ); intent.setType( \"video/*\" ); Intent wrapperIntent = Intent.createChooser(intent, null); startActivityForResult(wrapperIntent, requestCode); //视频 Intent intent = new Intent(); intent.setAction(Intent. ACTION_GET_CONTENT ); intent.setType( \"video/*\" ); Intent wrapperIntent = Intent.createChooser(intent, null); startActivityForResult(wrapperIntent, requestCode); //录音 Intent intent = new Intent(); intent.setAction(Intent. ACTION_GET_CONTENT ); intent.setType( \"audio/amr\" ); intent.setClassName(\"com.android.soundrecorder\",\"com.android.soundrecorder.SoundRecorder\"); startActivityForResult(intent, requestCode); Category Category表示Intent的种类，从android上启动Activity有多种方式，比如 程序列表、桌面图标、点击Home激活的桌面等等，Category则用来标识这些Activity的图标会出现在哪些启动的上下文环境里。 Category属性为Action增加额外的附加类别信息。CATEGORY_LAUNCHER意味着在加载程序的时候Acticity出现在最上面，而CATEGORY_HOME表示页面跳转到HOME界面。 实现页面跳转到HOME界面的代码： Intent intent = new Intent(); intent.setAction(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGOTY_HOME); startActivity(intent); 常用Category属性常量 CATEGORY_DEFAULT： （android.intent.category.DEFAULT） Android系统中默认的执行方式，按照普通Activity的执行方式执行。 CATEGORY_HOME： （android.intent.category.HOME） 设置该组件为Home Activity。 CATEGORY_PREFERENCE： （android.intent.category.PREFERENCE） 设置该组件为Preference。 CATEGORY_LAUNCHER： （android.intent.category.LAUNCHER） 设置该组件为在当前应用程序启动器中优先级最高的Activity，通常与入口ACTION_MAIN配合使用。 CATEGORY_BROWSABLE： （android.intent.category.BROWSABLE） 设置该组件可以使用浏览器启动。 Data Data属性通常用于向Action属性提供操作的数据。Data属性的值是个Uri对象。 Uri的格式如下：scheme://host:port/path 系统内置的几个Data属性常量： tel://：号码数据格式，后跟电话号码。 mailto://：邮件数据格式，后跟邮件收件人地址。 smsto://：短息数据格式，后跟短信接收号码。 content://：内容数据格式，后跟需要读取的内容。 file://：文件数据格式，后跟文件路径。 market://search?q=pname:pkgname：市场数据格式，在Google Market里搜索包名为pkgname的应用。 geo://latitude, longitude：经纬数据格式，在地图上显示经纬度所指定的位置。 Intent利用Action属性和Data属性启动Android系统内置组件的代码： 拨打电话 Intent intent=new Intent(); intent.setAction(Intent.ACTION_CALL); //intent.setAction(\"android.intent.action.CALL\"); //以下各项皆如此，都有两种写法。 intent.setData(Uri.parse(\"tel:1320010001\")); startActivity(intent); //调用拨号面板： Intent intent=new Intent(); intent.setAction(Intent.ACTION_DIAL); intent.setData(Uri.parse(\"tel:1320010001\")); startActivity(intent); //调用拨号面板： Intent intent=new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.setData(Uri.parse(\"tel:1320010001\")); startActivity(intent); 利用Uri打开浏览器、打开地图等 Uri uri = Uri.parse(\"http://www.google.com\"); //浏览器 Uri uri=Uri.parse(\"geo:39.899533,116.036476\"); //打开地图定位 Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.setData(uri); startActivity(intent); Type Type属性用于指定Data所指定的Uri对应的MIME类型。MIME只要符合“abc/xyz”这样的字符串格式即可。 Intent利用Action、Data和Type属性启动Android系统内置组件的代码（播放视频）： Intent intent = new Intent(); Uri uri = Uri.parse(\"file:///sdcard/media.mp4\"); intent.setAction(Intent.ACTION_VIEW); intent.setDataAndType(uri, \"video/*\"); startActivity(intent); Extra Extras保存需要传递的额外数据。 通过intent.putExtra(键, 值)的形式在多个Activity之间进行数据交换 系统内置的几个Extra常量： EXTRA_BCC：存放邮件密送人地址的字符串数组。 EXTRA_CC：存放邮件抄送人地址的字符串数组。 EXTRA_EMAIL：存放邮件地址的字符串数组。 EXTRA_SUBJECT：存放邮件主题字符串。 EXTRA_TEXT：存放邮件内容。 EXTRA_KEY_EVENT：以KeyEvent对象方式存放触发Intent的按键。 EXTRA_PHONE_NUMBER：存放调用ACTION_CALL时的电话号码。 Intent利用Action、Data和Type、Extra属性启动Android系统内置组件的代码（调用发送短信的程序）： Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.setType(\"vnd.android-dir/mms-sms\"); intent.putExtra(\"sms_body\", \"信息内容...\"); startActivity(intent); //发送短信息 Uri uri = Uri.parse(\"smsto:13200100001\"); Intent intent = new Intent(); intent.setAction(Intent. ACTION_SENDTO ); intent.setData(uri); intent.putExtra(\"sms_body\", \"信息内容...\"); startActivity( intent ); //发送彩信,设备会提示选择合适的程序发送 Uri uri = Uri.parse(\"content://media/external/images/media/23\"); //设备中的资源（图像或其他资源） Intent intent = new Intent(); intent.setAction(Intent. ACTION_SEND ); intent.setType(\"image/png\"); intent.putExtra(\"sms_body\", \"内容\"); intent.putExtra(Intent.EXTRA_STREAM, uri); startActivity(it); 发送Email： Intent intent=new Intent(); intent.setAction(Intent. ACTION_SEND ); String[] tos={\"android1@163.com\"}; String[] ccs={\"you@yahoo.com\"}; intent.putExtra(Intent.EXTRA_EMAIL, tos); intent.putExtra(Intent.EXTRA_CC, ccs); intent.putExtra(Intent.EXTRA_TEXT, \"The email body text\"); intent.putExtra(Intent.EXTRA_SUBJECT, \"The email subject text\"); intent.setType(\"message/rfc822\"); startActivity(Intent.createChooser(intent, \"Choose Email Client\")); Intent intent = new Intent(Intent.ACTION_SEND); String[] tos = { \"mobileservice@ablesky.com\" }; intent.putExtra(Intent.EXTRA_EMAIL, tos); intent.putExtra(Intent.EXTRA_TEXT, getPhoneParameter()); intent.putExtra(Intent.EXTRA_SUBJECT, \"Android日志\"); intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(cacheDir)); intent.setType(\"message/rfc882\"); intent.setType(\"plain/text\"); Intent.createChooser(intent, \"请选择邮件发送软件\"); startActivity(intent); intent.setAction(android.provider.Settings.ACTION_SETTINGS); Flags Intent可调用addFlags()方法来为Intent添加控制标记 FLAG_ACTIVITY_CLEAR_TOP:（效果同Activity LaunchMode的singleTask） 如果在栈中已经有该Activity的实例，就重用该实例。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移除栈。如果栈中不存在该实例，将会创建新的实例放入栈中。 FLAG_ACTIVITY_SINGLE_TOP:（效果同Activity LaunchMode的singleTop） 如果在任务的栈顶正好存在该Activity的实例， 就重用该实例，而不会创建新的Activity对象。 FLAG_ACTIVITY_NEW_TASK: （效果类似Activity LaunchMode的singleInstance） FLAG_ACTIVITY_MULTIPLE_TASK FLAG_ACTIVITY_BROUGHT_TO_FRONT FLAG_ACTIVITY_RESET_TASK_IF_NEEDED 示例代码： Intent intent = new Intent(this, MainActivity.class); //将Activity栈中处于MainActivity主页面之上的Activity都弹出。 intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent); 如果依次启动了四个Activity：A、B、C、D。 在D Activity里，跳到B Activity，同时希望D 和 C 都finish掉，可以在startActivity(intent)里的intent里添加flags标记，如下所示： Intent intent = new Intent(this, B.class); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent); 这样启动B Activity的同时，就会把D、C都finished掉。 如果B Activity的launchMode是默认的“standard”，则B Activity会首先finished掉旧的B页面，再启动一个新的Activity B。 如果不想重新再创建一个新的B Activity，而是重用之前的B Activity，可以将B Activity的launchMode设置为“singleTask”。【特别需要注意的是：在部分手机中，如三星手机。即便是singleTask也会产生新的页面，而不是重用之前的页面。】 IntentFilter 定义 IntentFilter翻译成中文就是“意图过滤器”，主要用来过滤隐式意图。当用户进行一项操作的时候，Android系统会根据配置的 “意图过滤器” 来寻找可以响应该操作的组件，服务。 例如：当用户点击PDF文件的时候，Android系统就会通过设定好的意图过滤器，进行匹配测试。找到能够打开PDF文件的APP程序。 原理 Android系统会根据我们配置的Intent Filter（意图过滤器），来进行匹配测试。匹配的时候，只会考虑三个方面：动作、数据（URI以及数据类型）和类别。也就是说Android系统会进行“动作测试”，“数据测试”，“类别测试”，来寻找可以响应隐式意图的组件或服务。 另外，当对其他App程序开放组件和服务的时候也需要配置Intent Filter（意图过滤器），一个Activity可以配置多个。 动作测试 对应中的标签； 如果标签中有多个，那么Intent请求的Action，只要匹配其中的一条就可以通过了这条的动作测试。 如果中没有包含任何，那么无论什么Intent请求都无法和这条匹配。 如果Intent请求中没有设定Action(动作)，那么这个Intent请求就将顺利地通过的动作测试（前提是中必须包含有，否则与第二条冲突）。 类别测试 对应中的标签； Intent中的类别必须全部匹配中的，但是中多余的将不会导致匹配失败。 例如：Intent中有3个类别，而意图过滤器中定义了5个，如果Intent中的3个类别都与过滤器中的匹配，那么过滤器中的另外2个，将不会导致类别测试失败。 注意：有一个例外，Android把所有传给startActivity()的隐式意图当作他们包含至少一个类别：\"android.intent.category.DEFAULT\" （CATEGORY_DEFAULT常量）。 因此，想要接收隐式意图的活动必须在它们的意图过滤器中包含\"android.intent.category.DEFAULT\"。（带\"android.intent.action.MAIN\"和\"android.intent.category.LAUNCHER\"设置的过滤器是例外） 数据测试 对应中的标签； 元素指定了可以接受的Intent传过来的数据URI和数据类型，当一个意图对象中的URI被用来和一个过滤器中的URI比较时，比较的是URI的各个组成部分。 例如： 如果过滤器仅指定了一个scheme，所有该scheme的URIs都能够和这个过滤器相匹配； 如果过滤器指定了一个scheme、主机名但没有路经部分，所有具有相同scheme和主机名的URIs都可以和这个过滤器相匹配，而不管它们的路经； 如果过滤器指定了一个scheme、主机名和路经，只有具有相同scheme、主机名和路经的URIs才可以和这个过滤器相匹配。 当然，一个过滤器中的路径规格可以包含通配符，这样只需要部分匹配即可。 比较规则 一个既不包含URI也不包含数据类型的意图对象，仅在过滤器也同样没有指定任何URI和数据类型的情况下才能通过测试。 一个包含URI但没有数据类型的意图对象，仅在它的URI和一个同样没有指定数据类型的，过滤器里的URI匹配时才能通过测试。这通常发生在类似于mailto:和tel：这样的URIs上：它们并不引用实际数据。 一个包含数据类型但不包含URI的意图对象，仅在这个过滤器列举了同样的数据类型，而且也没有指定一个URI的情况下才能通过测试。 一个同时包含URI和数据类型（或者可从URI推断出数据类型）的意图对象可以通过测试，如果它的类型和过滤器中列举的类型相匹配的话。如果它的URI和这个过滤器中的一个URI相匹配或者它有一个内容content:或者文件file: URI，而且这个过滤器没有指定一个URI，那么它也能通过测试。换句话说，一个组件被假定为支持　”content: 数据“　和　“file: 数据”，如果它的过滤器仅列举了一个数据类型。 例如AndroidManifest.xml中有： 　　 　　 　　 　　 　　 对于中的action项可以有多个只要匹配其中一个就可以了 intent.setAction(\"com.nanlove.wangshiming\");//中的action也可以为wangshiming intent.addCategory(\"wangshiming.intent.category\")代码中的addCategory并不用写因为android他有默认的category 只要配置清单中存在就可以了. 没有 \"数据参数\"　的情况下只要意图对象中的设置动作和类别都出现在intent-filter就能跟filter匹配，但是有数据数据项一定要完全匹配。 当数据和数据类型 android:mimeType=\"text/plain\"同时存在的时候，不能使用intent.setData(Uri.parse(\"love://hao123.com:888/MM\")) ； 因为setData的方法会自动清除前面的数据类型：This method automatically clears any type that was previously set by setType； 所以后面的setType就无法匹配，应该使用intent.setDataAndType(Uri.parse(\"love://hao123.com:888/MM\"), \"text/plain\"); 提示：在同一个应用内，能使用显示意图，就尽量使用显示意图，增加程序的效率，理论上隐式意图匹配规则是需要花时间寻找的。 注意 getIntent() getIntent ()方法在Activity中使用，获得启动当前活动时的Intent内容。. 使用的时候要注意， 如果想每次启动Activity时使用此方法获得通过Intent传输的数据，要注意使用的启动模式。. 因为此时获得的Intent数据是在初始创建Activity时的赋值，如果使用standard启动模式则没有什么问题，但如果使用的是singleTask、singleTop等模式，若任务栈中（singleTask）或顶部（singleTop）存在该Activity，下次启动时则不会重新创建Activity（具体出入栈机制或四种启动模式详情请自行了解），所以此时获得的Intent仍为创建时的缓存数据。. 隐式启动问题及其变动 Android5.0之前 例子：使用隐式启动意图打开浏览器并显示网页，可以使用以下代码： javaCopy codeIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(\"http://www.example.com\")); startActivity(intent); Android5.0之后 在安卓5.0及其以上版本中，隐式启动意图的方式和之前的版本略有不同，主要表现在以下几个方面： 显式设置要启动的组件 在安卓5.0及其以上版本中，使用隐式启动意图时，需要显式地指定要启动的组件，即需要为意图设置一个明确的组件，这可以确保您的应用程序只能启动您指定的组件。 例如，要使用隐式意图启动名为com.example.activity.MainActivity的活动，可以使用以下代码： javaCopy codeIntent intent = new Intent(); intent.setComponent(new ComponentName(\"com.example\", \"com.example.activity.MainActivity\")); startActivity(intent); 这里的setComponent()方法为隐式意图设置了一个明确的组件，即名为com.example.activity.MainActivity的活动组件。 设置IntentFilter 在安卓5.0及其以上版本中，要使用隐式意图启动组件，必须在要启动的组件中设置IntentFilter。IntentFilter指定了可以处理特定操作的组件，可以为操作设置多个过滤器，并且可以在IntentFilter中指定要处理的数据类型。 例如，要启动能够处理ACTION_VIEW操作的浏览器活动，可以使用以下代码： 这里的intent-filter元素指定了能够处理ACTION_VIEW操作和具有http和https协议的数据类型的活动。通过设置IntentFilter，可以确保组件只会被正确的意图启动，并且可以在应用程序中进行正确的操作。 总之，隐式启动意图在安卓5.0及其以上版本中仍然可用，但需要显式指定要启动的组件，并为组件设置适当的IntentFilter。这种方式可以提高应用程序的安全性和稳定性。 Service不再可以被隐式启动，需要转换为显示启动 转换为显示启动：设置Action和packageName final Intent serviceIntent=new Intent(); serviceIntent.setAction(\"com.android.ForegroundService\"); serviceIntent.setPackage(getPackageName());//设置应用的包名 startService(serviceIntent); Android6.0之后 在安卓6.0及其以上版本中，与安卓5.0相比，隐式启动意图的方式基本保持不变。但是，安卓6.0引入了一些新的权限控制机制，需要在隐式启动意图中包含一些新的属性。 设置Package 在安卓6.0及其以上版本中，如果您的应用程序需要使用隐式意图启动其他应用程序的组件，您必须使用setPackage()方法显式地指定目标应用程序的包名。这可以确保您的应用程序只能启动您指定的应用程序，而不是启动任何具有相同包名的恶意应用程序。 例如，要使用隐式意图启动名为com.example.activity.MainActivity的活动，并确保它属于com.example应用程序，可以使用以下代码： javaCopy codeIntent intent = new Intent(); intent.setComponent(new ComponentName(\"com.example\", \"com.example.activity.MainActivity\")); intent.setPackage(\"com.example\"); startActivity(intent); 这里的setPackage()方法为隐式意图设置了目标应用程序的包名，即com.example。 请求权限 在安卓6.0及其以上版本中，访问某些敏感数据或执行某些敏感操作需要请求权限。如果您的应用程序需要使用隐式意图执行这些操作，则必须在AndroidManifest.xml文件中声明相应的权限，并在运行时请求该权限。如果您的应用程序没有请求所需的权限，则可能会发生安全问题或运行时错误。 例如，要使用隐式意图访问设备上的照片，您需要在AndroidManifest.xml文件中声明READ_EXTERNAL_STORAGE权限，并在运行时请求该权限，可以使用以下代码： javaCopy codeif (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_EXTERNAL_STORAGE}, REQUEST_CODE); } 这里的checkSelfPermission()方法用于检查是否已授予该权限，requestPermissions()方法用于请求该权限。如果用户授予了该权限，则您的应用程序可以使用隐式意图访问设备上的照片。 总之，在安卓6.0及其以上版本中，与安卓5.0相比，隐式启动意图的方式基本保持不变，但是需要在隐式启动意图中包含一些新的属性，例如setPackage()和请求权限等。这些属性可以提高应用程序的安全性和稳定性。 Android13.0之后 Intent 过滤器会屏蔽不匹配的 intent: 当您的应用向以 Android 13 或更高版本为目标平台的其他应用的导出组件发送 intent 时，仅当该 intent 与接收应用中的 元素匹配时，系统才会传送该 intent。不匹配的 intent 会被屏蔽 . 因此, 使用隐式intent的地方要注意. 注意：每一个通过 startActivity() 方法发出的隐式 Intent 都至少有一个 category，就是 “android.intent.category.DEFAULT”，所以只要是想接收一个隐式 Intent 的 Activity 都应该包括 “android.intent.category.DEFAULT” category，不然将导致 Intent 匹配失败。 显式Intent和隐式Intent的区别 显式Intent：通过Component可以直接设置需要调用的Activity类，可以唯一确定一个Activity，意图特别明确，所以是显式的。设置这个类的方式可以是Class对象（如SecondActivity.class），也可以是包名加类名的字符串（如\"com.example.app016.SecondActivity\"） 隐式Intent：即不是像显式的那样直接指定需要调用的Activity，隐式不明确指定启动哪个Activity，而是设置Action、Data、Category，让系统来筛选出合适的Activity。筛选是根据所有的来筛选。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-2.应用层-样式/Dialog.html":{"url":"04_Android/应用层/SDK/2-2.应用层-样式/Dialog.html","title":"Dialog","keywords":"","body":"Dialog对话框 提示对话框(AlertDialog) method1 method2(相对麻烦) 截图丢失 PopupWindow step1 创建PopupWindow对象实例 step2 设置背景、注册事件监听器和添加动画 step3 显示PopupWindow 自定义对话框 step1 设置自定义对话框样式-->dialog_layout.xml step2 设置style（去标题栏，去背景） step3 将第一步的布局应用到当前定义的对话框 step4 实例化对话框 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-2.应用层-样式/Jetpack.html":{"url":"04_Android/应用层/SDK/2-2.应用层-样式/Jetpack.html","title":"Jetpack","keywords":"","body":"Jetpack Jetpack介绍 什么是Jetpack？ Jetpack 是一个由多个库组成的套件，可帮助开发者遵循最佳做法，减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码，让开发者精力集中编写重要的代码。 Jetpack 是 Google 为解决 Android 开发碎片化，打造成熟健康生态圈提出的战略规划，是 Google 对 Android 未来提出的发展方向，同时它也是众多优秀 Android 组件的集合。 为何使用Jetpack 遵循最佳做法：Android Jetpack 组件采用最新的设计方法构建，具有向后兼容性，可以减少崩溃和内存泄露。 消除样板代码：Android Jetpack 可以管理各种繁琐的 Activity（如后台任务、导航和生命周期管理），以便您可以专注于打造出色的应用。 减少不一致：这些库可在各种 Android 版本和设备中以一致的方式运作，助您降低复杂性。 Jetpack的优势 Jetpack 拥有基于生命周期感知的能力，可以减少 NPE(空指针异常) 崩溃、内存泄漏，为开发出健壮且流畅的程序提供强力保障； Jetpack 可以消除大量重复样板式的代码，可以加速 Android 的开发进程，组件可搭配工作，也可单独使用，同时配合 Kotlin 语言特性能够显著提高工作效率； 统一开发模式，抛弃传统的 MVC, MVP； Jetpack构成 如上图：Jetpack 主要包括 4 个部分，分别是【Architecture：架构】、【UI：界面】、【Behavior：行为】和【Foundation：基础】。 Architecture：架构组件 目的：帮助开发者设计稳健、可测试且易维护的应用； Lifecycle：具备宿主生命周期感知能力的组件。特性：持有组件(如 Activity 或 Fragment)生命周期状态的信息，并且允许其他对象观察此状态； LiveData：新一代具备生命周期感知能力的数据订阅、分发的组件。特性：支持共享资源、支持黏性事件的分发、不再需要手动处理生命周期、确保界面符合数据状态； ViewModel：具备生命周期感知能力的数据存储组件。特性：页面因配置变更导致的重启，此时数据不丢失；可以实现跨页面(跨 Activity)的数据共享； SavedState：架构组件原理解析。特性：因内存不足，电量不足导致页面被回收时可以搭配 ViewModel 实现数据存储与恢复； Room：轻量级 orm 数据库，本质上是一个 SQLite 抽象层。特性：使用简单(类似于 Retrofit 库)，通过注解的方式实现相关功能，编译时自动生成相关实现类 DataBinding：只是一种工具，解决的是 View 和数据之间的双向绑定。特性：支持数据与视图双向绑定、数据绑定空安全、减少模板代码、释放 Activity/Fragment 压力； Paging: 列表分页组件，可以轻松完成分页预加载以达到无限滑动的效果。特性：巧妙融合 LiveData、提供多种数据源加载方式；不足之处：不支持列表数据增删改，列表添加 HeaderView，FooterView 定位不准确； Navigation：端内统一路由组件。特性：能够为 Activity，Fragment，Dialog，FloatWindow 提供统一的路由导航服务，可以传递参数，指定导航动画，还支持深度链接等主要能力；不足：十分依赖 xml 配置文件不利于组件化，模块化 WorkManager：新一代后台任务管理组件，service 能做的事情它都能做。特性：支持周期性任务调度、链式任务调度、丰富的任务约束条件、程序即便退出，依旧能保证任务的执行； Foundationy：基础组件 目的：提供横向功能，例如向后兼容性、测试、安全、Kotlin 语言支持，并包括多个平台开发的组件； Android KTX：优化了供 Kotlin 使用的 Jetpack 和 Android 平台 API，帮助开发者以更简洁、更愉悦、更惯用的方式使用 Kotlin 进行 Android 开发； AppCompat：帮助较低版本的 Android 系统进行兼容； Auto：开发 Android Auto 应用的组件，提供了适用于所有车辆的标准化界面和用户交互； 检测：从 AndroidStudio 中快速检测基于 Kotlin 或 Java 的代码； 多 Dex 处理：为具有多个 Dex 文件应用提供支持； 安全：安全的读写加密文件和共享偏好设置； 测试：用于单元和运行时界面测试的 Android 测试框架； TV：构建可让用户在大屏幕上体验沉浸式内容的应用； Wear OS：开发 Wear 应用的组件； Behavior：行为组件 目的：帮助开发者的应用与标准 Android 服务(如通知、权限、分享)相集成； CameraX：帮助开发简化相机应用的开发工作，提供一致且易于使用的界面，适用于大多数 Android 设备，并可向后兼容至 Android 5.0(API 21)； DownloadManager：处理长时间运行的 HTP 下载的系统服务； 媒体和播放：用于媒体播放和路由(包括 Google Cast)的向后兼容 API； 通知：提供向后兼容的通知 API，支持 Wear 和 Auto； 权限：用于检查和请求应用权限的兼容性 API； 设置：创建交互式设置，建议使用 AndroidX Preference Library 库将用户可配置设置集成到应用中； 分享操作：可以更轻松地实现友好的用户分享操作； 切片：切片是一种 UI 模板，创建可在应用外部显示应用数据的灵活界面元素； UI：界面组件 Animation and Transition：该框架包含用于常见效果的内置动画，并允许开发者创建自定义动画和生命周期回调； Emoji Compatibility：即便用户没有更新 Android 系统也可以获取最新的表情符号； Fragment：组件化界面的基本单位； 布局：用 XML 中声明 UI 元素或者在代码中实例化 UI 元素； 调色板：从调色板中提取出有用的信息； Jetpack应用架构 ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。 LiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-2.应用层-样式/MaterialDesign.html":{"url":"04_Android/应用层/SDK/2-2.应用层-样式/MaterialDesign.html","title":"Materialdesign","keywords":"","body":"Toolbar 一、简介 Toolbar 是在 Android 5.0 开始推出的一个 Material Design 风格的导航控件 ，Google 非常推荐大家使用 Toolbar 来作为Android客户端的导航栏，以此来取代之前的 Actionbar 。与 Actionbar 相比，Toolbar 明显要灵活的多。它不像 Actionbar 一样，一定要固定在Activity的顶部，而是可以放到界面的任意位置。 二、建立前提： 加入 appcompat 库 extend AppCompatActivity 设置主题 设置NoActionBar主题 或者在主题中设置属性 false true 在Activity中的onCreate()方法中，调用setSupportActionBar() 方法建立Toolbar @Override protected void onCreate(Bundle savedInstanceState) { setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); //... } 三、使用 为了方便Toolbar的调用，可以把Toolbar封装成一个单独的layout，并且在需要使用到它的时候在布局中include这个layout Toolbar的组成如下: 组成： Home：导航按钮，类型为ImageButton，可设置点击事件，用于返回上个页面或者滑出侧滑菜单为 Logo：Logo展示图，类型为ImageView，不响应事件，仅仅作为展示 Title：主标题 SubTitle：副标题 CustomView：标题和菜单之间是留给我们添加子View的区域 Menu/Action：负责管理选项菜单，菜单本身可以点击 属性： android:theme是ToolBar单独使用的主题 app:popupTheme是弹出来的菜单项使用的主题 app:titleTextAppearance 设置title text 相关属性，如：字体,颜色，大小等等 app:subtitleTextAppearance 设置subtitletext相关属性，如：字体,颜色，大小等等 app:logoDescription logo 描述 android:background Toolbar 背景 Toolbar使用的颜色： 颜色： 状态栏颜色(statusBarColor/colorPrimaryDark/)(只在api21及以上有效) 标题栏背景颜色(ToolBar/colorPrimary) 弹出菜单背景颜色(OptionMenu) 内容区域背景颜色(Background) 导航栏颜色(NavigationBar)(只在api21及以上有效) 标题文字颜色 (TitleBarTextColor/TextColorPrimary) 弹出菜单文字颜色(TextColor) 内容文字颜色(TextColor) 控件颜色(ColorAccent) 三、Toolbar的操作 使用getsupportactionbar()方法获得ActionBar对象，然后调用ActionBar的方法调整应用程序栏。例如，调用ActionBar.hide()方法隐藏应用程序栏。 添加操作按钮 Toolbar上所有的操作按钮和下拉条目都需要在menu中定义，res/menu/目录下新建一个xml文件，在该文件下定义Toolbar所需要的操作按钮，代码如下： ①app:showAsAction：指定了这个操作按钮是否显示在Toolbar上； always表示永远显示在ToolBar中，如果屏幕空间不够则不显示； ifRoom：如果Toolbar上有足够的空间，则在Toolbar上显示为一个操作按钮；如果没有足够的空间，则在下拉菜单列表中； never：设置操作按钮在下拉菜单中显示，而不在Toolbar中显示。 设置操作按钮的监听事件 在menu设置了显示在Toolbar上的item之后，需要把Toolbar和menu关联才能显示定义的item，重写Activity提供的onCreateOptionsMenu()方法可以关联Toolbar和menu。 @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main,menu); return true; } 这样，你就能在Toolbar上看到你关联的item了，然后重写onOptionsItemSelected()方法就可以对Toolbar的按钮设置监听。 @Override protected boolean onOptionsItemSelected(MenuItem item) { Intent intent; switch (item.getItemId()) { case R.id.action_favorite: // User chose the \"Favorite\" action, mark the current item // as a favorite... return true; case R.id.action_favorite: // User chose the \"Favorite\" action, mark the current item // as a favorite... return true; default: // If we got here, the user's action was not recognized. // Invoke the superclass to handle it. return super.onOptionsItemSelected(item); } } 添加Toolbar的返回按钮 setSupportActionBar(toolbar)之后getSupportActionBar().setDisplayHomeAsUpEnabled(true); @Override protected void onCreate(Bundle savedInstanceState) { setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); if(getSupportActionBar() != null) // Enable the Up button getSupportActionBar().setDisplayHomeAsUpEnabled(true); } //... } 对NavigationIcon设置点击监听 NavigationIcon就是左上角的那个默认是返回箭头的键的图标 binding.toolbar.setNavigationOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Toast.makeText(MainActivity.this,\"navigationOnClickListener\",Toast.LENGTH_SHORT).show(); } }); 自定义Toolbar弹出菜单的样式 首先定义菜单样式的theme false @color/material_deep_teal_500 5dp -2dp @color/white 在Theme中定义使用 ... @style/toolbarMenuStyle ... No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-2.应用层-样式/Menu.html":{"url":"04_Android/应用层/SDK/2-2.应用层-样式/Menu.html","title":"Menu","keywords":"","body":"Menu 历史 3.0以前：在Android3.0，当用户按“菜单”按钮时，选项菜单的内容会出现在屏幕底部，如图1所示,可包含多达6个菜单项，超出部分则以“更多”来显示。 3.0以后：在Android3.0及更高版本的系统中，选项菜单中的项目将出现在操作栏中，用户可以使用操作栏右侧的图标或者按设备的菜单键显示操作溢出菜单。 选项菜单（OptionMenu） 使用 step1 新建菜单资源文件 在Design模式下编辑 在Text模式下编辑 图片丢失 step2 在相应的Activity类下创建OptionMenu 属性 showAsAction always表示菜单内容显示在导航栏上 图片丢失 当有图标时默认只显示图标 withText表示不仅显示图标还显示文字 never表示不显示 ifRoom表示如果有足够的空间再显示 点击响应 注意 最多允许两级菜单 上下文菜单（ContextMenu） 使用：长按某个 view不放，就会在屏幕中间弹出ContextMenu 使用 step1 在Activity中注册 step2 在Activity中重写onCreateContextMenu方法 step3 重新onContextItemSelected方法进行菜单项的操作 step4 为按钮设置上下文操作模式 ①实现ActionMode CallBack ②在view的长按事件中去启动上下文操作模式 弹出菜单（PopupMenu） 使用：一个模态形势展示的弹出风格的菜单，绑定在某个View上，一般出现在被绑定的View的下方 使用 Menu创建方式的优缺点 option1 通过xml定义：菜单一般在res中创建menu目录放置资源文件 清晰的菜单结构 将菜单内容与应用的逻辑代码分离 资源适配更容易 option2 通过java定义 处理Menu显示问题 onCreateOptionsMenu()必须返回true，否则菜单不显示 onOptionsItemSelected()方法返回true，告诉系统此处的操作已经完成；同时在switch中添加default实现父类功能避免有些操作未完成 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-2.应用层-样式/Style.html":{"url":"04_Android/应用层/SDK/2-2.应用层-样式/Style.html","title":"Style","keywords":"","body":"全样式列表： https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/themes.xml ThemeOverlay使用特点 当在某个Activity有些特殊要求的时候就可以用ThemeOverlay继承全局的样式,来修改自己的个性化样式,注意了该样式的引用只能设置在布局文件上,不能在清单文件里面进行设置 定义: @color/colorPrimary 调用: android:background=\"@color/dark_background\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark\"> 单独给toolbar设置样式 自定义样式属性 首先在attrs.xml 定义属性名称 在style.xml中使用自定义的属性 false true #2a2a2a 1dp @android:color/transparent 在布局文件中引用样式 自定义一个tootbar的样式 定义一个NoActionBar的样式 false true #6a1b9a #ec407a #f44336 布局中引人Toolbar 在Activity中设置Toobar为ActionBar public class TestAppComActivity extends AppCompatActivity{ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_testappcompat); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); } } No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-2.应用层-样式/Theme.html":{"url":"04_Android/应用层/SDK/2-2.应用层-样式/Theme.html","title":"Theme","keywords":"","body":"设置位置 AndroidManifest.xml中可以对application、activity添加android:theme属性设置主题 在src/res/values/themes.xml 在Activity的onCreate()中，在setContentView之前设置 protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setTheme(android.R.style.Theme_Light); setContentView(R.layout.linear_layout_3); } 作用域 application跟activity application中设置，这个就是全局的，如果你不再单独的重新为你要设置的activity设置一个主题，那么这个activity的主题就是“@style/AppTheme”这个主题 activity中设置，可以看到MainActivity这个activity就被单独的设置了一个主题为：@style/AppTheme.mytheme 主题与风格的联系与区别 style和theme:是一个包含一种 或者 多种格式化 属性 的集合 ,并且 style和theme都是资源,存放在res/values 文件夹下。 style:View级别的,只能在某个Activity的布局文件中使用 Theme:应用级别的,你必须在AndroidManifest.xml中的\\\"或者\\中使用 在定义Theme的时候@符号和?符号的区别 @符号表明我们引用的资源是前边定义过的(或者在前一个项目中或者在Android 框架中)。问号？表明 我们引用的资源的值在当前的主题当中定义过 AppTheme主题颜色 colorPrimary App Bar 的背景色,即 ActionBar,通常也是一个 App 的主题色调。不过 ActionBar 已经退出历史舞台,由 Toolbar 代替使用,但是 Toolbar 需要在 layout 文件中单独使用 background 属性设置背景色,如: colorPrimaryDark status bar(状态栏)背景色。仅作用于 Lollipop 及更高版本。 colorAccent 许多控件在选中状态或获取焦点状态下使用这个颜色,常见有: CheckBox:checked 状态 RadioButton:checked 状态 SwitchCompat:checked 状态 EditText:获取焦点时的 underline 和 cursor 颜色 TextInputLayout:悬浮 label 字体颜色 android:navigationBarColor navigation bar 背景色。仅作用于 Lollipop 及更高版本。 colorControlNormal 某些 Views \"normal\" 状态下的颜色,常见如:unselected CheckBox 和 RadioButton,失去焦点时的 EditText,Toolbar 溢出按钮颜色,等等。 colorControlActivated 某种程度上,是 colorAccent 的替代者,比如对于 CheckBox 和 RadioButton 的 checked 状态,colorControlActivated 属性会覆盖 colorAccent 属性的对应颜色。 colorControlHighlight 所有可点击 Views 触摸状态下的 Ripple(涟漪)效果。仅作用于 Lollipop 及更高版本。 colorButtonNormal Button normal 状态下的背景色。注意,这种设置与 Button 的 android:background 属性改变背景色不同的是,前者在 Lollipop 及更高版本上会让 Button 依旧保持阴影和 Ripple 触摸效果。 android:windowBackground 窗口背景色,诸如此类的还有:android:background,android:colorBackground 等。 android:textColorPrimary EditText 的 text color,等等文本颜色。 navigationIcon 返回按钮的图片 常见的主题与风格 android:theme=\"@android:style/Theme.Dialog\" 将一个Activity显示为能话框模式 android:theme=\"@android:style/Theme.NoTitleBar\" 不显示应用程序标题栏 android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\" 不显示应用程序标题栏,并全屏 android:theme=\"Theme.Light\" 背景为白色 android:theme=\"Theme.Light.NoTitleBar\" 白色背景并无标题栏 android:theme=\"Theme.Light.NoTitleBar.Fullscreen\" 白色背景,无标题栏,全屏 android:theme=\"Theme.Black\" 背景黑色 android:theme=\"Theme.Black.NoTitleBar\" 黑色背景并无标题栏 android:theme=\"Theme.Black.NoTitleBar.Fullscreen\" 黑色背景,无标题栏,全屏 android:theme=\"Theme.Wallpaper\" 用系统桌面为应用程序背景 android:theme=\"Theme.Wallpaper.NoTitleBar\" 用系统桌面为应用程序背景,且无标题栏 android:theme=\"Theme.Wallpaper.NoTitleBar.Fullscreen\" 用系统桌面为应用程序背景,无标题栏,全屏 android:theme=\"Translucent\" 半透明 android:theme=\"Theme.Translucent.NoTitleBar\" 半透明、无标题栏 android:theme=\"Theme.Translucent.NoTitleBar.Fullscreen\" 半透明、无标题栏、全屏 android:theme=\"Theme.Panel\" android:theme=\"Theme.Light.Panel\" AOSP中的主题列表 在以下连链接中查找：https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values themes.xml：Android 4.0 以前使用的默认主题 themes_holo.xml： Android 4.0 ~ Android 4.4 使用的默认主题 themes_materials.xml：Android 5.0 之后使用的默认主题 theme_device_defaults.xml：该文件的开头注释中写了如下文字，意思是，该文件中包含设备默认使用的主题，如果想修改系统默认主题，应该修改该文件，而不是 themes.xml 文件。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-2.应用层-样式/View-others.html":{"url":"04_Android/应用层/SDK/2-2.应用层-样式/View-others.html","title":"View-others","keywords":"","body":"View ProgressBar 【属性】 progress=\"\" //设置进度 max=\"\" //设置最大值，默认100 indeterminate=\"true\" //设置进度条一直滚动 ImageView 【属性】 scaleType //fitXY∶撑满控件，宽高比可能发生改变 //fitCenter:保持宽高比缩放，直至能够完全显示 //centerCrop∶保持宽高比缩放，直至完全覆盖控件，裁剪显示 android:rotation //旋转角度，可以设置正值负值，代表顺时针或逆时针 //还有rotationX、rotationY android:adjustViewBounds=\"true\" //解决旋转后边距问题 //https://blog.csdn.net/u011622280/article/details/110111667 contentDescription //一个ImageView里面放置一张颜色复杂的图片，可能一些色弱色盲的人，分不清这张图片中画的是什么东西。如果用户安装了辅助浏览工具比如TalkBack, TalkBack就会大声朗读出用户目前正在浏览的内容。TextView控件TalkBack可以直接读出里面的内容，但是ImageView TalkBack就只能去读contentDescription的值，告诉用户这个图片到底是什么。 //https://blog.csdn.net/TrineaShao/article/details/72459538 ImageButton FloatingActionButton 【支持库】 android.support.design.widget.FloatingActionButton compile 'com.android.support:design:25.3.1' 【属性】 //设置不同的图片 android:src=\"\" mFAButton.setImageResource(R.drawable.ic_action); //设置Fab的背景内容 //设置背景颜色 app:backgroundTint=\"\"，FloatingActionButton的颜色是跟随主题中的 colorAccent属性的 注意要使用自定义命名空间xmlns:app=\"http://schemas.android.com/apk/res-auto\"，因为FloatingActionButton重写了继承自View的android:backgroundTint属性，使用android:backgroundTint改变背景颜色会导致Fab四周有一个用colorAccent颜色填充的圆环。 产生涟漪效果，记得设置属性android:clickable=\"true\"。 默认的背景颜色是所使用主题的colorAccent颜色。 mFAButton.setBackgroundTintList(ColorStateList.valueOf(Color.parseColor(\"#FF13C6DA\"))); //设置Fab的背景颜色 app:borderWidth=\"0dp\" 在5.0之前，FloatingActionButton距离底部会有一个间隔，在5.0之后就没有了，解决方法就是设置以上属性 app:fabSize 为了符合Material Design的设计风格，Google给出了FloatingActionButton的三种大小值：mini、normal、auto。 auto：FloatingActionButton的大小会根据屏幕的大小自己改变，对于小屏幕设备（最大屏幕尺寸小于470 dp）会使用mini尺寸，比这个更大的屏幕会使用normal尺寸。 mFAButton.setSize(FloatingActionButton.SIZE_AUTO); // 设置Fab的大小 app:elevation=\"6dp\" 为了有投影悬浮效果，为FloatingActionButton设置一个高度值。 高度值越大，投影效果越淡，投影范围越大。 高度值越小，投影效果越浓，投影范围越小。 //设置FloatingActionButton的高度值，产生相应的阴影效果 mFAButton.setCompatElevation(5.0F); app:rippleColor 为了符合Material Design的设计风格，为了使可点击的选项给用户反馈，点击时会有水波纹扩散的效果。 默认值是灰色的水波纹效果。 如果设置rippleColor没有效果，记得设置属性android:clickable=\"true\"。 mFAButton.setRippleColor(Color.parseColor(\"#FFFFFFFF\")); //设置涟漪效果颜色 app:pressedTranslationZ=\"10dp\" 设置阴影的点击效果。与elevation控制的同一地方的阴影，不过elevation是非按压时的阴影效果，而pressedTranslationZ是点击按钮时阴影的效果（按钮被按压了，阴影当然也要随着变化啦）。 值越大，按下时阴影范围越大。这个值一般默认就好。 app:useCompatPadding=\"true\" 这个属性会让FloatingActionButton自己调整内边距。不过在5.0系统上设置此属性会导致按压时产生方形阴影效果，影响美观度。一般用android:layout_margin属性调整即可。 TextView TextView类似于Swing中的JLabel ,能完成的效果: 对长文本进行显示处理 支持Html代码 内容有样式、链接效果 android:includeFontPadding = \"false\" Google为了显示上下标而给TextView预设的padding，将这个属性设置为false即可去除padding（默认为true），实现文本的上对齐与下对齐 /**自动调整字体大小**/ android:autoSizeTextType： 自动调整大小的类型，取值none（0，不自动缩放，默认）或者uniform（1，水平和垂直均匀缩放文本大小适应容器），注意：这个功能不适用与EditText，仅仅TextView有效 android:autoSizeMaxTextSize： 自动调整文本大小的最大值，可用的单位有：px（pixels），dp（density-independent pixels），sp（scaled pixels based on preferred font size），in（inches），还有mm（millimeters） android:autoSizeMinTextSize： 自动调整文本大小的最小值，可用的单位有：px（pixels），dp（density-independent pixels），sp（scaled pixels based on preferred font size），in（inches），还有mm（millimeters） android:autoSizePresetSizes： 预设定的尺寸数组（类型为uniform时生效），会autoSizeStepGranularity属性覆盖 android:autoSizeStepGranularity： 自动调整字体大小的阶级（类型为uniform时生效），默认1px，会被autoSizePresetSizes属性覆盖 //关于字体大小使用sp?dp? 如果使用dp则设置系统字体大小的时候app内的字体大小不变，使用sp则改变，一般实际开发中使用dp，防止布局错位，然后在app内提供设置字体大小的功能 Button 【属性】 textAllCaps//是否全为大写 CompoundButton RadioButton 【属性】 android:orientation=\"vertical\" //设置内部空间的排列方向，水平或竖直 android:buttonTint=\"@color/...\" //设置选中按钮的颜色 CheckBox EditText 【输入类型】 android:inputType=”none” android:inputType=”text” android:inputType=”textCapCharacters” 字母大写 android:inputType=”textCapWords” 首字母大写 android:inputType=”textCapSentences” 仅第一个字母大写 android:inputType=”textAutoCorrect” 自动完成 android:inputType=”textAutoComplete” 自动完成 android:inputType=”textMultiLine” 多行输入 android:inputType=”textImeMultiLine” 输入法多行（如果支持） android:inputType=”textNoSuggestions” 不提示 android:inputType=”textUri” 网址 android:inputType=”textEmailAddress” 电子邮件地址 android:inputType=”textEmailSubject” 邮件主题 android:inputType=”textShortMessage” 短讯 android:inputType=”textLongMessage” 长信息 android:inputType=”textPersonName” 人名 android:inputType=”textPostalAddress” 地址 android:inputType=”textPassword” 密码 android:inputType=”textVisiblePassword” 可见密码 android:inputType=”textWebEditText” 作为网页表单的文本 android:inputType=”textFilter” 文本筛选过滤 android:inputType=”textPhonetic” 拼音输入 //数值类型 android:inputType=”number” 正整数 android:inputType=”numberSigned” 带符号数字格式 android:inputType=”numberDecimal” 带小数点的浮点格式 android:inputType=”phone” 拨号键盘 android:inputType=”datetime” 时间日期 android:inputType=”date” 日期键盘 android:inputType=”time” 时间键盘 【大小设置】 ①layout_width和layout_height layout_width告诉父容器EditText需要的宽度，layout_height则设置需要的高度。单位建议为dp，关于Android中单位转换问题可以参考Android根据分辨率进行单位转换-(dp,sp转像素px)。 ②minWidth/maxHeight和minHeight/maxHeight 这些属性用来动态的限制EditText的大小，应用场景有如下几种情况： 1)在没有内容情况下，通过min系列保证控件的最小宽高，保持界面整体美观。 2)在内容过多情况下，使用max系列来限制控件大小，确保不影响界面上的其他控件。 PS：还可以使用minLines和maxLines来限制内容显示的行数。 ③ems、minEms和maxEms ems指的是字体的宽度。此属性在Android中用来设置EditText的宽度，即设置EditText为n个字符的宽度。 PS：android:layout_width必须为wrap_content,否则ems将无效。 ④Android取消EditText自动获取焦点默认行为 在项目中，一进入一个页面, EditText默认就会自动获取焦点,很是郁闷，Android 如何让EditText不自动获取焦点？ 在EditText的父级控件中找一个，设置成 android:focusable=\"true\" android:focusableInTouchMode=\"true\" 这样，就把EditText默认的行为截断了！ 【自定义样式】 光标 step1 在drawable目录下自定义光标文件(一般为shape文件)，比如以下文件为:text_cursor.xml step2 在xml 中给edittext设置属性 android:textCursorDrawable=\"@drawable/text_cursor\" step3 设置光标位置 android:gravity=\"left\" //光标位于最开始位置 android:gravity=\"center\" //光标位于中间位置 【监听器】 view.addTextChangedListener(new TextWatcher()) 监听用户输入完成 常见问题 不显示输入文本和光标 原因：文本光标太大从edittext中跑出去了 解决：将edittext的高度设置为wrap_content 【注意】 点击屏幕其他地方让EditText失去焦点并隐藏输入法 https://blog.csdn.net/rongwenbin/article/details/51151244 SurfaceView SurfaceView与View区别 1.不使用onDraw 2.非UI线程绘制 3.独立的Surface 使用SurfaceView 1.利用SurfaceHolder监听Surface创建完毕 2.开启异步线程进行while循环 3.通过SurfaceHolder获取Canvas进行绘制 SurfaceView的具体使用场景 1.视频播放 2.一些炫酷的动画效果 3.小游戏 ViewGroup 【含义】 这是 Android 中所有布局控件的基类，它可以容纳其他视图，并决定它们的位置和大小。 【常用方法】 addView(); addView(View child);// child-被添加的View addView(View child, int index);// index-被添加的View的索引,最初的index为0 addView(View child, int width, int height);// width,height被添加的View指定的宽高 addView(View view, ViewGroup.LayoutParams params);// params被添加的View指定的布局参数 addView(View child, int index, LayoutParams params); ①在LinearLayout中的使用 在线性布局中，我们调用addView(View child)方法时，会在指定的方向的最后一个View的下面添加上child这个View，也就是说被添加的View的索引总是等于容器中当前子View的个数 当我们为添加的View指定了index后，我们被添加的View就会被添加到容器中指定的索引位置处，并把之前的View(包括此View后面的View)全部向后“挤”了一位 index我们可不可以随意定义呢？答案当然是不可以了。凡事都要讲究一个顺序嘛，总不能原来容器中只有2个子View，最大的索引才是1，你就一下子想把添加的View指定到索引10吧。因此，在我们向指定索引的时候，我们应当先做一个判断，确保我们指定的index不能大于当前容器内View的总数量 ②在RelativeLayout中的使用 AdapterView 【含义】 一个适配器视图控件的基类，它可以与适配器进行交互，并支持选项卡式导航，如 TabHost 和 ViewPager 等。 AbsSpinner（abstract） 【含义】 AbsSpinner 是一个抽象类，提供了一些 Spinner 所需的共同行为，如子项的点击事件处理和数据绑定等。 Spinner 【含义】 Spinner 是一个下拉列表控件，用于让用户从多个选项中选择一个。 Spinner 继承了 AbsSpinner 的大部分功能，如支持适配器（Adapter）和选择事件监听器（OnItemSelectedListener）。 【使用方法】 具体：https://cloud.tencent.com/developer/article/1678861 静态使用： 在res文件夹下新建array.xml > 在其中添加选项字符串 > 在布局的spinner中添加 android:entries=\"@array/准备的字符串序列\" 动态使用： 创建一个Adapter，传入context（在Activity中传入this）和layout 调用adapter.add()添加项目 调用spinnerItems.setAdapter(adapter)将adapter绑定到控件 静态+动态使用： 创建一个Adapter，传入context（在Activity中传入this）、layout、静态字符串数组 调用adapter.setDropDownViewResource(layout)传入layout 调用spinnerItems.setAdapter(adapter)将adapter绑定到控件 AbsListView GridView ListView 【含义】 ListView 是一个支持滚动列表的视图控件，它可以在有限的屏幕空间中显示大量数据，并支持滚动。ListView 继承了 AbsListView 的大部分功能，如支持滚动、分割线和选项菜单等。 适配器 ArrayAdapter SimpleAdapter //左边:头像右上:名字右下:心情 Map map1 = new HashMap<>(); map1.put(\"img\", R.mipmap.caocad); map1.put(\"name\", \"曹操\"); map1.put(\"mood\", \"宁教我负天下人,休教天下人负我\"); Map map2 = new HashMap<>(); map2.put(\"img\", R.mipmap.zhenji); map2.put(\"name\", \"甄姬\"); map2.put(\"mood\", \"飘摇兮若流风之回雪。仿佛兮若轻云之蔽月\"); Map map3 = new HashMap<>(); map3.put(\"img\", R.mipmap.zhenji); map3.put(\"name\", \"甄姬\"); map3.put(\"mood\", \"飘摇兮若流风之回雪,仿佛兮若轻云之蔽月\"); String[] from = {\"img\", \"name\", \"mood\"}; int[] to = {R.id.qq_img, R.id.qq_name, R.id.qq_mood}; //参数1:上下文 //参数2:Map //参数3:每一项布局 //参数4:数据来源的key数组 //参数5:数据去向的id数组 //参数45对应索引上，from数组的元素代码数据源每个map的key， //该key所指代的数据会作为to数组对应索引上id所代表的控件的内容显示处理 SimpleAdapter adapter = new SimpleAdapter(this, data, R.layout.item3, from, to); //点击事件 listView2.setOnItemClickListener(new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView adapterView, View view, int i, long l) { //用Toast提示Name· Mood Map map = data.get(i); String name = map.get(\"name\").toString(); String mood = map.get(\"mood\").toString(); Toast.makeText(SimpleActivity.this, name + \". \" + mood, Toast.LENGTH_SHORT), show(); }); } 【属性】 Android:divider=”@null”;//去除分割线 【方法】 //设置listview自动显示到最新数据 listview,setTranscriptMode(AbsListView.TRANSCRIPT_MODE_ALWAYS_SCORLL) 【优化】 在getView方法中 if(view==null){ Log.e(\"TAG\",\"=========\"+i); //优化1:利用进入RecyclerBin中的View,减少读view的赋值 view = LayoutInflater.from(ctx).inflate(R.layout.item,null); } 定义内部类ViewHolder,将需要保存的视图声明为公开的属性 保存：当view为空时，完成对viewHolder的实例化工作，并为各个控件属性赋值 使用的时机：什么时候都要用，性能的提升在view不为空时体现 使用的方法：当view为null时，完成了ViewHolder及内部控件属性的初始化工作后，调用一句代码view.setTag(holder);当view不为null时，holder=(ViewHolder)view.getTag(); ViewHolder holder; if(view==null){ Log.e(\"TAG\",\"=====\"+i); //优化1:利用进入RecyclerBin中的View,减少读view的赋值 view = LayoutInflater.from(ctx).inflate(R.layout.item,null); holder = new ViewHolder(); holder.profile = view.findViewById(R.id.profile); holder.nickname=view.findViewById(R.id.nickname); holder.content = view.findViewById(R.id.content); ... view.setTag(holder); }else{ //通过getTag()取出ViewHolder对象，然后能够直接通过holder.控件的方式在外面直接操作控件 //从而避免了大幅度使用findViewById操作 //而事实上，getTag()本身操作效率高 holder = (ViewHolder)view.getTag(); } ListView的优化(以异步加载Bitmap优化为例) 首先概括的说ListView优化分为三级缓存: 内存缓存 文件缓存 网络读取 简要概括就是在getView中，如果加载过一个图片，放入Map类型的一个MemoryCache中(示例代码使用的是Collections.synchronizedMap(new LinkedHashMap(10, 1.5f, true))来维护一个试用LRU的堆)。如果这里获取不到，根据View被Recycle之前放入的TAG中记录的uri从文件系统中读取文件缓存。如果本地都找不到，再去网络中异步加载。 这里有几个注意的优化点： 从文件系统中加载图片也没有内存中加载那么快，甚至可能内存中加载也不够快。因此在ListView中应设立busy标志位，当ListView滚动时busy设为true，停止各个view的图片加载。否则可能会让UI不够流畅用户体验度降低。 文件加载图片放在子线程实现，否则快速滑动屏幕会卡 开启网络访问等耗时操作需要开启新线程，应使用线程池避免资源浪费，最起码也要用AsyncTask。 Bitmap从网络下载下来最好先放到文件系统中缓存。这样一是方便下一次加载根据本地uri直接找到，二是如果Bitmap过大，从本地缓存可以方便的使用Option.inSampleSize配合Bitmap.decodeFile(ui, options)或Bitmap.createScaledBitmap来进行内存压缩 **原博文有非常好的代码示例: Listview异步加载图片之优化篇（有图有码有解释）非常值得看看。 此外Github上也有仓库：https://github.com/geniusgithub/SyncLoaderBitmapDemo ExpandableListView 这是 Android 中所有布局控件的基类，它可以容纳其他视图，并决定它们的位置和大小。 ExpandableListView 继承了 ListView 的大部分功能，如支持适配器（Adapter）和选择事件监听器（OnItemClickListener）。 图片丢失 常用属性 groupIndicator=\"@drawable/xxxxxxxxx\" 展开和收缩的时候分别展示不同的图标 childIndicator=\"@drawable/xxxxxx\" 每个子列表展示的图标 childDivider=“@color/xxxxxxxxx\" 每个子列表的分割线 常用方法 setAdapter(ExpandableListAdapter); setOnGroupClickListener(); setOnChildClickListener(); setOnGroupCollapseListener(); setOnGroupExpandListener(); GridLayout 【属性】 android:rowCount//行数量 android:columnCount//列数量 android:layout_row//位于第几行 android:layout_rowSpan//跨几行 【例子】 MapView LinearLayout 【排列方式】 分为vertical和horizontal两种，当控件有2个及2个以上式必须设置排列方式 【摆放位置】 gravity，当前控件是父控件，属性针对父控件内部的子控件的拜访。 如果是容器，则针对的是容器里面子view的摆放；如果是控件，则针对的是控件里面内容的摆放。 layout_gravity，当前控件是子控件，属性针对当前控件在父控件里面的摆放位置。 不过需要注意的一点是父控件设置的gravity的级别要低于子控件设置的layout_gravity。 【权重】 layout_weight，按比例来分配控件占用父控件的大小。 RelativeLayout 【常用属性】 1.与兄弟控件的关系——方向位置 android:layout_above=\"@id/xxx\" --将控件置于给定ID控件之上 android:layout_below=\"@id/xxx\" --将控件置于给定ID控件之下 android:layout_toLeftOf=\"@id/xxx\" --将控件的右边缘和给定ID控件的左边缘对齐（将控件置于给定ID控件之左） android:layout_toRightOf=\"@id/xxx\" --将控件的左边缘和给定ID控件的右边缘对齐（将控件置于给定ID控件之右） 2.与兄弟控件的关系——方向对齐 android:layout_alignLeft=\"@id/xxx\" --将控件的左边缘和给定ID控件的左边缘对齐 android:layout_alignTop=\"@id/xxx\" --将控件的上边缘和给定ID控件的上边缘对齐 android:layout_alignRight=\"@id/xxx\" --将控件的右边缘和给定ID控件的右边缘对齐 android:layout_alignBottom=\"@id/xxx\" --将控件的底边缘和给定ID控件的底边缘对齐 3.与父控件的关系——边缘对齐 android:layout_alignParentLeft=\"true\" --将控件的左边缘和父控件的左边缘对齐 android:layout_alignParentTop=\"true\" --将控件的上边缘和父控件的上边缘对齐 android:layout_alignParentRight=\"true\" --将控件的右边缘和父控件的右边缘对齐 android:layout_alignParentBottom=\"true\" --将控件的底边缘和父控件的底边缘对齐 4.与父控件的关系——居中对齐 android:layout_centerInParent=\"true\" --将控件置于父控件的中心位置 android:layout_centerHorizontal=\"true\" --将控件置于水平方向的中心位置 android:layout_centerVertical=\"true\" --将控件置于垂直方向的中心位置 5.相对于基准线位置： android:layout_alignBaseline=”@id/xxx” --以两控件字体下方的线对齐(针对英文) 6、头部尾部对齐（版本4.2以上的新属性） android:layout_alignStart=”@id/xxx” --将控件对齐给定ID控件的头部 android:layout_alignEnd=”@id/xxx” --将控件对齐给定ID控件的尾部 android:layout_alignParentStart=true --将控件对齐到父控件的头部 android:layout_alignParentEnd=true --将控件对齐到父控件的尾部 RadioGroup TableLayout 【属性】 android:stretchColumns=\"1,2”//设置可伸展的列 android:shrinkColumns=\"1,2”//设置可收缩的列 android:collapseColumns=\"0,1”//设置可隐藏的列 【注意】 如果直接在TableLayout中添加控件﹐那么控件将和父容器等宽如果想让控件出现在同一行﹐那么这些控件的外层一定要加一对在TableRow中的控件﹐宽度都是默认wrap_content FrameLayout 重要属性 android:layout_gravity//控件重力 android:foreground//前景 android:foregroundGravity//前景重力 ScrollView ScrollView的子元素只能有一个，可以是一个View（如ImageView、TextView等） 也可以是一个ViewGroup（如LinearLayout、RelativeLayout等），其子元素内部则不再限制，否则会报异常。 【常用属性】 android:fadingEdge=\"none\" 设置拉滚动条时，边框渐变的方向。none（边框颜色不变），horizontal（水平方向颜色变淡），vertical（垂直方向颜色变淡）。 android:overScrollMode=\"never\" 删除ScrollView拉到尽头（顶部、底部），然后继续拉出现的阴影效果，适用于2.3及以上的 否则不用设置。 android:scrollbars=\"none\" 设置滚动条显示，none（隐藏），horizontal（水平），vertical（垂直）。 android:descendantFocusability=\"\" 该属性是当一个为view获取焦点时，定义ViewGroup和其子控件两者之间的关系。 属性的值有三种： beforeDescendants //viewgroup会优先其子类控件而获取到焦点 afterDescendants //viewgroup只有当其子类控件不需要获取焦点时才获取焦点 blocksDescendants //viewgroup会覆盖子类控件而直接获得焦点 android:fillViewport=“true\" 这是 ScrollView 独有的属性，用来定义 ScrollView 对象是否需要拉伸自身内容来填充 viewport。通俗来说，就是允许ScrollView去填充整个屏幕。比如ScrollView嵌套的子控件高度达不到屏幕高度时，虽然ScrollView高度设置了match_parent，也无法充满整个屏幕，需设置android:fillViewport=“true\"使ScrollView填充整个页面，给ScrollView设置背景颜色就能体现。 【常用方法】 //滑动开关控制 scrollView.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View view, MotionEvent motionEvent) { // true禁止滑动 false可滑动 return true; } }); //滑动位置控制 scrollView.post(new Runnable() { @Override public void run() { //滑动到顶部 scrollView.fullScroll(ScrollView.FOCUS_UP); //滑动到底部 scrollView.fullScroll(ScrollView.FOCUS_DOWN); } }); //滑动到某个位置 scrollView.post(new Runnable() { @Override public void run() { //偏移值 int offset = 100; scrollView.smoothScrollTo(0, offset); } }); CardView Z轴的概念 Z属性可以通过elevation和translationZ进行修改 Z＝ elevation＋translationZ android:elevation=\" \" 设置该属性使控件有一个阴影，感觉该控件像是“浮”起来一样，达到3D效果 android:translationZ=\"\" 设置该组件阴影在Z轴（垂直屏幕方向）上的位移 在5.0之前，我们如果想给View添加阴影效果，以体现其层次感，通常的做法是给View设置一个带阴影的背景图片. 在5.0之后，我们只需要简单的修改View的Z属性，就能让其具备阴影的层次感，不过要求版本至少5.0 Lollipop,也就是API21. 在Android Design Support Library和support -v7中一些组件已经封装好了Z属性，不需要5.0 就可以使用. 像FloatingActionButton就可以通过app:elevation=\" \"使用Z属性，CardView可以通过app:cardElevation=\" \" 来使用. 【属性】 app:cardCornerRadius=\"\"//卡片边角半径 app:cardBackgroundColor=\" \"//设置背景颜色,直接设置android:background=\" \"无效 app:contentPadding=\" \"//设置padding,直接设置android:padding=\" \"无效 app:contentPaddingTop=\" \" app:contentPaddingBottom=\" \" app:contentPaddingLeft=\" \" app:contentPaddingRight=\" \" app:cardElevation=\"\"//卡片的阴影实际宽度，大家都知道 Material Design 就是引入了材质厚度的概念。实际就是通过投射阴影的原理实现这种视觉效果。 app:cardMaxElevation=\" \"//设置Z轴的最大高度 app:cardPreventCornerOverlap=\"\"//设置是否圆角重叠。 android:foreground=\"?android:attr/selectableItemBackground\"//设置点击了之后的涟漪效果 如果你的CardView是可点击的，可以通过foreground属性使用系统定义好的RippleDrawable: selectableItemBackground，从而达到在5.0及以上版本系统中实现点击时的涟漪效果（Ripple）。涟漪效果在5.0以上版本中才能展示，在低版本上是一个普通的点击变暗的效果 兼容问题 https://www.jianshu.com/p/b105019028b6 AbsoluteLayout WebView 基于webkit内核（Chromium) ConstraintLayout 【添加依赖】 implementation 'com.android.support.constraint:constraint-layout:1.1.3' 【常用属性】 layout_constraintLeft_toLeftOf //此控件的左边与另一个控件的左边对齐 layout_constraintLeft_toRightOf //此控件的左边与另一个控件的右边对齐 layout_constraintRight_toLeftOf //此控件的右边与另一个控件的左边对齐 layout_constraintRight_toRightOf //此控件的右边与另一个控件的右边对齐 layout_constraintTop_toTopOf //此控件的顶部与另一个控件的顶部对齐 layout_constraintTop_toBottomOf //此控件的顶部与另一个控件的底部对齐 layout_constraintBottom_toTopOf //此控件的底部与另一个控件的顶部对齐 layout_constraintBottom_toBottomOf //此控件的底部与另一个控件的底部对齐 layout_constraintStart_toEndOf //此控件的开始与另一控件的结束对齐 layout_constraintStart_toStartOf //此控件的开始与另一控件的开始对齐 layout_constraintEnd_toStartOf //此控件的结束与另一控件的开始对齐 layout_constraintEnd_toEndOf //此控件的结束与另一控件的结束对齐 文本对齐 layout_constraintBaseline_toBaselineOf //此控件的基本线与另一个控件的基本线对齐(见下) 角度定位 上面例子中的TextView2用到了3个属性: app:layout_constraintCircle=\"@+id/TextView1\" app:layout_constraintCircleAngle=\"120\"(角度) app:layout_constraintCircleRadius=\"150dp\"(距离) 指的是TextView2的中心在TextView1的中心的120度,距离为150dp,效果如下: margin 在约束布局中使用margin,控件必须在布局里约束一个相对位置 margin只能大于等于0 goneMargin 效果如下,TextView2在TextView1的右边,且没有边距。 这个时候把TextView1的可见性设为gone,效果如下: TextView1消失后,TextView2有一个距离左边10dp的边距。 居中和偏移 ①居中: app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" ②水平居中: app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" ③垂直居中: app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" 偏移 假如现在要实现水平偏移,给TextView1的layout_constraintHorizontal_bias赋一个范围为 0-1 的值,假如赋值为0,则TextView1在布局的最左侧,假如赋值为1,则TextView1在布局的最右侧,假如假如赋值为0.5,则水平居中,假如假如赋值为0.3,则更倾向于左侧。 垂直偏移同理。 尺寸约束 控件的尺寸可以通过四种不同方式指定: ①使用指定的尺寸 ②使用wrap_content,让控件自己计算大小 当控件的高度或宽度为wrap_content时,可以使用下列属性来控制最大、最小的高度或宽度: android:minWidth 最小的宽度 android:minHeight 最小的高度 android:maxWidth 最大的宽度 android:maxHeight 最大的高度 注意!当ConstraintLayout为1.1版本以下时,使用这些属性需要加上强制约束,如下所示: app:constrainedWidth=\"true\" app:constrainedHeight=\"true\" ③使用 0dp (MATCH_CONSTRAINT) ④宽高比 在设置宽高比的值的时候,还可以在前面加W或H,分别指定宽度或高度限制。 例如: app:layout_constraintDimensionRatio=\"H,2:3\"指的是 高:宽=2:3 app:layout_constraintDimensionRatio=\"W,2:3\"指的是 宽:高=2:3 链 如果两个或以上控件通过下图的方式约束在一起,就可以认为是他们是一条链(图为横向的链,纵向同理)。 3个TextView相互约束,两端两个TextView分别与parent约束,成为一条链,效果如下: 一条链的第一个控件是这条链的链头,我们可以在链头中设置 layout_constraintHorizontal_chainStyle来改变整条链的样式。chains提供了3种样式,分别是: CHAIN_SPREAD —— 展开元素 (默认)； CHAIN_SPREAD_INSIDE —— 展开元素,但链的两端贴近parent； CHAIN_PACKED —— 链的元素将被打包在一起。 如图所示: 上面的例子创建了一个样式链,除了样式链外,还可以创建一个权重链。 可以留意到上面所用到的3个TextView宽度都为wrap_content,如果我们把宽度都设为0dp,这个时候可以在每个TextView中设置横向权重layout_constraintHorizontal_weight(constraintVertical为纵向)来创建一个权重链,如下所示: 效果如下: 辅助工具 ①Optimizer 当我们使用 MATCH_CONSTRAINT 时,ConstraintLayout 将对控件进行 2 次测量,ConstraintLayout在1.1中可以通过设置 layout_optimizationLevel 进行优化,可设置的值有: none:无优化 standard:仅优化直接约束和屏障约束(默认) direct:优化直接约束 barrier:优化屏障约束 chain:优化链约束 dimensions:优化尺寸测量 ②Barrier 假设有3个控件ABC,C在AB的右边,但是AB的宽是不固定的,这个时候C无论约束在A的右边或者B的右边都不对。当出现这种情况可以用Barrier来解决。Barrier可以在多个控件的一侧建立一个屏障,如下所示: 这个时候C只要约束在Barrier的右边就可以了,代码如下: app:barrierDirection为屏障所在的位置,可设置的值有:bottom、end、left、right、start、top app:constraint_referenced_ids为屏障引用的控件,可设置多个(用\",\"隔开) Group Group可以把多个控件归为一组,方便隐藏或显示一组控件,举个例子: 现在有3个并排的TextView,用Group把TextView1和TextView3归为一组,再设置这组控件的可见性,如下所示: Placeholder Placeholder指的是占位符。在Placeholder中可使用setContent()设置另一个控件的id,使这个控件移动到占位符的位置。举个例子: 新建一个Placeholder约束在屏幕的左上角,新建一个TextView约束在屏幕的右上角,在Placeholder中设置 app:content=\"@+id/textview\",这时TextView会跑到屏幕的左上角。效果如下: Guideline Guildline像辅助线一样,在预览的时候帮助你完成布局(不会显示在界面上)。 Guildline的主要属性: android:orientation 垂直vertical,水平horizontal layout_constraintGuide_begin 开始位置 layout_constraintGuide_end 结束位置 layout_constraintGuide_percent 距离顶部的百分比(orientation = horizontal时则为距离左边) 举个例子: guideline1为水平辅助线,开始位置是距离顶部50dp,guideline2位垂直辅助线,开始位置为屏幕宽的0.5(中点位置),效果如下: ViewPager 导入 使用 step1 定义ViewPager对象和视图id数组 step2 把视图添加到视图List中 step3 添加适配器PagerAdapter 或者FragmentPagerAdapter Fragment中 监听器 ①视图转换监听器 RecyclerView 添加依赖 implementation 'com.android.support:appcompat=v7:28.0.0' implementation 'com.android.support:recyclerview-V7:28.0.0'//版本需要和appcompat包的版本一致 忽略警告的操作： 布局方式 LinearLayoutManager linearLayoutManager = new LinearLayoutManager( context: this) //横向排列ItemView linearLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); mRecyclerView.setLayoutManager( linearLayoutManager); //数据反向展示 linearLayoutManager.setReverseLayout(true); //网格布局 GridLayoutManager gridLayoutManager = new GridLayoutManage(this,2) mRecyclerView.setLayoutManager(gridLayoutManager); //瀑布流布局 StaggeredGridLayoutManager staggeredGridLayoutManager = new StaggeredGridLayoutManager(2StaggeredGridLayoutManager.VERTICAL); StaggeredGridLaymRecyclerView.setLayoutManager(staggeredGridLayoutManager); recyclerView.requestLayout(): 当我们按下某个按钮的时候，我们选择的布局发生改变，如原先我们使用的是item_defalut布局，之后使用的是item_selected布局，再次按下按钮，布局又从item_selected变回item_default. 官方文档 https://developer.android.com/guide/topics/ui/layout/recyclerview?gclid=CjwKCAiAg6yRBhBNEiwAeVyL0J8fiOjFy0GepIR3niy5Q9c2Olf5aeToq1Sp88lN8jYbdffJyhBAjBoCBBQQAvD_BwE&gclsrc=aw.ds 内部添加监听器s https://blog.csdn.net/dl10210950/article/details/52918019 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-2.应用层-样式/View.html":{"url":"04_Android/应用层/SDK/2-2.应用层-样式/View.html","title":"View","keywords":"","body":"View 通用属性 LayoutInflater LayoutInflater inflate() 方法用于动态加载布局，将 XML 布局文件实例化为其对应的 View 对象。 //resource(int): 需要加载的 XML 布局资源的 ID //root(ViewGroup): 设置加载的布局的父级层次结构 //attachToRoot(boolean): 是否将加载的布局附加到父级层次结构 // 方法一 public View inflate(int resource, ViewGroup root) // 方法二 public View inflate(int resource, ViewGroup root, boolean attachToRoot) 情况一： root 为 null； 如果 root 为 null，attachToRoot 参数将失去意义。 无需将 resource 指定的布局添加到 root 中，同时没有任何 ViewGroup 容器来协助 resource 指定的布局的根元素生成布局参数 LayoutParams。 情况二： root 不为 null，attachToRoot 为 true； 将 resource 指定的布局添加到 root 中，inflate() 方法返回结合后的 View，其根元素是 root。View 将会根据它的父 ViewGroup 容器的 LayoutParams 进行测量和放置。 使用方法一即未设置 attachToRoot 参数时，如果 root 不为 null，attachToRoot 参数默认为true。 情况三： root 不为 null，attachToRoot 为 false； 无需将 resource 指定的布局添加到 root 中，inflate() 方法返回 resource 指定的布局 View，根元素是自身的最外层，View 不存在父 ViewGroup，但是可以根据 root 的 LayoutParams 进行测量和放置。 情况三不解之处在于，既然 attachToRoot 为 false，无需将 resource 指定的布局添加到 root 中，那么为什么 root 仍然不为 null？创建的 View 必然包含 layout 属性，但是这些属性需要在 ViewGroup 容器中才能生效，根据 ViewGroup 容器的 LayoutParams 进行测量和放置 View。 情况三的意思是，无需将 View 添加到某个 ViewGroup 容器中，却又能根据这个 ViewGroup 容器的 LayoutParams 进行测量和放置 View。 情况一和情况三依赖手动添加 View。 LayoutParams 先来看看LayoutParams的解释: LayoutParams继承于Android.View.ViewGroup.LayoutParams. LayoutParams相当于一个Layout的信息包，它封装了Layout的位置、高、宽等信息。假设在屏幕上一块区域是由一个Layout占领的，如果将一个View添加到一个Layout中，最好告诉Layout用户期望的布局方式，也就是将一个认可的layoutParams传递进去。 但LayoutParams类也只是简单的描述了宽高，宽和高都可以设置成三种值： 一个确定的值； MATH_PARENT，即填满（和父容器一样大小）； WRAP_CONTENT，即包裹住组件就好。 如果某View被LinearLayout包含，则该View的setLayoutParams参数类型必须是LinearLayout.LayoutParams。 视图绘制流程 onMeasure() 决定 View 的大小 onLayout() 决定 View 在 ViewGroup 中的位置 onDraw() 绘制 View onMeasure() 视图大小的测量过程，是由父视图、布局文件、以及视图本身共同完成的。 父视图提供参考大小（MeasureSpec: specSize, specMode）给子视图 UNSPECIFIED：子视图按照自身条件设置成任意的大小，没有限制 EXACTLY：父视图希望子视图的大小应该由 specSize 来决定，指定大小或MATCH_PARENT AT_MOST： 子视图最大只能是 specSize 中指定的大小，对应WRAP_CONTENT 布局文件中指定视图的大小 MATCH_PARENT WRAP_CONTENT 视图本身最终决定大小 onLayout() 根据测量出来的（onMeasure()）宽度和高度确定视图的位置。关键方法：public void layout (int l, int t, int r, int b) 方法接收左、上、右、下的坐标。 onDraw() 完成测量（onMeasure()）和布局操作（onLayout()）之后，创建 Canvas 对象绘制视图。 事件分发机制 dispatchTouchEvent() onInterceptTouchEvent() onTouchEvent() 事件分发顺序：由 Activity 开始先传递给 ViewGroup 再传递给 View。 Activity 层面 事件分发始于 Activity.dispatchTouchEvent() 方法，传递事件至 Window 的根视图。 若最终没有视图消费事件则调用 Activity.onTouchEvent(event) 方法。 ViewGroup 层面 ViewGroup 中可以通过 ViewGroup.onInterceptTouchEvent() 方法拦截事件传递，返回 true 代表同一事件列不再向下传递给子 View，返回 false 代表事件继续传递，默认返回 false。 事件递归传递至子 View 的 View.dispatchTouchEvent() 方法，如果事件被子 View 消费，则返回 true，ViewGroup 将无法再处理事件。 如果没有子 View 消费事件则判断 ViewGroup 中是否存在已注册的事件监听器（mOnTouchListener），存在则调用它的 ViewGroup.OnTouchListener.onTouch() 方法，如果 onTouch() 方法返回 false 即未消费事件，则进一步去执行 ViewGroup.onTouchEvent(event) 方法。 View 层面 View.dispatchTouchEvent() 方法：首先判断 View 中是否存在已注册的事件监听器（mOnTouchListener），存在则调用它的 View.OnTouchListener.onTouch() 方法，如若 onTouch() 方法返回 false 即未消费事件，则进一步去执行 View.onTouchEvent(event) 方法。 View 可以注册事件监听器（Listener）实现 onClick(View v)、onTouch(View v, MotionEvent event) 方法。相比 onClick() 方法，onTouch() 方法能够做的事情更多，判断手指按下、抬起、移动等事件。同时注册两者事件传递顺序，onTouch() 方法将会先于 onClick() 方法执行，并且 onTouch() 方法可能执行多次（MotionEvent 事件：ACTION_DOWN、ACTION_UP、ACTION_MOVE）。如若设置 onTouch() 方法返回值为 true，事件视为被 onTouch() 方法消费，不再继续向下传递给 onClick() 方法。 布局性能优化 优化布局层级 每个控件和布局都需要经过初始化、布局、绘制过程才能呈现出来。当使用多层嵌套的 LinearLayout 以致产生较深的视图层级结构，更甚者在 LinearLayout 中使用 layout_weight 参数，导致子 View 需要两次 onMeasure() 过程。如此反复执行初始化、布局、绘制过程容易造成性能问题。 需要开发者检查布局、修正布局，可以借助 Lint 工具发现布局文件中的视图层级结构里值得优化的地方，同时扁平化处理原本多层嵌套的布局，例如使用 RelativeLayout 作为根节点。 使用 复用布局 通过使用 和 标签，在当前布局中嵌入另一个较大的布局作为组件，从而复用完整的布局的视图层级结构。 和 标签的区别： 标签旨在重用布局文件 标签旨在减少视图层级 画笔&字体 //基本方法 reset(); 重置画笔 ，即这个操作会把画笔之前设置的属性全改成默认 比如颜色会变成黑色，无抗锯齿，等等； setColor(int color); 给画笔设置颜色值 ，int color 的值大家熟悉的是#FFFFFFFF这样的值，但在代码里这样的值是不被使用的必须转过来通过什么工具类我没研究过，但是有更方便的方法。就是关于色彩的理论，带#号的颜色表示方法 其实就是32位argb的表示方案，然而 setColor中我们需要传入的值显然是这个个32位的int值，所以 现在里面我们毋庸置疑的把#改成0x其他不变就好啦；实践证明我的方法是正确的；关于色彩理论我这也讲不明白，想深入研究的可以自行百度谷歌； setARGB(int a,int r.int g,int b); 同样是设置颜色，不过是把argb分开设置，同样的每个参数还可以用十六进制的int值来传入，比如红色 #FFFF0000 就可以传入，setARGB(0xFF,0xFF,0x00,0x00)，同理也可以用十进制的来传入，setARGB(255,255,0,0) setAlpha(int a); 设置画笔的透明度 setStyle(Paint.Style s); 设置画笔的样式， 样式取值 有三种: Paint.Style.FILL :填充内部 - Paint.Style.FILL_AND_STROKE ：填充内部和描边 - Paint.Style.STROKE ：仅描边 - setStrokeWidth(float w)：设置画笔描边粗细宽度 - setAntAlias(boolean b)：设置是否抗锯齿 其他方法 setStrokeCap(Paint.Cap cap) 设置画笔线帽的样式 取值有三种 Cap.ROUND 圆形线帽，Cap.SQUARE 方形线帽，Cap.BUTT 无线帽 setStrokeJoin(Paint.Join j); 设置线段连接处的连接模式，取值有：Join.MITER（结合处为锐角）、Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线) setStrokeMiter(float miter); 设置笔画的倾斜度，90度拿画笔与30拿画笔，画出来的线条样式肯定是不一样的吧。（事实证明，根本看不出来什么区别好吗……囧……） setPathEffect(PathEffect effect); 设置路径样式;取值类型是所有派生自PathEffect的子类：ComposePathEffect, CornerPathEffect, DashPathEffect, DiscretePathEffect, PathDashPathEffect, SumPathEffect这四个函数中，setStrokeMiter(float miter)就不再讲了，我做过试验，没什么变化，也就是没啥屌用……， //字体相关 setTextSize(float textSize); //设置文字大小 setFakeBoldText(boolean fakeBoldText); //设置是否为粗体文字 setStrikeThruText(boolean strikeThruText); //设置带有删除线效果 setUnderlineText(boolean underlineText); //设置下划线 setTextAlign(Paint.Align align); //设置开始绘图点位置 setTextScaleX(float scaleX); //水平拉伸设置 setTextSkewX(float skewX); //设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜 setTypeface(Typeface typeface); //字体样式 状态的存储与恢复 需要视图设置id 自定义属性 ①在资源文件中配置标签属性 在资源文件res/values/attrs.xml中增加 declare-styleable 节点，name为自定义控件名字；如下 //项目中资源id //颜色 //布尔值 //尺寸值 dp，sp，px等 //字符串 //枚举值 其中子节点attr中的name值backound、src、textColor、focusable、width、textStr均为范例，自己写的时候自定义属性名称 ②xml布局文件的控件中引用自己定义的属性 引入app的命名空间，自定义属性以\"app:\"为前缀 ③项目中自定义属性和布局文件中的属性值都配置好了，如何在自定义控件文件中拿到配置的参数呢；如 public class CustomerView extends AppCompatImageView { public CustomerView(Context context) { super(context); init(context,null); } public CustomerView(Context context, AttributeSet attrs) { super(context, attrs); init(context,attrs); } public CustomerView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(context,attrs); } private void init(Context context, AttributeSet attrs) { if(attrs != null) { //从项目style中文件中取出样式数组 TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CustomerView); //取到xml布局文件中配置的资源文件 Drawable drawable = typedArray.getDrawable(R.styleable.CustomerView_src); //字符串 String string = typedArray.getString(R.styleable.CustomerView_textStr); //布尔值 boolean aBoolean = typedArray.getBoolean(R.styleable.CustomerView_focusable, false); } } } 从typeArray数组中取值的参数，其中参数命门规则为R.styleable.控件名_属性名 只会获取用户设定的值，不会造成成员变量的覆盖 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-2.应用层-样式/事件分发机制.html":{"url":"04_Android/应用层/SDK/2-2.应用层-样式/事件分发机制.html","title":"事件分发机制","keywords":"","body":"Android事件分发机制 1. 基础认知 1.1 事件分发的”事件“是指什么？ 答：点击事件（Touch事件）。具体介绍如下： 此处需要特别说明：事件列，即指从手指接触屏幕至手指离开屏幕这个过程产生的一系列事件。一般情况下，事件列都是以DOWN事件开始、UP事件结束，中间有无数的MOVE事件。 1.2 事件分发的本质 答：将点击事件（MotionEvent）传递到某个具体的View & 处理的整个过程 即 事件传递的过程 = 分发过程。 1.3 事件在哪些对象之间进行传递？ 答：Activity、ViewGroup、View。Android的UI界面由Activity、ViewGroup、View 及其派生类组成 1.4 事件分发的顺序 即 事件传递的顺序：Activity -> ViewGroup -> View 即：1个点击事件发生后，事件先传到Activity、再传到ViewGroup、最终再传到 View 1.5 事件分发过程由哪些方法协作完成？ 答：dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent() 1.6 总结 2. 事件分发机制流程详细分析 主要包括：Activity事件分发机制、ViewGroup事件分发机制、View事件分发机制 流程1：Activity的事件分发机制 Android事件分发机制首先会将点击事件传递到Activity中，具体是执行dispatchTouchEvent()进行事件分. /** * 源码分析：Activity.dispatchTouchEvent（） */ public boolean dispatchTouchEvent(MotionEvent ev) { // 仅贴出核心代码 // ->>分析1 if (getWindow().superDispatchTouchEvent(ev)) { return true; // 若getWindow().superDispatchTouchEvent(ev)的返回true // 则Activity.dispatchTouchEvent（）就返回true，则方法结束。即 ：该点击事件停止往下传递 & 事件传递过程结束 // 否则：继续往下调用Activity.onTouchEvent } // ->>分析3 return onTouchEvent(ev); } /** * 分析1：getWindow().superDispatchTouchEvent(ev) * 说明： * a. getWindow() = 获取Window类的对象 * b. Window类是抽象类，其唯一实现类 = PhoneWindow类 * c. Window类的superDispatchTouchEvent() = 1个抽象方法，由子类PhoneWindow类实现 */ @Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); // mDecor = 顶层View（DecorView）的实例对象 // ->> 分析2 } /** * 分析2：mDecor.superDispatchTouchEvent(event) * 定义：属于顶层View（DecorView） * 说明： * a. DecorView类是PhoneWindow类的一个内部类 * b. DecorView继承自FrameLayout，是所有界面的父类 * c. FrameLayout是ViewGroup的子类，故DecorView的间接父类 = ViewGroup */ public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); // 调用父类的方法 = ViewGroup的dispatchTouchEvent() // 即将事件传递到ViewGroup去处理，详细请看后续章节分析的ViewGroup的事件分发机制 } // 回到最初的分析2入口处 /** * 分析3：Activity.onTouchEvent() * 调用场景：当一个点击事件未被Activity下任何一个View接收/处理时，就会调用该方法 */ public boolean onTouchEvent(MotionEvent event) { // ->> 分析5 if (mWindow.shouldCloseOnTouch(this, event)) { finish(); return true; } return false; // 即 只有在点击事件在Window边界外才会返回true，一般情况都返回false，分析完毕 } /** * 分析4：mWindow.shouldCloseOnTouch(this, event) * 作用：主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等 */ public boolean shouldCloseOnTouch(Context context, MotionEvent event) { if (mCloseOnTouchOutside && event.getAction() == MotionEvent.ACTION_DOWN && isOutOfBounds(context, event) && peekDecorView() != null) { // 返回true：说明事件在边界外，即 消费事件 return true; } // 返回false：在边界内，即未消费（默认） return false; } 当一个点击事件发生时，从Activity的事件分发开始（Activity.dispatchTouchEvent()），流程总结如下： 没看完 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-2.应用层-样式/如何检测UI卡顿.html":{"url":"04_Android/应用层/SDK/2-2.应用层-样式/如何检测UI卡顿.html","title":"如何检测ui卡顿","keywords":"","body":"如何检测UI卡顿 一、使用 GPU 渲染模式分析工具进行分析 GPU 渲染模式分析工具可以显示渲染流水线的每个阶段渲染前一帧所用的相对时间。这些信息有助于您确定流水线中的瓶颈所在，从而了解应该优化哪些方面来提高应用的渲染性能。 启用性能分析器 开始前，请确保您使用的是搭载 Android 4.1（API 级别 16）或更高版本的设备，并启用开发者选项。如需在使用应用时开始分析设备 GPU 渲染，请执行以下操作： 在您的设备上，转到设置并点按开发者选项。 在监控部分，选择 GPU 渲染模式分析或 HWUI 渲染模式分析，具体取决于设备上搭载的 Android 版本。 在“GPU 渲染模式分析”对话框中，选择在屏幕上显示为条形图，将图表以条形图的形式叠加在您设备的屏幕上。 打开您要分析的应用。 GPU 渲染模式分析工具以图表（以颜色编码的直方图）的形式显示各个阶段及其相对时间。图 1 显示了此图表的一个示例。 图 1. GPU 渲染模式分析图表 GPU 渲染模式分析图表中显示的每个竖条中的每个分段都表示流水线的一个阶段，并在条形图中使用特定的颜色突出显示。图 2 说明了显示的每种颜色所代表的含义。 图 2. GPU 渲染模式分析图表的图例 基本规则：对于每个可见的应用程序，该工具都会显示一个图形。 沿水平轴的每个柱状图都代表一帧，柱状图的高度代表该帧渲染所花费的时间（以毫秒为单位）。 水平的绿线表示16毫秒。为了达到每秒60帧，每帧柱状图的高度必须保持在此线以下。当柱状图超过该线时，动画中可能会有卡顿。 超过16毫秒阈值的帧通过加宽图形宽度和减少透明度来突出显示。 每个柱状图都有不同彩色组成，这些颜色表示不同的渲染阶段。颜色的数量取决于设备所使用的API level。 颜色 渲染阶段 描述 橙色 Swap Buffers 表示CPU等待GPU完成工作的时间。如果此线条变高，则表示该应用在GPU上执行了太多工作。 红色 Command Issue 表示Android的2D渲染器向OpenGL发送命令进行绘制及重新绘制显示列表所花费的时间。该条的高度与每个显示列表执行所花费的时间之和成正比，显示列表内容越多，红色条越高。 浅蓝色 Sync & Upload 表示将位图信息上传到GPU中所需的时间。多数时候意味着该应用程序需要花费大量时间来加载大量图形。 蓝色 Draw 表示用于创建和更新视图的显示列表的时间。如果这一部分很高，则可能有很多自定义的视图，或者onDraw方法中有很多工作。 浅绿色 Measure / Layout 表示在视图层次结构中的onLayout和onMeasure回调上花费的时间。意味着视图层次结构需要花费很长时间进行处理。 绿色 Animation 表示运行该帧中全部动画所花费的时间。如果此线条很高，则您的应用可能使用的自定义动画效果不佳，或者由于更新了属性而发生了意外工作。 深绿色 Input Handling 表示应用程序在输入事件回调中执行代码所花费的时间。如果此线条很高，则表明该应用花费了太多时间来处理用户输入。应该考虑将此类处理工作分配到另一个线程。 墨绿色 Misc Time / VSync Delay 表示应用在两个连续的帧之间花费执行时间的时间。如果此线条很高，可能是UI线程中发生了过多的处理，这些处理可以转移到其他线程。 二、利用loop()中打印的日志进行分析 public static void loop() { final Looper me = myLooper(); final MessageQueue queue = me.mQueue; //... for (;;) { Message msg = queue.next(); // might block if (msg == null) { return; } final Printer logging = me.mLogging; if (logging != null) { logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +msg.callback + \": \" + msg.what); } final long traceTag = me.mTraceTag; if (traceTag != 0 && Trace.isTagEnabled(traceTag)) { Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); } try { msg.target.dispatchMessage(msg); } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } if (logging != null) { logging.println(\" 通过给Looper类的mLogging属性创建一个Printer对象，那么运行在主线程中的所有代码都能获取执行的时间，找出耗费时间长的，分析出干了什么，优化之，从而解决UI卡顿问题。 三、利用Choreographer Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染。SDK中包含了一个相关类，以及相关回调。理论上来说两次回调的时间周期应该在16ms，如果超过了16ms我们则认为发生了卡顿，我们主要就是利用两次回调间的时间周期来判断. No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-2.应用层-样式/屏幕适配.html":{"url":"04_Android/应用层/SDK/2-2.应用层-样式/屏幕适配.html","title":"屏幕适配","keywords":"","body":"屏幕适配 基本概念 屏幕尺寸 屏幕尺寸指屏幕的对角线的长度，单位是英寸，1英寸=2.54厘米常见尺寸:2.4，2.8，3.5，3.7，4.2，5.0，5.5，6.0等 屏幕分辨率 屏幕分辨率是指在横纵向上的像素点数，单位是px,1px=1个像素点，一般以纵向像素*横向像素，如:1960*1080 屏幕像素密度 屏幕像素密度是指每英寸上的像素点数，单位是dpi，即“dot per inch”的缩写。屏幕像素密度与屏幕尺寸和屏幕分辨率有关。 像素单位 px: pixel的缩写，像素，1px代表屏幕上一个物理的像素点 dip、dp:都是Density Independent Pixels的缩写，即密度无关像素 sp : scaled pixels，与dp类似，用于设置字体大小 dp与px的换算 在屏幕像素密度为160dpi的情况下，1dp=1px。 假如:320dpi,1dp=2px 1dp=(像素密度/160dpi)*1px pxValue=(像素密度/160dpi)*dpValue density:(像素密度/160dpi) ldpi、mdpi、hdpi、xdpi的区别 名称 像素密度范围 比例 mdpi 120dpi~160dpi 2 hdpi 160dpi~240dpi 3 xhdpi 240dpi~320dpi 4 xxhdpi 320dpi~480dpi 6 xxxhdpi 480dpi~640dpi 8 布局适配 禁用绝对布局（横纵坐标点确定布局位置） 少用px 使用wrap_content、match_parent、layout_weight 重建布局文件 图片适配 提供不同分辨率的备用位图 使用自动拉伸图（.9图） 视图上方鼠标横向拉动：设置横向拉伸范围 视图左部鼠标纵向移动：设置纵向拉伸范围 视图右边鼠标纵向移动：设置文本显示的纵向范围 视图下方鼠标横向移动，设置文本显示的横向范围 https://www.jianshu.com/p/3a7c101780a0 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-2.应用层-样式/设计规范.html":{"url":"04_Android/应用层/SDK/2-2.应用层-样式/设计规范.html","title":"设计规范","keywords":"","body":"1、字体大小 导航标题: 18sp=36px 文章标题或图标名称: 16sp=32px 文本字体: 14sp=28px 注释最小字体: 12sp=24px 2、图标大小 ldpi mdpi hdpi xhdpi xxhdpi 程序启动图标 36 x 36 48 x 48 72 x 72 96 x 96 144 x 144 底部菜单图标 36 x 36 48 x 48 72 x 72 - - 弹出对话框顶部图标 24 x 24 32 x 32 48 x 48 - - 长列表内部列表项图标 24 x 24 32 x 32 48 x 48 - - 底部或顶部tab标签图标 24 x 24 32 x 32 48 x 48 - - 底部状态栏图标 18 x 18 24 x 24 36 x 36 48 x 48 - No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-2.应用层-样式/键盘.html":{"url":"04_Android/应用层/SDK/2-2.应用层-样式/键盘.html","title":"键盘","keywords":"","body":"键盘 tips1 点击其他地方隐藏键盘 `@Override public boolean dispatchTouchEvent*(*MotionEvent ev*) {* if *(*ev.getAction*()* == MotionEvent.*ACTION_DOWN) {* View v = getCurrentFocus*()*; if *(*isShouldHideKeyboard*(*v, ev*)) {* hideKeyboard*(*v.getWindowToken*())*; *} }* return super.dispatchTouchEvent*(*ev*)*;*}/** * 根据EditText所在坐标和用户点击的坐标相对比， * 来判断是否隐藏键盘，因为当用户点击EditText时则不能隐藏 */*private boolean isShouldHideKeyboard*(*View v, MotionEvent event*) {* if *(*v != null && *(*v instanceof EditText*)) {* int*[]* l = *{*0, 0*}*; v.getLocationInWindow*(*l*)*; int left = l*[*0*]*, top = l*[*1*]*, bottom = top + v.getHeight*()*, right = left + v.getWidth*()*; if *(*event.getX*()* > left && event.getX*()* top && event.getY*()* No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-3.应用层-数据持久化/Android中Serializable和Parcelable有什么区别.html":{"url":"04_Android/应用层/SDK/2-3.应用层-数据持久化/Android中Serializable和Parcelable有什么区别.html","title":"Android中serializable和parcelable有什么区别","keywords":"","body":"共性： 都可以实现序列化，使对象可以变为二进制流在内存中/网络上传输数据。 区别： Parcelable是Android提供的序列化接口，Serializable是Java提供的序列化接口。因此Parcelable只能在Android中使用，而Serializable可以在任何使用Java语言的地方使用。 Serializable只需要将对象标记为Serializable，比较简单，无需额外的实现；Parcelable需要手动实现Parcelable接口，包括编写序列化和反序列化过程的代码。 Serializable的序列化和反序列化都需要使用到IO操作；而Parcelable不需要IO操作，Parcelable的效率要高于Serializable，Android中推荐使用Parcelable。 如果需要简单地实现对象的序列化和反序列化，并且性能不是关键问题，可以使用 Serializable；如果要把对象持久化到存储设备或者通过网络传输到其它设备，最好使用Serializable；如果需要高效的对象传递，并且性能要求较高，可以选择实现 Parcelable。 二者使用的详解： Parcelable使用起来比较麻烦 序列化过程需要实现Parcelable的writeToParcel(Parcel dest, int f1ags)方法和describeContents()方法。 其中describeContents()方法直接返回0就可以了。 为了反序列化，还需要提供一个非空的名为CREATOR的静态字段，该字段类型是实现了Parcelable.Creator接口的类，一般用一个匿名内部类实现就可以了。 现在也有一些插件可以方便地实现Parcelable接口。 Serializable的使用就比较简单 直接实现Serializable接口即可，该接口没有任何方法。 序列化机制依赖于一个long型的serialVersionUID，如果没有显式的指定，在序列化运行时会基于该类的结构自动计算出一个值。如果类的结构发生变化就会导致自动计算出的serialVersionUID不同。这就会导致一个问题，序列化之后类如果新增了一个字段，反序列过程就会失败。一般会报InvalidClassException这样的异常。 而如果显式的指定了serialversionUID，只要类的结构不发生重大变化，如字段类型发生变化等，仅仅添加或者删除字段等都可以反序列化成功。 自定义一个类让其实现Parcelable的大致流程： 先实现该接口的writeToParcel(Parcel dest, int flags)和describeContents()方法 添加一个Parcelable.Creator类型的名字为CREATOR的非空字段 public class Person implements Parcelable { private String name; private int age; //... @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(name); // 写出name dest.writeInt(age); // 写出age } public static final Parcelable.Creator CREATOR = new Parcelable. Creator() { @Override public Person createFromParcel(Parcel source) { Person person = new Person(); person.name = source.readString(); // 读取name person.age = source.readInt(); // 读取age return person; } @Override public Person[] newArray(int size) { return new Person[size]; } }; } 该类中的字段类型除了基本类型和String及它们对应的数组，如果有其它自定义的类型，也需要实现Parcelable或者Serializable接口。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-3.应用层-数据持久化/ContentProvider.html":{"url":"04_Android/应用层/SDK/2-3.应用层-数据持久化/ContentProvider.html","title":"Contentprovider","keywords":"","body":"Android四大组件之一，为存储和获取数据提供统一的接口。可以在不同的应用程序之间共享数据。对于ContentProvier而言，无论数据的来源是什么，它都认为是种表，然后把数据组织成表格。 注意：表的实现是自己定义的，比如文件存储，数据库等，对外暴露的接口会被理解成类似表的操作。 此外一般我们不会直接使用ContentProvider来访问，而是会通过ContentResolver来访问ContentProvider，为什么？因为ContentProvider作为一个数据源处理中心，不止给App内部使用，还会被其他App访问。所以这里的ContentProvider就好比一个server，其他的App在访问这个ContentProvider的时候都必须先获得一个Server的Client才行，这里的ContentResolver就是Android提供给开发者使用来得到一个ContentProvider Client的管理工具类。 使用ContentProvider的一些基本步骤： 定义ContentProvider类：创建一个类，该类必须继承自ContentProvider类，并实现其中的一些方法，例如query(), insert(), update()和delete()等方法。 定义URI：ContentProvider必须公开一组URI，以便其他应用程序可以使用它。这些URI标识了ContentProvider所提供的数据集。 实现方法：ContentProvider的每个方法都有特定的功能。例如，query()方法用于查询ContentProvider提供的数据。在这些方法中，您需要执行所需的操作，并返回结果。 注册ContentProvider：在AndroidManifest.xml文件中注册ContentProvider，以使其他应用程序可以访问它。 注册 ContentProvider 时，必须配置 android:name、android:authorities、android:exported=true属性。 必须保证系统内authorities字段不重名，它就好比URL中的主机地址。 使用ContentProvider：使用ContentResolver类中的方法，例如query(), insert(), update()和delete()等方法，来访问ContentProvider中的数据。 ContentResolver，访问 ContentResolver 必须使用到 Uri 对象，可以通过 Uri.parse(String)方法将 String 转为 Uri 类型的数据，在访问 ContentProvider 时，Uri 的字符串格式必须是 content://??? 格式的。 Context 类定义了 getContentResolver()方法，用于获取 ContentResolver 对象，并且由 ContextWrapper 重写实现了该方法，所以，Activity 和 Service 均通过继承得到了 getContentResolver()方法。 使用ContentProvider可以提高应用程序之间的数据共享，并提高应用程序的安全性。但是，您必须确保您的ContentProvider能够正确地处理数据，以防止其他应用程序访问您的数据并修改它。 ContentObserver ContentObserver 是一个抽象类，用于监听内容提供者（ContentProvider）的数据变化。它通常用于监视系统设置、联系人、短信等数据的变化。继承 ContentObserver 类，并实现 onChange 方法来处理数据变化的逻辑。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-3.应用层-数据持久化/GreenDao基本使用.html":{"url":"04_Android/应用层/SDK/2-3.应用层-数据持久化/GreenDao基本使用.html","title":"Greendao基本使用","keywords":"","body":"GreenDao 地址:https://github.com/greenrobot/greenDAO 基本概念 某实体类------>某表 某DAO-------->数据访问对象（某表的操作) DaoMaster---->数据库连接对象 DaoSession--->由连接生成的会话 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-3.应用层-数据持久化/okio框架.html":{"url":"04_Android/应用层/SDK/2-3.应用层-数据持久化/okio框架.html","title":"Okio框架","keywords":"","body":"okio框架 ByteString String str = \"This is a string\" ; System.out.println(str.length()); ByteString bytestring = ByteString.encodeutf8(str); System.out.printin(byteString); //编码 String base64 = byteString.base64(); System.out.printin(base64); ByteString md5 = byteString.md5(); System.out.printin(md5);//获得md5字符串 System.out.printin(md5.hex());//获得md516进制字符串 //解码 ByteString bytestring1 = Bytestring.decodeBase64(\"YWj\"); System.out.print1n(bytestring1);//abc //获得SH1校验值 String hex = bytestring1.sha1( ).hex( ); System.out.println(hex); FileInputStream in = new FileInputStream(\"in.png\"); ByteString read = ByteString.read(in,in.available()); System.out.println(read); FileOutputStream out = new FileOutputStream(\"out.png\"); read.write(out); in.close(); out.close(); Buffer Buffer buffer = new Buffer(); System.out.println(buffer);//[size=0] buffer.writeUTF8(\"abc\" ) ; System.out.println(buffer);//[text=abc] while(!buffer.exhausted()){ System.out.println(buffer.readUTF8(1)); //a --> buffer:[text:bc] //b --> buffer:[text:c] //c --> buffer:[size:0] } BufferedSource source = okio.buffer(okio.source(new File( pathname: \"in.txt\"))); BufferedSink sink = okio.buffer(Okio.sink(new File( pathname: \"out.txt\"))); source.readAl1(sink) ; source.close(); sink.close(); No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-3.应用层-数据持久化/Room Persistent Library基本介绍.html":{"url":"04_Android/应用层/SDK/2-3.应用层-数据持久化/Room Persistent Library基本介绍.html","title":"Room persistent library基本介绍","keywords":"","body":" refs: https://www.geeksforgeeks.org/introduction-to-room-persistent-library-in-android/ 背景： Room是谷歌提供的用于数据库存储访问的Lib，包含在jetpack project之中。 依赖： dependencies { implementation \"androidx.room:room-runtime:2.2.5\" kapt \"androidx.room:room-compiler:2.2.5\" } 好处： 查询在编译时进行验证。 这意味着在编译代码时，Room会检查你的查询语句是否正确，这有助于减少在运行时出现的错误。 减少样板代码。 Room提供了简洁的API，使得开发者在编写数据库相关代码时不需要编写大量重复的代码。 简单易懂，容易应用。 Room的设计理念简单，使得开发者可以更容易地理解和使用它。 与RxJava、LiveData和Kotlin协程的集成简单。 组件： 数据库（Database）：这包含了数据库持有者，并作为应用程序持久化、关系型数据的主要访问点。 实体（Entity）：数据库中的一个表，由一个实体表示。 DAO（Data Access Object）：这个类包含了访问数据库的方法。 Room数据库：您的应用程序使用Room数据库来检索与数据库相关的数据访问对象（DAOs）。然后，每个DAO被应用程序用于从数据库检索实体并保存任何对这些实体的更改。最后，应用程序使用一个实体来检索和设置与数据库中表列对应的值。 Database： @Database(entities = arrayOf(User::class), version = 1) abstract class courseDB: RoomDatabase() { abstract fun courseName(): courseDB } 继承自抽象类RoomDatabase 注解中包含所有的Entity 包含一个无参数的抽象方法，用于返回@Dao注解的实例 设计模式为单例 Entity： @Entity data class User( @PrimaryKey val uid: Int, @ColumnInfo(name = \"courseName\") val firstName: String?, @ColumnInfo(name = \"courseHolder\") val lastName: String? ) 此类用@Entity注解，代表一张表 每个成员变量代表一列，所有域必须都为public并且有getter and setter方法. 如果所有的域都可访问，采用空的构造函数，或者采用含参构造函数。Room也可以使用部分构造函数。 每个实体类至少需要有一个主键。要定义单个字段的主键，可以使用 @PrimaryKey注解，或者在 @Entity注解的 primaryKeys属性中为多个字段定义主键。还可以使用 @PrimaryKey注解的 autoGenerate属性自动分配主键。 @Entity(indices = arrayOf(Index(value = [\"courseHolder\", \"address\"])))@Entity(indices = arrayOf(Index(value = [\"courseName\", \"courseHolder\"], unique = true))) 使用 @Entity注解的 indices 属性可以为实体添加索引。 使用 @Index注解并将 unique属性设置为 true 可以创建唯一索引。 Data Access Object (DAO)： @Dao interface courseDAO{ @Query(\"SELECT * FROM course\") fun getAll(): List @Query(\"SELECT * FROM course WHERE uid IN (:userIds)\") fun loadAllByIds(userIds: IntArray): List @Insert fun insertAll(vararg courses: User) @Delete fun delete(course: Courses) } DAO（数据访问对象）提供了与数据库交互的API。 DAO 是一个带有 @Dao 注解的接口。 这个接口的方法用于从数据库检索数据或对数据库进行更改。 通过注解如 @Query、@Insert 和 @Delete来标识这些方法。 Converting Types： class GFG { @TypeConverter fun fromTimestamp(value: Long?): Date? { return value?.let { Date(it) } } @TypeConverter fun dateToTimestamp(date: Date?): Long? { return date?.time?.toLong() } } 将自定义数据类型持久化到单个数据库列中，可以使用类型转换器（Type converters） No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-3.应用层-数据持久化/ScopeStorage.html":{"url":"04_Android/应用层/SDK/2-3.应用层-数据持久化/ScopeStorage.html","title":"Scopestorage","keywords":"","body":"1.强制启用ScopedStorage Android 11中，Scoped Storage被强制启用了。 Android 10中虽然也有Scoped Storage功能，但没有强制启用。 只要应用程序指定的targetSdkVersion低于29，或targetSdkVersion等于29，但在AndroidManifest.xml中加入了如下配置： ... 那么Scoped Storage功能就不会被启用。 在Android 11中以上配置依然有效，但仅限于targetSdkVersion小于或等于29的情况。如果你的targetSdkVersion等于30，Scoped Storage就会被强制启用，requestLegacyExternalStorage标记将会被忽略。 2.管理设备上所有的文件 在Android 11中，如果你想要管理整个设备上的文件，也需要使用类似的技术。 首先，你必须在AndroidManifest.xml中声明MANAGE_EXTERNAL_STORAGE权限，如下所示： 3.Batch operations 每个应用程序都有权限向MediaStore贡献数据，比如说插入一张图片到手机相册当中。也有权限读取其他应用程序所贡献的数据，比如说获取手机相册中的所有图片，但限制了写入其他应用程序所贡献数据的权限。 Batch operations，允许我们可以一次性对多个文件的操作权限进行申请。 createWriteRequest() 用于请求对多个文件的写入权限。 createFavoriteRequest() 用于请求将多个文件加入到Favorite（收藏）的权限。 createTrashRequest() 用于请求将多个文件移至回收站的权限。 createDeleteRequest() 用于请求将多个文件删除的权限。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-3.应用层-数据持久化/SharedPreferences.html":{"url":"04_Android/应用层/SDK/2-3.应用层-数据持久化/SharedPreferences.html","title":"Sharedpreferences","keywords":"","body":"存放一些类似登录的配置信息 本质上是一个xml文件，通过类似键值对的方式存放信息 位于程序私有目录中，即data/data/[packageName]/shared_prefs 覆盖安装后sp文件依旧存在 SharedPreferences操作模式 MODE_APPEND:追加方式存储(先检查，不存在则创建，存在则追加)（现在不能使用了） MODE_PRIVATE:私有方式存储,其他应用无法访问 MODE_WORLD_READABLE:可被其他应用读取 MODE_WORLD_WRITEABLE:可被其他应用写入 在安卓中，您可以使用SharedPreferences（以下简称为sp）来存储和获取应用程序的数据。以下是获取和设置sp中的值的示例代码： 获取sp中的值： javaCopy code// 获取SharedPreferences对象 SharedPreferences sharedPreferences = getSharedPreferences(\"myPrefs\", Context.MODE_PRIVATE); // 从SharedPreferences中获取一个值 String value = sharedPreferences.getString(\"key\", defaultValue); 在这里，\"myPrefs\"是您想要使用的SharedPreferences文件的名称，\"key\"是要获取的值的键，defaultValue是如果找不到该键时返回的默认值。 设置sp中的值： javaCopy code// 获取SharedPreferences对象 SharedPreferences sharedPreferences = getSharedPreferences(\"myPrefs\", Context.MODE_PRIVATE); // 使用SharedPreferences.Editor对象来编辑SharedPreferences SharedPreferences.Editor editor = sharedPreferences.edit(); // 将值存储到SharedPreferences中 editor.putString(\"key\", value); // 应用更改 editor.apply(); 在这里，您首先获取了SharedPreferences对象，然后创建了一个SharedPreferences.Editor对象来编辑SharedPreferences。接下来，您可以使用putString()方法将键值对存储到SharedPreferences中。最后，调用apply()方法来应用更改。 请注意，\"key\"是您要存储的值的键，value是要存储的值。此外，要确保在更改完SharedPreferences之后调用apply()方法，以确保更改得到应用。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-3.应用层-数据持久化/SQLite基本使用.html":{"url":"04_Android/应用层/SDK/2-3.应用层-数据持久化/SQLite基本使用.html","title":"Sqlite基本使用","keywords":"","body":"SQLite SQLite数据库是个轻量级的数据库，本质上是个二进制文件。 SQLiteExpert工具 SQLiteOpenHelper SQLiteDatabase rawQuery();查询 execSQL();添加、删除、修改、创建 API函数 /**1.添加**/ //参数1：所要操作的数据库表的名称 //参数2：可以为空的列 //参数3：添加的参数 ContentValues values = new ContentValues(); values.put(\"name\",name); values.put(\"age\",age); values.put(\"sex\",sex); long id = db.insert(\"test_db\",null,values); /**2.查询**/ //参数1：所要操作的数据库表的名称 //参数2：要查询的列，传入null代表查询所有列 //参数3：条件语句 //参数4：条件参数 //参数5：group by 分组 //参数6：having 去除不符合条件的组 //参数7：order by 按……排序 Cursor c = db.query(\"test_db\",null,\"name=? and age=? and sex=?\",new String[]{\"李清秋\",\"23\",\"女\"},null,null); Cursor c2 = db.query(\"test_db\",null,null,null,null,\"group by (age)\",\"having sex='女'\"); 数据库更新、升级、降级 https://www.jianshu.com/p/65923fa3e3dc No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-3.应用层-数据持久化/文件.html":{"url":"04_Android/应用层/SDK/2-3.应用层-数据持久化/文件.html","title":"文件","keywords":"","body":"文件 基本概念 内存(memory) 设备的容量 内部存储(internal storage) 设备中间实际存储的位置，如sp存放的私有目录 外部存储(external storage) storage或者mnt文件夹 Environment.getExternalStorageDirectory() 公有目录(DCIM、DOWNLOAD等) 私有目录(Android/data/应用包名) 卸载时清除 文件权限 第1位：文件类型 字符 含义 d 文件夹 - 普通文件 l 链接文件/映射文件 第2-4位：当前文件属组所具备的权限 字符 含义 r 可读 w 可写 x 可执行 第5-7位：同一组的用户所具备的权限 第8-10位：其他用户所具备的权限 外部存储 权限 android6.0以上需要动态申请权限 步骤 step1 获取外部存储路径 外部存储公有目录（应用卸载后仍然存在） 外部存储私有目录（随着应用卸载一起被清除）（不需要权限） 第一个为长期数据 第二个为临时数据 step2 检测内存卡是否存在 step3 写入操作 step4 读取操作 内部存储 内部存储，简称为内存 通过DDMS-->File Explorer可以找到，文件夹叫做data 内存中有两个文件夹:app , data app 存放apk文件 data 应用包名下 步骤 step1 获取内部存储目录 一样的，files放置长期数据，cache放置缓存数据 如果SD卡不存在，则使用内部存储 step2 写入数据 step3 读取数据 问题 FileNotFound异常解决方案 检查下错误提示中的路径是否存在 检查权限是否处理正确 确认设备是否有SDCard DDMS中data、SDCard目录无法展开 模拟器需要更改只读权限，有的真机data目录需要root Environment.getExternalStorageDirectory()的获取目录才是SDCard的实际目录，因为系统不同路径会有差异 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-4.应用层-功能模块/AndroidX.html":{"url":"04_Android/应用层/SDK/2-4.应用层-功能模块/AndroidX.html","title":"Androidx","keywords":"","body":"AndroidX Android Support Library 用于提供向下兼容的功能，比如support-v4、appcompat-v7。4、7代表API号码，对应系统版本1.6、2.1，指库能够向下兼容到的最低的版本。 现在安卓官方支持的最低系统版本已经是4.0.1，对应API号15.support-v4、appcompat-v7库也不再支持那么久远的系统了，但是它们的名字却一直保留了下来，虽然它们现在的实际作用已经对不上当初命名的原因了。 那么很明显，Android团队也意识到这种命名已经非常不合适了，于是对这些API的架构进行了一次重新的划分，推出了AndroidX。因此，AndroidX本质上其实就是对Android Support Library进行的一次升级，升级内容主要在于以下两个方面。 包名。之前Android Support Library中的API，它们的包名都是在android.support.下面的，而AndroidX库中所有API的包名都变成了在androidx.下面。这是一个很大的变化，意味着以后凡是android.包下面的API都是随着Android操作系统发布的，而androidx.包下面的API都是随着扩展库发布的，这些API基本不会依赖于操作系统的具体版本。 命名规则。吸取了之前命名规则的弊端，AndroidX所有库的命名规则里都不会再包含具体操作系统API的版本号了。比如，像appcompat-v7库，在AndroidX中就变成了appcompat库。 一个AndroidX完整的依赖库格式如下所示： implementation 'androidx.appcompat:appcompat:1.0.2 AndroidX和Android Support Library中的库是非常不建议混合在一起使用的，因为它们可能会产生很多不兼容的问题。最好的做法是，要么全部使用AndroidX中的库，要么全部使用Android Support Library中的库。 而现在Android团队官方的态度也很明确，未来都会为AndroidX为主，Android Support Library已经不再建议使用，并会慢慢停止维护。另外，从Android Studio 3.4.2开始，新建的项目已经强制勾选使用AndroidX架构了。 那么对于老项目的迁移应该怎么办呢？由于涉及到了包名的改动，如果从Android Support Library升级到AndroidX需要手动去改每一个文件的包名，那可真得要改死了。为此，Android Studio提供了一个一键迁移的功能，只需要对着你的项目名右击 → Refactor → Migrate to AndroidX，就会弹出如下图所示的窗口。 这里点击Migrate，Android Studio就会自动检查你项目中所有使用Android Support Library的地方，并将它们全部改成AndroidX中对应的库。另外Android Studio还会将你原来的项目备份成一个zip文件，这样即使迁移之后的代码出现了问题你还可以随时还原回之前的代码。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-4.应用层-功能模块/MediaSession框架.html":{"url":"04_Android/应用层/SDK/2-4.应用层-功能模块/MediaSession框架.html","title":"Mediasession框架","keywords":"","body":"MediaSession-CS框架 C/S架构 规范了音视频应用中界面与播放器之间的通信接口，实现界面与播放器之间的完全解耦。 MediaSession媒体会话（Server） 负责与MediaPlayer播放器的所有通信，对应用的其它部分隐藏播放器的API，系统只能从控制播放器的MediaSession中调用播放器。 维持的信息：PlaybackState-播放器状态（播放/暂停），MetaData-播放内容的相关信息（标题/音乐家）。 MediaSession可以接收来自一个或多个MediaController的回调，响应回调的逻辑必须保持一致，无论哪个客户端应用发起了回调，对回调的响应都是相同的。 MediaController媒体控制器（Client） 界面的代码只与MediaController通信，MediaController会将传输控制操作转换为对媒体会话的回调。每当会话状态发生变化时，它也会接收来自媒体会话的回调，这时便可以更新界面。 MediaController一次只能连接到一个MediaSession MediaController 创建时需要受控端的配对令牌，因此需要在浏览器连接成功后才进行 MediaController 的创建。 MediaSession-授权框架 MediaBrowser媒体浏览器（Client） 用来连接媒体服务MediaBrowserService和订阅数据，在注册的回调接口中可以获取到Service的连接状态、获取音乐数据，一般在客户端中创建。 MediaBrowserService媒体服务（Server） 它有两个关键的回调函数，onGetRoot（控制客户端MediaBrowser的连接请求，返回值中决定是否允许连接）,onLoadChildren（MediaBrowser向服务器发送数据订阅请求时会被调用，一般在这里执行异步获取数据的操作，然后在将数据发送回MediaBrowser注册的接口中）。 命令传递 客户端调用服务器 意义 MediaController.TransportControls MediaSession.Callback 播放 play() onPlay() 暂停 pause() onPause() 停止 stop() onStop() 指定播放位置 seekTo(long) onSeekTo(long) 快进 fastForward() onFastForward() 回倒 rewind() onRewind() 下一首 skipToNext() onSkipToNext() 上一首 skipToPrevious() onSkipToPrevious() 设置播放速度 setPlaybackSpeed(float) onSetPlaybackSpeed(float) 打分 setRating(Rating) onSetRating(Rating) 发送自定义动作 sendCustomAction(String,Bundle) onSendCustomAction(String,Bundle) 支持判断 议题1：SearchApp能否通过代码知道播放器是否支持某些操作指令 结论：可以知道非自定义的指令是否支持，但自定义指令不可以 自定义指令比如单曲循环/顺序播放、切换全屏/半屏等，无法通过代码判断播放器是否支持 代码示例： MediaController mediaController = getMediaController(context); if (null != mediaController) { // 获取当前的 PlaybackState PlaybackState playbackState = mediaController.getPlaybackState(); if (playbackState != null) { // 获取支持的操作 long actions = playbackState.getActions(); // 检查播放器是否支持播放 if ((actions & PlaybackState.ACTION_PLAY) != 0) { Log.d(\"MediaSession\", \"播放器支持播放操作\"); } // 检查播放器是否支持暂停 if ((actions & PlaybackState.ACTION_PAUSE) != 0) { Log.d(\"MediaSession\", \"播放器支持暂停操作\"); } // 检查播放器是否支持快进 if ((actions & PlaybackState.ACTION_FAST_FORWARD) != 0) { Log.d(\"MediaSession\", \"播放器支持快进操作\"); } } } 议题2：SearchApp能否通过代码知道播放器是否成功完成了指令 结论：只能知道部分指令是否成功执行 暂停\\继续播放等可以通过PlaybackState判断，但上一首\\下一首等没有相应的Callback 代码示例： // 假设已经有一个 MediaController 实例 MediaController mediaController = ...; // 创建并注册一个 Callback 来监听播放状态的变化 MediaController.Callback callback = new MediaController.Callback() { @Override public void onPlaybackStateChanged(PlaybackState state) { super.onPlaybackStateChanged(state); if (state != null) { int playbackState = state.getState(); switch (playbackState) { case PlaybackState.STATE_PLAYING: Log.d(\"MediaController\", \"Playback started successfully.\"); break; case PlaybackState.STATE_PAUSED: Log.d(\"MediaController\", \"Playback is paused.\"); break; case PlaybackState.STATE_STOPPED: Log.d(\"MediaController\", \"Playback stopped.\"); break; case PlaybackState.STATE_ERROR: Log.e(\"MediaController\", \"Playback encountered an error: \" + state.getErrorMessage()); break; // 其他状态可以根据需要处理 default: Log.d(\"MediaController\", \"Playback state changed: \" + playbackState); break; } } } }; // 注册 Callback mediaController.registerCallback(callback); // 执行播放操作 mediaController.getTransportControls().play(); // 在适当的时候注销 Callback // mediaController.unregisterCallback(callback); No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-4.应用层-功能模块/动画.html":{"url":"04_Android/应用层/SDK/2-4.应用层-功能模块/动画.html","title":"动画","keywords":"","body":"分类： 补间动画(Tweened Animation) 在几个关键的节点对对象进行描述又系统进行填充 逐帧动画(Frame-by-Frame Animation)。 在固定的时间点以一定速率播放一系列的drawable资源 补间动画 补间动画分为如下种 Alpha 淡入淡出 Scale 缩放 Rotate 旋转 Translate 平移 这些动画是可以同时进行和顺次进行的。需要用到AnimationSet来实现。调用AnimationSet.addAnimation()即可。 实现方法举例: (Button)btn = (Button)findViewById(...); AnimationSet as = new AnimationSet(false);//新建AnimationSet实例 TranslateAnimation ta = new TranslateAnimation(//新建平移动画实例，在构造函数中传入平移的始末位置 Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, 0.3f, Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, 0.3f); ta.setStartOffset(0);//AnimationSet被触发后立刻执行 ta.setInterpolator(new AccelerateDecelerateInterpolator());//加入一个加速减速插值器 ta.setFillAfter(true);//动画结束后保持该状态 ta.setDuration(700);//设置动画时长 ScaleAnimation sa = new ScaleAnimation(1f, 0.1f, 1f, 0.1f,//构造一个缩放动画实例，构造函数参数传入百分比和缩放中心 ScaleAnimation.RELATIVE_TO_SELF, 0.5f, ScaleAnimation.RELATIVE_TO_SELF, 0.5f); sa.setInterpolator(new AccelerateDecelerateInterpolator());//加入一个加速减速插值器 sa.setDuration(700);//设置时长 sa.setFillAfter(true);//动画结束后保持该状态 sa.setStartOffset(650);//AnimationSet触发后650ms启动动画 AlphaAnimation aa = new AlphaAnimation(1f, 0f);//构造一个淡出动画，从100%变为0% aa.setDuration(700);//设置时长 aa.setStartOffset(650);//AnimationSet触发后650ms启动动画 aa.setFillAfter(true);//动画结束后保持该状态 as.addAnimation(ta); as.addAnimation(sa); as.addAnimation(aa);//将动画放入AnimationSet中 btn.setOnClickListener(new OnClickListener(){ public void onClick(View view){ btn.startAnimation(as);//触发动画 } } 该段代码实现了先平移，然后边缩小边淡出。 具体的代码实现需要注意各个参数所代表的含义，比较琐碎，建议阅读文档熟悉。在这里不做过多讲解，文档说的已经很清楚了。 文档连接http://developer.android.com/reference/android/view/animation/Animation.html 视图动画 Scale缩放动画 set标签属性： duration:持续时间 fillAfter:动画完成后保持完成状态 pivotX pivotY 拉伸基准点 Translate位移动画 p代表父控件 Rotate旋转动画 repeatCount重复次数 ，可为infinite代表无限重复 repeatMode默认为restart，重复开始，可为reverse 原路返回 复合动画 利用 startOffset 开始等待时长 animatorSet Alpha动画 xml： 2.动画结束停留在第一帖 --> 在Java中使用xml代码： //初始化渐变动画 Animation animation = AnimationUtils.loadAnimation(this, R.anim.alpha); //设置动画监听器 animation.setAnimationListener(new AnimationListener() { @Override public void onAnimationStart(Animation animation) { } @Override public void onAnimationRepeat(Animation animation) { // TODO Auto-generated method stub } @Override public void onAnimationEnd(Animation animation) { //当监听到动画结束时，进行一些操作 } }); //开始播放动画 rootView.startAnimation(animation); 在java代码中实现渐变的透明动画： /** * 渐变透明动画的实现 */ public AlphaAnimation getAlphaAnimotion() { //创建 AlphaAnimation 对象 并指定透明渐变的范围 AlphaAnimation alphaAnimation = new AlphaAnimation(0.0f, 1.0f); //设置动画执行的时间 alphaAnimation.setDuration(300); //设置动画是否在壁纸上运行 alphaAnimation.setDetachWallpaper(false); //设置动画执行完毕后所要停留的位置 alphaAnimation.setFillAfter(true); alphaAnimation.setFillEnabled(true); alphaAnimation.setFillBefore(true); //设置动画为线性匀速执行 alphaAnimation.setInterpolator(new LinearInterpolator()); //设置动画执行重复的次数 alphaAnimation.setRepeatCount(2); //设置动画执行重复的模式 alphaAnimation.setRepeatMode(Animation.RESTART); //设置动画的执行时间间隔为3秒 alphaAnimation.setStartOffset(3000); //设置动画开始的时间 alphaAnimation.setStartTime(3000); alphaAnimation.start(); return alphaAnimation; } 逐帧动画 这一部分只涉及非常基础的知识。我们可以将每帧图片资源放到drawable下然后代码中canvas.drawBitmap(Bitmap, Matrix, Paint)进行动画播放。 drawable存放动画的方式： 每一帧是一张png图片中 所有动画帧都存在一张png图片中、 每一帧是一张png 说的就是这个效果： 在animation1.xml文件中进行如下配置：（一个item就是一帧） ?xml version=\"1.0\" encoding=\"utf-8\"?> > 在JAVA文件中我们进行如下加载： ImageView animationIV; AnimationDrawable animationDrawable; animationIV.setImageResource(R.drawable.animation1); animationDrawable = (AnimationDrawable) animationIV.getDrawable(); animationDrawable.start(); 注意动画的播放是按照xml文件中的顺序顺次播放，如果要考虑到循环播放的时候应该写两个xml一个正向一个反向才能很好地循环播放。 使用方式2 所有动画在一张png中 说的就是这个效果： animation.xml的配置： 010001.png frame { {378, 438}, {374, 144} } offset {-2, 7} sourceColorRect { {61, 51}, {374, 144} } sourceSize {500, 260} 010002.png frame { {384, 294}, {380, 142} } offset {1, 7} sourceColorRect rotate { {61, 52}, {380, 142} } sourceSize {500, 260} … 其中： frame 指定在原图中截取的框大小； offeset 指定原图中心与截图中心偏移的向量； rotate若为true顺时针旋转90°； sourceColorRect 截取原图透明部分的大小 sourceSize 原图大小 JAVA的加载方式与第一种方法相同。 在使用过程中一定要注意内存资源的回收和drawable的压缩，一不小心可能爆掉。 本文参考博闻： .plist中各个key的含义 Android游戏中的动画制作 Android研究院值游戏开发 用Animation-list实现逐帧动画 最后放一张demo: 属性动画 Animator AnimatorSet animatorSet ValueAnimator 针对属性的值进行动画 也可以生成浮点数 ObjectAnimator 调用对象对应属性的get/set方法吧属性的值设置给对象的属性 //绕Z轴旋转 ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(btnShow,\"rotation\",0,360); objectAnimator.setDuration(3000); objectAnimator.start(); //绕X轴旋转 ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(btnShow,\"rotationX\",0,360); objectAnimator.setDuration(3000); objectAnimator.start(); //透明 ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(btnShow,\"alpha\",0,1,0,1); objectAnimator.setDuration(3000); objectAnimator.start(); //沿X轴平移 ObjectAnimator.ofFloat(btnShow, \"translationX\",0,200) .setDuration(3000) .start(); //沿Y轴平移 ObjectAnimator.ofFloat(btnShow, \"translationY\",0,200) .setDuration(3000) .start(); //沿X轴缩放 ObjectAnimator.ofFloat(btnShow, \"scaleX\",0,1) .setDuration(3000) .start(); //沿Y轴平移 ObjectAnimator.ofFloat(btnShow, \"scaleY\",0,1) .setDuration(3000) .start(); TimeAnimator 提供一个监听回调，返回动画执行的总时间，距离上次动画执行的时间等。 其它 插值器Interpolator 作用： 时间控制：通过设置插值器，可以改变动画的持续时间、加速度和减速度等。默认情况下，动画的时间是线性变化的，但通过插值器可以实现自定义的时间曲线，例如渐入渐出、弹跳效果等，使动画更加生动和自然。 变化速率控制：插值器还可以调整动画在不同时间点上的变化速率。通过选择不同的插值器，可以实现匀速、加速、减速、抛物线等变化速率效果，使动画呈现出不同的动态特性。 自定义效果：使用自定义插值器，开发者可以根据自己的需求实现独特的动画效果。通过调整插值器的定义函数，可以创造出各种奇特、非线性的动画效果，为应用增添创意和个性化。 在安卓中，系统提供了一些常用的插值器，例如线性插值器（LinearInterpolator）、加速插值器（AccelerateInterpolator）、减速插值器（DecelerateInterpolator）等。此外，开发者也可以自定义插值器，通过实现Interpolator接口，定义自己的插值器行为。 Code： svg动画 1.解析SVG文件：使用SVG库解析SVG文件并将其转换为可操作的对象。您可以使用以下代码示例将SVG文件解析为SVG对象： SVG svg = SVGParser.getSVGFromInputStream(getResources().openRawResource(R.raw.your_svg_file)); 2.将SVG绘制到画布：使用SVG库提供的绘制方法，将SVG对象绘制到画布上。例如，您可以使用以下代码将SVG绘制到Canvas对象： svg.renderToCanvas(canvas); No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-4.应用层-功能模块/图片处理.html":{"url":"04_Android/应用层/SDK/2-4.应用层-功能模块/图片处理.html","title":"图片处理","keywords":"","body":"Glide 加载图片 对比其他图片加载库： UniversalImageLoader功能全面但使用比较复杂 Volley谷歌推出，功能不够强大 Picasso不支持GIF图片加载 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-4.应用层-功能模块/推送.html":{"url":"04_Android/应用层/SDK/2-4.应用层-功能模块/推送.html","title":"推送","keywords":"","body":"推送 常用推送平台： 谷歌云通讯（限制访问）、极光推送、友盟推送、个推 集成极光推送： 1.创建极光账号 2.创建应用并开通推送功能 3.集成SDK No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-4.应用层-功能模块/时间.html":{"url":"04_Android/应用层/SDK/2-4.应用层-功能模块/时间.html","title":"时间","keywords":"","body":"时间 获取当前时间戳的方法 //方法 一 System.currentTimeMillis(); //方法 二,较慢 Calendar.getInstance().getTimeInMillis(); //方法 三 new Date().getTime(); 获取当前时间 SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式 String date = df.format(new Date());// new Date()为获取当前系统时间，也可使用当前时间戳 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-4.应用层-功能模块/蓝牙.html":{"url":"04_Android/应用层/SDK/2-4.应用层-功能模块/蓝牙.html","title":"蓝牙","keywords":"","body":"蓝牙 安卓提供的Bluetooth API 功能进行的操作： 扫描其他蓝牙设备 查询本地蓝牙适配器的配对蓝牙设备 建立 RFCOMM 通道 通过服务发现连接到其他设备 与其他设备进行双向数据传输 管理多个连接 传统蓝牙适用于较为耗电的操作，其中包括 Android 设备之间的流式传输和通信等。针对具有低功耗要求的蓝牙设备，Android 4.3(API 级别 18)中引入了面向低功耗蓝牙的 API 支持。如需了解更多信息，请参阅低功耗蓝牙。 蓝牙基础知识： 为了让支持蓝牙的设备能够在彼此之间传输数据，它们必须先通过配对过程形成通信通道。其中一台设备(可检测到的设备)需将自身设置为可接收传入的连接请求。另一台设备会使用服务发现过程找到此可检测到的设备。在可检测到的设备接受配对请求后，这两台设备会完成绑定过程，并在此期间交换安全密钥。二者会缓存这些密钥，以供日后使用。完成配对和绑定过程后，两台设备会交换信息。当会话完成时，发起配对请求的设备会发布已将其链接到可检测设备的通道。但是，这两台设备仍保持绑定状态，因此在未来的会话期间，只要二者在彼此的范围内且均未移除绑定，便可自动重新连接。 权限 蓝牙权限 如要在应用中使用蓝牙功能，您必须声明两个权限。第一个是 BLUETOOTH。您需要此权限才能执行任何蓝牙通信，例如请求连接、接受连接和传输数据等。 如果您想让应用启动设备发现或操纵蓝牙设置，则除了 BLUETOOTH 权限以外，您还必须声明 BLUETOOTH_ADMIN 权限。大多数应用只是需利用此权限发现本地蓝牙设备。除非应用是根据用户请求修改蓝牙设置的“超级管理员”，否则不应使用此权限所授予的其他功能。 蓝牙权限是normal级权限，只需要在Manifest里面声明即可，不需要判断和处理(测试即使禁用了也不影响蓝牙连接)。 位置权限 第二个必须声明的权限是 ACCESS_FINE_LOCATION。您的应用需要此权限，因为蓝牙扫描可用于收集用户的位置信息。此类信息可能来自用户自己的设备，以及在商店和交通设施等位置使用的蓝牙信标。 注意：如果您的应用适配 Android 9(API 级别 28)或更低版本，则您可以声明 ACCESS_COARSE_LOCATION 权限而非 ACCESS_FINE_LOCATION 权限。 ACCESS_COARSE_LOCATION通过WiFi或移动基站获取粗略定位(误差在30~1500米)，ACCESS_FINE_LOCATION为GPS精确定位(精度10米以内)。 位置权限是dangerous级权限，除了需要在Manifest里申请之外，还需要在代码中进行动态申请。 代码 清单文件中声明权限 ... 动态申请权限 /** * 动态申请权限会调用弹窗导致调用两次onResume */ private void checkPermission() { //华为的动态申请权限 if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED || ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED || ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_BACKGROUND_LOCATION) != PackageManager.PERMISSION_GRANTED || ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) { String[] strings = {Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_BACKGROUND_LOCATION, Manifest.permission.WRITE_EXTERNAL_STORAGE}; ActivityCompat.requestPermissions(this, strings, 2); } } 配置文件 https://developer.android.com/guide/topics/connectivity/bluetooth?hl=zh-cn 设置蓝牙 您需验证设备支持蓝牙，确保在此情况下启用该功能，这样您的应用才能通过蓝牙进行通信。 如果设备不支持蓝牙，则应正常停用任何蓝牙功能。如果设备支持蓝牙但已停用此功能，则您可以请求用户在不离开应用的同时启用蓝牙。借助 BluetoothAdapter，您可以分两步完成此设置： 获取 BluetoothAdapter。 所有蓝牙 Activity 都需要 BluetoothAdapter。如要获取 BluetoothAdapter，请调用静态的 getDefaultAdapter() 方法。此方法会返回一个 BluetoothAdapter 对象，表示设备自身的蓝牙适配器(蓝牙无线装置)。整个系统只有一个蓝牙适配器，并且您的应用可使用此对象与之进行交互。如果 getDefaultAdapter() 返回 null，则表示设备不支持蓝牙。例如： BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); if (bluetoothAdapter == null) { // Device doesn't support Bluetooth } 启用蓝牙。 下一步，您需要确保已启用蓝牙。调用 isEnabled()，以检查当前是否已启用蓝牙。如果此方法返回 false，则表示蓝牙处于停用状态。如要请求启用蓝牙，请调用 startActivityForResult()，从而传入一个 ACTION_REQUEST_ENABLE Intent 操作。此调用会发出通过系统设置启用蓝牙的请求(无需停止应用)。例如： if (!bluetoothAdapter.isEnabled()) { Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT); } 系统将显示对话框，请求用户允许启用蓝牙。如果用户响应“Yes”，系统会开始启用蓝牙，并在该进程完成(或失败)后将焦点返回您应用。 传递给 startActivityForResult() 的 REQUEST_ENABLE_BT 常量为局部定义的整型数(必须大于 0)。系统会以 onActivityResult() 实现中的 requestCode 参数形式，向您传回该常量。 如果成功启用蓝牙，您的 Activity 会在 onActivityResult() 回调中收到 RESULT_OK 结果代码。如果由于某个错误(或用户响应“No”)未成功启用蓝牙，则结果代码为 RESULT_CANCELED。 您的应用还可选择侦听 ACTION_STATE_CHANGED 广播 Intent，每当蓝牙状态发生变化时，系统都会广播此 Intent。此广播包含额外字段 EXTRA_STATE 和 EXTRA_PREVIOUS_STATE，二者分别包含新的和旧的蓝牙状态。这些额外字段可能为以下值：STATE_TURNING_ON、STATE_ON、STATE_TURNING_OFF 和 STATE_OFF。如果您的应用需检测对蓝牙状态所做的运行时更改，请侦听此广播。 提示：启用可检测性即可自动启用蓝牙。如果您计划在执行蓝牙 Activity 之前一直启用设备的可检测性，则可以跳过上述步骤 2。如需了解详情，请阅读本页面上的启用可检测性部分。 查找设备 利用 BluetoothAdapter，您可以通过设备发现或查询配对设备的列表来查找远程蓝牙设备。 设备发现是一个扫描过程，它会搜索局部区域内已启用蓝牙功能的设备，并请求与每台设备相关的某些信息。此过程有时也被称为发现、查询或扫描。但是，只有在当下接受信息请求时，附近区域的蓝牙设备才会通过启用可检测性响应发现请求。如果设备已启用可检测性，它会通过共享一些信息(例如设备的名称、类及其唯一的 MAC 地址)来响应发现请求。借助此类信息，执行发现过程的设备可选择发起对已检测到设备的连接。 在首次与远程设备建立连接后，系统会自动向用户显示配对请求。当设备完成配对后，系统会保存关于该设备的基本信息(例如设备的名称、类和 MAC 地址)，并且可使用 Bluetooth API 读取这些信息。借助远程设备的已知 MAC 地址，您可以随时向其发起连接，而无需执行发现操作(假定该设备仍处于有效范围内)。 请注意，被配对与被连接之间存在区别： 被配对是指两台设备知晓彼此的存在，具有可用于身份验证的共享链路密钥，并且能够与彼此建立加密连接。 被连接是指设备当前共享一个 RFCOMM 通道，并且能够向彼此传输数据。当前的 Android Bluetooth API 要求规定，只有先对设备进行配对，然后才能建立 RFCOMM 连接。在使用 Bluetooth API 发起加密连接时，系统会自动执行配对。 以下部分介绍如何查找已配对的设备，或使用设备发现功能来发现新设备。 注意：Android 设备默认处于不可检测到状态。用户可通过系统设置将设备设为在有限的时间内处于可检测到状态，或者，应用可请求用户在不离开应用的同时启用可检测性。如需了解更多信息，请参阅本页面的启用可检测性部分。 查询已配对设备 在执行设备发现之前，您必须查询已配对的设备集，以了解所需的设备是否处于已检测到状态。为此，请调用 getBondedDevices()。此方法会返回一组表示已配对设备的 BluetoothDevice 对象。例如，您可以查询所有已配对设备，并获取每台设备的名称和 MAC 地址，如以下代码段所示： Set pairedDevices = bluetoothAdapter.getBondedDevices(); if (pairedDevices.size() > 0) { // There are paired devices. Get the name and address of each paired device. for (BluetoothDevice device : pairedDevices) { String deviceName = device.getName(); String deviceHardwareAddress = device.getAddress(); // MAC address } } 如要发起与蓝牙设备的连接，您只需从关联的 BluetoothDevice 对象获取 MAC 地址，您可通过调用 getAddress() 检索此地址。有关创建连接的详情，请参阅连接设备部分。 注意：执行设备发现将消耗蓝牙适配器的大量资源。在找到要连接的设备后，请务必使用 cancelDiscovery() 停止发现，然后再尝试连接。此外，您不应在连接到设备的情况下执行设备发现，因为发现过程会大幅减少可供任何现有连接使用的带宽。 发现设备 如要开始发现设备，只需调用 startDiscovery()。该进程为异步操作，并且会返回一个布尔值，指示发现进程是否已成功启动。发现进程通常包含约 12 秒钟的查询扫描，随后会对发现的每台设备进行页面扫描，以检索其蓝牙名称。 您的应用必须针对 ACTION_FOUND Intent 注册一个 BroadcastReceiver，以便接收每台发现的设备的相关信息。系统会为每台设备广播此 Intent。Intent 包含额外字段 EXTRA_DEVICE 和 EXTRA_CLASS，二者又分别包含 BluetoothDevice 和 BluetoothClass。以下代码段展示如何在发现设备时通过注册来处理广播： @Override protected void onCreate(Bundle savedInstanceState) { ... // Register for broadcasts when a device is discovered. IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); registerReceiver(receiver, filter); } // Create a BroadcastReceiver for ACTION_FOUND. private final BroadcastReceiver receiver = new BroadcastReceiver() { public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (BluetoothDevice.ACTION_FOUND.equals(action)) { // Discovery has found a device. Get the BluetoothDevice // object and its info from the Intent. BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); String deviceName = device.getName(); String deviceHardwareAddress = device.getAddress(); // MAC address } } }; @Override protected void onDestroy() { super.onDestroy(); ... // Don't forget to unregister the ACTION_FOUND receiver. unregisterReceiver(receiver); } 如要发起与蓝牙设备的连接，您只需从关联的 BluetoothDevice 对象获取 MAC 地址，您可通过调用 getAddress() 检索此地址。有关创建连接的详情，请参阅连接设备部分。 注意：执行设备发现将消耗蓝牙适配器的大量资源。在找到要连接的设备后，请务必使用 cancelDiscovery() 停止发现，然后再尝试连接。此外，您不应在连接到设备的情况下执行设备发现，因为发现过程会大幅减少可供任何现有连接使用的带宽。 启用可检测性 如果您希望将本地设备设为可被其他设备检测到，请使用 ACTION_REQUEST_DISCOVERABLE Intent 调用 startActivityForResult(Intent, int)。这样便可发出启用系统可检测到模式的请求，从而无需导航至设置应用，避免暂停使用您的应用。默认情况下，设备处于可检测到模式的时间为 120 秒(2 分钟)。通过添加 EXTRA_DISCOVERABLE_DURATION Extra 属性，您可以定义不同的持续时间，最高可达 3600 秒(1 小时)。 注意：如果您将 EXTRA_DISCOVERABLE_DURATION Extra 属性的值设置为 0，则设备将始终处于可检测到模式。此配置安全性低，因而非常不建议使用。 以下代码段将设备处于可检测到模式的时间设置为 5 分钟(300 秒)： Intent discoverableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE); discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300); startActivity(discoverableIntent); 统将显示对话框，请求用户允许将设备设为可检测到模式。如果用户响应“Yes”，则设备会变为可检测到模式，并在指定时间内保持该模式。然后，您的 Activity 将会收到对 onActivityResult() 回调的调用，其结果代码等于设备可检测到的持续时间。如果用户响应“No”或出现错误，则结果代码为 RESULT_CANCELED。 注意：如果尚未在设备上启用蓝牙，则启用设备可检测性会自动启用蓝牙。 设备将在分配的时间内以静默方式保持可检测到模式。如果您希望在可检测到模式发生变化时收到通知，则可以为 ACTION_SCAN_MODE_CHANGED Intent 注册 BroadcastReceiver。此 Intent 将包含额外字段 EXTRA_SCAN_MODE 和 EXTRA_PREVIOUS_SCAN_MODE，二者分别提供新的和旧的扫描模式。每个 Extra 属性可能拥有以下值： SCAN_MODE_CONNECTABLE_DISCOVERABLE 设备处于可检测到模式。 SCAN_MODE_CONNECTABLE 设备未处于可检测到模式，但仍能收到连接。 SCAN_MODE_NONE 设备未处于可检测到模式，且无法收到连接。 如果您要发起对远程设备的连接，则无需启用设备可检测性。只有当您希望应用对接受传入连接的服务器套接字进行托管时，才有必要启用可检测性，因为在发起对其他设备的连接之前，远程设备必须能够发现这些设备。 连接设备 如要在两台设备之间创建连接，您必须同时实现服务器端和客户端机制，因为其中一台设备必须开放服务器套接字，而另一台设备必须使用服务器设备的 MAC 地址发起连接。服务器设备和客户端设备均会以不同方法获得所需的 BluetoothSocket。接受传入连接后，服务器会收到套接字信息。在打开与服务器相连的 RFCOMM 通道时，客户端会提供套接字信息。 当服务器和客户端在同一 RFCOMM 通道上分别拥有已连接的 BluetoothSocket 时，即可将二者视为彼此连接。这种情况下，每台设备都能获得输入和输出流式传输，并开始传输数据，相关详细介绍请参阅管理连接部分。本部分介绍如何在两台设备之间发起连接。 连接技术 一种实现技术是自动将每台设备准备为一个服务器，从而使每台设备开放一个服务器套接字并侦听连接。在此情况下，任一设备都可发起与另一台设备的连接，并成为客户端。或者，其中一台设备可显式托管连接并按需开放一个服务器套接字，而另一台设备则发起连接。 注意：如果两台设备之前尚未配对，则在连接过程中，Android 框架会自动向用户显示配对请求通知或对话框(如图 3 所示)。因此，在尝试连接设备时，您的应用无需担心设备是否已配对。在用户成功配对两台设备之前，您的 RFCOMM 连接尝试会一直阻塞，并且如果用户拒绝配对，或者配对过程失败或超时，则该尝试便会失败。 作为服务器连接 当您需要连接两台设备时，其中一台设备必须保持开放的 BluetoothServerSocket，从而充当服务器。服务器套接字的用途是侦听传入的连接请求，并在接受请求后提供已连接的 BluetoothSocket。从 BluetoothServerSocket 获取 BluetoothSocket 后，您可以(并且应该)舍弃 BluetoothServerSocket，除非您的设备需要接受更多连接。 如要设置服务器套接字并接受连接，请依次完成以下步骤： 通过调用 listenUsingRfcommWithServiceRecord() 获取 BluetoothServerSocket。 该字符串是服务的可识别名称，系统会自动将其写入到设备上的新服务发现协议 (SDP) 数据库条目。此名称没有限制，可直接使用您的应用名称。SDP 条目中也包含通用唯一标识符 (UUID)，这也是客户端设备连接协议的基础。换言之，当客户端尝试连接此设备时，它会携带 UUID，从而对其想要连接的服务进行唯一标识。为了让服务器接受连接，这些 UUID 必须互相匹配。 UUID 是一种标准化的 128 位格式，可供字符串 ID 用来对信息进行唯一标识。UUID 的特点是其足够庞大，因此您可以选择任意随机 ID，而不会与其他任何 ID 发生冲突。在本例中，其用于对应用的蓝牙服务进行唯一标识。如要获取供应用使用的 UUID，您可以从网络上的众多随机 UUID 生成器中任选一种，然后使用 fromString(String) 初始化一个 UUID。 通过调用 accept() 开始侦听连接请求。 这是一个阻塞调用。当服务器接受连接或异常发生时，该调用便会返回。只有当远程设备发送包含 UUID 的连接请求，并且该 UUID 与使用此侦听服务器套接字注册的 UUID 相匹配时，服务器才会接受连接。连接成功后，accept() 将返回已连接的 BluetoothSocket。 如果您无需接受更多连接，请调用 close()。 此方法调用会释放服务器套接字及其所有资源，但不会关闭 accept() 所返回的已连接的 BluetoothSocket。与 TCP/IP 不同，RFCOMM 一次只允许每个通道有一个已连接的客户端，因此大多数情况下，在接受已连接的套接字后，您可以立即在 BluetoothServerSocket 上调用 close()。 由于 accept() 是阻塞调用，因此您不应在主 Activity 界面线程中执行该调用，这样您的应用才仍然可以响应其他用户的交互。通常，您可以在应用所管理的新线程中完成所有涉及 BluetoothServerSocket 或 BluetoothSocket 的工作。如要取消 accept() 等被阻塞的调用，请通过另一个线程，在 BluetoothServerSocket 或 BluetoothSocket 上调用 close()。请注意，BluetoothServerSocket 或 BluetoothSocket 中的所有方法都是线程安全的方法。 示例 服务器组件可通过以下简化线程接受传入连接： private class AcceptThread extends Thread { private final BluetoothServerSocket mmServerSocket; public AcceptThread() { // Use a temporary object that is later assigned to mmServerSocket // because mmServerSocket is final. BluetoothServerSocket tmp = null; try { // MY_UUID is the app's UUID string, also used by the client code. tmp = bluetoothAdapter.listenUsingRfcommWithServiceRecord(NAME, MY_UUID); } catch (IOException e) { Log.e(TAG, \"Socket's listen() method failed\", e); } mmServerSocket = tmp; } public void run() { BluetoothSocket socket = null; // Keep listening until exception occurs or a socket is returned. while (true) { try { socket = mmServerSocket.accept(); } catch (IOException e) { Log.e(TAG, \"Socket's accept() method failed\", e); break; } if (socket != null) { // A connection was accepted. Perform work associated with // the connection in a separate thread. manageMyConnectedSocket(socket); mmServerSocket.close(); break; } } } // Closes the connect socket and causes the thread to finish. public void cancel() { try { mmServerSocket.close(); } catch (IOException e) { Log.e(TAG, \"Could not close the connect socket\", e); } } } 在此示例中，只需要一个传入连接，因此在接受连接并获取 BluetoothSocket 之后，应用会立即将获取的 BluetoothSocket 传送到单独的线程、关闭 BluetoothServerSocket 并中断循环。 请注意，如果 accept() 返回 BluetoothSocket，则表示已连接套接字。因此，您不应像从客户端那样调用 connect()。 应用特定的 manageMyConnectedSocket() 方法旨在启动用于传输数据的线程(详情请参阅管理连接部分)。 通常，在完成传入连接的侦听后，您应立即关闭您的 BluetoothServerSocket。在此示例中，获取 BluetoothSocket 后会立即调用 close()。此外，您可能还希望在线程中提供一个公共方法，以便在需要停止侦听服务器套接字时关闭私有 BluetoothSocket。 作为客户端连接 如果远程设备在开放服务器套接字上接受连接，则为了发起与此设备的连接，您必须首先获取表示该远程设备的 BluetoothDevice 对象。如要了解如何创建 BluetoothDevice，请参阅查找设备。然后，您必须使用 BluetoothDevice 来获取 BluetoothSocket 并发起连接。 基本步骤如下所示： 使用 BluetoothDevice，通过调用 createRfcommSocketToServiceRecord(UUID) 获取 BluetoothSocket。 此方法会初始化 BluetoothSocket 对象，以便客户端连接至 BluetoothDevice。此处传递的 UUID 必须与服务器设备在调用 listenUsingRfcommWithServiceRecord(String, UUID) 开放其 BluetoothServerSocket 时所用的 UUID 相匹配。如要使用匹配的 UUID，请通过硬编码方式将 UUID 字符串写入您的应用，然后通过服务器和客户端代码引用该字符串。 通过调用 connect() 发起连接。请注意，此方法为阻塞调用。 当客户端调用此方法后，系统会执行 SDP 查找，以找到带有所匹配 UUID 的远程设备。如果查找成功并且远程设备接受连接，则其会共享 RFCOMM 通道以便在连接期间使用，并且 connect() 方法将会返回。如果连接失败，或者 connect() 方法超时(约 12 秒后)，则此方法将引发 IOException。 由于 connect() 是阻塞调用，因此您应始终在主 Activity(界面)线程以外的线程中执行此连接步骤。 注意：您应始终调用 cancelDiscovery()，以确保设备在您调用 connect() 之前不会执行设备发现。如果正在执行发现操作，则会大幅降低连接尝试的速度，并增加连接失败的可能性。 示例 以下是发起蓝牙连接的客户端线程的基本示例： private class ConnectThread extends Thread { private final BluetoothSocket mmSocket; private final BluetoothDevice mmDevice; public ConnectThread(BluetoothDevice device) { // Use a temporary object that is later assigned to mmSocket // because mmSocket is final. BluetoothSocket tmp = null; mmDevice = device; try { // Get a BluetoothSocket to connect with the given BluetoothDevice. // MY_UUID is the app's UUID string, also used in the server code. tmp = device.createRfcommSocketToServiceRecord(MY_UUID); } catch (IOException e) { Log.e(TAG, \"Socket's create() method failed\", e); } mmSocket = tmp; } public void run() { // Cancel discovery because it otherwise slows down the connection. bluetoothAdapter.cancelDiscovery(); try { // Connect to the remote device through the socket. This call blocks // until it succeeds or throws an exception. mmSocket.connect(); } catch (IOException connectException) { // Unable to connect; close the socket and return. try { mmSocket.close(); } catch (IOException closeException) { Log.e(TAG, \"Could not close the client socket\", closeException); } return; } // The connection attempt succeeded. Perform work associated with // the connection in a separate thread. manageMyConnectedSocket(mmSocket); } // Closes the client socket and causes the thread to finish. public void cancel() { try { mmSocket.close(); } catch (IOException e) { Log.e(TAG, \"Could not close the client socket\", e); } } } 请注意，此段代码在尝试连接之前先调用了 cancelDiscovery()。您应始终在 connect() 之前调用 cancelDiscovery()，这是因为无论当前是否正在执行设备发现，cancelDiscovery() 都会成功。但是，如果应用需要确定是否正在执行设备发现，您可以使用 isDiscovering() 进行检测。 应用特定 manageMyConnectedSocket() 方法旨在启动用于传输数据的线程(详情请参阅管理连接部分)。 使用完 BluetoothSocket 后，请务必调用 close()。这样，您便可立即关闭连接的套接字，并释放所有相关的内部资源。 管理连接 成功连接多台设备后，每台设备都会有已连接的 BluetoothSocket。这一点非常有趣，因为这表示您可以在设备之间共享信息。使用 BluetoothSocket 传输数据的一般过程如下所示： 使用 getInputStream() 和 getOutputStream()，分别获取通过套接字处理数据传输的 InputStream 和 OutputStream。 使用 read(byte[]) 和 write(byte[]) 读取数据以及将其写入数据流。 当然，您还需考虑实现细节。具体来说，您应使用专门的线程从数据流读取数据，以及将数据写入数据流。这一点非常重要，因为 read(byte[]) 和 write(byte[]) 方法都是阻塞调用。read(byte[]) 方法将会阻塞，直至从数据流中读取数据。write(byte[]) 方法通常不会阻塞，但若远程设备调用 read(byte[]) 方法的速度不够快，进而导致中间缓冲区已满，则该方法可能会保持阻塞状态以实现流量控制。因此，线程中的主循环应专门用于从 InputStream 中读取数据。您可使用线程中单独的公共方法，发起对 OutputStream 的写入操作。 示例 以下示例介绍如何在通过蓝牙连接的两台设备之间传输数据： public class MyBluetoothService { private static final String TAG = \"MY_APP_DEBUG_TAG\"; private Handler handler; // handler that gets info from Bluetooth service // Defines several constants used when transmitting messages between the // service and the UI. private interface MessageConstants { public static final int MESSAGE_READ = 0; public static final int MESSAGE_WRITE = 1; public static final int MESSAGE_TOAST = 2; // ... (Add other message types here as needed.) } private class ConnectedThread extends Thread { private final BluetoothSocket mmSocket; private final InputStream mmInStream; private final OutputStream mmOutStream; private byte[] mmBuffer; // mmBuffer store for the stream public ConnectedThread(BluetoothSocket socket) { mmSocket = socket; InputStream tmpIn = null; OutputStream tmpOut = null; // Get the input and output streams; using temp objects because // member streams are final. try { tmpIn = socket.getInputStream(); } catch (IOException e) { Log.e(TAG, \"Error occurred when creating input stream\", e); } try { tmpOut = socket.getOutputStream(); } catch (IOException e) { Log.e(TAG, \"Error occurred when creating output stream\", e); } mmInStream = tmpIn; mmOutStream = tmpOut; } public void run() { mmBuffer = new byte[1024]; int numBytes; // bytes returned from read() // Keep listening to the InputStream until an exception occurs. while (true) { try { // Read from the InputStream. numBytes = mmInStream.read(mmBuffer); // Send the obtained bytes to the UI activity. Message readMsg = handler.obtainMessage( MessageConstants.MESSAGE_READ, numBytes, -1, mmBuffer); readMsg.sendToTarget(); } catch (IOException e) { Log.d(TAG, \"Input stream was disconnected\", e); break; } } } // Call this from the main activity to send data to the remote device. public void write(byte[] bytes) { try { mmOutStream.write(bytes); // Share the sent message with the UI activity. Message writtenMsg = handler.obtainMessage( MessageConstants.MESSAGE_WRITE, -1, -1, mmBuffer); writtenMsg.sendToTarget(); } catch (IOException e) { Log.e(TAG, \"Error occurred when sending data\", e); // Send a failure message back to the activity. Message writeErrorMsg = handler.obtainMessage(MessageConstants.MESSAGE_TOAST); Bundle bundle = new Bundle(); bundle.putString(\"toast\", \"Couldn't send data to the other device\"); writeErrorMsg.setData(bundle); handler.sendMessage(writeErrorMsg); } } // Call this method from the main activity to shut down the connection. public void cancel() { try { mmSocket.close(); } catch (IOException e) { Log.e(TAG, \"Could not close the connect socket\", e); } } } } 当构造函数获取必要的数据流后，线程会等待通过 InputStream 传入的数据。当 read(byte[]) 返回数据流中的数据时，将使用来自父类的 Handler 成员将数据发送到主 Activity。然后，线程会等待从 InputStream 中读取更多字节。 发送传出数据不外乎从主 Activity 调用线程的 write() 方法，并传入要发送的字节。此方法会调用 write(byte[])，从而将数据发送到远程设备。如果在调用 write(byte[]) 时引发 IOException，则线程会发送一条 Toast 至主 Activity，向用户说明设备无法将给定的字节发送到另一台(连接的)设备。 借助线程的 cancel() 方法，您可通过关闭 BluetoothSocket 随时终止连接。当您结束蓝牙连接的使用时，应始终调用此方法。 关键类和接口 BluetoothAdapter 表示本地蓝牙适配器(蓝牙无线装置)。BluetoothAdapter 是所有蓝牙交互的入口点。借助该类，您可以发现其他蓝牙设备、查询已绑定(已配对)设备的列表、使用已知的 MAC 地址实例化 BluetoothDevice，以及通过创建 BluetoothServerSocket 侦听来自其他设备的通信。 BluetoothDevice 表示远程蓝牙设备。借助该类，您可以通过 BluetoothSocket 请求与某个远程设备建立连接，或查询有关该设备的信息，例如设备的名称、地址、类和绑定状态等。 BluetoothSocket 表示蓝牙套接字接口(类似于 TCP Socket)。这是允许应用使用 InputStream 和 OutputStream 与其他蓝牙设备交换数据的连接点。 BluetoothServerSocket 表示用于侦听传入请求的开放服务器套接字(类似于 TCP ServerSocket)。如要连接两台 Android 设备，其中一台设备必须使用此类开放一个服务器套接字。当远程蓝牙设备向此设备发出连接请求时，该设备接受连接，然后返回已连接的 BluetoothSocket。 BluetoothClass 描述蓝牙设备的一般特征和功能。这是一组只读属性，用于定义设备的类和服务。虽然这些信息会提供关于设备类型的有用提示，但该类的属性未必描述设备支持的所有蓝牙配置文件和服务。 BluetoothProfile 表示蓝牙配置文件的接口。蓝牙配置文件是适用于设备间蓝牙通信的无线接口规范。举个例子：免提配置文件。如需了解有关配置文件的详细讨论，请参阅使用配置文件。 BluetoothHeadset 提供蓝牙耳机支持，以便与手机配合使用。这包括蓝牙耳机配置文件和免提 (v1.5) 配置文件。 BluetoothA2dp 定义如何使用蓝牙立体声音频传输配置文件 (A2DP)，通过蓝牙连接将高质量音频从一个设备流式传输至另一个设备。 BluetoothHealth 表示用于控制蓝牙服务的健康设备配置文件代理。 BluetoothHealthCallback 用于实现 BluetoothHealth 回调的抽象类。您必须扩展此类并实现回调方法，以接收关于应用注册状态和蓝牙通道状态变化的更新内容。 BluetoothHealthAppConfiguration 表示第三方蓝牙健康应用注册的应用配置，该配置旨在实现与远程蓝牙健康设备的通信。 BluetoothProfile.ServiceListener 当 BluetoothProfile 进程间通信 (IPC) 客户端连接到运行特定配置文件的内部服务或断开该服务连接时，向该客户端发送通知的接口。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-4.应用层-功能模块/音视频.html":{"url":"04_Android/应用层/SDK/2-4.应用层-功能模块/音视频.html","title":"音视频","keywords":"","body":"反思 | Android 音视频缓存机制的系统性设计：https://juejin.cn/post/7011881370968408071 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-5.应用层-网络通信/HttpClient和UriConnection的区别.html":{"url":"04_Android/应用层/SDK/2-5.应用层-网络通信/HttpClient和UriConnection的区别.html","title":"Httpclient和uriconnection的区别","keywords":"","body":"HttpClient和URLConnection的区别 区别 1、HttpURLConnection是java的标准类，没有做封装，用起来比较原始 2、HttpClient是开源框架，封装了访问HTTP的请求头、参数、内容体、响应等；HttpURLConnection中的输入输出流操作，在这个接口中被统一封装成了HttpPost（HttpGet）和HttpResponse。这样，减少了操作的繁琐性。 下面分别给出HttpURLConnection和HttpClient实现GET、POST请求示例，作为学习。 （1）HttpURLConnection实现GET package com.jingchenyong.test; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL; public class Test_HttpURLConnection_GET { public static void main(String[] args) throws Exception { String urlString=\"http://15.6.46.35:8080/platform/index.html\"; URL url=new URL(urlString); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); conn.setRequestProperty(\"Accept-Charset\", \"UTF-8\"); conn.setRequestProperty(\"connection\", \"keep-Alive\"); conn.setRequestMethod(\"GET\"); conn.connect(); int code=conn.getResponseCode(); System.out.println(code); //把流转为字符串方式一 //String result=IOUtils.toString(conn.getInputStream(),\"UTF-8\"); //把流转为字符串方式二 BufferedReader br=new BufferedReader(new InputStreamReader(conn.getInputStream(), \"UTF-8\")); String result=\"\"; String tmp=\"\"; while((tmp=br.readLine())!=null){ result=result+tmp; } System.out.println(result); //关闭流和连接 } } HttpURLConnection实现POST package com.jingchenyong.test; import java.io.BufferedOutputStream; import java.net.HttpURLConnection; import java.net.URL; import org.apache.commons.io.IOUtils; import org.apache.commons.lang.StringUtils; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class Test_HttpURLConnection_POST { public static void main(String[] args) throws Exception { //设置连接 String urlString = \"http://15.6.46.37:9200//henry/henry/_search\"; URL url = new URL(urlString); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); conn.setRequestProperty(\"Accept-Charset\", \"UTF-8\"); conn.setRequestProperty(\"connection\", \"keep-Alive\"); conn.setRequestMethod(\"POST\"); conn.setDoInput(true); conn.setDoOutput(true); conn.connect(); String jsonstring = getJOSNString(); if (StringUtils.isNotBlank(jsonstring)) { /** * post提交方式一 */ /* OutputStream os = conn.getOutputStream(); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os)); writer.write(jsonstring); writer.flush(); writer.close();*/ BufferedOutputStream out = new BufferedOutputStream(conn.getOutputStream()); out.write(jsonstring.getBytes()); out.flush(); out.close(); //流转字符串的另一种方式见GET方式 String result=IOUtils.toString(conn.getInputStream(),\"UTF-8\"); System.out.println(result); //注意关闭流和连接，这里省略 } } public static String getJOSNString() { JSONObject jsonobject = new JSONObject(); JSONObject jsonobject1 = new JSONObject(); JSONObject jsonobject2 = new JSONObject(); jsonobject2.put(\"name\", \"jingchenyong\"); jsonobject1.put(\"match\", jsonobject2); jsonobject.put(\"query\", jsonobject1); String jsonstring = JSON.toJSONString(jsonobject); return jsonstring; } } HttpClient实现GET package com.jingchenyong.test; import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; import java.util.HashMap; import java.util.Map; import java.util.Map.Entry; import org.apache.commons.collections.MapUtils; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.utils.URIBuilder; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; public class Test_HttpClient_GET { public static void main(String[] args) throws Exception { String url=\"http://15.6.46.35:8080/platform/index.html\"; URIBuilder builder = new URIBuilder(url); CloseableHttpClient httpClient = HttpClients.createDefault(); Map map=getMap(); if(MapUtils.isNotEmpty(map)){ for(Entry entry:map.entrySet()){ builder.addParameter(entry.getKey(), String.valueOf(entry.getValue())); } url=builder.build().toString(); } HttpGet get=new HttpGet(url); // 增加超时设置 RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(1000).build(); get.setConfig(requestConfig); //发送GET请求 CloseableHttpResponse response=httpClient.execute(get); //获取状态码 System.out.println(response.getStatusLine().getStatusCode()); //把结果流转为字符串方式一 /* String result=IOUtils.toString(response.getEntity().getContent()); System.out.println(result); */ //把结果流转为字符串方式二 StringBuilder reMsgBuider = new StringBuilder(); InputStream in = response.getEntity().getContent(); BufferedReader reader = new BufferedReader(new InputStreamReader(in, \"UTF-8\")); String msg = null; // 读取返回消息体 while ((msg = reader.readLine()) != null) { reMsgBuider.append(msg); } String result = reMsgBuider.toString(); System.out.println(result); //关闭流和连接 } public static Map getMap(){ Map map=new HashMap(); //map.put(\"name\", \"jingchenyong\"); //map.put(\"age\", 26); return map; } } HttpClient实现POST package com.jingchenyong.test; import org.apache.commons.io.IOUtils; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class Test_HttpClient_POST { public static void main(String[] args) throws Exception{ String jsonstring=getJOSNString(); RequestConfig config = RequestConfig.custom().setSocketTimeout(30000).setConnectTimeout(30000).build(); CloseableHttpClient client = HttpClients.custom().setDefaultRequestConfig(config).build(); HttpPost post = new HttpPost(\"http://15.6.46.37:9200//henry/henry/_search\"); //填充post体 post.setEntity(new StringEntity(jsonstring,\"UTF-8\")); CloseableHttpResponse response = client.execute(post); System.out.println(\"状态码为：\"+response.getStatusLine().getStatusCode()); //方式一 //System.out.println(\"获取的结果为(获取方式一)：\"+IOUtils.toString(response.getEntity().getContent())); //方式二 见GET //方式三 System.out.println(\"获取的结果为(获取方式二)：\"+EntityUtils.toString(response.getEntity(), \"UTF-8\")); } public static String getJOSNString() { JSONObject jsonobject = new JSONObject(); JSONObject jsonobject1 = new JSONObject(); JSONObject jsonobject2 = new JSONObject(); jsonobject2.put(\"name\", \"jingchenyong\"); jsonobject1.put(\"match\", jsonobject2); jsonobject.put(\"query\", jsonobject1); String jsonstring = JSON.toJSONString(jsonobject); return jsonstring; } } 性能方面： HttpURLConnection的访问速度比HttpClient要快。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-5.应用层-网络通信/网络通信.html":{"url":"04_Android/应用层/SDK/2-5.应用层-网络通信/网络通信.html","title":"网络通信","keywords":"","body":"网络通信 网络通信基础知识 HTTP协议 请求格式 响应格式 工作原理 客户端连接到服务器 发送HTTP请求 服务器接收请求并返回HTTP响应 释放连接 客户端解析响应内容 URL解析 组成 协议 主机 端口 路径 语法 协议://主机名称[:端口]/路径/[:参数][?查询字符串][#片段] Android中的网络操作 网络操作必须在子线程中 权限申请 http请求的限制 9.0对http请求的限制 创建安全配置文件 在res文件夹下创建xml/network-security-config文件 增加cleartextTrafficPermitted属性 添加安全配置文件 AndroidManifest.xml中的Application申明 GET请求 请求数据在url中para1=data1&para2=data2 POST请求 请求数据在数据体中para1=data1&para2=data2 GET VS POST GET 请求可被缓存、保留在浏览器历史记录、被收藏为书签 不适合处理敏感数据 对数据长度有限制(最多1024个字节) 用于获取数据 POST 请求不会被缓存、不会保留在浏览器历史记录中、不能被收藏为书签 更安全 对数据长度没有要求 用于提交数据 JSON解析 getJSONObject(String name)-获取JSONObject对象 toString()-把JSONObject对象转换为json格式的字符串 需要调用runOnUiThread(new Runnable)方法在UI线程中更新界面 GOSN解析 常用方法 toJson-将bean对象转换为json字符串 fromJson-将json字符串转为bean对象 添加依赖库 implementation 'com.google.code.gson:gson:2.8.6' fastjson使用 实体类或集合转JSON串 String jsonStr = JSONObject.toJSONString(实体类对象); JSON串转JSONObject JSONObject jsonObj = JSONObject.parseObject(json串); JSON串转实体类 实体类类名 javaBean = JSON.parseObject(json, 实体类类名.class); JSON串转List集合 List list = JSON.parseObject(json, new TypeReference>(){}); JSONArray字符串转List String courseData = \"...\"; List courseTable; courseTable = JSON.parseObject(courseData, new TypeReference>() {}); courseTable = JSON.parseArray(courseData, Course.class); courseTable = JSON.parseArray(courseData).toJavaList(Course.class); System.out.println(courseTable); OkHttp框架 Get Request.Builder builder = new Request.Builder(); builder.ur1( \"http: //httpbin.org/get\"); Request request = builder.build(); Call call call = client.newCall(request); Response response = call.execute(); call.enqueue( callback) ; Response 使用UDP通信 使用TCP通信 HTTPS 提供加密方案，更安全 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-6.应用层-应用通信/AIDL-RemoteCallbackList.html":{"url":"04_Android/应用层/SDK/2-6.应用层-应用通信/AIDL-RemoteCallbackList.html","title":"Aidl-remotecallbacklist","keywords":"","body":"RemoteCallbackList 类注释 RemoteCallbackList 类负责维护远程接口列表的繁重工作，通常用于在 android.app.Service 和其客户端之间执行回调。具体来说，这个类： 功能概述： 跟踪注册的 IInterface 回调：通过它们的底层唯一的 IBinder 进行识别（通过调用 IInterface.asBinder()）。 为每个注册的接口附加 IBinder.DeathRecipient：这样，如果其进程消失，它可以从列表中清除。 执行底层接口列表的锁定：以处理多线程的传入调用，并以线程安全的方式迭代列表的快照，而不持有其锁。 如何使用： 要使用这个类，只需在您的服务（Service）中创建一个实例，并在客户端注册和注销时调用其 register 和 unregister 方法。要回调注册的客户端，使用 beginBroadcast、getBroadcastItem 和 finishBroadcast 方法。 注意事项： 如果注册的回调的进程消失，这个类会自动从列表中删除它。如果您想在这种情况下进行额外的工作，您可以创建一个子类来实现 onCallbackDied 方法。 示例： javaCopy codepublic class RemoteCallbackList { /** * Registers a callback to be executed by the service. * * @param callback The callback to be registered. * @return `true` if successfully registered, `false` otherwise. */ public boolean register(E callback) { // Implementation } /** * Unregisters a previously registered callback. * * @param callback The callback to be unregistered. * @return `true` if successfully unregistered, `false` otherwise. */ public boolean unregister(E callback) { // Implementation } /** * Begins a broadcast of a call to all registered callbacks. * * @return The count of live callbacks. */ public int beginBroadcast() { // Implementation } /** * Gets the item at the specified index in the broadcast list. * * @param index The index of the item to get. * @return The callback at the specified index. */ public E getBroadcastItem(int index) { // Implementation } /** * Finishes a broadcast. */ public void finishBroadcast() { // Implementation } /** * Called when a registered callback's process goes away. * * @param callback The callback whose process has gone away. */ public void onCallbackDied(E callback) { // Implementation } } 这个 RemoteCallbackList 类提供了一个强大的机制，用于在 Android 应用程序的服务和客户端之间进行高效的回调通信。通过使用这个类，您可以更容易地管理和处理跨进程通信的复杂性。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-6.应用层-应用通信/AIDL.html":{"url":"04_Android/应用层/SDK/2-6.应用层-应用通信/AIDL.html","title":"Aidl","keywords":"","body":"Android 中的 AIDL（Android Interface Definition Language） AIDL（Android Interface Definition Language）是 Android 提供的一种用于在应用组件间进行 IPC（进程间通信）的机制。通过 AIDL，开发者可以定义一个接口，然后在不同的应用组件之间进行通信，例如在应用与服务之间。 1. AIDL 基本概念： 接口定义：使用 AIDL 定义一个接口，该接口定义了可供其他组件调用的方法。 跨进程通信：AIDL 允许应用组件（例如 Activity、Service）与其他进程中的组件进行通信。 2. AIDL 数据类型： AIDL 支持以下数据类型： 基本数据类型（如 int、long、boolean 等） String CharSequence List Map 自定义的 Parcelable 对象 3. AIDL 文件结构： AIDL 文件通常具有 .aidl 扩展名，并且其内容类似于 Java 接口。 aidlCopy code// IMyAidlInterface.aidl package com.example; // 定义接口 interface IMyAidlInterface { int add(int num1, int num2); String concatenate(String str1, String str2); } 4. AIDL 用法： 定义 AIDL 接口：创建 .aidl 文件，并在其中定义接口。 实现 AIDL 接口：在服务（Service）中实现定义的 AIDL 接口。 绑定服务：在客户端（通常是 Activity 或其他服务）中绑定到该 AIDL 服务，并调用其方法。 5. 示例： a. 定义 AIDL 接口： aidlCopy code// IMyAidlInterface.aidl package com.example; // 定义接口 interface IMyAidlInterface { int add(int num1, int num2); String concatenate(String str1, String str2); } b. 实现 AIDL 接口： javaCopy code// MyAidlService.java public class MyAidlService extends Service { private final IMyAidlInterface.Stub mBinder = new IMyAidlInterface.Stub() { @Override public int add(int num1, int num2) throws RemoteException { return num1 + num2; } @Override public String concatenate(String str1, String str2) throws RemoteException { return str1 + str2; } }; @Nullable @Override public IBinder onBind(Intent intent) { return mBinder; } } c. 绑定 AIDL 服务： javaCopy code// MainActivity.java public class MainActivity extends AppCompatActivity { private IMyAidlInterface mService; private final ServiceConnection mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName className, IBinder service) { mService = IMyAidlInterface.Stub.asInterface(service); try { int result = mService.add(5, 3); String concatenatedStr = mService.concatenate(\"Hello, \", \"World!\"); Log.d(\"MainActivity\", \"Add Result: \" + result); Log.d(\"MainActivity\", \"Concatenated String: \" + concatenatedStr); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName className) { mService = null; } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(); intent.setComponent(new ComponentName(\"com.example\", \"com.example.MyAidlService\")); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); } @Override protected void onDestroy() { unbindService(mConnection); super.onDestroy(); } } 6. 注意事项： 线程安全：由于 AIDL 方法在 IPC 通信时运行在服务进程中，因此需要确保 AIDL 接口的实现是线程安全的。 数据传输：当传输自定义对象或列表时，需要确保对象实现了 Parcelable 接口。 AIDL 跨进程抛出异常 来源：https://blog.csdn.net/LVXIANGAN/article/details/103441176 1、跨进程通讯中，从一端到另外一端，只支持传递以下9种异常: SecurityException BadParcelableException IllegalArgumentException NullPointerException IllegalStateException NetworkOnMainThreadException UnsupportedOperationException ServiceSpecificException Parcelable的异常 2、对于不支持的异常，会在程序内部处理，可能导致崩溃，但不会传递给对方。常见的不支持的异常， 运行时异常：RuntimeException 算术异常类：ArithmeticExecption 类型强制转换异常：ClassCastException 数组下标越界异常：ArrayIndexOutOfBoundsException 文件未找到异常：FileNotFoundException 字符串转换为数字异常：NumberFormatException 输入输出异常：IOException 方法未找到异常：NoSuchMethodException 报错： 01-01 05:49:46.770 19937 19937 E testtest: RemoteException 01-01 05:49:46.770 19937 19937 E testtest: java.lang.UnsupportedOperationException: TestException 01-01 05:49:46.770 19937 19937 E testtest: at android.os.Parcel.readException(Parcel.java:1728) 01-01 05:49:46.770 19937 19937 E testtest: at android.os.Parcel.readException(Parcel.java:1669) 01-01 05:49:46.770 19937 19937 E testtest: at me.linjw.demo.ipcdemo.ITestExceptionAidl$Stub$Proxy.testThrowException(ITestExceptionAidl.java:77) 01-01 05:49:46.770 19937 19937 E testtest: at me.linjw.demo.ipcdemo.MainActivity$3.onServiceConnected(MainActivity.java:132) 01-01 05:49:46.770 19937 19937 E testtest: at android.app.LoadedApk$ServiceDispatcher.doConnected(LoadedApk.java:1465) 01-01 05:49:46.770 19937 19937 E testtest: at android.app.LoadedApk$ServiceDispatcher$RunConnection.run(LoadedApk.java:1482) 01-01 05:49:46.770 19937 19937 E testtest: at android.os.Handler.handleCallback(Handler.java:751) 01-01 05:49:46.770 19937 19937 E testtest: at android.os.Handler.dispatchMessage(Handler.java:95) 01-01 05:49:46.770 19937 19937 E testtest: at android.os.Looper.loop(Looper.java:154) 01-01 05:49:46.770 19937 19937 E testtest: at android.app.ActivityThread.main(ActivityThread.java:6097) 01-01 05:49:46.770 19937 19937 E testtest: at java.lang.reflect.Method.invoke(Native Method) 01-01 05:49:46.770 19937 19937 E testtest: at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1052) 01-01 05:49:46.770 19937 19937 E testtest: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:942) RemoteCallbackList 类注释 为什么需要RemoteCallbackList？ 在 Android 中，服务和客户端可能运行在不同的进程中。直接使用普通的列表来管理回调接口时，如果某个客户端进程崩溃，可能会导致服务端引用了无效的回调接口，从而引发 RemoteException。RemoteCallbackList 能自动处理进程间通信的细节，确保回调接口的可靠性和安全性。这也减少了服务端开发者手动管理和清理无效回调的复杂性，避免了内存泄漏和资源浪费。 有什么功能？ Func List： 跟踪注册的 IInterface 回调：通过它们的底层唯一的 IBinder 进行识别（通过调用 IInterface.asBinder()）。 为每个注册的接口附加 IBinder.DeathRecipient：这样，如果其进程消失，它可以从列表中清除。 执行底层接口列表的锁定：以处理多线程的传入调用，并以线程安全的方式迭代列表的快照，而不持有其锁。 API List： register(E callback): 注册回调接口。 unregister(E callback): 反注册回调接口。 beginBroadcast(): 准备回调广播，返回当前注册的回调数量。 getBroadcastItem(int index): 获取特定位置的回调接口。 finishBroadcast(): 完成回调广播。 如何使用？ 要使用这个类，只需在您的服务（Service）中创建一个实例，并在客户端注册和注销时调用其 register 和 unregister 方法。要回调注册的客户端，使用 beginBroadcast、getBroadcastItem 和 finishBroadcast 方法。 注意事项： 如果注册的回调的进程消失，这个类会自动从列表中删除它。如果您想在这种情况下进行额外的工作，您可以创建一个子类来实现 onCallbackDied 方法。 AIDL跨进程 最大传输大小 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-6.应用层-应用通信/Binder-onTransact.html":{"url":"04_Android/应用层/SDK/2-6.应用层-应用通信/Binder-onTransact.html","title":"Binder-ontransact","keywords":"","body":"No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-6.应用层-应用通信/Binder.html":{"url":"04_Android/应用层/SDK/2-6.应用层-应用通信/Binder.html","title":"Binder","keywords":"","body":"Binder Binder的定义与作用 Binder跨进程通信机制 进程空间划分 一个进程空间分为 用户空间 & 内核空间（Kernel），即把进程内 用户 & 内核 隔离开来 二者区别： 1、进程间，用户空间的数据不可共享，所以用户空间 = 不可共享空间 2、进程间，内核空间的数据可共享，所以内核空间 = 可共享空间 所有进程共用1个内核空间 进程内 用户空间 & 内核空间 进行交互 需通过 系统调用，主要通过函数： copy_from_user（）：将用户空间的数据拷贝到内核空间 copy_to_user（）：将内核空间的数据拷贝到用户空间 进程隔离 & 跨进程通信（ IPC ） 进程隔离为了保证 安全性 & 独立性，一个进程不能直接操作或者访问另一个进程，即Android的进程是相互独立、隔离的 跨进程通信（ IPC ）即进程间需进行数据交互、通信 跨进程通信的基本原理 而Binder的作用则是：连接 两个进程，实现了mmap()系统调用，主要负责 创建数据接收的缓存空间 & 管理数据接收缓存 注：传统的跨进程通信需拷贝数据2次，但Binder机制只需1次，主要是使用到了内存映射 跨进程通信核心原理 模型原理步骤说明 Client进程、Server进程 & Service Manager 进程之间的交互 都必须通过Binder驱动（使用 open 和 ioctl文件操作函数），而非直接交互 因为Client进程、Server进程 & Service Manager进程属于进程空间的用户空间，不可进行进程间交互。 Binder驱动 属于 进程空间的 内核空间，可进行进程间 & 进程内交互所以，原理图可表示为以下： Binder请求的线程管理 Server进程会创建很多线程来处理Binder请求，Binder模型的线程管理 采用Binder驱动的线程池，并由Binder驱动自身进行管理，而不是由Server进程来管理的。 一个进程的Binder线程数默认最大是16，超过的请求会被阻塞等待空闲的Binder线程。 所以，在进程间通信时处理并发问题时，如使用ContentProvider时，它的CRUD（创建、检索、更新和删除）方法只能同时有16个线程同时工作。 安卓中实现Binder AIDL生成的就是IMyService这个接口，而Stub和Proxy则是这个接口的两个内部类，分别是Binder和BinderProxy的子类（Proxy类虽然是用组合方式来持有BinderProxy的，但实际就是在直接用这个类，只不过做了一层封装，让其更易使用而已），Stub和Proxy都实现了IMyService。 IInterface是一个用于表达Service提供功能的一个契约，也就是说IInterface里有的方法，Service都能提供。只要拿到IInterface，就可以直接调用里面的方法。 Stub虽然实现了IMyService，但是没有实现里面的方法，它是一个抽象类，开发者需要自己子类化Stub去实现具体的功能。Proxy实现了IMyService，并且实现了里面的方法。 Stub适用于本地调用情况，如果Service运行在同一个线程，那就直接用Stub，因为它直接实现了Service提供的功能，不需要任何IPC过程。如果Service运行在其他进程，那客户端使用的就是Proxy，Proxy可以将参数封装后发送给Binder驱动，然后执行一系列IPC操作最后再取出结果返回。 当客户端的请求提供Proxy发送出去时，Service需要利用Stub接收请求做出响应。Stub继承自Binder，Binder有一个onTransact方法，Stub重写了这个函数，这个函数三个重要参数：int code、Parcel data、Parcel reply，分别对应了被调函数编号、参数包、响应包。当Proxy发起了一个请求，服务端中相应的响应线程就会通过JNI调用到Stub类，然后执行里面的execTransact方法，进而转到onTransact方法。 onTransact: @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException { switch (code) { case INTERFACE_TRANSACTION: { reply.writeString(DESCRIPTOR); return true; } case TRANSACTION_increaseCounter: { data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _result = this.increaseCounter(_arg0); reply.writeNoException(); reply.writeInt(_result); return true; } } return super.onTransact(code, data, reply, flags); } 可以看到onTransact就是根据传过来的数据包做相应的操作，然后把结果写回数据包。Binder驱动会帮我们做好数据包的分发工作。这段代码是运行再Service本地进程中的，它可以直接调用实现好的Stub类中的相关方法（本例中为increaseCounter方法）。 Proxy中的incraseCounter: @Override public int increaseCounter(int increment) throws RemoteException{ Parcel _data = Parcel.obtain(); Parcel _reply = Parcel.obtain(); int _result; try { _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(increment); mRemote.transact(Stub.TRANSACTION_increaseCounter, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); }finally { _reply.recycle(); _data.recycle(); } return _result; } Service里面有一个onBind方法，里面返回了实现好的Stub类，而客户端bindService时拿到的又是一个IBinder对象，我们每次只需要调用Stub的asInterface静态方法，把这个IBinder对象传进去就能拿到Stub类或者Proxy类了。 asInterface: public static IBackgroundService asInterface(IBinder obj){ if ((obj==null)) { return null; } IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) && (iin instanceof IBackgroundService))) { return ((IBackgroundService) iin); } return new IBackgroundService.Stub.Proxy(obj); } queryLocalIInterface: public IInterface queryLocalInterface(String descriptor) { if (mDescriptor.equals(descriptor)) { return mOwner; } return null; } owner和descriptor都是在Stub的构造函数中被设置的。 如果 Service 运行在同一进程，那么客户端拿到的 IBinder 就是 Stub 类，而 Stub 的 queryLocalInterface 又会返回自己；而 Service 运行在单独进程中时，客户端拿到的 IBinder 就是系统提供好的 BinderProxy，BinderProxy 中的 queryLocalInterface 默认直接返回 null，根据代码，asInterface 就会构造一个 Proxy 返回给客户端。 自己利用Binder进行IPC Service中的onBinder这样实现: @Nullable @Override public IBinder onBind(Intent intent){ return new Binder(){ @Override protected boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException { if(code == FIRST_CALL_TRANSACTION){ int i = data.readInt(); reply.writeNoException(); reply.writeInt(2*i); return true; } return super.onTransact(code,data,reply,flags); } }; } 客户端： private ServiceConnection connection = new ServiceConnection(){ @Override public void onServiceConnected(ComponentName name,IBinder service){ if(!(service instanceof IBackgroundService.Stub)){ Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); try{ data.writeInt(3); service.transact(Binder.FIRST_CALL_TRANSACTION,data,reply,0); reply.readException(); Log.i(\"Client\",String.valueOf(reply.readInt())); }catch(RemoteException e){ e.printStackTrace(); }finally{ data.recycle(); reply.recycle(); } } } } onTransact 方法 作用： 验证请求的合法性：onTransact 方法首先会检查传入的事务代码（transaction code）是否合法，以防止恶意或非法的调用。 执行请求的操作：如果请求合法，onTransact 方法会根据传入的事务代码执行相应的操作。 响应调用者：处理完请求后，onTransact 方法会返回一个 boolean 值，指示操作是否成功执行。 方法签名： javaCopy code protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException; code：事务代码，用于标识请求的具体操作。 data：输入参数，包含客户端发送的数据。 reply：输出参数，用于存储要返回给客户端的数据。 flags：标志，通常为 0。 示例： 假设有一个远程服务 IRemoteService，其中定义了一个方法 add(int a, int b)，对应的事务代码为 TRANSACTION_add（通常是一个常量）： javaCopy codepublic interface IRemoteService extends IInterface { static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); int add(int a, int b) throws RemoteException; } 当客户端调用这个方法时，Binder 会调用服务端 IRemoteService 的 onTransact 方法： javaCopy code@Override protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException { switch (code) { case TRANSACTION_add: data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _arg1; _arg1 = data.readInt(); int _result = this.add(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; } return super.onTransact(code, data, reply, flags); } 在上述代码中： code 是 TRANSACTION_add，表示客户端请求执行 add 方法。 data 包含两个整数参数 _arg0 和 _arg1，分别是客户端传递的两个整数值。 reply 用于存储 add 方法的返回值 _result。 注意： onTransact 方法通常不应该在客户端直接调用。它是由系统自动调用的，用于处理客户端发送的请求。 在实现自定义 Binder 类时，开发者需要覆写 onTransact 方法来处理特定的事务代码，并执行相应的操作。 总结： Binder 的 onTransact 方法是 Android 系统用于处理跨进程通信请求的核心方法。它负责验证请求的合法性、执行请求的操作，并响应调用者。开发者在实现远程服务时，需要在 onTransact 方法中处理特定的事务代码，以实现跨进程方法调用。 Binder 的 onTransact 方法是 Android 系统用于处理跨进程通信（IPC，Inter-Process Communication）请求的核心方法。当一个客户端组件（如 Activity、Service 或其他应用程序）尝试调用一个远程服务的方法时，实际上是通过 Binder 进行 IPC 通信的。以下是关于 onTransact 方法的详细解释： onTransact 方法 作用： 验证请求的合法性：onTransact 方法首先会检查传入的事务代码（transaction code）是否合法，以防止恶意或非法的调用。 执行请求的操作：如果请求合法，onTransact 方法会根据传入的事务代码执行相应的操作。 响应调用者：处理完请求后，onTransact 方法会返回一个 boolean 值，指示操作是否成功执行。 方法签名： javaCopy code protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException; code：事务代码，用于标识请求的具体操作。 data：输入参数，包含客户端发送的数据。 reply：输出参数，用于存储要返回给客户端的数据。 flags：标志，通常为 0。 示例： 假设有一个远程服务 IRemoteService，其中定义了一个方法 add(int a, int b)，对应的事务代码为 TRANSACTION_add（通常是一个常量）： javaCopy codepublic interface IRemoteService extends IInterface { static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); int add(int a, int b) throws RemoteException; } 当客户端调用这个方法时，Binder 会调用服务端 IRemoteService 的 onTransact 方法： javaCopy code@Override protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException { switch (code) { case TRANSACTION_add: data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _arg1; _arg1 = data.readInt(); int _result = this.add(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; } return super.onTransact(code, data, reply, flags); } 在上述代码中： code 是 TRANSACTION_add，表示客户端请求执行 add 方法。 data 包含两个整数参数 _arg0 和 _arg1，分别是客户端传递的两个整数值。 reply 用于存储 add 方法的返回值 _result。 注意： onTransact 方法通常不应该在客户端直接调用。它是由系统自动调用的，用于处理客户端发送的请求。 在实现自定义 Binder 类时，开发者需要覆写 onTransact 方法来处理特定的事务代码，并执行相应的操作。 总结： Binder 的 onTransact 方法是 Android 系统用于处理跨进程通信请求的核心方法。它负责验证请求的合法性、执行请求的操作，并响应调用者。开发者在实现远程服务时，需要在 onTransact 方法中处理特定的事务代码，以实现跨进程方法调用。 为什么Binder通信只需要拷贝一次数据？ Linux中的进程是被隔离不能直接进行通信的，A进程向B进程传递数据，需要先将数据从A的用户空间拷贝到内核空间，然后从内核空间拷贝到B的用户空间。 Binder通信采用了mmap()函数，将内核空间和接收方用户空间的数据缓存区之间做了一层内存映射，这样，A进程向B进程传递数据，只需要从A的用户空间拷贝到B的用户空间数据缓存区在内核空间中的内存映射，就相当于直接拷贝到了B的用户空间。 由于Binder是双向通信，还会有A的用户空间数据缓存区在内核空间中的内存映射 sharedUserId的使用 一. 当A和B共用一个sharedUserId时,或者同时具有某种系统权限.A和B能达到互相唤醒的效果. 使用绑定服务的方式传递AIDL接口 A和B互相绑定一个服务接口,那么任何一方进程死的时候,另一方都会感知到. B绑定A,A不绑定B时,A进程死亡时,B能感知;B进程死亡,A感知不到.(如果B绑定A后,利用上面的IIpcInvoke接口向A提供了ICallback接口,A对这个ICallback做了\"死亡绑定\",那么也能感知到B进程的死亡状态) Binder自带的线程管理 这个Binder线程池不是我们平时理解的那个\"线程池\",Binder线程池是不能处理耗时任务的,要处理的话,还是需要在服务端或者在客户端使用子线程去处理的. Binder线程池更好的理解是把它理解成一个口(如高速公路上收费站的收费口).Binder就是个\"收费站\",收费站的各个收费口就是Binder线程池, 一个进程中的Binder(收费站)最多有\"16\"个\"收费口\".也就是说这个\"收费站\"能同时让16辆车经过而不会发生阻塞,当这16辆车在经过同时, 在第17辆车到来时,这第17辆车只能等着,等到前面16辆车中的其中一辆车完全经过收费口时,第17辆车才允许经过. Binder也不是一创建的时候就马上把16个\"收费口\"一起创建出来的.它是一个一个创建的,用到时才创建的,但是最多只能创建16个\"收费口\". 如果现在已经创建了5个\"收费口\",这5个口对于处理事务已经够用了,那就不会再创建第6个\"收费口\"了.直到来不及处理的时候才会再创建. No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-6.应用层-应用通信/EventBus.html":{"url":"04_Android/应用层/SDK/2-6.应用层-应用通信/EventBus.html","title":"Eventbus","keywords":"","body":"EventBus EventBus监听流程：在订阅者中定义监听器，传递给发布者，发布者使用监听器 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-6.应用层-应用通信/Handler.html":{"url":"04_Android/应用层/SDK/2-6.应用层-应用通信/Handler.html","title":"Handler","keywords":"","body":"Handler 应用场景 To schedule messages and runnables to be executed as some point in the future(实现定时任务) To enqueue an action to be performed on a different thread than your own.(不同进程间通信) 相关概念 UI线程:就是我们的主线程,系统在创建UI线程的时候会初始化一个Looper对象,同时也会创建一个与其关联的MessageQueue; Handler:作用就是发送与处理信息,如果希望Handler正常工作,在当前线程中要有一个Looper对象 Message:Handler接收与处理的消息对象 MessageQueue:消息队列,先进先出管理Message,在初始化Looper对象时会创建一个与之关联的MessageQueue; Looper:每个线程只能够有一个Looper,管理MessageQueue,不断地从中取出Message分发给对应的Handler处理！ 创建和发送Message的方法 1. Message 自己绑定到目标 Handler 后发送 (被动) 这种方式强调的是 Message 自己“知道”它将由哪个 Handler 来处理，消息在创建时已经被绑定到特定的 Handler 上： javaCopy codeMessage message = Message.obtain(handler, 33, 2, 3, \"hello\"); message.sendToTarget(); 获取 Message 对象：Message.obtain(handler, 33, 2, 3, \"hello\") 方法不仅初始化了 Message 的内容（what, arg1, arg2, obj），还将这个 Message 绑定到指定的 Handler 上。 发送消息：调用 message.sendToTarget() 会将 Message 发送给绑定的 Handler，Handler 接着会将消息放入它的 MessageQueue 中等待处理。 在这种方式中，Message 创建时就已经“知道”要发送到哪个 Handler，可以看作是一种被动的行为，Message 被创建后再调用 sendToTarget()，就会自动发送给指定的 Handler。 2. Handler 主动创建并发送消息 (主动) 在这种方式中，Handler 主动地创建 Message，并在适当的时候发送它： javaCopy codeMessage message = handler.obtainMessage(3, 1, 2, \"java\"); handler.sendMessage(message); 获取 Message 对象：handler.obtainMessage(3, 1, 2, \"java\") 方法从 Handler 中获取一个新的 Message 对象，并设置它的内容（what, arg1, arg2, obj）。 发送消息：handler.sendMessage(message) 方法将这个 Message 发送出去，由 Handler 自己将消息放入 MessageQueue 中。 在这种方式中，Handler 是“主动”的，Handler 自己创建 Message，并决定何时发送。 主动与被动的区别（意会） 被动：Message 创建时已经决定好由哪个 Handler 来处理，只需调用 sendToTarget()，它会自动被发送给目标 Handler。Message 是被动的，因为它自己“知道”要去哪。 主动：Handler 主动决定要创建并发送 Message，Message 本身并不知道它会被发送给哪个 Handler。Handler 是主动的，因为它控制着消息的整个生命周期。 常用方法 Handler 和 Message 提供了一些常用的方法来简化消息处理： Handler 的常用方法： obtainMessage(int what)：获取一个 what 值的 Message。 obtainMessage(int what, Object obj)：获取一个 what 和 obj 值的 Message。 obtainMessage(int what, int arg1, int arg2)：获取一个 what, arg1, arg2 值的 Message。 sendMessage(Message msg)：发送一个 Message。 sendEmptyMessage(int what)：发送一个仅包含 what 值的 Message。 post(Runnable r)：将一个 Runnable 放入消息队列，Handler 处理时会执行此 Runnable。 Message 的常用方法： obtain()：获取一个空的 Message。 obtain(Handler h)：获取一个绑定了特定 Handler 的 Message。 sendToTarget()：将 Message 发送给已经绑定的 Handler。 setTarget(Handler target)：设置消息的目标 Handler。 recycle()：回收 Message，以便重复使用。 Handler的使用 1.最好显式地声明使用的Looper Handler handler = new Handler() -> 会默认用当前线程的looper 如果在代码中Handler的定位是用来刷新操作UI，需要在主线程中操作。 2.最好使用static的Handler 内存泄漏：当我们在使用完某个对象时，如果这个对象所占据的内存不及时的别释放，这就可能发生了内存越来越少的情况，最后可能就没了。 内存溢出：溢出就是太多了，很显然不是可用内存太多了，而是我们在执行某个操作的时候需要的内存，超过了应用的分配内存，这就是内存溢出。 Handler作为一个内部类被声明时，这个handler就会持有外部类的引用，如果在我们的handler关联的MessageQueue还有消息没有处理，或者有一个延时很长的消息，那么垃圾回收器就无法回收这个使用handler的Activity，就会导致内存泄漏问题。因为和Activity有关，换句话说，只有在主线程中才可能发生内存泄漏的情况 解决方式1：声明称一个static 的内部类，持有外部类的weakReference，在内部类中使用外部类传递过来的weakReference的成员。 public class MainActivity extends Activity { private TextView mTextView; private Handler mHandler; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView)findViewById(R.id.textview); mHandler = new MyHandler(this); } /** *测试方法 */ public void executeTest(View v){ mHandler.sendEmptyMessage(0x110); } static class MyHandler extends Handler{ WeakReference mActivity; public MyHandler(MainActivity activity) { mActivity = new WeakReference(activity); } @Override public void handleMessage(Message msg) { MainActivity mainActivity = mActivity.get(); if(msg.what==1){ mainActivity.mTextView.setText(\"执行正确\"); } } } } 解决方式2：简单版 private Handler mHandler = new Handler(new Handler.Callback() { @Override public boolean handleMessage(Message msg) { // TODO Auto-generated method stub return false; } }); No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-IntentService.html":{"url":"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-IntentService.html","title":"Service-intentservice","keywords":"","body":"IntentService 是 Android 中的一个类，它是 Service 的一个子类。它可以帮助开发者处理异步任务，同时还可以保证任务的执行顺序，避免多个任务同时执行的情况。 IntentService 可以处理通过 Intent 发送过来的请求。当开发者启动一个 IntentService 时，IntentService 会在一个单独的线程中执行任务。当任务执行完毕后，IntentService 会自动停止。 IntentService 的主要优势是可以避免在 UI 线程中执行耗时操作，从而提高应用程序的性能和用户体验。它还可以处理多个请求，而不需要开发者手动管理线程和任务队列。 需要注意的是，IntentService 默认会在主线程中执行 onHandleIntent() 方法。如果任务很耗时，需要在子线程中执行，开发者需要手动创建线程。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-JobService.html":{"url":"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-JobService.html","title":"Service-jobservice","keywords":"","body":"JobService JobService是Android L时候官方加入的组件。适用于需要特定条件下才执行后台任务的场景。 由系统统一管理和调度，在特定场景下使用JobService更加灵活和省心，相当于是Service的加强或者优化。 JobService 与Service的对比 对比角度 Service JobService 补充 实现原理 由APP侧发出请求，ActivityManagerService接收请求后进行调度，通知APP侧进行创建，开始(绑定)，停止(解绑)和销毁Service。 由APP侧发出请求，JobSchedulerService接收请求后，通过ActivityManagerService去调度JobService的创建，绑定和解绑。并由JobSchedulerService自己进行JobService的开始，取消和停止等操作。 从原理上看，JobService的开始，取消和停止是由JobSchedulerService维护的，而不是由ActivityManagerService维护的。这是他们在实现原理上的明显区别。即JobService是由系统负责调用和维护 启动条件 Service的启动并没有什么特定的条件设置。如果说非要有什么具体的执行条件的话，就是APP侧自己根据业务逻辑在适当的时候调用startService()或者bindService()。 JobService的执行需要至少一个条件。没有条件的JobService是无法启动的，在创建JobInfo的时候会抛出异常。 运行时间 onStartCommand()的回调在UI线程，不可执行耗时逻辑，否则可能造成ANR。 onStartJob()的回调在UI线程，不可执行耗时逻辑，否则可能造成ANR或者Job被强制销毁(超过8s)。并且，JobService里即便新起了线程，处理的时间也不能超过10min，否则Job将被强制销毁。 启动角度 onStartCommand()里返回START_STICKY可以告诉AMS在被停止后自动启动。 onStopJob()里返回true，即可在被强制停止后再度启动起来。 扩展性 APP侧可以通过Binder创建远程Service进行IPC。 JobService的绑定实际上是由JobSchedulerService自己去做的。绑定后产生的Binder用于和JobSchedulerService进行IPC，APP侧无法通过JobService扩展去实现别的IPC功能。 Google本来的初衷也不是让JobService实现远程Service的功能。 实际应用上 适合需要常驻后台，立即执行，进行数据获取，功能维持的场景。比如 音乐播放，定位，邮件收发等。 适合不需要常驻后台，不需要立即执行，在某种条件下触发，执行简单任务的场景。比如 联系人信息变化后的快捷方式的更新，定期的更新电话程序的联系人信息，壁纸更改后去从壁纸提取颜色的后台任务。 简单来讲，Service适合一些优先级较高，执行任务复杂耗时的任务。JobService适合轻量级的灵活的任务。 JobService API 方法名 参数 描述 补充 onStartJob(JobParameters params) params：包含用于配置/识别作业的参数，系统传递给我们的 定义：Job开始的时候的回调，实现实际的工作逻辑。执行该方法时需要返回一个Boolean值，True表示需要执行，返回True时，作业将保持活动状态，直到系统调用jobFinished或者直到该作业所需的条件不再满了 注意：如果返回false的话，系统会自动结束本job；只要Job工作正在执行，系统就会代表应用程序保留一个唤醒锁。 在调用此方法之前获取此唤醒锁，并且直到您调用jobFinished（JobParameters，boolean）或系统调用onStopJob（JobParameters）以通知正在执行的作业它过早关闭之后才会释放。 jobFinished(JobParameters params, boolean wantsReschedule) wantsReschedule：若希望系统再次执行该Job，则设置为true后返回 调用此方法通知JobScheduler该作业已完成其工作。当系统收到此消息时，它会释放为该作业保留的唤醒锁。该操作在Job的任务执行完毕后，APP端自己的调用通知JobScheduler已经完成了任务。 注意:该方法执行完后不会回调onStopJob(),但是会回调onDestroy() onStopJob(JobParameters params) 同上 定义：停止该Job。当JobScheduler发觉该Job条件不满足的时候，或者job被抢占被取消的时候的强制回调。即如果系统确定你必须在有机会调用jobFinished（JobParameters，boolean）之前必须停止执行作业，则调用此方法。 注意:如果想在这种意外的情况下让Job重新开始，返回值应该设置为true。 onCreate() 父类Service的基础方法，可以覆写来实现一些辅助作用。Service被初始化后的回调。 作用：可以在这里设置BroadcastReceiver或者ContentObserver onDestroy() 定义：Service被销毁前的回调。 作用：可以在这里注销BroadcastReceiver或者ContentObserver 上面可以看出，JobService只是实际的执行和停止任务的回调入口。 那如何将这个入口告诉系统，就需要用到JobScheduler了。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-manifest.html":{"url":"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-manifest.html","title":"Service-manifest","keywords":"","body":"Service在清单文件中的声明 前面说过Service分为启动状态和绑定状态两种，但无论哪种具体的Service启动类型，都是通过继承Service基类自定义而来，也都需要在AndroidManifest.xml中声明，那么在分析这两种状态之前，我们先来了解一下Service在AndroidManifest.xml中的声明语法，其格式如下： . . . android:exported：代表是否能被其他应用隐式调用，其默认值是由service中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。为false的情况下，即使有intent-filter匹配，也无法打开，即无法被其他应用隐式调用。 android:name：对应Service类名 android:permission：是权限声明 android:process：是否需要在单独的进程中运行,当设置 android:process=”:remote”时，代表Service在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。 android:isolatedProcess ：设置 true 意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(bind and start)。 android:enabled：是否可以被系统实例化，默认为 true因为父标签 也有 enable 属性，所以必须两个都为默认值 true 的情况下服务才会被激活，否则不会激活。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-保活方案.html":{"url":"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-保活方案.html","title":"Service-保活方案","keywords":"","body":"前台服务 前台服务的创建及通知 前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，状态栏位于“正在进行”标题下方，这意味着除非服务停止或从前台删除，否则不能清除通知。例如将从服务播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。 设置服务运行于前台的方法： startForeground(int id, Notification notification) 该方法的作用是把当前服务设置为前台服务，其中id参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而notification是一个状态栏的通知。 stopForeground(boolean removeNotification) 该方法是用来从前台删除服务，此方法传入一个布尔值，指示是否也删除状态栏通知，true为删除。 注意该方法并不会停止服务。 但是，如果在服务正在前台运行时将其停止，则通知也会被删除。 下面我们结合一个简单案例来使用以上两个方法，ForegroundService代码如下： package com.zejian.ipctest.foregroundService; import android.app.Notification; import android.app.Service; import android.content.Intent; import android.graphics.BitmapFactory; import android.os.IBinder; import android.support.annotation.Nullable; import android.support.v4.app.NotificationCompat; import com.zejian.ipctest.R; /** * Created by zejian * Time 2016/10/4. * Description:启动前台服务Demo */ public class ForegroundService extends Service { /** * id不可设置为0,否则不能设置为前台service */ private static final int NOTIFICATION_DOWNLOAD_PROGRESS_ID = 0x0001; private boolean isRemove=false;//是否需要移除 /** * Notification */ public void createNotification(){ //使用兼容版本 NotificationCompat.Builder builder=new NotificationCompat.Builder(this); //设置状态栏的通知图标 builder.setSmallIcon(R.mipmap.ic_launcher); //设置通知栏横条的图标 builder.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.screenflash_logo)); //禁止用户点击删除按钮删除 builder.setAutoCancel(false); //禁止滑动删除 builder.setOngoing(true); //右上角的时间显示 builder.setShowWhen(true); //设置通知栏的标题内容 builder.setContentTitle(\"I am Foreground Service!!!\"); //创建通知 Notification notification = builder.build(); //设置为前台服务 startForeground(NOTIFICATION_DOWNLOAD_PROGRESS_ID,notification); } @Override public int onStartCommand(Intent intent, int flags, int startId) { int i=intent.getExtras().getInt(\"cmd\"); if(i==0){ if(!isRemove) { createNotification(); } isRemove=true; }else { //移除前台服务 if (isRemove) { stopForeground(true); } isRemove=false; } return super.onStartCommand(intent, flags, startId); } @Override public void onDestroy() { //移除前台服务 if (isRemove) { stopForeground(true); } isRemove=false; super.onDestroy(); } @Nullable @Override public IBinder onBind(Intent intent) { return null; } } 在ForegroundService类中，创建了一个notification的通知，并通过启动Service时传递过来的参数判断是启动前台服务还是关闭前台服务，最后在onDestroy方法被调用时，也应该移除前台服务。以下是ForegroundActivity的实现： package com.zejian.ipctest.foregroundService; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Button; import com.zejian.ipctest.R; /** * Created by zejian * Time 2016/10/4. * Description: */ public class ForegroundActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_foreground); Button btnStart= (Button) findViewById(R.id.startForeground); Button btnStop= (Button) findViewById(R.id.stopForeground); final Intent intent = new Intent(this,ForegroundService.class); btnStart.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { intent.putExtra(\"cmd\",0);//0,开启前台服务,1,关闭前台服务 startService(intent); } }); btnStop.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { intent.putExtra(\"cmd\",1);//0,开启前台服务,1,关闭前台服务 startService(intent); } }); } } Service保活 【情况1】因内存资源不足而杀死Service 这种情况比较容易处理，可将onStartCommand() 方法的返回值设为 START_STICKY或START_REDELIVER_INTENT ，该值表示服务在内存资源紧张时被杀死后，在内存资源足够时再恢复。也可将Service设置为前台服务，这样就有比较高的优先级，在内存资源紧张时也不会被杀掉。这两点的实现，我们在前面已分析过和实现过这里就不重复。简单代码如下： /** * 返回 START_STICKY或START_REDELIVER_INTENT * @param intent * @param flags * @param startId * @return */ @Override public int onStartCommand(Intent intent, int flags, int startId) { // return super.onStartCommand(intent, flags, startId); return START_STICKY; } 【情况2】用户通过 settings -> Apps -> Running -> Stop 方式杀死Service 这种情况是用户手动干预的，不过幸运的是这个过程会执行Service的生命周期，也就是onDestory方法会被调用，这时便可以在 onDestory() 中发送广播重新启动。这样杀死服务后会立即启动。这种方案是行得通的，但为程序更健全，我们可开启两个服务，相互监听，相互启动。服务A监听B的广播来启动B，服务B监听A的广播来启动A。这里给出第一种方式的代码实现如下： package com.zejian.ipctest.neverKilledService; import android.app.Service; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.os.IBinder; import android.support.annotation.Nullable; /** * Created by zejian * Time 2016/10/4. * Description:用户通过 settings -> Apps -> Running -> Stop 方式杀死Service */ public class ServiceKilledByAppStop extends Service{ private BroadcastReceiver mReceiver; private IntentFilter mIF; @Nullable @Override public IBinder onBind(Intent intent) { return null; } @Override public void onCreate() { super.onCreate(); mReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { Intent a = new Intent(ServiceKilledByAppStop.this, ServiceKilledByAppStop.class); startService(a); } }; mIF = new IntentFilter(); //自定义action mIF.addAction(\"com.restart.service\"); //注册广播接者 registerReceiver(mReceiver, mIF); } @Override public void onDestroy() { super.onDestroy(); Intent intent = new Intent(); intent.setAction(\"com.restart.service\"); //发送广播 sendBroadcast(intent); unregisterReceiver(mReceiver); } } 【情况3】用户通过 settings -> Apps -> Downloaded -> Force Stop 方式强制性杀死Service 这种方式就比较悲剧了，因为是直接kill运行程序的，不会走生命周期的过程,前面两种情况只要是执行Force Stop ，也就废了。也就是说这种情况下无法让服务重启，或者只能去设置Force Stop 无法操作了，不过也就没必要了，太流氓了。。。。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-生命周期.html":{"url":"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-生命周期.html","title":"Service-生命周期","keywords":"","body":" 1. 生命周期常用方法 在Service的生命周期里，常用的有： 4个手动调用的方法 手动调用方法 作用 startService() 启动服务 stopService() 关闭服务 bindService() 绑定服务 unbindService() 解绑服务 5个内部自动调用的方法 内部自动调用的方法 作用 onCreat() 创建服务 onStartCommand() 开始服务 onDestroy() 销毁服务 onBind() 绑定服务 onUnbind() 解绑服务 2. 生命周期方法具体介绍 主要介绍内部调用方法和外部调用方法的关系。 2.1 startService() 作用：启动Service服务 手动调用startService()后，自动调用内部方法：onCreate()、onStartCommand() 调用逻辑如下： 调用逻辑 2.2 stopService() 作用：关闭Service服务 手动调用stopService()后，自动调用内部方法：onDestory() 调用的逻辑： 调用逻辑 2.3 bindService() 作用：绑定Service服务 手动调用bindService()后，自动调用内部方法：onCreate()、onBind() 调用的逻辑： 调用的逻辑 2.4 unbindService() 作用：解绑Service服务 手动调用unbindService()后，自动调用内部方法：onCreate()、onBind()、onDestory() 调用的逻辑： 调用的逻辑 3. 常见的生命周期使用 3.1 只使用startService启动服务的生命周期 startService启动服务的生命周期 3.2 只使用BindService绑定服务的生命周期 BindService绑定服务的生命周期 3.3 同时使用startService()启动服务、BindService()绑定服务的生命周期 Paste_Image.png 4. 特别注意 Service在系统中永远为单一实例 Android系统仅会为一个Service创建一个实例对象，所以不管是启动服务还是绑定服务，操作的是同一个Service实例 4.1 startService() 服务可以在后台无限期运行 当应用组件（如 Activity 或 Fragment）通过调用 startService() 启动一个服务时，该服务进入了“启动”状态。即： 这个服务将继续运行，即使启动它的 Activity 已经被销毁。这意味着服务和启动它的组件之间没有直接的生命周期联系。组件销毁不会影响服务的运行。 必须显式停止 服务一旦通过 startService() 启动后，需要显式地停止。有两种方式可以停止服务： 调用 stopService()：由启动服务的组件或其他组件调用 stopService() 停止服务。 调用 stopSelf()：服务内部通过调用 stopSelf() 来决定自己停止。常用于任务完成后服务自动结束。 如果不手动调用这两个方法，服务会一直运行下去，占用系统资源。 通常执行单一操作，不返回结果 通过 startService() 启动的服务往往被设计为执行特定的任务（如文件上传、下载、播放音乐），并且这些任务通常不需要返回结果给调用方。 例如，假设 Activity 启动了一个服务来下载文件，Activity 不会直接从服务中获取下载状态或结果。这种服务不会像 bindService() 那样通过客户端-服务端交互，来实时返回信息。 无法调用Service的方法 startService()和stopService()只能开启和关闭Service，无法操作Service 4.2 bindService() 当不存在绑定方时，服务自动销毁 startService开启的Service，调用者退出后Service仍然存在； BindService开启的Service，调用者退出后，Service随着调用者销毁。 可以需要处理回调或通知 当组件需要接收服务中的回调或通知时，通过 bindService() 绑定服务可以实现此功能。例如，服务可以通过 Binder 返回一个接口，客户端可以实现这个接口以接收回调。 5. 方法详解 onStartCommand（Intent intent, int flags, int startId） intent ：启动时，启动组件传递过来的Intent，如Activity可利用Intent封装所需要的参数并传递给Service flags：表示启动请求时是否有额外数据，可选值有 0，START_FLAG_REDELIVERY，START_FLAG_RETRY，0代表没有： START_FLAG_REDELIVERY：这个值代表了onStartCommand方法的返回值为 START_REDELIVER_INTENT，而且在上一次服务被杀死前会去调用stopSelf方法停止服务。其中START_REDELIVER_INTENT意味着当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，此时Intent时有值的。 START_FLAG_RETRY：该flag代表当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()。 startId ： 指明当前服务的唯一ID，与stopSelfResult (int startId)配合使用，stopSelfResult 可以更安全地根据ID停止服务。 onStartCommand的返回值int类型，有三种可选值， START_STICKY，START_NOT_STICKY，START_REDELIVER_INTENT，它们具体含义如下： START_STICKY：当Service因内存不足而被系统kill后，一段时间后内存再次空闲时，系统将会尝试重新创建此Service，一旦创建成功后将回调onStartCommand方法，但其中的Intent将是null，除非有挂起的Intent，如pendingintent，这个状态下比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。 START_NOT_STICKY：当Service因内存不足而被系统kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此Service。除非程序中再次调用startService启动此Service，这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 START_REDELIVER_INTENT：当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，任何挂起 Intent均依次传递。与START_STICKY不同的是，其中的传递的Intent将是非空，是最后一次调用startService中的intent。这个值适用于主动执行应该立即恢复的作业（例如下载文件）的服务。 由于每次启动服务（调用startService）时，onStartCommand方法都会被调用，因此我们可以通过该方法使用Intent给Service传递所需要的参数，然后在onStartCommand方法中处理的事件，最后根据需求选择不同的Flag返回值，以达到对程序更友好的控制。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-绑定方法-Binder&Messager&AIDL.html":{"url":"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-绑定方法-Binder&Messager&AIDL.html","title":"Service-绑定方法-binder&messager&aidl","keywords":"","body":"Service绑定服务 特点： 组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信。 绑定服务的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说宿主(如Activity)解除绑定后，绑定服务就会被销毁 该如何实现呢？实际上我们必须提供一个 IBinder接口的实现类，该类用以提供客户端用来与服务进行交互的编程接口，该接口可以通过三种方法定义接口： 三种方法 扩展 Binder 类 如果服务是提供给自有应用专用的，并且Service(服务端)与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。 客户端收到 Binder 后，可利用它直接访问 Binder 实现中以及Service 中可用的公共方法。 如果我们的服务只是自有应用的后台工作线程，则优先采用这种方法。 不采用该方式创建接口的唯一原因是，服务被其他应用或不同的进程调用。 使用 Messenger Messenger可以翻译为信使，通过它可以在不同的进程中共传递Message对象(Handler中的Messager，因此 Handler 是 Messenger 的基础)，在Message中可以存放我们需要传递的数据，然后在进程间传递。 如果需要让接口跨不同的进程工作，则可使用 Messenger 为服务创建接口，客户端就可利用 Message 对象向服务发送命令。 同时客户端也可定义自有 Messenger，以便服务回传消息。这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在单一线程中创建包含所有请求的队列，也就是说Messenger是以串行的方式处理客户端发来的消息，这样我们就不必对服务进行线程安全设计了。 使用 AIDL 由于Messenger是以串行的方式处理客户端发来的消息，如果当前有大量消息同时发送到Service(服务端)，Service仍然只能一个个处理，这也就是Messenger跨进程通信的缺点了，因此如果有大量并发请求，Messenger就会显得力不从心了，这时AIDL（Android 接口定义语言）就派上用场了， 但实际上Messenger 的跨进程方式其底层实现 就是AIDL，只不过android系统帮我们封装成透明的Messenger罢了 。因此，如果我们想让服务同时处理多个请求，则应该使用 AIDL。 在此情况下，服务必须具备多线程处理能力，并采用线程安全式设计。使用AIDL必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，随后可在服务内对其进行扩展。 扩展 Binder 类 开发步骤： 创建服务端，继承自Service并在类中，创建一个实现IBinder 接口的实例对象并提供公共方法给客户端调用。 从 onBind() 回调方法返回此 Binder 实例。 在客户端中，从 onServiceConnected() 回调方法接收 Binder，并使用提供的方法调用绑定服务。 注意：此方式只有在客户端和服务位于同一应用和进程内才有效，如对于需要将 Activity 绑定到在后台播放音乐的自有服务的音乐应用，此方式非常有效。另一点之所以要求服务和客户端必须在同一应用内，是为了便于客户端转换返回的对象和正确调用其 API。服务和客户端还必须在同一进程内，因为此方式不执行任何跨进程编组。 以下是一个扩展 Binder 类的实例，先看看Service端的实现BindService.java package com.zejian.ipctest.service; import android.app.Service; import android.content.Intent; import android.os.Binder; import android.os.IBinder; import android.support.annotation.Nullable; import android.util.Log; /** * Created by zejian * Time 2016/10/2. * Description:绑定服务简单实例--服务端 */ public class LocalService extends Service{ private final static String TAG = \"wzj\"; private int count; private boolean quit; private Thread thread; private LocalBinder binder = new LocalBinder(); /** * 创建Binder对象，返回给客户端即Activity使用，提供数据交换的接口 */ public class LocalBinder extends Binder { // 声明一个方法，getService。（提供给客户端调用） LocalService getService() { // 返回当前对象LocalService,这样我们就可在客户端端调用Service的公共方法了 return LocalService.this; } } /** * 把Binder类返回给客户端 */ @Nullable @Override public IBinder onBind(Intent intent) { return binder; } @Override public void onCreate() { super.onCreate(); Log.i(TAG, \"Service is invoke Created\"); thread = new Thread(new Runnable() { @Override public void run() { // 每间隔一秒count加1 ，直到quit为true。 while (!quit) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } count++; } } }); thread.start(); } /** * 公共方法 * @return */ public int getCount(){ return count; } /** * 解除绑定时调用 * @return */ @Override public boolean onUnbind(Intent intent) { Log.i(TAG, \"Service is invoke onUnbind\"); return super.onUnbind(intent); } @Override public void onDestroy() { Log.i(TAG, \"Service is invoke Destroyed\"); this.quit = true; super.onDestroy(); } } LocalService类继承自Service，在该类中创建了一个LocalBinder继承自Binder类，LocalBinder中声明了一个getService方法，客户端可访问该方法获取LocalService对象的实例，只要客户端获取到LocalService对象的实例就可调用LocalService服务端的公共方法，如getCount方法，值得注意的是，我们在onBind方法中返回了binder对象，该对象便是LocalBinder的具体实例，而binder对象最终会返回给客户端，客户端通过返回的binder对象便可以与服务端实现交互。接着看看客户端BindActivity的实现： package com.zejian.ipctest.service; import android.app.Activity; import android.app.Service; import android.content.ComponentName; import android.content.Intent; import android.content.ServiceConnection; import android.os.Bundle; import android.os.IBinder; import android.util.Log; import android.view.View; import android.widget.Button; import com.zejian.ipctest.R; /** * Created by zejian * Time 2016/10/2. * Description:绑定服务实例--客户端 */ public class BindActivity extends Activity { protected static final String TAG = \"wzj\"; Button btnBind; Button btnUnBind; Button btnGetDatas; /** * ServiceConnection代表与服务的连接，它只有两个方法， * onServiceConnected和onServiceDisconnected， * 前者是在操作者在连接一个服务成功时被调用，而后者是在服务崩溃或被杀死导致的连接中断时被调用 */ private ServiceConnection conn; private LocalService mService; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_bind); btnBind = (Button) findViewById(R.id.BindService); btnUnBind = (Button) findViewById(R.id.unBindService); btnGetDatas = (Button) findViewById(R.id.getServiceDatas); //创建绑定对象 final Intent intent = new Intent(this, LocalService.class); // 开启绑定 btnBind.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.d(TAG, \"绑定调用：bindService\"); //调用绑定方法 bindService(intent, conn, Service.BIND_AUTO_CREATE); } }); // 解除绑定 btnUnBind.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.d(TAG, \"解除绑定调用：unbindService\"); // 解除绑定 if(mService!=null) { mService = null; unbindService(conn); } } }); // 获取数据 btnGetDatas.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (mService != null) { // 通过绑定服务传递的Binder对象，获取Service暴露出来的数据 Log.d(TAG, \"从服务端获取数据：\" + mService.getCount()); } else { Log.d(TAG, \"还没绑定呢，先绑定,无法从服务端获取数据\"); } } }); conn = new ServiceConnection() { /** * 与服务器端交互的接口方法 绑定服务的时候被回调，在这个方法获取绑定Service传递过来的IBinder对象， * 通过这个IBinder对象，实现宿主和Service的交互。 */ @Override public void onServiceConnected(ComponentName name, IBinder service) { Log.d(TAG, \"绑定成功调用：onServiceConnected\"); // 获取Binder LocalService.LocalBinder binder = (LocalService.LocalBinder) service; mService = binder.getService(); } /** * 当取消绑定的时候被回调。但正常情况下是不被调用的，它的调用时机是当Service服务被意外销毁时， * 例如内存的资源不足时这个方法才被自动调用。 */ @Override public void onServiceDisconnected(ComponentName name) { mService=null; } }; } } 在客户端中我们创建了一个ServiceConnection对象，该代表与服务的连接，它只有两个方法， onServiceConnected和onServiceDisconnected，其含义如下： onServiceConnected(ComponentName name, IBinder service) 系统会调用该方法以传递服务的　onBind() 方法返回的 IBinder。其中service便是服务端返回的IBinder实现类对象，通过该对象我们便可以调用获取LocalService实例对象，进而调用服务端的公共方法。而ComponentName是一个封装了组件(Activity, Service, BroadcastReceiver, or ContentProvider信息的类，如包名，组件描述等信息，较少使用该参数。 onServiceDisconnected(ComponentName name) Android 系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。注意:当客户端取消绑定时，系统“绝对不会”调用该方法。 conn = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { Log.d(TAG, \"绑定成功调用：onServiceConnected\"); // 获取Binder LocalService.LocalBinder binder = (LocalService.LocalBinder) service; mService = binder.getService(); } @Override public void onServiceDisconnected(ComponentName name) { mService=null; } }; 在onServiceConnected()被回调前，我们还需先把当前Activity绑定到服务LocalService上，绑定服务是通过通过bindService()方法，解绑服务则使用unbindService()方法，这两个方法解析如下： bindService(Intent service, ServiceConnection conn, int flags) 该方法执行绑定服务操作，其中Intent是我们要绑定的服务(也就是LocalService)的意图，而ServiceConnection代表与服务的连接，它只有两个方法，前面已分析过，flags则是指定绑定时是否自动创建Service。0代表不自动创建、BIND_AUTO_CREATE则代表自动创建。 unbindService(ServiceConnection conn) 该方法执行解除绑定的操作，其中ServiceConnection代表与服务的连接，它只有两个方法，前面已分析过。 Activity通过bindService()绑定到LocalService后，ServiceConnection#onServiceConnected()便会被回调并可以获取到LocalService实例对象mService，之后我们就可以调用LocalService服务端的公共方法了，最后还需要在清单文件中声明该Service。而客户端布局文件实现如下： 我们运行程序，点击绑定服务并多次点击绑定服务接着多次调用LocalService中的getCount()获取数据，最后调用解除绑定的方法移除服务，其结果如下： 通过Log可知，当我们第一次点击绑定服务时，LocalService服务端的onCreate()、onBind方法会依次被调用，此时客户端的ServiceConnection#onServiceConnected()被调用并返回LocalBinder对象，接着调用LocalBinder#getService方法返回LocalService实例对象，此时客户端便持有了LocalService的实例对象，也就可以任意调用LocalService类中的声明公共方法了。 更值得注意的是，我们多次调用bindService方法绑定LocalService服务端，而LocalService得onBind方法只调用了一次，那就是在第一次调用bindService时才会回调onBind方法。接着我们点击获取服务端的数据，从Log中看出我们点击了3次通过getCount()获取了服务端的3个不同数据，最后点击解除绑定，此时LocalService的onUnBind、onDestroy方法依次被回调，并且多次绑定只需一次解绑即可。此情景也就说明了绑定状态下的Service生命周期方法的调用依次为onCreate()、onBind()、onUnBind()、onDestroy()。 使用Messenger 前面了解了如何使用IBinder应用内同一进程的通信后，我们接着来了解服务与远程进程（即不同进程间）通信，而不同进程间的通信，最简单的方式就是使用 Messenger 服务提供通信接口，利用此方式，我们无需使用 AIDL 便可执行进程间通信 (IPC)。以下是 Messenger 使用的主要步骤： 服务实现一个 Handler，由其接收来自客户端的每个调用的回调 Handler 用于创建 Messenger 对象（对 Handler 的引用） Messenger 创建一个 IBinder，服务通过 onBind() 使其返回客户端 客户端使用 IBinder 将 Messenger（引用服务的 Handler）实例化，然后使用Messenger将 Message 对象发送给服务 服务在其 Handler 中（在 handleMessage() 方法中）接收每个 Message 以下是一个使用 Messenger 接口的简单服务示例，服务端进程实现如下： package com.zejian.ipctest.messenger; import android.app.Service; import android.content.Intent; import android.os.Handler; import android.os.IBinder; import android.os.Message; import android.os.Messenger; import android.util.Log; /** * Created by zejian * Time 2016/10/3. * Description:Messenger服务端简单实例,服务端进程 */ public class MessengerService extends Service { /** Command to the service to display a message */ static final int MSG_SAY_HELLO = 1; private static final String TAG =\"wzj\" ; /** * 用于接收从客户端传递过来的数据 */ class IncomingHandler extends Handler { @Override public void handleMessage(Message msg) { switch (msg.what) { case MSG_SAY_HELLO: Log.i(TAG, \"thanks,Service had receiver message from client!\"); break; default: super.handleMessage(msg); } } } /** * 创建Messenger并传入Handler实例对象 */ final Messenger mMessenger = new Messenger(new IncomingHandler()); /** * 当绑定Service时,该方法被调用,将通过mMessenger返回一个实现 * IBinder接口的实例对象 */ @Override public IBinder onBind(Intent intent) { Log.i(TAG, \"Service is invoke onBind\"); return mMessenger.getBinder(); } } 首先我们同样需要创建一个服务类MessengerService继承自Service，同时创建一个继承自Handler的IncomingHandler对象来接收客户端进程发送过来的消息并通过其handleMessage(Message msg)进行消息处理。接着通过IncomingHandler对象创建一个Messenger对象，该对象是与客户端交互的特殊对象，然后在Service的onBind中返回这个Messenger对象的底层Binder即可。下面看看客户端进程的实现： package com.zejian.ipctest.messenger; import android.app.Activity; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.ServiceConnection; import android.os.Bundle; import android.os.IBinder; import android.os.Message; import android.os.Messenger; import android.os.RemoteException; import android.util.Log; import android.view.View; import android.widget.Button; import com.zejian.ipctest.R; /** * Created by zejian * Time 2016/10/3. * Description: 与服务器交互的客户端 */ public class ActivityMessenger extends Activity { /** * 与服务端交互的Messenger */ Messenger mService = null; /** Flag indicating whether we have called bind on the service. */ boolean mBound; /** * 实现与服务端链接的对象 */ private ServiceConnection mConnection = new ServiceConnection() { public void onServiceConnected(ComponentName className, IBinder service) { /** * 通过服务端传递的IBinder对象,创建相应的Messenger * 通过该Messenger对象与服务端进行交互 */ mService = new Messenger(service); mBound = true; } public void onServiceDisconnected(ComponentName className) { // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mBound = false; } }; public void sayHello(View v) { if (!mBound) return; // 创建与服务交互的消息实体Message Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); try { //发送消息 mService.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenager); Button bindService= (Button) findViewById(R.id.bindService); Button unbindService= (Button) findViewById(R.id.unbindService); Button sendMsg= (Button) findViewById(R.id.sendMsgToService); bindService.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.d(\"zj\",\"onClick-->bindService\"); //当前Activity绑定服务端 bindService(new Intent(ActivityMessenger.this, MessengerService.class), mConnection, Context.BIND_AUTO_CREATE); } }); //发送消息给服务端 sendMsg.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { sayHello(v); } }); unbindService.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // Unbind from the service if (mBound) { Log.d(\"zj\",\"onClick-->unbindService\"); unbindService(mConnection); mBound = false; } } }); } } 在客户端进程中，我们需要创建一个ServiceConnection对象，该对象代表与服务端的链接，当调用bindService方法将当前Activity绑定到MessengerService时，onServiceConnected方法被调用，利用服务端传递给来的底层Binder对象构造出与服务端交互的Messenger对象，接着创建与服务交互的消息实体Message，将要发生的信息封装在Message中并通过Messenger实例对象发送给服务端。关于ServiceConnection、bindService方法、unbindService方法，前面已分析过，这里就不重复了，最后我们需要在清单文件声明Service和Activity，由于要测试不同进程的交互，则需要将Service放在单独的进程中，因此Service声明如下： 接着多次点击绑定服务，然后发送信息给服务端，最后解除绑定，Log打印如下： 通过上述例子可知Service服务端确实收到了客户端发送的信息，而且在Messenger中进行数据传递必须将数据封装到Message中，因为Message和Messenger都实现了Parcelable接口，可以轻松跨进程传递数据，而Message可以传递的信息载体有，what,arg1,arg2,Bundle以及replyTo，至于object字段，对于同一进程中的数据传递确实很实用，但对于进程间的通信，则显得相当尴尬，在android2.2前，object不支持跨进程传输，但即便是android2.2之后也只能传递android系统提供的实现了Parcelable接口的对象，也就是说我们通过自定义实现Parcelable接口的对象无法通过object字段来传递，因此object字段的实用性在跨进程中也变得相当低了。不过所幸我们还有Bundle对象，Bundle可以支持大量的数据类型。接着从Log我们也看出无论是使用拓展Binder类的实现方式还是使用Messenger的实现方式，它们的生命周期方法的调用顺序基本是一样的，即onCreate()、onBind、onUnBind、onDestroy，而且多次绑定中也只有第一次时才调用onBind()。 简单服务端与客户端双向消息传递的简单例子： 先来看看服务端的修改，在服务端，我们只需修改IncomingHandler，收到消息后，给客户端回复一条信息。 /** * 用于接收从客户端传递过来的数据 */ class IncomingHandler extends Handler { @Override public void handleMessage(Message msg) { switch (msg.what) { case MSG_SAY_HELLO: Log.i(TAG, \"thanks,Service had receiver message from client!\"); //回复客户端信息,该对象由客户端传递过来 Messenger client=msg.replyTo; //获取回复信息的消息实体 Message replyMsg=Message.obtain(null,MessengerService.MSG_SAY_HELLO); Bundle bundle=new Bundle(); bundle.putString(\"reply\",\"ok~,I had receiver message from you! \"); replyMsg.setData(bundle); //向客户端发送消息 try { client.send(replyMsg); } catch (RemoteException e) { e.printStackTrace(); } break; default: super.handleMessage(msg); } } } 接着修改客户端，为了接收服务端的回复，客户端也需要一个接收消息的Messenger和Handler，其实现如下： /** * 用于接收服务器返回的信息 */ private Messenger mRecevierReplyMsg= new Messenger(new ReceiverReplyMsgHandler()); private static class ReceiverReplyMsgHandler extends Handler{ private static final String TAG = \"zj\"; @Override public void handleMessage(Message msg) { switch (msg.what) { //接收服务端回复 case MessengerService.MSG_SAY_HELLO: Log.i(TAG, \"receiver message from service:\"+msg.getData().getString(\"reply\")); break; default: super.handleMessage(msg); } } } 除了添加以上代码，还需要在发送信息时把接收服务器端的回复的Messenger通过Message的replyTo参数传递给服务端，以便作为同学桥梁，代码如下： public void sayHello(View v) { if (!mBound) return; // 创建与服务交互的消息实体Message Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); // 把接收服务器端的回复的Messenger通过Message的replyTo参数传递给服务端 msg.replyTo = mRecevierReplyMsg; try { //发送消息 mService.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } 原理图： 使用AIDL Code&Step：https://blog.csdn.net/weixin_37749732/article/details/124271111 要点： Server中创建并使用AIDL： 1.创建AIDL文件 2.自动生成对应的Java文件 Server中创建一个继承自IAidl.Stub的类，并于onBind()时return public class MyRemoteService extends Service { @Nullable @Override public IBinder onBind(Intent intent) { Log.e(\"MyRemoteSerivce\", \"onBind \"); return new StudentService(); } private class StudentService extends IStudentService.Stub { @Override public Student getStudentById(int id) throws RemoteException { Log.e(\"MyRemoteSerivce\", \"getStudentById:\" + id); return new Student(id, \"wang\", 10000); } } } Client中的aidl文件放置层级应完全复制自Server 绑定到Service时应使用IAidl.Stub.asInterface(iBinder)得到Server的Binder conn = new ServiceConnection() { //下面这个方法是bind绑定成功后的回调方法，在server服务端的 onBind返回的studentService //可以在这里通过iBinder进行获取 @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) { Log.e(TAG, \"onServiceConnected: \"); studentService = IStudentService.Stub.asInterface(iBinder); } @Override public void onServiceDisconnected(ComponentName componentName) { } }; 关于绑定服务的注意点 多个客户端可同时连接到一个服务。不过，只有在第一个客户端绑定时，系统才会调用服务的 onBind() 方法来检索 IBinder。系统随后无需再次调用 onBind()，便可将同一 IBinder 传递至任何其他绑定的客户端。当最后一个客户端取消与服务的绑定时，系统会将服务销毁（除非 startService() 也启动了该服务）。 通常情况下我们应该在客户端生命周期（如Activity的生命周期）的引入 (bring-up) 和退出 (tear-down) 时刻设置绑定和取消绑定操作，以便控制绑定状态下的Service，一般有以下两种情况： 如果只需要在 Activity 可见时与服务交互，则应在 onStart() 期间绑定，在 onStop() 期间取消绑定。 如果希望 Activity 在后台停止运行状态下仍可接收响应，则可在 onCreate() 期间绑定，在 onDestroy() 期间取消绑定。需要注意的是，这意味着 Activity 在其整个运行过程中（甚至包括后台运行期间）都需要使用服务，因此如果服务位于其他进程内，那么当提高该进程的权重时，系统很可能会终止服务进程。 通常情况下(注意)，切勿在 Activity 的 onResume() 和 onPause() 期间绑定和取消绑定，因为每一次生命周期转换都会发生这些回调，这样反复绑定与解绑是不合理的。此外，如果应用内的多个 Activity 绑定到同一服务，并且其中两个 Activity 之间发生了转换，则如果当前 Activity 在下一次绑定（恢复期间）之前取消绑定（暂停期间），系统可能会销毁服务并重建服务，因此服务的绑定不应该发生在 Activity 的 onResume() 和 onPause()中。 我们应该始终捕获 DeadObjectException DeadObjectException 异常，该异常是在连接中断时引发的，表示调用的对象已死亡，也就是Service对象已销毁，这是远程方法引发的唯一异常，DeadObjectException继承自RemoteException，因此我们也可以捕获RemoteException异常。 如何始终捕获某一异常？ 应用组件（客户端）可通过调用 bindService() 绑定到服务,Android 系统随后调用服务的 onBind() 方法，该方法返回用于与服务交互的 IBinder，而该绑定是异步执行的。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-问题解决.html":{"url":"04_Android/应用层/SDK/2-6.应用层-应用通信/Service-问题解决.html","title":"Service-问题解决","keywords":"","body":"问题 android 使用service时遇到 java.lang.IllegalArgumentException https://www.jianshu.com/p/07be44e9b6cf No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/TV/AndroidTV.html":{"url":"04_Android/应用层/TV/AndroidTV.html","title":"Androidtv","keywords":"","body":"开发入门 UI设计 TV的观看距离较远，建议限制TV屏幕上的文字和阅读量 确保界面具有清晰的两轴导航路径以供上下左右四个方向的移动操作使用 应用必须清楚地指明聚焦的对象，这样用户就很容易看出他们可以执行的操作。使用缩放、阴影亮度 、不透明度、动画来帮助用户看出聚焦的对象。 声明 TV Activity 目标平台为 TV 设备的应用必须在其清单中声明 TV 启动器 Activity。它使用 CATEGORY_LEANBACK_LAUNCHER intent 过滤器来执行此操作。此过滤器可将您的应用标识为支持 TV 平台，并让 Google Play 将其识别为 TV 应用。 ... 注意：如果您不在应用中包含 CATEGORY_LEANBACK_LAUNCHER intent 过滤器，那么用户在 TV 设备上运行 Google Play 时将看不到您的应用。此外，如果您的应用没有此过滤器，那么当您使用开发者工具将其加载到 TV 设备上时，该应用不会出现在 TV 界面中。 声明Leanback支持 声明您的应用使用 Android TV 所要求的 Leanback 界面。如果您要开发一款在移动设备（手机、穿戴式设备、平板电脑等）以及 Android TV 上都可运行的应用，请将 required 属性值设为 false。如果您将 required 属性值设为 true，您的应用将只能在使用 Leanback 界面的设备上运行。 ... 将触摸屏声明为非必备条件 目标平台为 TV 设备的应用不依赖于触摸屏进行输入。为明确这一点，您的 TV 应用的清单必须声明 android.hardware.touchscreen 功能为非必备功能。此设置会将您的应用标识为能够在 TV 设备上工作，这也是您的应用在 Google Play 中被视为 TV 应用的必要条件。以下代码示例展示了如何添加此清单声明： ... 注意：您必须在应用清单中声明触摸屏并非必要条件（如本示例代码中所示），否则您的应用将不会出现在 TV 设备上的 Google Play 中。 提供主屏幕横幅 如果应用包含 Leanback 启动器 intent 过滤器，那么它必须针对每种本地化语言提供一张主屏幕横幅图片。横幅是显示在主屏幕的应用和游戏行中的应用启动点。如需向您的应用添加横幅，请在清单中描述横幅，如下所示： ... 您可以将 android:banner 属性与 标记一起使用，为所有应用 Activity 提供默认横幅，也可以将其与 标记一起使用，为特定 Activity 提供横幅。 横幅应该是 xhdpi 资源，尺寸为 320 x 180 像素。文本必须包含在图片中。如果您的应用支持多种语言，对于带文本的横幅，您必须针对支持的每种语言提供单独的版本。 *大概类似于logo吧。。。 更改启动器颜色 当 TV 应用启动时，系统会显示动画，就像一个不断膨胀的实心圆。要自定义此动画的颜色，请将 TV 应用或 Activity 的 android:colorPrimary 属性设为特定颜色。此外，还应将另外两个过渡重叠属性设为 true，如主题背景资源 XML 文件中的以下代码段所示： @color/primary true true 添加 TV 库 Jetpack 包含用于 TV 应用的 androidx 软件包库。这些库为 TV 设备提供了 API 和界面微件。 androidx.leanback.app androidx.leanback.database androidx.leanback.graphics androidx.leanback.media androidx.leanback.preference androidx.leanback.system androidx.leanback.widget androidx.leanback.widget.picker 代理设置 C:\\Users\\5109U25854.gradle的gradle.properties文件下 systemProp.http.proxyHost=137.153.66.14 systemProp.http.proxyPort=10080 systemProp.https.proxyHost=137.153.66.14 systemProp.https.proxyPort=10080 确认App是否运行在TV设备下 UiModeManager.getCurrentModeType() public static final String TAG = \"DeviceTypeRuntimeCheck\"; UiModeManager uiModeManager = (UiModeManager)getSystemService(UI_MODE_SERVICE); if(uiModeManager.getCurrentModeType()==Configuration.UI_MODE_TYPE_TELEVISION){ Log.d(TAG,\"Running on a TV Device\") }else{ Log.d(TAG,\"Running on a non-TV Device\") } 连接 TV开发不像手机开发， 通过USB线连接进行调试。 可以在电视的网络设置中找到电视的IP地址，通过以下adb命令进行连接， 连接成功后即可在AS中操作电视设备。 // 连接电视 adb connect 170.2.10.20 // 断开连接 adb disconnect 170.2.10.20 开发版的系统可以直接连接 键盘输入 和手机的输入方式相比，可以说复杂了很多。电视不是触屏的，每一个字符度需要操作遥控器，通过上下左右找到字符，点击确认输入。 如果发现之前的某个字符输错， 又要返回去删除， 简直是噩梦。 部分遥控器已经有了红外操作装置， 输入字符类似于鼠标点击键盘， 但是相比手机触屏，依旧复杂....... 通过下面的adb命令可以快速将字符串输入到电视的输入框中 adb shell input text \"hello,world\" 焦点控制 电视的按钮状态，相比手机要稍微复杂一些。 用户使用手机APP是可以随处点击，没有限制。 有点击事件的，没有点击事件的，都想点点试试。 电视用户的话，需要限制用户那块可以点击，那块不可以，这就需要用遥控器的上下左右跳转来限制View能否或得焦点。并需要时时刻刻需要告诉用户目前的焦点处于什么位置，方便进行接下来的操作。 1.设置可获取焦点 布局文件中 android:focusable=\"true\" 代码中 view.setFocusable(true); 2.设置触摸获取焦点 布局文件中 android:focusableInTouchMode=\"true\" 代码中 view.setFocusableInTouchMode(true); 3.View焦点监听 view.setOnFocusChangeListener(new View.OnFocusChangeListener() { @Override public void onFocusChange(View v, boolean hasFocus) { if (hasFocus) { // 获取焦点时操作，常见的有放大、加边框等 } else { // 失去焦点时操作，恢复默认状态 } } }); 4.View获取焦点时， 设置下一个获取焦点的View 布局文件中： android:nextFocusDown=\"@id/button1\" android:nextFocusUp=\"@id/button2\" android:nextFocusLeft=\"@id/button3\" android:nextFocusRight=\"@id/button4\" 代码中： view.setNextFocusDownId(R.id.button1); view.setNextFocusUpId(R.id.button2); view.setNextFocusLeftId(R.id.button3); view.setNextFocusRightId(R.id.button4); 5.确定焦点的位置 TV开发过程中，最头疼的就是遥控器按着按着就不知道焦点去哪了。 明明所有的的View都限制了能否获取焦点，以及获取焦点的状态。 还是会出现按着按着就不知道焦点去哪了。这个在复杂的自定义View中容易出现。 这个时候就要相办法定位到焦点躲到哪里去了...... ViewTreeObserver observer = getWindow().getDecorView().getViewTreeObserver(); observer.addOnGlobalFocusChangeListener(new ViewTreeObserver.OnGlobalFocusChangeListener() { @Override public void onGlobalFocusChanged(View oldFocus, View newFocus) { VLog.d(TAG, \"oldFocus: \" + oldFocus + \"/n\" + \"newFocus: \" + newFocus); } }); 复制代码 设置Window的全局焦点监听，将失去焦点和获得焦点的View打印出来。 6.descendantFocusability属性 在复杂的自定义View中， 只有外层的父View能获取到焦点， 子View无论如何也获取不到焦点。 如何让子View也能获取到焦点那？descendantFocusability属性可以帮忙搞定 官方的定义是这样子的： descendantFocusability是View的一个属性。通过这个属性可以指定viewGroup和其子View到底谁获取焦点， 直接在viewGroup的 xml的布局上使用就行。 android:descendantFocusability=\"afterDescendants\" 三种属性值分别为： beforeDescendants ：viewGroup会优先其子类控件而获取到焦点 afterDescendants ：viewGroup只有当其子类控件不需要获取焦点时才获取焦点 blocksDescendants ：viewGroup会覆盖子类控件而直接获得焦点 按键监听 UI可能天马行空的想给某个View的按下操作加个动画， 这个时候就要监听遥控器的按下操作，并开启动画了。 如何监听那？ view.setOnKeyListener(new View.OnKeyListener() { @Override public boolean onKey(View v, int keyCode, KeyEvent event) { if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) { // 这种情况就是当按下遥控器返回键时 return true; } return false; } }); 复制代码 常用的遥控器按键： KeyEvent.KEYCODE_BACK // 返回键 KeyEvent.KEYCODE_DPAD_DOWN // 下键 KeyEvent.KEYCODE_DPAD_UP // 上键 KeyEvent.KEYCODE_DPAD_LEFT // 左键 KeyEvent.KEYCODE_DPAD_RIGHT // 右键 KeyEvent.KEYCODE_MENU // 菜单键 KeyEvent.KEYCODE_SETTINGS // 设置键 跟手机开发一样，HOME键监听不到 UI状态 为了方便用户的操作，更好的提示用户。按钮有焦点态， 按下态，点击态等多种状态，这些可能度需要处理。类似于下图这种 像这种其实也是比较简单的，用一个SelectDrawable就可以解决 复制代码 模拟器模拟电视分辨率 如果电视的屏幕特别大的话， 对UI的开发也是一种挑战。 现在的电视动辄就五十多英寸起步，太大了。 看个UI效果都要退后离电视三五米。这样开发谁受得了。 这个时候就需要模拟器来帮你了， 用模拟器模拟电视的分辨率， 可以在本地的模拟器上直接看效果。 不用再离电视三五米的距离了...... 我用的MuMu模拟器设置分辨率， 其他第三方模拟器应该也是支持的 Chrome插件模拟遥控器点击 既然使用模拟器来模拟TV， 那就还缺一样东西。 PC的模拟器虽然不是触控的， 需要用鼠标操作。 和电视的遥控器有一定区别。 那有没有一种工具， 像遥控器一样操作模拟器来模拟上下左右的按键嘛？答案是有的。 Chrome插件，ChromeADB可以模拟遥控器对设备的操作 下载地址：chrome.google.com/webstore/de… 不能科学上网的同学，可以去GitHub下载进行离线安装：github.com/importre/ch… 安装完成后， 连接模拟器。右边的Keyboard就可以当做遥控器来操作设备了。 实战之RecyclerView的焦点问题处理 在开发Android TV应用时， 使用遥控器控制RecyclerView的焦点，向用户展示当前选中的是那个item。会遇到几个头疼的问题： 设置Item获得焦点时的效果 RecyclerView第一次获得焦点，默认选中第一项 RecyclerView重新获得焦点后，选中上次的item RecyclerView失去焦点后，继续保持item的选中效果 1.设置Item获得焦点时的效果 和单个View一样， 给Item设置SelectDrawable即可。 2.RecyclerView第一次获得焦点，默认选中第一项 由于Android系统的焦点跳转规则是就近跳转，可能某个离RecyclerView比较近的View，在跳转时， 跳转到了离它比较近的，RecyclerView内部的某个ItemView，而不是RecyclerView内部的第一个ItemView。这显然不符合我们的要求。 那么如何才能让我们在RecyclerView第一次获得焦点时，选中第一项那？ 答案是使用： HorizontalGridView或者VerticalGridView。这两个View是leanback仓库里面的两个类， 都是继承自BaseGridView，而BaseGridView继承自RecyclerView。HorizontalGridView是处理横向RecyclerView的焦点问题， VerticalGridView是处理竖向的。 添加依赖： implementation \"androidx.leanback:leanback:1.0.0\" 使用 因为HorizontalGridView extends BaseGridView extends RecyclerView，所以之前使用RecyclerView的代码基本不用改变，并且不用调用setLayoutManager。（千万不调用setLayoutManager，调用的话会不生效。BaseGridView的焦点控制完全是由内部设置的LayoutManager来生效的） 3.RecyclerView重新获得焦点后，选中上次的item 在不做任何处理的情况下，RecyclerView重新获得焦点也是按照最近原则来获得焦点的，而不是上次选中的View获得焦点。 要想让RecyclerView重新获得焦点后，选中上次的item。 使用HorizontalGridView或者VerticalGridView即可。 4.RecyclerView失去焦点后，继续保持item的选中效果 (1)同一时刻，有且只能有一个View保持选中状态。当一个View选中时， 之前选中的View取消选中。 那就保存上一次选中的View，当有新的View选中时， 上一次选中的View取消选中，新的View失去焦点时， 将其更新为上次选中的View。 mRootView.setOnFocusChangeListener(new View.OnFocusChangeListener() { @Override public void onFocusChange(View v, boolean hasFocus) { if (hasFocus) { v.setSelected(true); if (mLastFocusView!= null) { mLastFocusView.setSelected(false); } } else { mLastFocusView = v; } } }); 复制代码 (2)既然每次只能有一个ItemView处于选中状态，那就拿到被选中ItemView 的positon, 遍历RecyclerView的所有ItemView, 只要不是被选中的positon, 均不让其处于选中状态。 第二种方法比较暴力，推荐使用第一种方法。 LeanBack项目 仓库地址： github.com/android/tv-… This sample is a Videos By Google app, designed to run on an Android TV device, which demonstrates how to use the Leanback Support library which enables you to easily develop beautiful Android TV apps with a user-friendly UI that complies with the UX guidelines of Android TV. 这个项目是Google官方提供，面向TV设备的一个视频APP。主要目的是教你使用Leanback库，轻松的上手开发对用户友好，规范的Android TV APP。 这个库通过一些界面的实现方式， 帮助开发者快速实现TV的开发。下面是这个库一些界面的截图。 感兴趣的同学可以下载到本地，体验一下。 推荐 Google TV开发指南： developer.android.com/training/tv… Android TV--RecyclerView中item焦点实战：juejin.cn/post/687811… LeanbackShowcase：github.com/android/tv-… tv-samples： github.com/android/tv-… No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/TV/DayDream互动屏保.html":{"url":"04_Android/应用层/TV/DayDream互动屏保.html","title":"Daydream互动屏保","keywords":"","body":"参考：https://www.jianshu.com/p/0d7c44c84b9e 介绍 自定义屏保，当充电的设备空闲或者插入底座时显示的互动屏保。 使用 需要在Service中定义权限android.permission.BIND_DREAM_SERVICE 定义intent-filter\\ 指定的图标和标题都在这里设置 如果填写了 元素，dream的附加信息就被指定在XML文件的 元素中。 通常提供的附加信息是对互动屏保的自定义设置，指向一个自己写的Activity 比如：res/xml/my_dream.xml .MyDream需要继承自DreamService，在onAttachedToWindow中设置布局 package com.rust.service; import android.service.dreams.DreamService; import com.rust.aboutview.R; public class MyDayDream extends DreamService { @Override public void onAttachedToWindow() { super.onAttachedToWindow(); // Exit dream upon user touch setInteractive(false); // Hide system UI setFullscreen(true); // Set the dream layout setContentView(R.layout.my_day_dream); } } 生命周期： onAttachedToWindow() 初始化设置，在这里可以调用 setContentView() onDreamingStarted() 互动屏保已经启动，这里可以开始播放动画或者其他操作 onDreamingStopped() 在停止 onDreamingStarted() 里启动的东西 onDetachedFromWindow() 在这里回收前面调用的资源（比如 handlers 和 listeners） 另外，onCreate 和 onDestroy 也会被调用。但要复写上面的几个方法来执行初始化和销毁操作。 在Settings-Display-Daydream中可以找到新增的选项 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/TV/KEYCODE.html":{"url":"04_Android/应用层/TV/KEYCODE.html","title":"Keycode","keywords":"","body":"电话键 键名 描述 键值 KEYCODE_CALL 拨号键5 KEYCODE_ENDCALL 挂机键6 KEYCODE_HOME 按键Home3 KEYCODE_MENU 菜单键82 KEYCODE_BACK 返回键4 KEYCODE_SEARCH 搜索键84 KEYCODE_CAMERA 拍照键27 KEYCODE_FOCUS 拍照对焦键80 KEYCODE_POWER 电源键26 KEYCODE_NOTIFICATION 通知键83 KEYCODE_MUTE 话筒静音键91 KEYCODE_VOLUME_MUTE 扬声器静音键164 KEYCODE_VOLUME_UP 音量增加键24 KEYCODE_VOLUME_DOWN 音量减小键25 控制键 键名 描述 键值 KEYCODE_ENTER 回车键66 KEYCODE_ESCAPE ESC键111 KEYCODE_DPAD_CENTER 导航键 确定键23 KEYCODE_DPAD_UP 导航键 向上19 KEYCODE_DPAD_DOWN 导航键 向下20 KEYCODE_DPAD_LEFT 导航键 向左21 KEYCODE_DPAD_RIGHT 导航键 向右22 KEYCODE_MOVE_HOME 光标移动到开始键122 KEYCODE_MOVE_END 光标移动到末尾键123 KEYCODE_PAGE_UP 向上翻页键92 KEYCODE_PAGE_DOWN 向下翻页键93 KEYCODE_DEL 退格键67 KEYCODE_FORWARD_DEL 删除键112 KEYCODE_INSERT 插入键124 KEYCODE_TAB Tab键61 KEYCODE_NUM_LOCK 小键盘锁143 KEYCODE_CAPS_LOCK 大写锁定键115 KEYCODE_BREAK Break/Pause键121 KEYCODE_SCROLL_LOCK 滚动锁定键116 KEYCODE_ZOOM_IN 放大键168 KEYCODE_ZOOM_OUT 缩小键169 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/TV/VoiceInteractionServiceAPI.html":{"url":"04_Android/应用层/TV/VoiceInteractionServiceAPI.html","title":"Voiceinteractionserviceapi","keywords":"","body":"如需实现语音交互应用 (VIA)，您需要完成以下步骤： 创建 VIA 框架。 （可选）实现首次设置/登录流程。 （可选）实现“设置”屏幕。 在清单文件中声明必需的权限。 实现语音控制面板界面。 实现语音识别（必须包含 RecognitionService API 实现）。 实现语音内容（可以选择性地实现 TextToSpeech API）。 实现命令执行。请参阅执行命令，了解这方面的内容。 创建 VIA 框架 当应用清单中包含以下内容时，该应用会被检测为具有语音交互功能。 AndroidManifest.xml ... 在此示例中： VIA 必须公开一项用于扩展 VoiceInteractionService 的服务，并为 VoiceInteractionService.SERVICE_INTERFACE (\"android.service.voice.VoiceInteractionService\") 操作提供 intent 过滤器。 此服务必须拥有 BIND_VOICE_INTERACTION 系统签名权限。 此服务应具有包含以下代码的 android.voice_interaction 元数据文件： res/xml/interaction_service.xml 如需详细了解各字段，请参阅 R.styleable#VoiceInteractionService。鉴于所有的 VIA 也都属于语音识别器服务，您还必须在清单中添加以下代码： AndroidManifest.xml ... 语音识别服务还需要具有以下元数据： res/xml/recognition_service.xml VoiceInteractionService、VoiceInteractionSessionService 和 VoiceInteractionSession 如前所述，VoiceInteractionService 是 VIA 的入口点。此服务的主要职责包括： 初始化所有应在此 VIA 处于活跃状态时保持运行的进程，例如启动指令检测。 报告支持的语音操作（请参阅语音助理点读功能）。 从锁定屏幕 (keyguard) 启动语音交互会话。 形式最简单的 VoiceInteractionService 实现如下所示： public class MyVoiceInteractionService extends VoiceInteractionService { private static final List SUPPORTED_VOICE_ACTIONS = Arrays.asList( CarVoiceInteractionSession.VOICE_ACTION_READ_NOTIFICATION, CarVoiceInteractionSession.VOICE_ACTION_REPLY_NOTIFICATION, CarVoiceInteractionSession.VOICE_ACTION_HANDLE_EXCEPTION ); @Override public void onReady() { super.onReady(); // TODO: Setup hotword detector } @NonNull @Override public Set onGetSupportedVoiceActions( @NonNull Set voiceActions) { Set result = new HashSet<>(voiceActions); result.retainAll(SUPPORTED_VOICE_ACTIONS); return result; } ... } 如需处理语音助理点读功能，必须实现VoiceInteractionService#onGetSupportedVoiceActions()。系统使用 VoiceInteractionSessionService 创建 VoiceInteractionSession 并与之交互。它只有一项职责：在接到请求时发起新的会话。 public class MyVoiceInteractionSessionService extends VoiceInteractionSessionService { @Override public VoiceInteractionSession onNewSession(Bundle args) { return new MyVoiceInteractionSession(this); } } 最后，大部分工作会在 VoiceInteractionSession 中完成。一个会话实例可能会被重复使用，以完成多个用户交互。在 AAOS 中，存在一个辅助 CarVoiceInteractionSession ，可帮助实现汽车特有的一些功能。 public class MyVoiceInteractionSession extends CarVoiceInteractionSession { public InteractionSession(Context context) { super(context); } @Override protected void onShow(String action, Bundle args, int showFlags) { closeSystemDialogs(); // TODO: Unhide UI and update UI state // TODO: Start processing audio input } ... } VoiceInteractionSession 包含大量的回调方法，我们将在下面的各个部分进行介绍。如需查看完整列表，请参阅介绍 VoiceInterationSession 的文档。 实现首次设置/登录流程 首次设置和登录可在以下三种情况下发生： 在设备初始配置期间（设置向导）。 在语音交互服务交换期间（设置）。 首次启动时（应用被选中时）。 如需详细了解推荐的用户体验和视觉指南，请参阅预加载的助理：用户体验指南。 在语音服务交换期间进行设置 用户总是有可能选择未正确配置的 VIA。出现这种情况的原因如下： 用户完全跳过了设置向导，或者用户跳过了语音交互配置步骤。 用户选择的 VIA 与设备初始配置期间配置的 VIA 不同。 在任何情况下，VoiceInteractionService 都可通过以下几种方式来鼓励用户完成设置： 通知提醒。 用户尝试使用 VIA 时的自动语音回复。 注意：在用户未明确请求的情况下，强烈建议不要显示 VIA 设置流程。这意味着在设备启动期间或者用户切换或解锁后，VIA 应避免自动在 HU 上显示内容。 通知提醒：通知提醒会以不干扰用户的方式来表明需要进行设置，并为用户提供一种导航到助理设置流程的途径。 https://source.android.google.cn/static/devices/automotive/images/vi_08.gif?hl=zh-cn 此流程的工作原理如下： 语音回复 这是实现起来最简单的流程：用 VoiceInteractionSession#onShow() 回调发起语音提示，向用户说明需要执行什么操作，然后询问用户（如果根据用户体验限制状态允许进行设置）是否想要启动设置流程。如果当时无法进行设置，则对此作出解释。 首次使用时设置 用户常常有可能触发尚未正确配置的 VIA。在这种情况下： 请用语音告知用户这一情况（例如，“请完成几个步骤，以便我正常运行…”）。 如果用户体验限制引擎允许（请参阅 UX_RESTRICTIONS_NO_SETUP），请询问用户是否要启动首次设置流程，如果是，则打开 VIA 的“设置”屏幕。 如果不允许（例如，当用户正在驾车时），请留下一条通知，供用户在安全的情况下点击相应选项。 构建语音交互首次设置屏幕 首次设置屏幕和登录屏幕应作为常规 Activity 进行开发。请参阅预加载的助理：用户体验指南，了解有关界面开发的用户体验和视觉准则。 通用准则： VIA 应允许用户随时中断和恢复设置。 如果 UX_RESTRICTIONS_NO_SETUP 限制当时有效，则不应允许进行设置。如需了解详情，请参阅有关防止驾驶员分心的准则。 首次设置屏幕应与每辆车的设计系统相匹配。一般屏幕布局、图标、颜色及其他方面应与界面的其余部分保持一致。如需了解详情，请参阅自定义。 设置屏幕属于常规 Android Activity。如果设置屏幕已实现，必须在 res/xml/interaction_service.xml 中将其入口点声明为 VIA 清单的一部分（请参阅清单部分）。“设置”部分非常适合用来继续进行首次设置和登录（如果用户未完成此步骤），或在需要时提供退出帐号或切换用户选项。与上述首次设置屏幕类似，这些屏幕应该： 提供返回屏幕堆栈中上一个屏幕（如“汽车设置”）的选项。 在驾车时禁止使用。如需了解详情，请参阅有关防止驾驶员分心的准则。 匹配各种车辆设计系统。如需了解详情，请参阅自定义。 在清单文件中声明必需的权限 VIA 需要的权限可分为三类： 系统签名权限。这些权限只会授予系统签名的预装 APK。用户无法授予这些权限，只有原始设备制造商 (OEM) 可以在构建系统映像时授予这些权限。如需详细了解如何获取签名权限，请参阅授予系统特许权限。 危险权限。这些是用户必须使用 PermissionsController 对话框授予的权限。OEM 可以将其中的一些权限预先授予默认的 VoiceInteractionService。但考虑到这个默认项可能会因设备而改变，应用应该能够在需要时请求这些权限。 其他权限。这些包括其他所有不需要用户干预的权限。这些权限将由系统自动授予。 基于上述内容，下一部分仅重点介绍请求危险权限的相关信息。只有当用户在登录或设置屏幕中时，才应请求权限。 在“设置”屏幕中请求权限 您应使用常规 ActivityCompat#requestPermission() 方法（或等效方法）请求危险权限。如需详细了解如何请求权限，请参阅请求应用权限。 通知监听器权限 为了实现 TTR 流程，必须将 VIA 指定为通知监听器。这本身并不是权限，而是允许系统向注册的监听器发送通知的配置。为了解 VIA 是否获取了对这些信息的访问权限，应用可以执行以下操作： （可选）使用 CarAssistUtils#assistantIsNotificationListener() 提前检查是否有通知监听器。例如，您可以在设置流程中执行此操作。 （必需）针对使用操作 VOICE_ACTION_HANDLE_EXCEPTION 和异常 EXCEPTION_NOTIFICATION_LISTENER_PERMISSIONS_MISSING 处理 CarVoiceInteractionSession#onShow() 做出响应。 如果没有预先授予此访问权限，VIA 应结合使用语音提示和通知，引导用户转到“汽车设置”的“通知使用权”部分。可以使用以下代码打开设置应用的相应部分： private void requestNotificationListenerAccess() { Intent intent = new Intent(Settings .ACTION_NOTIFICATION_LISTENER_SETTINGS); intent.putExtra(Settings.EXTRA_APP_PACKAGE, getPackageName()); startActivity(intent); } 实现语音控制面板界面 当 VoiceInteractionSession 收到 onShow() 回调时，它可以显示语音控制面板界面。如需了解有关语音控制面板实现的视觉和用户体验准则，请参阅预加载的助理：用户体验指南。 实现此界面的方式有两种： 覆盖 VoiceInteractionSession#onCreateContentView() 使用 VoiceInteractionSession#startAssistantActivity() 启动 Activity 使用 onCreateContentView() 这是显示语音控制面板的默认方式。只要语音会话处于活动状态，VoiceInteractionSession 基类就会创建一个窗口并管理其生命周期。应用必须覆盖 VoiceInteractionSession#onCreateContentView() 并返回一个视图，该视图将在会话创建后立即附加到该窗口。该视图最初应该是不可见的。当语音交互开始时，这个视图应该在 VoiceInteractionSession#onShow() 上变得可见，然后在 VoiceInteractionSession#onHide() 上又变得不可见。 public class MyVoiceInteractionSession extends CarVoiceInteractionSession { private View mVoicePlate; … @Override public View onCreateContentView() { mVoicePlate = inflater.inflate(R.layout.voice_plate, null); … } @Override protected void onShow(String action, Bundle args, int showFlags) { // TODO: Update UI state to \"listening\" mVoicePlate.setVisibility(View.VISIBLE); } @Override public void onHide() { mVoicePlate.setVisibility(View.GONE); } … } 使用此方法时，不妨调整 VoiceInteractionSession#onComputeInsets())，以考虑界面中被遮盖的区域。 使用 startAssistantActivity() 在此情形中，VoiceInteractionSession 会将语音控制面板界面的处理委托给一个常规的 Activity。使用此选项时，VoiceInteractionSession 实现必须对 onPrepareShow() 回调停用其默认内容窗口的创建（请参阅使用 onCreateContentView()）。在 VoiceInteractionSession#onShow() 时，会话将使用 VoiceInteractionSession#startAssistantActivity() 启动语音控制面板 Activity。此方法会使用合适的窗口设置和 Activity 标志启动界面。 public class MyVoiceInteractionSession extends CarVoiceInteractionSession { … @Override public void onPrepareShow(Bundle args, int showFlags) { super.onPrepareShow(args, showFlags); setUiEnabled(false); } @Override protected void onShow(String action, Bundle args, int showFlags) { closeSystemDialogs(); Intent intent = new Intent(getContext(), VoicePlateActivity.class); intent.putExtra(VoicePlateActivity.EXTRA_ACTION, action); intent.putExtra(VoicePlateActivity.EXTRA_ARGS, args); startAssistantActivity(intent); } … } 为了让这个 Activity 与 VoiceInteractionSession 之间保持通信，可能需要一组内部 Intent 或服务绑定。例如，调用 VoiceInteractionSession#onHide() 时，会话必须能够将此请求传递给这个 Activity。 重要提示：在 Automotive 中，驾车期间只能显示带有特殊注解的 Activity 或者 UXR“许可名单”中列出的 Activity。这也适用于以 VoiceInteractionSession#startAssistantActivity() 开头的 Activity。请务必使用 为 Activity 添加注解，或在 /packages/services/Car/service/res/values/config.xml 文件的 systemActivityWhitelist 键中添加此 Activity。如需了解详情，请参阅有关防止驾驶员分散注意力的准则。 实现语音识别 在本部分中，您将了解如何通过检测和识别启动指令来实现语音识别。启动指令是用来通过语音启动新查询或操作的触发字词，例如“Ok Google”或“Hey Google”。 DSP 启动指令检测 Android 通过 AlwaysOnHotwordDetector 类在 DSP 级提供了对一个始终开启的启动指令检测器的访问权限。这提供了一种便捷方式，仅使用较低的 CPU 开销即可实现启动指令检测。此功能的用法分为两个部分： AlwaysOnHotwordDetector 的实例化。 启动指令检测声音模型的注册。 VoiceInteractionService 实现可以使用 VoiceInteractionService#createAlwaysOnHotwordDetector() 创建启动指令检测器，并传递它们希望用于检测的启动指令和语言区域。因此，应用会收到 onAvailabilityChanged() 回调，其中包含下列某个可能的值： STATE_HARDWARE_UNAVAILABLE。DSP 功能在该设备上不可用。在这种情况下，应用将使用软件启动指令检测。 STATE_HARDWARE_UNSUPPORTED。DSP 支持通常不可用，而且 DSP 也不支持给定的启动指令和语言区域组合。应用可以选择使用软件启动指令检测。 STATE_HARDWARE_ENROLLED。启动指令检测已就绪，可以通过调用 startRecognition() 方法来启动。 STATE_HARDWARE_UNENROLLED。所请求的启动指令的声音模型不可用，但可以进行注册。 您可以使用 IVoiceInteractionManagerService#updateKeyphraseSoundModel() 注册启动指令检测声音模型。在给定的时间内，您可以在系统中注册多个模型，但只有一个模型会与 AlwaysOnHotwordDetector 相关联。DSP 启动指令检测可能不一定适用于所有设备。VIA 开发者应使用 getDspModuleProperties() 方法检查硬件功能。如需查看展示如何注册声音模型的示例代码，请参阅 VoiceEnrollment/src/com/android/test/voiceenrollment/EnrollmentUtil.java。如需了解并发启动指令识别，请参阅并发捕获。 软件启动指令检测 如上所述，DSP 启动指令检测可能不适用于某些设备（例如，Android 模拟器就不提供 DSP 模拟）。在这种情况下，软件语音识别是唯一的替代方案。为避免干扰其他可能需要使用麦克风的应用，VIA 必须使用以下方法访问音频输入： 音频捕获必须使用 MediaRecorder.AudioSource.HOTWORD。 拥有 android.Manifest.permission.CAPTURE_AUDIO_HOTWORD 权限。 这两个常量均为 @hide，并且仅适用于捆绑应用。 管理音频输入和语音识别 音频输入将使用 MediaRecorder API 实现。如需详细了解如何使用此 API，请参阅 MediaRecorder 概览。此外，语音交互服务应该为 RecognitionService 实现。系统中任何需要语音识别功能的应用都将使用 SpeechRecognizer API 来访问此功能。为实现语音识别功能并且能使用麦克风，VIA 必须拥有 android.permission.RECORD_AUDIO 权限。此外，访问 RecognitionService 实现的应用也应拥有此权限。 在 Android 10 之前的版本中，一次只能向一个应用授予麦克风访问权限（启动指令检测除外，具体请参阅上文）。从 Android 10 开始，麦克风访问权限可以共享。如需了解详情，请参阅共享音频输入。 访问音频输出 当 VIA 准备好提供语音回复时，请务必遵循下面这一系列准则： 在请求音频焦点或管理音频输出时，应用必须使用 AudioAttributes#USAGE_ASSISTANT 和 AudioAttributes#CONTENT_TYPE_SPEECH 作为音频属性。 在语音识别期间，必须使用 AudioManage#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE 请求音频焦点。请注意，某些媒体应用在其音频焦点被移除时，可能无法对媒体命令做出正确的回应（请参阅填充媒体命令）。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/反编译/Android反编译.html":{"url":"04_Android/应用层/反编译/Android反编译.html","title":"Android反编译","keywords":"","body":"Smail Smali语法 Smali--Dalvik虚拟机指令语言-->【android_smali语法学习一】 一个简单的Activity代码如下： public class SmaliActivity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_smail); initView(); } private void initView() { int num = 2 + 3; String name = \"zhangsan\"; Log.w(\"xfhy666\", \"initView: num = \" + num + \" name = \" + name); } @Override protected void onDestroy() { super.onDestroy(); } } 它的smali代码如下： # 这里简单介绍了类的名称,父类是谁 .class public Lcom/xfhy/allinone/smali/SmaliActivity; .super Landroidx/appcompat/app/AppCompatActivity; .source \"SmaliActivity.java\" # direct methods 从这里开始的都是在当前类定义的方法 # .method 表示这是一个方法 # 这里定义的是当前类的不带参数缺省的构造方法,末尾的V表示方法返回类型是void .method public constructor ()V # .locals 表示当前方法需要申请多少个寄存器 .locals 0 .line 16 invoke-direct {p0}, Landroidx/appcompat/app/AppCompatActivity;->()V return-void .end method .method private initView()V .locals 4 .line 27 const/4 v0, 0x5 .line 28 .local v0, \"num\":I const-string v1, \"lisi\" .line 29 .local v1, \"name\":Ljava/lang/String; new-instance v2, Ljava/lang/StringBuilder; invoke-direct {v2}, Ljava/lang/StringBuilder;->()V const-string v3, \"initView: num = \" invoke-virtual {v2, v3}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder; invoke-virtual {v2, v0}, Ljava/lang/StringBuilder;->append(I)Ljava/lang/StringBuilder; const-string v3, \" name = \" invoke-virtual {v2, v3}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder; invoke-virtual {v2, v1}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder; invoke-virtual {v2}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String; move-result-object v2 const-string v3, \"xfhy666\" invoke-static {v3, v2}, Landroid/util/Log;->w(Ljava/lang/String;Ljava/lang/String;)I .line 30 return-void .end method # virtual methods 从这里开始的都是覆写父类的方法 .method protected onCreate(Landroid/os/Bundle;)V .locals 1 .param p1, \"savedInstanceState\" # Landroid/os/Bundle; .line 20 invoke-super {p0, p1}, Landroidx/appcompat/app/AppCompatActivity;->onCreate(Landroid/os/Bundle;)V .line 21 const v0, 0x7f0b001f invoke-virtual {p0, v0}, Lcom/xfhy/allinone/smali/SmaliActivity;->setContentView(I)V .line 23 invoke-direct {p0}, Lcom/xfhy/allinone/smali/SmaliActivity;->initView()V .line 24 return-void .end method .method protected onDestroy()V .locals 0 .line 35 invoke-super {p0}, Landroidx/appcompat/app/AppCompatActivity;->onDestroy()V .line 36 return-void .end method 上面的这份smali代码就比Java代码多了一个缺省的构造方法.然后每个方法的开始是以.method开始的,以.end method结束. Smali官方文档 Davlik字节码中,寄存器是32位,一般的类型用一个寄存器就够存了.只有64位类型的需要2个寄存器来存储,Long和Double就是64位类型的. 原始数据类型 类型表示 原始类型 v void Z boolean B byte S short C char I int J long (64位) F float D double (64位) 对象类型 类型表示 Java中的类型 Ljava/lang/String; String Landroid/os/Bundle; Bundle 对象类型的前面会加一个L 末尾会加一个; 包名全路径,中间以/分隔 数组 类型表示 Java中的类型 [I int[] [[I int[][] [Ljava/lang/String; String[] 方法定义 类型表示 Java中的表示 public getDouble()D public double getDouble() public getNum(ILjava/lang/String;Z)Ljava/lang/String; public String getNum(int a,String b,boolean c) .method public getDouble()D .locals 2 .line 45 const-wide/16 v0, 0x0 return-wide v0 .end method 字段定义 类型表示 Java中的表示 .field private num:I private int num .field public text:Ljava/lang/String; public String text .field private tvName:Landroid/widget/TextView; private TextView tvName 可以看到在字段定义的前面会加一个关键字.field,然后修饰符+名称+:+类型. 指定方法寄存器个数 一个方法中需要多少个寄存器是需要指定好的.有2种方式 .registers 指定方法寄存器总数 .locals 表名方法中非参寄存器的总数,一般在方法的第一行 .method public getNum(ILjava/lang/String;Z)Ljava/lang/String; .registers 6 .param p1, \"a\" # I .param p2, \"b\" # Ljava/lang/String; .param p3, \"c\" # Z .prologue .line 40 const/4 v0, 0x2 .line 41 .local v0, \"num\":I const-string v1, \"\" return-object v1 .end method .method public getNum(ILjava/lang/String;Z)Ljava/lang/String; .locals 2 .param p1, \"a\" # I .param p2, \"b\" # Ljava/lang/String; .param p3, \"c\" # Z .line 40 const/4 v0, 0x2 .line 41 .local v0, \"num\":I const-string v1, \"\" return-object v1 .end method 方法传参 方法的形参也会被存储于寄存器中,形参一般被放置于该方法的最后N个寄存器中(eg:形参是2个,那么该方法的最后2个寄存器就是拿来存储形参的). 值得注意的是,非静态方法隐含有一个this参数. 寄存器命名方式 命名方式有2种,v命名法(v0,v1...)和p命名法(p0,p1...) 来看一段smali代码加深一下印象 .method public getNum(ILjava/lang/String;Z)Ljava/lang/String; .locals 2 .param p1, \"a\" # I .param p2, \"b\" # Ljava/lang/String; .param p3, \"c\" # Z .line 40 const/4 v0, 0x2 .line 41 .local v0, \"num\":I const-string v1, \"\" return-object v1 .end method 首先通过.locals 2表明该方法内有2个v寄存器. 然后定义了p1,p2,p3这3个寄存器,其实还有一个p0寄存器,p0表示this(即本身的引用,this指针). 这个方法里面既有v命名的,也有p命名的 只有v命名的寄存器需要在.locals处声明个数,而p命名的不需要 字段定义 标记 含义 static fields 定义静态变量 instance fields 定义实例变量 direct methods 定义静态方法 virtual methods 定义非静态方法 控制条件 语句 含义 if-eq vA, vB, :cond_** 如果vA等于vB则跳转到:cond_** if-nevA, vB, :cond_** 如果vA不等于vB则跳转到:cond_** if-ltvA, vB, :cond_** 如果vA小于vB则跳转到:cond_** if-gevA, vB, :cond_** 如果vA大于等于vB则跳转到:cond_** if-gtvA, vB, :cond_** 如果vA大于vB则跳转到:cond_** if-levA, vB, :cond_** 如果vA小于等于vB则跳转到:cond_** if-eqz vA, :cond_** 如果vA等于0则跳转到:cond_** if-nezvA, :cond_** 如果vA不等于0则跳转到:cond_** if-ltzvA, :cond_** 如果vA小于0则跳转到:cond_** if-gezvA, :cond_** 如果vA大于等于0则跳转到:cond_** if-gtzvA, :cond_** 如果vA大于0则跳转到:cond_** if-lezvA, :cond_** 如果vA小于等于0则跳转到:cond_** Smali插桩（代码注入） 关于smali插桩 smali修改部分省略 smali代码改好之后保存,然后用apktool工具,打包成apk : apktool b apkFileName. 打包完成之后,是不能立即在Android手机上进行安装的,还需要签名.得去下载一个autosign,给这个apk签名,命令是java -jar signapk.jar testkey.x509.pem testkey.pk8 update.apk update_signed.apk. 打包好之后,运行到手机上,完美,toast输出的是Skip ad.插桩成功. 可以下载一个Android逆向助手,里面有autosign工具包. 下载地址如下: 链接:https://pan.baidu.com/s/1NW9PAyuar1dWeUfQBQEftg 密码:8nb7 工具 apktool 官方网站 apktool主要用于逆向apk文件,可以将资源解码,并在修改之后可以重新构建它们.它还可以用来重新构建apk. 功能 将资源解码成近乎原始的形式(包括resources.arsc, classes.dex, 9.png. 和 XMLs) 将解码的资源重新打包成apk/jar 组织和处理依赖于框架资源的APK Smali调试 执行自动化任务 安装教程 使用 逆向apk文件: apktool d xx.apk,逆向之后只能看到代码的smali格式文件,需要学习smali语法才能看懂. 重新打包: apktool b xx,打包出来的是没有签名的apk,需要签名才能安装 dex2jar 一个将dex转换成jar的工具,下载下来之后是一个压缩包,里面有很多工具. 使用方式也比较简单,随便举个例子,命令行进入解压之后的文件夹,将待转成jar的dex(假设为classes.dex,拷贝到当前文件夹)准备好.让这些文件全部有执行权限,chmod +x *(Windows不需要).然后执行./d2j-dex2jar.sh classes.dex即可将dex转成jar(转出来的jar包名字是classes-dex2jar.jar),然后用jd-gui工具即可查看该jar中的class对应的java源码(和原始的源码不太一样哈). 下载地址: https://sourceforge.net/projects/dex2jar/ jd-gui jd-gui是一款反编译软件,可以将查看jar中的class对应的java代码.使用方式: 直接将jar文件拖入jd-gui即可,查看里面的class对应的java代码. jd-gui github : https://github.com/java-decompiler/jd-gui jadx jadx github : https://github.com/skylot/jadx 需要下载jadx的直接到GitHub页面下载最新的Relase包. jadx就更厉害了,直接将apk文件将其拖入.可得到如下信息: 签名的详细信息(类型,版本,主题,签名算法,MD5,SHA-1,SHA-256等等) 所有资源文件(比如layout布局文件都是反编译了的,可以直接查看) 所有class对应的java代码(未加壳的才行),java代码对应的smali代码也能看. so文件 据说,jadx是史上最好用的反编译软件,从使用上来看,确实是这样,操作简单.除了上面提到的功能点外,还有些你可能更喜欢的,比如: 导出Gradle工程 反混淆 代码跳转(Ctrl+鼠标左键) 全局搜索文本 脱壳 软件脱壳，顾名思义，就是对软件加壳的逆操作，把软件上存在的壳去掉。在一些计算机软件里也有一段专门负责保护软件不被非法修改或反编译的程序。它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。 说到脱壳,这里简单介绍几个工具 Xposed 框架 VirtualXposed FDex2 如果手机已经root,则选择Xposed框架+FDex2. 如果手机没有root,则选择VirtualXposed+FDex2. Xposed 框架 首先我们得知道什么是Xposed框架? 维基百科: Xposed框架（Xposed framework）是一套开放源代码的、在Android高权限模式下运行的框架服务，可以在不修改APK文件的情况下修改程序的运行（修改系统），基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。这套框架需要设备解锁了Bootloader方可安装使用（root为解锁Bootloader的充分不必要条件，而xposed安装仅需通过TWRP等第三方Recovery卡刷安装包而不需要设备拥有完整的root权限）。 Xposed框架非常非常牛皮,可以安装各种插件(xposed插件,这里有很多 https://www.xda.im/),比如自动抢红包、防撤回、步数修改等等各种骚操作.就是Xpose框架的安装非常麻烦.安装教程这里就不说了,每个手机可能不太一样.我记得我的手机当时解锁BootLoader,刷机啥的,麻烦. 传统的Xposed框架只支持到Android N,后续的Android版本可以使用EdXposed替代. VirtualXposed 官网: https://vxposed.com/ VirtualXposed也非常牛逼,它看起来提供了一个虚拟的安卓环境,但它其实是一个app.它提供Xposed框架环境,而不需要将手机root,不需要解锁BootLoader,也不需要刷机.Xposed模块提供了超多应用、游戏的辅助,但是苦于Xposed框架安装的麻烦很多用户只能放弃,VirtualXposed最新版让用户可以非常方便地使用各种Xposed模块. FDex2 FDex2是Xposed的一个插件,用来从运行中的app中导出dex文件的工具. 使用:首先安装FDex2这个apk,然后在Xposed框架中勾选这个插件,然后手机重启.进入FDex2,点击需要脱壳的应用,然后FDex2会展示该app脱壳之后的dex输出目录.然后去运行那个需要脱壳的app,就可以获得该app对应的dex.然后导出dex到电脑上,用jadx查看反编译的代码. 当然,FDex2不一定能成功. 开发者助手 这个工具特别厉害,但是大部分功能是需要root权限才能使用的.主要功能如下: 实时查看任何应用数据库和SP 网络请求信息 log输出 当前Activity或者Fragment 界面资源分析(可以查看那个控件是什么做的) apk酷安下载地址: https://www.coolapk.com/apk/com.toshiba_dealin.developerhelper 从应用详情里面看到,开发者助手还有电脑版本,功能也不少 支持了大部分手机版开发者助手的功能 支持截图到电脑 支持全局debug开启 (动态调试用) 支持进程优先级查看 更稳定的当前包名/activity名/fragment名获取 开发者助手电脑版下载链接：https://pan.baidu.com/s/1MFagBWVbR1xNDMakWUlv5g 提取码：l4hv 其他 大概的工具就是上面这些了,勉强够用了.还有些其他的工具我也一并放入下面的下载链接里面了. 链接:https://pan.baidu.com/s/1kuoJ83vob13SM971mIwrmw 密码:lc6p 这里有一个库,里面关于安卓应用的安全和破解讲解的很全面,喜欢的可以去看看. https://github.com/crifan/android_app_security_crack 流程 （2020） 1. 反编译基操 1.1 借鉴code 一般来说,如果只是想借鉴一下友商的code,我们只需要拿到对方的apk,拖到jadx里面就行.jadx能查看apk的xml布局和java代码.jadx有时候会出现部分class反编译失败的情况,这时可以试试Bytecode-Viewer,它也能反编译, 而且还能反编译出jadx不能反编译的class.但是如果apk是已加固了的,那么jadx是不能查看代码的.这时需要脱壳,然后再进行反编译. 1.2 修改执行逻辑 如果是想修改程序的执行逻辑,则需要修改smali代码. 如何拿smali代码? 这时需要用到apktool,使用命令:apktool d xx.apk即可将apk逆向完成,拿到smali代码.这里如果反编译失败了且报错org.jf.dexlib2.dexbacked.DexBackedDexFile$NotADexFile: Not a valid dex magic value: cf 77 4c c7 9b 21 01 cd,则试试apktool d xx.apk -o xx --only-main-classes这条命令. 然后用VS Code打开,这里最好在VS Code里面装一个Smali插件,用于在VS Code里面支持smali语法,高亮之类的.完成之后大概是这个样子: 环境倒是OK了,回到正题,我们需要修改执行逻辑.在此之前,我们最好先简单学习一下smali的基本语法,详情见我之前写过的文章反编译基础知识. 修改好逻辑之后,我们需要将这些代码重新打包成apk,此时需要用到apktool,执行:apktool b xx.执行完成之后,输出的apk会在xx/dist目录下.它打包出来的是没有签名的apk,需要签名才能安装. 签名需要用到autosign这个工具包,使用命令java -jar signapk.jar testkey.x509.pem testkey.pk8 debug.apk debug_signed.apk 2. 加日志 有时候,你可能需要在修改原有执行逻辑之后,在代码里面加点日志,方便查看打出来的包逻辑是否正确.这里我摸索出一个简单的方式打日志,写一个日志打印工具类,然后将这个工具类转成smali文件,然后放入apk反编译出来的smali代码文件夹中, 之后就可以在这个项目的任何smali中使用这个工具类了.下面详细介绍一下: 2.1 写日志打印工具类LogUtil 这个日志打印工具类是为了外界方便调用的,所以需要让外界调用的时候尽量简单.下面是我简单实现的工具类,tag都是我定义好了的,免得外面再定义一次(麻烦). public class LogUtil { public static void logNoTrace(String str) { Log.d(\"xfhy888\", str); } public static void test() { logNoTrace(\"大撒大撒大撒\"); } } 2.2 打印调用栈 上面的工具类目前只能打印普通的日志,但是有时我们想在打印日志的同时输出这个地方的调用栈,此时我们再加个方法扩展一下. public static void log(String str) { Log.d(\"xfhy888\", str); Throwable throwable = new Throwable(); StackTraceElement[] stackElements = throwable.getStackTrace(); StringBuilder stringBuilder = new StringBuilder(); if (stackElements != null) { for (StackTraceElement stackElement : stackElements) { stringBuilder.append(stackElement.getClassName()).append(\" \"); stringBuilder.append(stackElement.getFileName()).append(\" \"); stringBuilder.append(stackElement.getMethodName()).append(\" \"); stringBuilder.append(stackElement.getLineNumber()).append(\"\\n\"); } } Log.d(\"xfhy888\", stringBuilder.toString()); } 在log方法中我们手工构建了一个Throwable,然后通过其getStackTrace方法即可得到调用栈信息,通过Log打印出来.效果如下: 12817-12817/com.xfhy.demo D/xfhy888: com.xfhy.LogUtil LogUtil.java log 10 com.xfhy.startactivitydemo.MainActivity$1 MainActivity.java onClick 45 android.view.View View.java performClick 6724 android.view.View View.java performClickInternal 6682 android.view.View View.java access$3400 797 android.view.View$PerformClick View.java run 26472 android.os.Handler Handler.java handleCallback 873 android.os.Handler Handler.java dispatchMessage 99 android.os.Looper Looper.java loop 233 android.app.ActivityThread ActivityThread.java main 7210 java.lang.reflect.Method Method.java invoke -2 com.android.internal.os.RuntimeInit$MethodAndArgsCaller RuntimeInit.java run 499 com.android.internal.os.ZygoteInit ZygoteInit.java main 956 2.3 将工具类转smali 在Android Studio里面写好这个工具类之后,装一个java2smali插件.然后选中LogUtil文件,再依次点击Build->Compile to Smali,即可将LogUtil.java转成smali.下面是我转好的 .class public Lcom/xfhy/LogUtil; .super Ljava/lang/Object; .source \"LogUtil.java\" # direct methods .method public constructor ()V .registers 1 .prologue .line 5 invoke-direct {p0}, Ljava/lang/Object;->()V return-void .end method .method public static log(Ljava/lang/String;)V .registers 9 .param p0, \"str\" # Ljava/lang/String; .prologue .line 8 const-string v4, \"xfhy888\" invoke-static {v4, p0}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I .line 10 new-instance v3, Ljava/lang/Throwable; invoke-direct {v3}, Ljava/lang/Throwable;->()V .line 11 .local v3, \"throwable\":Ljava/lang/Throwable; invoke-virtual {v3}, Ljava/lang/Throwable;->getStackTrace()[Ljava/lang/StackTraceElement; move-result-object v1 .line 12 .local v1, \"stackElements\":[Ljava/lang/StackTraceElement; new-instance v2, Ljava/lang/StringBuilder; invoke-direct {v2}, Ljava/lang/StringBuilder;->()V .line 13 .local v2, \"stringBuilder\":Ljava/lang/StringBuilder; if-eqz v1, :cond_52 .line 14 array-length v5, v1 const/4 v4, 0x0 :goto_17 if-ge v4, v5, :cond_52 aget-object v0, v1, v4 .line 15 .local v0, \"stackElement\":Ljava/lang/StackTraceElement; invoke-virtual {v0}, Ljava/lang/StackTraceElement;->getClassName()Ljava/lang/String; move-result-object v6 invoke-virtual {v2, v6}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder; move-result-object v6 const-string v7, \" \" invoke-virtual {v6, v7}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder; .line 16 invoke-virtual {v0}, Ljava/lang/StackTraceElement;->getFileName()Ljava/lang/String; move-result-object v6 invoke-virtual {v2, v6}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder; move-result-object v6 const-string v7, \" \" invoke-virtual {v6, v7}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder; .line 17 invoke-virtual {v0}, Ljava/lang/StackTraceElement;->getMethodName()Ljava/lang/String; move-result-object v6 invoke-virtual {v2, v6}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder; move-result-object v6 const-string v7, \" \" invoke-virtual {v6, v7}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder; .line 18 invoke-virtual {v0}, Ljava/lang/StackTraceElement;->getLineNumber()I move-result v6 invoke-virtual {v2, v6}, Ljava/lang/StringBuilder;->append(I)Ljava/lang/StringBuilder; move-result-object v6 const-string v7, \"\\n\" invoke-virtual {v6, v7}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder; .line 14 add-int/lit8 v4, v4, 0x1 goto :goto_17 .line 21 .end local v0 # \"stackElement\":Ljava/lang/StackTraceElement; :cond_52 const-string v4, \"xfhy888\" invoke-virtual {v2}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String; move-result-object v5 invoke-static {v4, v5}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I .line 22 return-void .end method .method public static logNoTrace(Ljava/lang/String;)V .registers 2 .param p0, \"str\" # Ljava/lang/String; .prologue .line 25 const-string v0, \"xfhy888\" invoke-static {v0, p0}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I .line 26 return-void .end method 有了编译好的smali文件,还需要放到反编译项目的对应包名里面,我这里的是com/xfhy/,那我就得放到这个目录下. 2.4 使用工具类 这里我随便写个方法测试一下,java代码如下: public void test() { for (int i = 0; i 它所对应的smali代码如下: .method public test()V .registers 3 .prologue .line 29 const/4 v0, 0x0 .local v0, \"i\":I :goto_1 const/16 v1, 0xa if-ge v0, v1, :cond_d .line 30 sget-object v1, Ljava/lang/System;->out:Ljava/io/PrintStream; invoke-virtual {v1, v0}, Ljava/io/PrintStream;->println(I)V .line 29 add-int/lit8 v0, v0, 0x1 goto :goto_1 .line 32 :cond_d return-void .end method 我在方法的一开始就打印一句日志,首先加registers个数+1,因为需要新定义一个变量来存字符串,然后再调用LogUtil的静态方法打印这个字符串. .method public test()V .registers 4 const-string v2, \"test method\" invoke-static {v2}, Lcom/xfhy/LogUtil;->log(Ljava/lang/String;)V .prologue .line 29 const/4 v0, 0x0 .local v0, \"i\":I :goto_1 const/16 v1, 0xa if-ge v0, v1, :cond_d .line 30 sget-object v1, Ljava/lang/System;->out:Ljava/io/PrintStream; invoke-virtual {v1, v0}, Ljava/io/PrintStream;->println(I)V .line 29 add-int/lit8 v0, v0, 0x1 goto :goto_1 .line 32 :cond_d return-void .end method 3. 调试smali 我们不能直接调试反编译拿到的java代码,而是只能调试反编译拿到的smali代码.当然,调试的时候,需要懂一些smali的基本语法,这样的话,基本能看懂程序在干嘛. 3.1 让App可以调试 首先是让App可以调试 可以修改AndroidManifest.xml中的debuggable改为true(具体操作:先用apktool反编译,再修改AndroidManifest,再打包签名,运行到手机上); 也可以使用XDebug 让所有进程处于可以被调试的状态; 3.2 如何调试? 首先是在Android Studio里装一个smalidea的插件,我上面分享的网盘地址里面有.我试了下,smalidea是不支持最新版的Android Studio的.我去查了下,smalidea最后一个版本是0.05, 最后更新时间是2017-03-31。确实有点老了,我看18年年末的时候有人在博客中提到了这个插件,于是我想了下,同时期的Android Studio肯定可以用这个插件. 在Android Studio官网一顿乱串之后发现, 官网提供了历史版本的下载地址. 最后下载了一个2018年10月11日的Android 3.2.1,装上插件试了下->可行->完美. 把apktool反编译好的文件夹导入Android Studio,把所有smali开头的文件夹都标记一下Sources Root(标记方法: 文件夹右键,Mark Directory as -> Sources Root).然后找到你需要调试的类,打好断点. 打开需要调试的App,然后打开Android Device Monitor(在SDK\\tools里面).打开Monitor的时候需要关闭Android Studio. 查看该App对应的端口是多少,记录下来.重新打开Android Studio,编辑Edit Configurations,点击Add New Configuration,添加之后再修改一下端口号就行,这里的端口号填上面Monitor看到的那个端口号. Configuration添加好之后,点击Debug按钮即可进行调试. 熟悉的界面,熟悉的调试方式,开始愉快的调试吧,起飞~ No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/名词解释.html":{"url":"04_Android/应用层/名词解释.html","title":"名词解释","keywords":"","body":"ATV：AndroidTV AOSP：Android Open Source Project NDK: Android's Native Development Kit GMS：Google Mobile Services Google应用程序和API的集合 https://zhuanlan.zhihu.com/p/66478028 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/框架/":{"url":"04_Android/应用层/框架/","title":"应用架构","keywords":"","body":"No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/框架/appcompact.html":{"url":"04_Android/应用层/框架/appcompact.html","title":"appcompact","keywords":"","body":"什么是 AppCompat？ AppCompat 是 AndroidX 支持库 的一部分，它提供了对较旧 Android 系统（通常是 API 21+）的兼容性支持，同时允许开发者在旧设备上使用现代的 Android 功能和 Material Design 设计规范。 AppCompat 的核心目标是： 向后兼容性：帮助开发者在旧版本的 Android 系统上实现新特性。 一致性体验：确保不同 Android 系统版本上的应用外观和行为保持一致。 简化开发：为开发者提供一个统一的工具集，减少开发复杂度。 AppCompat 的关键功能 向后兼容现代组件 AppCompat 提供了一些现代化的 UI 组件和 API，即使在旧版 Android 系统上也能正常运行。例如： Toolbar：取代旧版的 ActionBar，支持更灵活的布局。 Vector Drawable：支持在 API 21 以下的系统中使用矢量图形。 Material Design：即便设备运行旧系统，AppCompat 也能实现 Material Design 风格的 UI。 主题支持 AppCompat 提供了一组 Material Design 主题，如 Theme.AppCompat，可以在旧系统中使用现代设计语言，同时支持动态样式切换（如深色模式）。 API 的改进 提供了对某些 API 的改进封装，使得开发者在编写代码时无需考虑设备的 API 版本差异。例如： 使用 AppCompatActivity 替代 Activity，以便在旧设备上也能使用 Lifecycle 和 ViewModel 等功能。 统一外观 在不同的 Android 设备和系统版本上，通过 AppCompat 可以保持应用的外观一致，避免因系统版本差异导致的视觉效果不统一。 AppCompat 的主要组件 AppCompatActivity AppCompat 提供的基础 Activity，支持现代 Android 功能（如 Fragment、Lifecycle）并确保兼容性。 用法： kotlin复制代码class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } } Toolbar 替代原来的 ActionBar，提供了更灵活和可定制的标题栏。 用法： xml复制代码 Material Components 使用 AppCompat，可以轻松引入 Material Design 风格的组件（如按钮、对话框、输入框）。 例如： xml复制代码 Vector Drawable 使用矢量图形替代传统的位图图像，减少 APK 体积。 AppCompat 在低于 API 21 的设备上也支持矢量图形。 AppCompat 主题示例 AppCompat 提供的主题以 Theme.AppCompat 开头，常用主题包括： Theme.AppCompat.Light 亮色主题。 Theme.AppCompat.Dark 暗色主题。 Theme.AppCompat.DayNight 自动切换亮暗模式（基于系统设置）。 示例代码： xml复制代码 #6200EE #3700B3 #03DAC5 AppCompat 的应用场景 向后兼容性要求高的项目 如果你的应用需要支持较旧版本的 Android 系统（如 API 21 或更低），AppCompat 是必备的工具。 需要一致的设计风格 通过 AppCompat，可以在所有设备上实现一致的 Material Design 外观。 减少重复工作 AppCompat 封装了许多兼容性处理的逻辑，开发者无需针对不同 Android 版本单独实现逻辑。 AppCompat 的局限性 增加应用体积 引入 AppCompat 会增加 APK 的大小，尤其是在轻量化项目中可能不适用。 性能开销 在老旧设备上，使用 AppCompat 的部分功能可能带来性能开销。 逐渐被 Jetpack 组件取代 随着 Android Jetpack 的发展，许多新的库和组件提供了更现代化的替代方案。 总结 AppCompat 是一个强大的工具，帮助开发者解决 Android 系统碎片化带来的兼容性问题。通过使用 AppCompat，开发者可以在旧版设备上实现现代化的功能和设计。然而，随着 Jetpack 和更现代化组件（如 Jetpack Compose）的普及，AppCompat 的重要性可能逐渐减少，但对于需要支持老设备的项目来说，它仍然是不可或缺的选择。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/框架/jetpack.html":{"url":"04_Android/应用层/框架/jetpack.html","title":"jetpack","keywords":"","body":"Jetpack 是一个由 Google 开发并维护的 Android 开发组件库，用于简化应用开发过程并提供现代化的功能。Jetpack 提供了一套高度模块化、可组合的库，可以帮助开发者遵循最佳实践，同时提升应用的性能、兼容性和开发效率。 Jetpack 的主要特点 模块化设计 Jetpack 的组件是独立的，开发者可以根据项目需求选择使用特定的库，而不需要引入整个框架。 向后兼容性 Jetpack 的库与不同版本的 Android 系统兼容，开发者无需担心因系统版本差异导致功能不可用。 简化开发 Jetpack 提供了许多工具和 API，帮助开发者简化常见的开发任务，例如数据绑定、生命周期管理和导航等。 最佳实践 Jetpack 组件基于 Google 推荐的最佳实践设计，帮助开发者构建高质量的应用程序。 Jetpack 的主要组件 Jetpack 组件按功能划分为以下 4 大类： 1. Architecture（架构） 用于帮助开发者实现干净、模块化和可维护的代码。 关键库 ： ViewModel：管理 UI 数据，支持屏幕旋转等生命周期变化。 LiveData：可感知生命周期的数据容器，用于实现数据驱动的 UI。 Room：本地数据库解决方案，支持类型安全的数据库访问。 WorkManager：管理异步任务并保证任务可靠执行。 2. UI 提供了现代化的工具和组件，用于构建易于使用的用户界面。 关键库 ： Compose：现代化的声明式 UI 框架，替代传统的 XML 布局。 Navigation：简化应用内导航。 ConstraintLayout：高性能的 UI 布局工具。 3. Behavior（行为） 提供了可扩展的功能库来提升应用的用户体验。 关键库 ： Media & Playback：处理多媒体播放。 Notifications：处理通知。 Permission：简化权限管理。 4. Foundation（基础功能） 提供 Android 应用开发所需的基本功能。 关键库 ： AppCompat：兼容旧版 Android 系统的支持库。 Core：提供核心的 Android 功能。 Test：支持单元测试和 UI 测试。 Jetpack 的优势 提升开发效率：通过标准化和简化开发任务，开发者可以专注于业务逻辑。 减少错误：Jetpack 提供了许多工具来减少常见的开发错误，例如生命周期管理和线程安全。 支持现代化技术：例如 Jetpack Compose，帮助开发者使用更现代的工具构建应用。 典型使用场景 管理 UI 的生命周期：使用 ViewModel 和 LiveData 确保数据在屏幕旋转或后台切换时不丢失。 本地数据存储：使用 Room 数据库存储应用数据。 异步任务管理：通过 WorkManager 运行后台任务。 声明式 UI 构建：使用 Jetpack Compose 创建高性能的动态用户界面。 Jetpack 和 AndroidX 的关系 Jetpack 是一个更高层次的概念，而 AndroidX 是其技术实现的一部分。 Jetpack 是开发工具和库的集合，帮助开发者更高效地构建应用。 AndroidX 是支持库的更新版本，包含 Jetpack 的实现。 如果你正在开发 Android 应用，Jetpack 是不可或缺的工具，可以大幅提升你的开发体验和代码质量！ No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/":{"url":"04_Android/应用层/工程/","title":"1.工程-androidstudio","keywords":"","body":"工程 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/ADB-命令.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/ADB-命令.html","title":"Adb-命令","keywords":"","body":"pm 【清空缓存】 adb shell pm clear 【完全删除某一系统应用】 adb root adb shell pm uninstall -k --user 0 【查询应用安装路径】 adb shell pm path 【查看所有已安装的app包名】 adb shell pm list packages 【查看自己安装的app包名】 adb shell pm list packages -3 am 【强制停止】 adb shell am force-stop dumpsys 【查看版本号】 adb shell dumpsys package | grep \"version\" 【查看Activities信息】 adb shell dumpsys activity activities logcat 【输出日志】 adb logcat -s com.sony.dtv.searchapp > 1.txt adb logcat -time > screencap 【截屏】 adb shell screencap -p /sdcard/screenshot.png adb pull /sdcard/screenshot.png mount/remount 【更改系统文件权限】 adb shell mount -rw -o remount / adb shell mount -o rw,remount / adb remount 【remount】 adb remount将 /system部分置于可写入的模式，默认情况下 /system 部分是只读模式的。这个命令只适用于已被 root 的设备。 在将文件 push 到 /system 文件夹之前，必须先输入命令 adb remount。 adb remount 的作用相当于 adb shell mount -o rw,remount,rw /system。 adb remount 其他 【根据包名查找应用路径/查看应用大小】 进入adb shell 之后 拿path adb shell dumpsys package | grep path 输出： ... path: /data/app/~~TEGS7xtZ4eH-bLK3sKfKwA==/com.sony.dtv.searchapp-xqyu1EsYldLgqQNvokbJ1A==/base.apk du -h 粘贴path adb shell du -h /data/app/~~TEGS7xtZ4eH-bLK3sKfKwA==/com.sony.dtv.searchapp-xqyu1EsYldLgqQNvokbJ1A==/base.apk 输出： 98M /data/app/~~TEGS7xtZ4eH-bLK3sKfKwA==/com.sony.dtv.searchapp-xqyu1EsYldLgqQNvokbJ1A==/base.apk 【查看前5进程cpu占用%】 adb shell top -m 5 -d 1 【查看设备Android版本】 adb shell getprop ro.build.version.sdk 【注入按键】 adb shell input keyevent 219(219是语音键) 【查看设备的cpu架构】 adb shell getprop ro.product.cpu.abi 【查看platform版本号】 adb shell getprop ro.build.version.release 【查看api版本号】 adb shell getprop ro.build.version.sdk 【获取设备名称】 adb root adb shell cat /system/build.prop 【全局查找文件】 https://blog.csdn.net/chouzhou9701/article/details/119395831 > adb shell # cd data/local/tmp # ./busybox find 目录 -name \"文件名\" # ./busybox find / -name \"*.txt\" 【查看KernelLog】 adb shell dmesg 【查看当前窗口属于的应用】 adb shell dumpsys window | grep mCurrentFocus adb shell dumpsys activity activities | grep \"mResumedActivity\" 【查看？】 adb shell dumpsys activity > 1.txt 【监控广播发送】 adb logcat -v time | grep -i \"broadcast\" No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/AndroidStudio-快捷键.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/AndroidStudio-快捷键.html","title":"Androidstudio-快捷键","keywords":"","body":"快捷键 （Eclipse） 快捷键 用途 Ctrl+Alt+(空格) 提示化代码 Alt+F 格式化代码 Ctrl+Q 显示文档说明 Ctrl+Shift+F 全局搜索字符 Ctrl+F 查找 Ctrl+Alt+C 抽取字符串为常量 Ctrl+Alt+M 提取方法 Ctrl+Alt+F 提取全局变量 Alt+J Json格式化工具（自定义） Ctrl+Shift+X/Y 转换选中文本为小写或大写，适用于变量名或字符串的统一管理。 Logcat的使用 https://developer.android.com/studio/debug/logcat?hl=zh-cn No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/AndroidStudio-插件.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/AndroidStudio-插件.html","title":"Androidstudio-插件","keywords":"","body":"自动生成UML PlantUML Integration 可以使用.pu语言生成UML文件，语言需要自己编写 入门参考：https://blog.csdn.net/vitaviva/article/details/120639074 PlantUML Parser 可以将Java文件（可以多选）转换成.puml文件，需要使用markdown插件或者PlantUML Integration才能查看 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/AndroidStudio-问题解决.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/AndroidStudio-问题解决.html","title":"Androidstudio-问题解决","keywords":"","body":"没有配置ndk的项目找不到ndk路径 This is a Gradle bug that is documented here: https://code.google.com/p/android/issues/detail?id=228424 The problem is that Gradle is computing the location of an NDK folder by just tacking on the string \"/ndk-bundle\" to the SDK folder location, even if you have never installed the NDK. After establishing this false expectation of an NDK folder existing in a particular location, each time you build, Gradle gives you a warning that you're \"missing\" that folder. The solution was the following: 1. Open project in Android Studio 2. Wait for sync to finish 3. Click on File -> Project structure -> SDK Location 4. At Android NDK Location, if you don't have any NDK, install one 5. Select an existing NDK location. That should fix it. Entry name 'assets/agent_channel.ini' collided 更改apk生成的路径，举个栗子，Android studio 打包默认路径是这样的： 等待你的就是Entry name 'res/layout/test_toolbar.xml' collided 解决办法，更改生成apk的路径，如 Entry name *.xml collided 解决 https://blog.csdn.net/luo_boke/article/details/106113266 总结：更改打包生成路径 Current JDK version 1.8.0_341-b10 has a bug (https://bugs.openjdk.java.net/browse/JDK-8007720) that prevents Room from being incremental. https://stackoverflow.com/questions/58822538/current-jdk-version-1-8-has-a-bug-that-prevents-room-from-being-incremental The specified Gradle installation directory does not exist error... https://stackoverflow.com/questions/71452170/the-specified-gradle-installation-directory-does-not-exist-error-after-android-s 选择'gradle-wrapper.properties' file output中文乱码问题 https://blog.csdn.net/jankingmeaning/article/details/104772104 自定义Todo https://www.cnblogs.com/bellkosmos/p/AndroidStudio_custom_TODO.html#:~:text=AndroidStudio%E8%87%AA%E5%AE%9A%E4%B9%89TODO%20-%20%E8%B5%9B%E8%89%87%E9%98%9F%E9%95%BF%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD%201.%E5%A2%9E%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89TODO%E6%A0%87%E8%AE%B0%20Preferences,-%3E%20Editor%20-%3E%20TODO%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%8A%A0%E5%8F%B7%EF%BC%8C%E8%BE%93%E5%85%A5%E6%83%B3%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84TODO%E7%9A%84%E6%AD%A3%E5%88%99%20%E8%BE%93%E5%85%A5%20bXb.%2A%20%EF%BC%88X%E4%B8%BATODO%E6%A0%87%E7%AD%BE%E7%9A%84%E5%90%8D%E5%AD%97%EF%BC%89%EF%BC%8C%E8%BF%99%E9%87%8C%E4%BB%A5to_complete%E4%B8%BA%E4%BE%8B%EF%BC%8C%E8%BE%93%E5%85%A5%20bto_completeb.%2A Cmd下启动使用模拟器 cmd下启动使用模拟器 先运行一次程序才能找到R文件 修改工程名称及修改包名 https://blog.csdn.net/u012693479/article/details/107233954 查找库 File > Project Structure 然后就可以搜索了 将本机文件导入到手机 打开模块设置 Gradle SDK Java AndroidStudio的历史版本查看下载 https://www.jianshu.com/p/f7eca878b8d7 Rebuild Project命令包含Clean Project命令 查看apk签名 进入SDK/build_tools//目录下使用apksigner apksigner verify -v No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/AndroidStudio-项目文件与目录.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/AndroidStudio-项目文件与目录.html","title":"Androidstudio-项目文件与目录","keywords":"","body":"一、总项目的目录结构 目录名/文件名 作用 .idea/.build 自动生成的文件 app 项目的代码文件和资源文件 build 编译时自动生成的文件 gradle 构建项目的gradle。 .gitignore 将指定的文件排除在版本控制之外 build.gradle(proj) 项目全局的gradle构建脚本 gradle.properties 全局的gradle配置文件，这里配置的属性能影响到项目所有的gradle编译脚本 gradlew/gradlew.bat 用于在命令行界面下执行gradle命令，gradlew在linux和mac中执行，gradlew.bat则在windows下执行 local.properties 本机中AndroidSDK的路径，一般自动生成，除非发生变化，则要修改 XXX.iml 表示该项目是IntelliJIDEA项目 setting.gradle 用于指定项目中所有引入的模块。一般可自动生成，也可自行设置，比如引入flutter模块时，可在此文件上设置该模块路径等 注意：而gradle文件里面包含gradlewrapper配置文件，使用gradle wrapper方式会自动联网下载gradle,，当然AndroidStudio会首先检查本地是否有缓存gradle，没有就会自动联网下载gradle，这样就不用自己先下载gradle，当然如果要使用离线模式，也可以自己setting：File---Settings---Build,Execution,Deployment---Gradle 二、app目录下的结构 目录名/文件名 作用 libs 放置jar包 release 该目录并不是非得有，也可以在外面项目层路径下，它是存放你打包后的apk文件，你在打包的时候是可以设置它的路径的 src/androidTest 编写Android Test测试用例，进行自动化测试用的。 src/test 用来编写Unit Test测试，也是进行自动化测试用的 main/java 存放所有你的项目源代码 main/res 存放资源文件 main/res/layout 存放布局文件 main/res/values 存放字符串文件 main/res/mipmap 存放图标 main/res/drawable 存放图片 AndroidManifest.xml 注册四大组件、添加应用权限 .gitignore 将app中的文件和目录排除在版本控制之外 app.iml IntelliJIDEA自动生成的文件 build.gradle(app) app模块的gradle构建脚本，指定项目构建相关的配置 proguard-rules.pro 混淆文件，指定项目代码的混淆规则，为了防止apk文件被别人破解时采取混淆代码 三、build.gradle(proj)和build.gradle(app) (1)build.gradle(proj) 代码如图所示： //构建描述 buildscript { //添加依赖库 respsitories { //google官方依赖库 google() //第三方开源库 jcenter() } dependencies { //gradle插件，因为Gradle插件不仅仅为构建Android项目服务的，它还可以构建java项目和C++项目的，所以要声明Gradle插件是构建Android项目的，版本号跟Android Studio的版本号一致 classpath 'com.android.tools.build:gradle:3.5.2' } } //同上 allprojects { respositories { google() jcenter() } } (2)build.gradle(app) //应用程序模块，可以直接运行 apply plugin:'com.android.application' //库模块，需要依附于应用程序模块 apply plugin:'com.android.library' //android闭包 android { //指定项目的编译版本 compileSdkVersion 30 //指定构建项目工具的版本 buildToolsVersion \"30.0.2\" defaultConfig { //指定项目的包名，具有唯一性，是项目的唯一标识 applicationId \"com.example.myapplication\" //最低兼容的Android系统版本 minSdkVersion 19 //指定目前使用到最高的Android系统版本 targetSdkVersion 30 //项目版本号 versionCode 1 //项目版本名 versionName \"1.0\" testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\" multiDexEnabled true } //项目生成安装文件的相关配置，release和debug都可以指定 buildTypes { release { //是否使用混淆 minifyEnabled false //设置使用的混淆文件，凡是在Android Studio运行生成的都是测试版安装文件。正式版需Build—Generate Signed Bundle/Apk里产生。 proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'),'proguard-rules.pro' } } } //指定了项目所有的依赖关系：本地依赖、库依赖、远程依赖 dependencies { implementation fileTree(dir:'libs',include:['*.jar']) implementation 'androidx.appcompat:appcompat:1.0.2' implementation 'androidx.constraintlayout:constraintlayout:1.1.3' testImplementation 'junit:junit:4.12' androidResr } 库类型 使用 本地依赖 对本地的jar包和目录添加依赖关系，implementationfileTree声明，将libs中的.jar文件都添加到构建目录中 远程依赖 对jcenter仓库的上的开源项目添加依赖关系，也就是平时我们在github上添加的第三方开源库，也是直接implementation，先检查本地是否有缓存，没有就直接联网下载到构建路径 库依赖 对项目中的库模块进行依赖，implementation project声明，通常格式为implementation project(‘:库名’) No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/AndroidStudio与IntelliJIDEA.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/AndroidStudio与IntelliJIDEA.html","title":"Androidstudio与intellijidea","keywords":"","body":"来源： https://pcedu.pconline.com.cn/1021/10217235.html IntelliJIDEA是JetBrains公司推出的Java集成开发环境，分为免费社区版与收费旗舰版。 社区版只支持JavaSE，Android，Groovy，Scale，收费版还支持JavaEE的开发。 Android studio 是基于IDEA Commutity Edition开发的，因为Community 版本不仅是免费的而且是开源的，可以看出之前刚推出的studio1.0正式版是基于idea13开发的，而不是最新的idea14。 两者之间的利弊： 虽然Android Studio是基于IDEA开发的，但studio是一个纯粹的Android开发环境，并不支持诸如Groovy,scale虽然IDEA社区版支持，但google已把它们剔除了，所以可能Studio支持的开发更少，貌似属于弊的范畴吧(可我觉得这是优点，Android Studio就只做Android)。 再者，虽然IDEA社区版也原生支持Android开发，但对于Android开发的支持上定不如Studio来的彻底，再加上经过Google两年的开发studio已经进入了1.0的正式版时代，所以如果你做Android开发选studio就对了。 (在Studio转正之前idea应该是做Android开发的一个不错的选择，但现在不是了)。 最后总结一句，如果你是Android开发者就选择studio吧，这是最佳选择，而如果你不是那就选择idea吧。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/Android中的混淆.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/Android中的混淆.html","title":"Android中的混淆","keywords":"","body":"refs:：https://blog.csdn.net/weixin_42602900/article/details/127671586 混淆的机制： 代码压缩（Shrinking）：删除未被引用的类、字段、方法和属性，减少 APK 文件大小。 优化（Optimization）：对字节码进行优化，以减少运行时的开销。 混淆（Obfuscation）：重命名类、方法和字段名称为无意义的名称，增加反编译的难度。 主要作用： 提高安全性：通过混淆代码，可以减少因反编译而泄露代码逻辑和关键信息的风险。 减小 APK 大小：通过代码压缩，可以减少未被使用的代码和资源，从而减小应用程序的体积。 优化执行速度：通过优化字节码，可以提高应用程序的执行速度。 混淆的配置： 要在 Android 项目中使用混淆，通常需要在 build.gradle 文件中进行配置。以下是一个基本的混淆配置示例： groovyCopy codeandroid { ... buildTypes { release { minifyEnabled true //开启混淆 zipAlignEnabled true //压缩优化 shrinkResources true //移除无用资源 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' //默认的混淆文件以及我们指定的混淆文件 } } } 在上述配置中： minifyEnabled true：启用代码压缩和混淆。 proguardFiles：指定 ProGuard 配置文件。'proguard-android-optimize.txt' 是一个 Android 提供的默认配置文件，而 'proguard-rules.pro' 是自定义的 ProGuard 配置文件，用于指定特定的混淆规则。 混淆规则（proguard-rules.pro）： 在 proguard-rules.pro 文件中，您可以自定义混淆规则，如下所示： proCopy code# 保留特定的类或方法不被混淆 -keep class com.example.MyClass { *; } # 保留特定的类中的方法不被混淆 -keepclassmembers class com.example.MyClass { public (...); public void myMethod(...); } # 保留特定的类或方法不被删除 -keep class com.example.MyClass -keepclassmembers class com.example.MyClass { *; } 编写语法： -keep 防止类和成员被移除或者被重命名 -keepnames 防止类和成员被重命名 -keepclassmembers 防止成员被移除或者被重命名 -keepclasseswithmembers 防止拥有该成员的类和成员被移除或者被重命名 -keepclasseswithmembernames 防止拥有该成员的类和成员被重命名 注意事项： 保留入口点（Main Entry Points）：确保应用程序的主要入口点（如 Activity、Service、BroadcastReceiver 和 ContentProvider）不被混淆。 避免不必要的混淆：避免对与 Android 框架相关的类进行混淆，以免影响应用程序的正常运行。 调试：在进行混淆后，建议在真实设备上进行充分的测试，以确保应用程序的功能和性能没有受到影响。 通过合理配置和使用混淆，可以有效提高 Android 应用程序的安全性和性能。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/Android热修复.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/Android热修复.html","title":"Android热修复","keywords":"","body":"安卓热修复技术是一种用于修复已部署的安卓应用程序中的bug、漏洞或其他问题的技术。热修复技术旨在允许应用程序开发者在不需要重新发布整个应用程序的情况下，快速地修复问题并向用户提供修复后的版本。这种技术通常用于以下情况： 快速响应安全漏洞：当发现应用程序中的安全漏洞时，开发者可以使用热修复技术快速修复问题，而无需等待用户手动更新应用程序。 修复功能性问题：开发者可以使用热修复技术来修复应用程序中的功能性问题，例如崩溃、错误或不正常的行为。 优化性能：热修复还可以用于优化应用程序性能或改进用户体验，而无需等待全新版本发布。 热修复技术的实现方式可以多种多样，但通常包括以下几个步骤： 生成修复补丁：开发者识别出应用程序中的问题，并创建修复补丁，这是一个包含问题修复代码的小型文件。 传递修复补丁：修复补丁通常以增量方式传递给用户设备。这可以通过应用程序的后台服务、推送通知或其他通信渠道实现。 应用修复补丁：用户的设备接收到修复补丁后，应用程序会将其应用于现有安装的应用程序，以修复问题。这通常需要一些时间，但不需要用户手动干预。 尽管热修复技术可以帮助开发者更快速地修复问题，但也存在一些潜在的风险和挑战。例如，修复补丁的传递和应用可能会引入新的问题，因此需要谨慎测试。此外，热修复技术可能会引发一些安全和隐私问题，因此开发者需要采取适当的安全措施来保护用户数据和应用程序的完整性。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/Android项目构建流程.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/Android项目构建流程.html","title":"Android项目构建流程","keywords":"","body":" 整体流程： 首先aapt工具会将资源文件进行转化，生成对应资源ID的R文件和资源文件。 aidl工具会将其中的aidl接口转化成Java的接口 至此，Java Compiler开始进行Java文件向class文件的转化，将R文件，Java源代码，由aidl转化来的Java接口，统一转化成.class文件。 通过dx工具将class文件转化为dex文件。 此时我们得到了经过处理后的资源文件和一个dex文件，当然，还会存在一些其它的资源文件，这个时候，就是将其打包成一个类似apk的文件。但还并不是直接可以安装在Android系统上的APK文件。 通过签名工具对其进行签名。 通过Zipalign进行优化，提升运行速度（原理后文会提及）。 最终，一个可以安装在我们手机上的APK了。 第1步：aapt打包资源文件，生成R.java和编译后的资源（二进制文件） 讲到资源文件的处理，我们先来看一下Android中的资源文件有那些呢?Android应用程序资源可以分为两大类，分别是assets和res： assets类资源放在工程根目录的assets子目录下，它里面保存的是一些原始的文件，可以以任何方式来进行组织。这些文件最终会被原装不动地打包在apk文件中。如果我们要在程序中访问这些文件，那么就需要指定文件名来访问。例如，假设在assets目录下有一个名称为filename的文件，那么就可以使用以下代码来访问它： AssetManager am = getAssets(); InputStream is = assset.open(\"filename\"); res类资源放在工程根目录的res子目录下，它里面保存的文件大多数都会被编译，并且都会被赋予资源ID。这样我们就可以在程序中通过ID来访问res类的资源。res类资源按照不同的用途可以进一步划分为以下10种子类型：layout(布局文件)，drawable，xml，value，menu，raw，color，anim，animator，mipmap。 为了使得一个应用程序能够在运行时同时支持不同的大小和密度的屏幕，以及支持国际化，即支持不同的国家地区和语言，Android应用程序资源的组织方式有18个维度，每一个维度都代表一个配置信息，从而可以使得应用程序能够根据设备的当前配置信息来找到最匹配的资源来展现在UI上，从而提高用户体验。由于Android应用程序资源的组织方式可以达到18个维度，因此就要求Android资源管理框架能够快速定位最匹配设备当前配置信息的资源来展现在UI上，否则的话，就会影响用户体验。为了支持Android资源管理框架快速定位最匹配资源，Android资源打包工具aapt在编译和打包资源的过程中，会执行以下两个额外的操作： 赋予每一个非assets资源一个ID值，这些ID值以常量的形式定义在一个R.java文件中。 生成一个resources.arsc文件，用来描述那些具有ID值的资源的配置信息，它的内容就相当于是一个资源索引表。包含了所有的id值的数据集合。在该文件中，如果某个id对应的是string，那么该文件会直接包含该值，如果id对应的资源是某个layout或者drawable资源，那么该文件会存入对应资源的路径。 为什么要转化为二进制文件？ 二进制格式的XML文件占用空间更小。这是由于所有XML元素的标签、属性名称、属性值和内容所涉及到的字符串都会被统一收集到一个字符串资源池中去，并且会去重。有了这个字符串资源池，原来使用字符串的地方就会被替换成一个索引到字符串资源池的整数值，从而可以减少文件的大小。 二进制格式的XML文件解析速度更快。这是由于二进制格式的XML元素里面不再包含有字符串值，因此就避免了进行字符串解析，从而提高速度。 有了资源ID以及资源索引表之后，Android资源管理框架就可以迅速将根据设备当前配置信息来定位最匹配的资源了。 第2步：aidl aidl，全名Android Interface Definition Language，即Android接口定义语言。是我们在编写进程间通信的代码的时候，定义的接口。 输入：aidl后缀的文件。输出：可用于进程通信的C/S端java代码，位于build/generated/source/aidl。 第3步：Java源码编译 我们有了R.java和aidl生成的Java文件，再加上工程的源代码，现在可以使用javac进行正常的java编译生成class文件了。 输入：java source的文件夹（另外还包括了build/generated下的：R.java, aidl生成的java文件，以及BuildConfig.java）。输出：对于gradle编译，可以在build/intermediates/classes里，看到输出的class文件。 第4步：代码混淆（proguard） 源码编译之后，我们可能还会对其进行代码的混淆，混淆的作用是增加反编译的难度，同时也将一些代码的命名进行了缩短，减少代码占用的空间。混淆完成之后，会生成一个混淆前后的映射表，这个是用来在反应我们的应用执行的时候的一些堆栈信息，可以将混淆后的信息转化为我们混淆前实际代码中的内容。 而这个过程使用的工具就是ProGuard，是一个开源的Java代码混淆器（obfuscation）。ADT r8开始它被默认集成到了Android SDK中。 其具备三个主要功能。 压缩 - 移除无效的类、属性、方法等 优化 - 优化bytecode移除没用的结构 混淆 - 把类名、属性名、方法名替换为晦涩难懂的1到2个字母的名字 当然它也只能混淆Java代码，Android工程中Native代码，资源文件（图片、xml），它是无法混淆的。而且对于Java的常量值也是无法混淆的，所以不要使用常量定义平文的密码等重要信息。同时对于混淆，我们可以通过代码制定去混淆那些，不去混淆那些。 -keep public class com.rensanning.example.Test 第5步：转化为dex 调用dx.bat将所有的class文件转化为classes.dex文件，dx会将class转换为Dalvik字节码，生成常量池，消除冗余数据等。由于dalvik是一种针对嵌入式设备而特殊设计的java虚拟机，所以dex文件与标准的class文件在结构设计上有着本质的区别,当java程序编译成class后，使用dx工具将所有的class文件整合到一个dex文件，目的是其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加经凑，实验表明，dex文件是传统jar文件大小的50%左右。class文件结构和dex文件结构比对。 第6步：apkbuilder 打包生成APK文件。旧的apkbuilder脚本已经废弃，现在都已经通过sdklib.jar的ApkBuilder类进行打包了。输入为我们之前生成的包含resources.arcs的.ap文件，上一步生成的dex文件，以及其他资源如jni、.so文件。 大致步骤为：以包含resources.arcs的.ap_文件为基础，new一个ApkBuilder，设置debugMode apkBuilder.addZipFile(f); apkBuilder.addSourceFolder(f); apkBuilder.addResourcesFromJar(f); apkBuilder.addNativeLibraries(nativeFileList); apkBuilder.sealApk(); // 关闭apk文件 generateDependencyFile(depFile, inputPaths, outputFile.getAbsolutePath()); 第7步：对APK签名 对APK文件进行签名。Android系统在安装APK的时候，首先会检验APK的签名，如果发现签名文件不存在或者校验签名失败，则会拒绝安装，所以应用程序在发布之前一定要进行签名。签名信息中包含有开发者信息，在一定程度上可以防止应用被伪造。对一个APK文件签名之后，APK文件根目录下会增加META-INF目录，该目录下增加三个文件： MANIFEST.MF [CERT].RSA [CERT] Android系统就是根据这三个文件的内容对APK文件进行签名检验的。签名过程主要利用apksign.jar或者jarsinger.jar两个工具。将根据我们提供的Debug和Release两个版本的Keystore进行相应的签名。 MANIFEST.MF中包含对apk中除了/META-INF文件夹外所有文件的签名值，签名方法是先SHA1()(或其他hash方法)在base64()。存储形式是：Name加[SHA1]-Digest。 [CERT].SF是对MANIFEST.MF文件整体签名以及其中各个条目的签名。一般地，如果是使用工具签名，还多包括一项。就是对MANIFEST.MF头部信息的签名。 [CERT].RSA包含用私钥对[CERT].SF的签名以及包含公钥信息的数字证书。 第8步：zipalign优化 Zipalign是一个Android平台上整理APK文件的工具，它首次被引入是在Android 1.6版本的SDK软件开发工具包中。它能够对打包的Android应用程序进行优化， 以使Android操作系统与应用程序之间的交互作用更有效率，这能够让应用程序和整个系统运行得更快。用Zipalign处理过的应用程序执行时间达到最低限度，当设备运行APK应用程序时占更少的RAM。 Zipalign如何进行优化的呢？ 调用buildtoolszipalign，对签名后的APK文件进行对齐处理，使APK中所有资源文件距离文件起始偏移为4字节的整数倍，从而在通过内存映射访问APK文件时会更快。同时也减少了在设备上运行时的内存消耗。如果对于为何提速不理解，那么可以看下内存对齐的规则以及作用该篇文章，对于内存对齐的好处有比较生动详细的解释。最终这样我们的APK就生成完毕了。 典型的APK中内容 AndroidManifest.xml 程序全局配置文件 classes.dex Dalvik字节码 resources.arsc 资源索引表 META-INF该目录下存放的是签名信息 res 该目录存放资源文件 assets该目录可以存放一些配置或资源文件 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/APK&JAR&AAR处理.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/APK&JAR&AAR处理.html","title":"Apk&jar&aar处理","keywords":"","body":" 【jar包依赖项检查】 jdeps -verbose -R classes.jar | grep -v \"java\\.\" | grep -v \"android\\.\" | grep -v \"com.ktcp\\.\" | grep -v \"com.sony\\.\" AAR的话解压之后对classes.jar运行jdeps就行了 【给apk重新签名】 apksigner java -jar apksigner.jar sign --ks --ks-key-alias --in --out apksigner sign --ks --ks-key-alias --in --out jarsigner jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore jarsigner只能进行V1签名，而V2签名是SDK>=24时才支持的，所以使用jarsigner签名后，在强制要求V2签名的系统上安装时会报错：INSTALL_PARSE_FAILED_NO_CERTIFICATES 【apk打包解包】 apktool最新版（v2.6.1）已经能够自动对SDK版本大于等于30的项目打包时跳过resource.arsc文件的压缩。 如果使用的是旧版或者自己编译的apktool，可以在打包apk时指定参数-api 30或者在解包文件夹的apktool.yml文件的doNotCompress节点中追加- resources.arsc，即可跳过resource.arsc文件的压缩。 逆向apk文件: apktool d xx.apk,逆向之后只能看到代码的smali格式文件,需要学习smali语法才能看懂. 重新打包: apktool b xx,打包出来的是没有签名的apk,需要签名才能安装 【强制对齐】 zipalign -f -v 4 input.apk output.apk 【APK Compare Tool】 chmod +x compare.sh &&./compare.sh No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/Maven.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/Maven.html","title":"Maven","keywords":"","body":"Maven简介 Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。 Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。 Maven 功能 Maven 能够帮助开发者完成以下工作： 构建 文档生成 报告 依赖 SCMs 发布 分发 邮件列表 约定配置 Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示： 目录 目的 ${basedir} 存放pom.xml和所有的子目录 ${basedir}/src/main/java 项目的java源代码 ${basedir}/src/main/resources 项目的资源，比如说property文件，springmvc.xml ${basedir}/src/test/java 项目的测试类，比如说Junit代码 ${basedir}/src/test/resources 测试用的资源 ${basedir}/src/main/webapp/WEB-INF web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面 ${basedir}/target 打包输出目录 ${basedir}/target/classes 编译输出目录 ${basedir}/target/test-classes 测试编译输出目录 Test.java Maven只会自动运行符合该命名规则的测试类 ~/.m2/repository Maven默认的本地仓库目录位置 Maven 特点 项目设置遵循统一的规则。 任意工程中共享。 依赖管理包括自动更新。 一个庞大且不断增长的库。 可扩展，能够轻松编写 Java 或脚本语言的插件。 只需很少或不需要额外配置即可即时访问新功能。 基于模型的构建 − Maven能够将任意数量的项目构建到预定义的输出类型中，如 JAR，WAR 或基于项目元数据的分发，而不需要在大多数情况下执行任何脚本。 项目信息的一致性站点 − 使用与构建过程相同的元数据，Maven 能够生成一个网站或PDF，包括您要添加的任何文档，并添加到关于项目开发状态的标准报告中。 发布管理和发布单独的输出 − Maven 将不需要额外的配置，就可以与源代码管理系统（如 Subversion 或 Git）集成，并可以基于某个标签管理项目的发布。它也可以将其发布到分发位置供其他项目使用。Maven 能够发布单独的输出，如 JAR，包含其他依赖和文档的归档，或者作为源代码发布。 向后兼容性 − 您可以很轻松的从旧版本 Maven 的多个模块移植到 Maven 3 中。 子项目使用父项目依赖时，正常情况子项目应该继承父项目依赖，无需使用版本号， 并行构建 − 编译的速度能普遍提高20 - 50 %。 更好的错误报告 − Maven 改进了错误报告，它为您提供了 Maven wiki 页面的链接，您可以点击链接查看错误的完整描述。 Maven使用 在AS上使用maven https://www.jianshu.com/p/41b3e906f60c No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/ubuntu下安装AndroidStudio.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/ubuntu下安装AndroidStudio.html","title":"Ubuntu下安装androidstudio","keywords":"","body":" 在Ubuntu上安装Android Studio详细指南 准备工作 Java开发工具包（JDK）: Android Studio需要Java环境来运行。确保已经安装了JDK。如果没有，可以使用以下命令在终端中安装OpenJDK 11： Bash sudo apt install openjdk-11-jdk 下载Android Studio: 从Android Studio官网（https://developer.android.com/studio）下载适合Linux系统的安装包。 安装步骤 创建安装目录: Bash sudo mkdir /opt/android-studio 解压安装包: 将下载的.zip文件移动到/opt/android-studio目录并解压： Bash sudo unzip android-studio-*.zip -d /opt/android-studio 注意替换android-studio-.zip为你的实际文件名* 创建桌面启动器: Bash sudo gedit /usr/share/applications/android-studio.desktop 在打开的文件中输入以下内容，并根据实际情况修改： [Desktop Entry] Name=Android Studio Comment=Android Studio IDE Exec=/opt/android-studio/bin/studio.sh Icon=/opt/android-studio/bin/studio.png Terminal=false Type=Application Categories=Development;IDE; 注意：studio.png文件可能需要根据你的安装包版本进行调整 运行Android Studio: 打开终端，输入以下命令运行Android Studio： Bash /opt/android-studio/bin/studio.sh 配置Android Studio 首次运行: 首次运行时，Android Studio会提示你导入之前的设置或进行默认设置。 SDK安装: Android Studio会自动下载并安装必要的Android SDK组件。如果需要自定义，可以在设置中进行配置。 模拟器: Android Studio内置了Android虚拟设备（AVD）管理器，可以创建并管理虚拟设备。 验证安装 启动Android Studio: 如果能够正常启动并创建新的Android项目，则说明安装成功。 常见问题与解决 权限问题: 如果遇到权限问题，可以在命令前加上sudo。 环境变量: 确保Java环境变量配置正确。 网络问题: 下载SDK组件时，可能需要配置代理或翻墙。 其他提示 更新Android Studio: 定期更新Android Studio可以获取最新的功能和修复。 配置主题和插件: Android Studio提供了丰富的主题和插件，可以根据个人喜好进行配置。 更多详细的安装步骤和配置指南，可以参考Android Studio官方文档： https://developer.android.com/studio/install 注意: 上述步骤是基于Ubuntu系统的一般安装过程，具体步骤可能因Ubuntu版本和Android Studio版本的不同而略有差异。 如果遇到问题，可以在Android Studio的官方论坛或社区寻求帮助。 通过以上步骤，你就可以在Ubuntu系统上成功安装并配置Android Studio，开始你的Android应用开发之旅。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/内存占用分析.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/内存占用分析.html","title":"内存占用分析","keywords":"","body":"vss/rss/pss/uss的介绍 内存耗用：VSS_RSS_PSS_USS 的介绍 - 简书.pdf 使用adb查看 使用命令 adb shell dumpsys procstats --hours 3 得到的log （minPSS-avgPSS-maxPSS/minUSS-avgUSS-maxUSS/minRSS-avgRSS-maxRSS` over 样本数） TOTAL: 40% (264MB-317MB-333MB/237MB-291MB-307MB/390MB-456MB-477MB over 7) 使用AndroidStudio Profiler 使用Android studio 的 profiler 看到的RSS No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/打包.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/打包.html","title":"打包","keywords":"","body":"apk打包 多渠道打包 我们都知道国内应用市场非常多，为了统计各个应用市场的app下载量和使用情况，我们需要多渠道的打包。如果一个一个的手动去打包岂不烦死了，要多麻烦就有多麻烦。这就要求我们学会使用Gradle进行多渠道打包。废话不多说了，直接进入正题吧！ 第一步：配置AndroidManifest.xml 以友盟渠道为例，渠道信息一般都是写在 AndroidManifest.xml文件中，大约如下： 如果不使用多渠道打包方法，那就需要我们手动一个一个去修改value中的值，xiaomi，360，qq，wandoujia等等。使用多渠道打包的方式，就需要把上面的value配置成下面的方式： 其中${UMENG_CHANNEL_VALUE}中的值就是你在gradle中自定义配置的值。 第二步： 在build.gradle设置productFlavors productFlavors { wandoujia { manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"wandoujia\"] } xiaomi{ manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"xiaomi\"] } qq { manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"qq\"] } _360 { manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"360\"] } } 其中[UMENG_CHANNEL_VALUE: “wandoujia”]就是对应${UMENG_CHANNEL_VALUE}的值。我们可以发现，按照上面的方式写，比较繁琐，其实还有更简洁的方式去写，方法如下： android { productFlavors { wandoujia{} xiaomi{} qq{} _360 {} } productFlavors.all { flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] } } 其中name的值对相对应各个productFlavors的选项值，这样就达到自动替换渠道值的目的了。这样生成apk时，选择相应的Flavors来生成指定渠道的包就可以了，而且生成的apk会自动帮你加上相应渠道的后缀，非常方便和直观。大家可以自己反编译验证。 第三步：一次生成所有渠道包 我们可以使用CMD命令，进入到项目所在的目录，直接输入命令： gradle assembleRelease 就开始打包了，如果渠道很多的话，时间可能会很长。 或者，当然Android Studio中的下方底栏中有个命令行工具Terminal，你也可以直接打开，输入上面的命令： gradle assembleRelease 用CMD进入到项目所在目录执行，或者用AS中自带的命令行工具Terminal其实性质都是一样的。 注意：如果没有对gradle配置的话，可能输入上面的命令，会提示“不是内部或者外部命令”，不要着急，我们只需要找到gradle的目录，把它配置到电脑中的环境变量中去即可。 配置方式如下： 先找到gralde的根目录，在系统变量里添加两个环境变量： 变量名为：GRADLE_HOME，变量值就为gradle的根目录； 所以变量值为：D:\\android\\android-studio-ide-143.2739321-windows\\android-studio\\gradle\\gradle-2.10 还有一个在系统变量里PATH里面添加gradle的bin目录 我的就是D:\\android\\android-studio-ide-143.2739321-windows\\android-studio\\gradle\\gradle-2.10\\bin 这样就配置完了，不信赶紧去试试，执行以下这个命令：gradle assembleRelease。是不是可以了。 第四步：如果要带签名的话，就得在build.gradle进行相关签名的配置 //签名 signingConfigs{ release { storeFile file(\"keystore路径\") storePassword \"***\" keyAlias \"***\" keyPassword \"***\" } } buildTypes { release { runProguard false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release } } 第五步：修改导出包的apk名称 我们打包有非常多的渠道包，所以我们可以根据渠道自定义apk的名称，方便运营人员看嘛，知道哪个apk对应的哪个渠道嘛。 android { applicationVariants.all { variant -> variant.outputs.each { output -> output.outputFile = new File( output.outputFile.parent, \"xxxx(apk的名字)-${variant.buildType.name}-${defaultConfig.versionName}-${variant.productFlavors[0].name}.apk\".toLowerCase()) } } } 最后打包完成之后，apk文件就会生成在项目的build\\outputs\\apk下。 aar打包 打包踩坑 打包时最好不要将minifyEnabled设为true，大概率引起崩溃。 aar中已经引用的库，工程中不要再引用，会导致无法编译。 aar中引用的库，会打包库的全部方法，而不是只打包aar中使用到的方法。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-AndroidStudio/网络设置ADB调试.html":{"url":"04_Android/应用层/工程/1.工程-AndroidStudio/网络设置ADB调试.html","title":"网络设置adb调试","keywords":"","body":"1. 安卓的adb调试模式有两种： 使用usb线 使用网络 2. 使用网络adb模式： 安卓设备跟电脑需处于同一局域网内，可以使用有线网的方式 让电脑跟安卓设备连接在同一wifi路由下，亦可通过电脑创建wifi热点让安卓设备连接都可以 3. 设置网络adb的监听端口，设置的方法有以下几种： 方法一：先是使用usb线连接电脑跟安卓设备，打开电脑的cmd窗口，输入命令：adb tcpip 5555 ；该条命令是设置网络adb监听的端口，5555是默认，也可以设置成其它的。 方法二：该种方法是在系统有root权限下才能使用，依次输入命令：adb shell su -c setprop service.adb.tcp.port 5555 方法三：该种方法是在系统有root权限下才能使用，使用文件管理器按照以下路径打开文件：/system/build.prop，在该文件的最后添加以下内容：service.adb.tcp.port=5555 方法一在安卓设备重启后会失效，需重新设置才行 方法二、三在重启后依然有效，但是该两种方法需在系统有root权限下才能做修改 一、二需先使用usb模式连接电脑设置，三不需要连接电脑 4. 在设置好端口后就可输入命令连接： 1 adb connect 192.168.1.1:5555 其中192.168.1.1是安卓设备的ip地址，如果设置的端口号是默认的5555，后面的：5555可以不用输入 5. 断开连接的命令： 1 adb disconnect 192.168.1.1 6. 如图的第一个adb devices,是使用usb线连接设置调试端口号 7. 在使用adb tcpip 5555设置好调试端口号，使用adb connect 192.168.1.5连接安卓屏，连接成功会显示下面的conenct to xxx.xxx.x.xxx:5555 注意：在connect成功后如果kill掉adb.exe后重新打开需要重新使用命令adb connect 192.168.1.1进行连接 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-AndroidDSL语言.html":{"url":"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-AndroidDSL语言.html","title":"Gradle-androiddsl语言","keywords":"","body":"Android 提供对应的 android 插件用于项目的构建配置，在 Android 中项目的类型有以下四种： AppExtension：对应 com.android.application。 LibraryExtension：对应 com.android.library。 TestExtension：对应 com.android.test。 FeatureExtension：对应 com.android.feature，及时应用。 Android 插件脚本块配置 Android 构建系统编译应用资源和源代码，然后将它们打包成可供测试、部署、签署和分发的 APK。Android Studio 使用 Gradle 这一高级构建工具包来自动化执行和管理构建流程，同时也允许您定义灵活的自定义构建配置。每个构建配置均可自行定义一组代码和资源，同时对所有应用版本共有的部分加以重复利用。Android Plugin for Gradle 与这个构建工具包协作，共同提供专用于构建和测试 Android 应用的流程和可配置设置。 ？1 aaptOptions { } 配置 Android 资源打包工具 AAPT 选项。 aaptOptions { additionalParameters '-S', '/Users/yifan/dev/github/Testapp/app/src/main/res3', '-S', '/Users/yifan/dev/github/Testapp/app/src/main/res2', '--auto-add-overlay' noCompress 'foo', 'bar' ignoreAssetsPattern '!.svn:!.git:!.ds_store:!*.scc:.*:_*:!CVS:!thumbs.db:!picasa.ini:!*~' } 这个选项用于配置 AAPT 资源打包时的一些处理，比如资源替换，这块内容可参照编译时替换资源。 ？2 adbOptions { } 配置 Android 调试工具 ADB 选项。通常我们通过 adb 指令来进行 Apk 的安装或卸载，或者一些文件拷贝工作，通过 adbOptions {} 脚本块同样可以在 Android Plugin 中进行配置，adbOptions {} 脚本块对应 AdbOptions 类，该类有两个属性： installOptions：adb 配置选项，是 List 类型。 timeOutInMs：是设置超时时间的，单位是毫秒，这个超时时间是执行adb这个命令的超时时间，int 类型。 android { adbOptions { timeOutInMs 10 * 1000 installOptions '-r','-s' } } -l：锁定该应用程序 -r：替换已存在的应用程序，也就是我们说的强制安装 -t：允许测试包 -s：把应用程序安装到 SD 卡上 -d：允许进行降级安装，也就是安装的比手机上带的版本低 -g：为该应用授予所有运行时的权限 3 buildTypes { } 当前项目的构建类型配置，对应的配置类型 BuildType 类，在 Android Studio 的中已经给我们内置了 release 和 debug 两种构建类型，这两种模式的主要差异在于能否在设备上调试以及签名不一样，这里会涉及到很多属性可以配置。 ? applicationIdSuffix：配置基于应用默认的 applicationId 的后缀，常用于构建变体应用。 ? consumerProguardFiles：配置 .aar 文件中是否使用 Proguard 混淆。 ? crunchPngs：针对 png 的优化，设置为 true 的时候会增加编译时间。 debuggable：配置构建的 apk 是否能够进行 debug。 javaCompileOptions：配置 Java 编译的配置 ? jniDebuggable：配置构建类型的 apk native code 是否能够进行 debug。 minifyEnabled：是否启用 Proguard 混淆。 ? multiDexEnabled：是否使用分包。 ? multiDexKeepFile：指定放到主 dex 中的文件。 ? multiDexKeepProguard：配置指定的文件使用 Proguard。 proguardFiles：混淆文件。 shrinkResources：用于配置是否自动清理未使用的资源，默认为 false。 signingConfig：签名文件。 ? useProguard ? versionNameSuffix：类似于 applicationIdSuffix。 ? zipAlignEnabled：zipAlign 优化 apk 文件的工具。 buildTypes { release { minifyEnabled false crunchPngs true debuggable false shrinkResources true multiDexEnabled true multiDexKeepProguard file('proguard-rules.pro') // keep specific classes using proguard syntax multiDexKeepFile file('multiDexKeep.txt') minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig zipAlignEnabled true applicationIdSuffix '.release' versionNameSuffix '.release' } debug { applicationIdSuffix '.debug' versionNameSuffix '.debug' } } 4 compileOptions { } Java 编译选项，通常是针对 JDK 进行编码格式修改或者指定 JDK 的版本,对应的类是 CompileOptions。 compileOptions { encoding = 'utf-8' sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } ? 5 dataBinding { } DataBinding 配置选项，查看源码可以发现对应 DataBindingOptions 类，该类包含四个属性： version：版本号。 enabled：是否可用。 addDefaultAdapters：是否使用默认的 Adapter。 enabledForTests：是否用于 Test。 dataBinding { enabled true version 1.0 } 6 defaultConfig { } defaultConfig 也是 Android 插件中常见的一个配置块，负责默认的所有配置。同样它是一个 ProductFlavor，如果一个 ProductFlavor 没有被特殊配置，则默认使用 defaultFlavor 的配置，比如报名、版本号、版本名称等。常见的属性有： applicationId：applicationId 是 ProductFlavor 的一个属性，用于配置 App 生成的进程名，默认情况下是 null。 minSdkVersion：指定 Apk 支持的最低 Android 操作系统版本。 targetSdkVersion：用于配置 Apk 基于的 SDK 哪个版本进行开发。 versionCode：同样是 ProductFlavor 的一个属性，配置 Apk 的内部版本号。 versionName：配置版本名称。 testApplicationId：配置测试 App 的报名，默认情况下是 applicationId + \".test\"。 testInstrumentationRunner：配置单元测试使用的 Runner，默认是 android.test.InstrumentationTestRunner,或者可以使用自定义的 Runner。 signingConfig：配置默认的签名信息，对生成的 App 签名。 proguardFile：用于配置使用的混淆文件。 proguardFiles：配置混淆使用的文件，可以配置多个。 defaultConfig { applicationId 'com.andoter.dsw' minSdkVersion 15 targetSdkVersion 28 versionCode 1 versionName \"1.0\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" signingConfigs signingConfigs.release } ？7 dexOptions { } dex 的配置项，通常在开发的过程中，我们可以通过配置 dexOptions {} 提高编译速度，与之对应的是 DexOptions 接口，该接口由 DefaultDexOptions 默认实现，DefaultDexOptions 类中包含以下属性： preDexLibraries：默认 true jumboMode：默认 false dexInProcess：默认为 true，所有的 dex 都在 process 中，提高效率 javaMaxHeapSize：最大的堆大小 maxProcessCount：最大的 process 个数 threadCount：线程个数 dexOptions { incremental true //是否增量，如果开启multi-dex, 此句无效 preDexLibraries true javaMaxHeapSize \"4g\" //java 编译的 Heap 大小 jumboMode true threadCount 8 //gradle输就输在了并行上, 都是串行, 增加线程数没用 // 设置最大的进程数：Memory = maxProcessCount * javaMaxHeapSize maxProcessCount 8 } ？8 lintOptions { } Lint 是Android Studio 提供的 代码扫描分析工具，它可以帮助我们发现代码结构/质量问题，同时提供一些解决方案，而且这个过程不需要我们手写测试用例。Lint 发现的每个问题都有描述信息和等级（和测试发现 bug 很相似），我们可以很方便地定位问题同时按照严重程度 进行解决。 android { lintOptions { // true--关闭lint报告的分析进度 quiet true // true--错误发生后停止gradle构建 abortOnError false // true--只报告error ignoreWarnings true // true--忽略有错误的文件的全/绝对路径(默认是true) //absolutePaths true // true--检查所有问题点，包含其他默认关闭项 checkAllWarnings true // true--所有warning当做error warningsAsErrors true // 关闭指定问题检查 disable 'TypographyFractions','TypographyQuotes' // 打开指定问题检查 enable 'RtlHardcoded','RtlCompat', 'RtlEnabled' // 仅检查指定问题 check 'NewApi', 'InlinedApi' // true--error输出文件不包含源码行号 noLines true // true--显示错误的所有发生位置，不截取 showAll true // 回退lint设置(默认规则) lintConfig file(\"default-lint.xml\") // true--生成txt格式报告(默认false) textReport true // 重定向输出；可以是文件或'stdout' textOutput 'stdout' // true--生成XML格式报告 xmlReport false // 指定xml报告文档(默认lint-results.xml) xmlOutput file(\"lint-report.xml\") // true--生成HTML报告(带问题解释，源码位置，等) htmlReport true // html报告可选路径(构建器默认是lint-results.html ) htmlOutput file(\"lint-report.html\") // true--所有正式版构建执行规则生成崩溃的lint检查，如果有崩溃问题将停止构建 checkReleaseBuilds true // 在发布版本编译时检查(即使不包含lint目标)，指定问题的规则生成崩溃 fatal 'NewApi', 'InlineApi' // 指定问题的规则生成错误 error 'Wakelock', 'TextViewEdits' // 指定问题的规则生成警告 warning 'ResourceAsColor' // 忽略指定问题的规则(同关闭检查) ignore 'TypographyQuotes' } } ？9 packagingOptions { } Android 打包配置项，可以配置打包的时候哪些打包进 Apk。当项目中依赖的第三方库越来越多时，有可能会出现两个依赖库中存在同一个 （名称）文件。如果这样，Gradle在打包时就会提示错误（警告）。那么就可以根据提示，然后使用以下方法将重复的文件剔除。 packagingOptions { //这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。 exclude 'META-INF/services/javax.annotation.processing.Processor' } 10 productFlavors { } 用于构建不同的产品风味，在上面我们提到 defaultConfig{} 也是一种产品风味，可作为所有产品风味的“基类”共同部分。风味(Flavor) 对应 ProductFlavor 类，该类的属性与配置属性相匹配。 android { ... defaultConfig {...} buildTypes {...} productFlavors { demo { applicationIdSuffix \".demo\" versionNameSuffix \"-demo\" } full { applicationIdSuffix \".full\" versionNameSuffix \"-full\" } } } 在创建和配置您的产品风味之后，在通知栏中点击 Sync Now。同步完成后，Gradle会根据您的构建类型和产品风味自动创建构建变体， 并按照 的格式命名这些变体。例如，如果您创建了“演示”和“完整”这两种产品风味并保留默认的“调试”和“发布”构建类型，Gradle 将创建以下构建变体： 演示调试 演示发布 完整调试 完整发布 您可以将构建变体更改为您要构建并运行的任何变体，只需转到 Build > Select Build Variant，然后从下拉菜单中选择一个变体。 产品风味组合 通常在适配多个渠道的时候，需要为特定的渠道做部分特殊的处理，这里就会涉及到结合 buildTypes{} 组合不同的产品风味组合。 android { ... buildTypes { debug {...} release {...} } // Specifies the flavor dimensions you want to use. The order in which you // list each dimension determines its priority, from highest to lowest, // when Gradle merges variant sources and configurations. You must assign // each product flavor you configure to one of the flavor dimensions. flavorDimensions \"api\", \"mode\" productFlavors { demo { // Assigns this product flavor to the \"mode\" flavor dimension. dimension \"mode\" ... } full { dimension \"mode\" ... } // Configurations in the \"api\" product flavors override those in \"mode\" // flavors and the defaultConfig {} block. Gradle determines the priority // between flavor dimensions based on the order in which they appear next // to the flavorDimensions property above--the first dimension has a higher // priority than the second, and so on. minApi24 { dimension \"api\" minSdkVersion '24' // To ensure the target device receives the version of the app with // the highest compatible API level, assign version codes in increasing // value with API level. To learn more about assigning version codes to // support app updates and uploading to Google Play, read Multiple APK Support versionCode 30000 + android.defaultConfig.versionCode versionNameSuffix \"-minApi24\" ... } minApi23 { dimension \"api\" minSdkVersion '23' versionCode 20000 + android.defaultConfig.versionCode versionNameSuffix \"-minApi23\" ... } minApi21 { dimension \"api\" minSdkVersion '21' versionCode 10000 + android.defaultConfig.versionCode versionNameSuffix \"-minApi21\" ... } } } Gradle 创建的构建变体数量等于每个风味维度中的风味数量与您配置的构建类型数量的乘积。在 Gradle 为每个构建变体或对应 APK 命名时，属于较高优先级风味维度的产品风味首先显示，之后是较低优先级维度的产品风味，再之后是构建类型。以上面的构建配置为例，Gradle 可以使用以下命名方案创建总共 12 个构建变体： 构建变体：[minApi24, minApi23, minApi21][Demo, Full][Debug, Release] 对应 APK：app-[minApi24, minApi23, minApi21]-[demo, full]-[debug, release].apk 同样我们在 Terminal 中通过 gradle 指令执行构建变体的任务：变体名称(flavorDimensions 的第一个维度的 Flavor) + flavorDimensions 的别的维度的 Flavor + buildTypes，例如：minApi24DemoDebug，构建出来的对应 Apk：app-minApi24-demo-debug.apk 过滤变体 Gradle 会自动根据设置的 buildTypes{} 和 flavorDimensions{} 创建很多变体的组合体，但是有些是我们不需要的，这里就涉及到过滤变体的操作。Gradle 提供了 variantFilter {} 脚本块来过滤，脚本块对应 VariantFilter 接口，接口中包含： setIgnore(boolean ignore)：设置是否忽略某个变体 getBuildType：获取变体的构建类型 List getFlavors()：返回所有变体的列表 getName：获取变体的 name 名称 variantFilter { variant -> def names = variant.flavors.name // To check for a certain build type, use variant.buildType.name == \"\" if (names.contains(\"minApi23\") && names.contains(\"demo\")) { // Gradle ignores any variants that satisfy the conditions above. setIgnore(true) } else { setIgnore(false) } } 更多关于构建变体内容参照官方：构建变体 11 signingConfigs { } 配置签名信息，常用于 BuildType 和 ProductFlavor 配置，在构建变体的过程中，会出现很多种类，所以针对不同类别的变体所使用的签名可能也是不同的，这就需要使用 signingConfigs{} 配置签名信息合集，然后按需所取。 signingConfigs { release {//发布版本的签名配置 storeFile file(props['KEYSTORE_FILE']) keyAlias props['KEY_ALIAS'] storePassword props['KEYSTORE_PWD'] keyPassword props['KEY_PWD'] } debug {//调试版本的签名配置 storeFile file(props['DEBUG_KEYSTORE']) keyAlias props['DEBUG_ALIAS'] storePassword props['DEBUG_KEYSTORE_PWD'] keyPassword props['DEBUG_KEY_PWD'] } } buildTypes { signingConfig signingConfigs.release } 12 sourceSets { } 在 AndroidStudio 中，在 src/main/java 目录下创建我们的 .java 文件，这些都是系统通过 sourceSet{} 设置好的，比如我们在外部创建一个文件夹，选中文件夹右键就无创建 .java 文件的选项。就需要我们通过 sourceSets 进行配置，脚本块对应 AndroidSourceSet 接口，接口中有： AndroidSourceSet java(Closure configureClosure)：配置 java 文件存放路径 AndroidSourceSet resources(Closure configureClosure)：配置 resource 目录 AndroidSourceSet jniLibs(Closure configureClosure)：配置 jniLibs 目录 AndroidSourceSet jni(Closure configureClosure)：配置 jni 文件目录 AndroidSourceSet renderscript(Closure configureClosure)：配置 renderscript 目录 AndroidSourceSet aidl(Closure configureClosure)：配置 aidl 文件目录 AndroidSourceSet assets(Closure configureClosure)：配置 assets 目录 AndroidSourceSet res(Closure configureClosure)：配置 res 目录 AndroidSourceSet manifest(Closure configureClosure)：配置 manifest 目录 sourceSets { main { java { srcDir 'src/main/testjava' } resources { srcDir 'src/resources' } } } ？13 splits { } 拆分机制比起使用 flavors，能让应用程序更有效地构建一些形式的多个apk。 多 apk 只支持以下类型: 屏幕密度 ABI 脚本块对应 Splits 类，该类中有三个属性： density：像素密度 abi：abi 类型 language：语言 splits { density { enable true exclude \"ldpi\", \"tvdpi\", \"xxxhdpi\" compatibleScreens 'small', 'normal', 'large', 'xlarge' } abi { enable true reset() include 'x86', 'armeabi-v7a', 'mips' universalApk true } } No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-AndroidStudio文件解析.html":{"url":"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-AndroidStudio文件解析.html","title":"Gradle-androidstudio文件解析","keywords":"","body":"Android studio中的Gradle文件 版本配置 项目的build.gradle（这里配置Gradle的Android插件的版本） dependencies { classpath 'com.android.tools.build:gradle:3.0.1' } gradle-wrapper.properties(在项目\\gradlelwrapperl)（这里配置Gradle的版本） distributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-allzip 相关文件目录 我们先来看看Android Gradle项目中那些涉及到gradle的文件分别是什么意思。 Gradle wrapper（gradle包装） 上图中涉及到Gradle wrapper的部分如下所示，具体有上图中的gradle文件夹，gradlew文件和gradlew.bat批处理文件。 |--gradle | |--wrapper | |--gradle-wrapper.jar | |--gradle-wrapper.properties |--gradlew |--gradlew.bat gradle文件夹中包含wrapper，wrapper顾名思义是对Gradle的一层包装，便于在团队开发过程中统一Gradle构建的版本。 上面目录中gradlew和gradlew.bat分别是Linux和Windows下的可执行脚本，gradle-wrapper.jar是具体业务逻辑实现的jar包，gradlew可执行脚本最终还是使用这个jar包来执行相关Gradle操作，gradle-wrapper.properties是配置文件，用于配置使用哪个版本的Gradle，配置文件中的具体内容如下所示： #Wed Jun 19 10:09:08 GMT+08:00 2019 distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists distributionUrl=https\\://services.gradle.org/distributions/gradle-5.1.1-all.zip Settings.gradle （多工程配置） 此文件用于初始化以及工程树的配置，大多数用于配置子工程，在Gradle中多个工程是通过工程树来表示的，相当于我们在Android Studio看到的Project和Module概念一样，根工程相当于Project，子工程相当于Module，一个Project可以有很多Module，一个子工程只有在Setting.gradle中配置了才会生效。 配置举例： // 添加:app和:common这两个module参与构建 include ':app' project(':app').projectDir = new File('存放目录') include':common' project(':common').projectDir = new File('存放目录') 如果不指定上述存放目录，则默认为是Settings.gradle其同级目录。 build.gradle文件（版本文件） 每个工程都会有build.gradle文件，该文件是该工程的构建入口，在此文件中可以对该工程进行配置，如配置版本，插件，依赖库等。 既然每个工程都有一个build文件，那么根工程也不例外，在根工程中可以对子Module进行统一配置，全局管理版本号或依赖库。 build文件分为Project和Module两种，如下图所示： Project的build.gradle：整个Project的共有属性，包括配置版本、插件、依赖库等信息 Module的build.gradle：各个module私有的配置文件 //Ali的maven源 // maven { url 'https://plugins.gradle.org/m2/' } // maven { url 'https://maven.aliyun.com/nexus/content/repositories/google' } // maven { url 'https://maven.aliyun.com/nexus/content/groups/public' } // maven { url 'https://maven.aliyun.com/nexus/content/repositories/jcenter'} Project中build.gradle文件（顶层版本文件） buildscript { // gradle脚本执行所需依赖仓库 repositories { google() jcenter() } // gradle脚本执行所需依赖 dependencies { classpath 'com.android.tools.build:gradle:3.4.1' } } allprojects { // 项目本身需要的依赖仓库 repositories { google() jcenter() } } 那么buildscript中的repositories和allprojects的repositories的作用和区别是什么呢？ buildscript里是gradle脚本执行所需依赖，分别是对应的maven库和插件； allprojects里是项目本身需要的依赖，比如我现在要依赖maven库的xx库，那么我应该将maven {url '库链接'}写在这里，而不是buildscript中，否则找不到所需要的库。 Module中build.gradle文件（模块级版本文件） 此部分内容参考下文中3.3.2节。 gradle.properties（属性文件） 此文件主要在其中配置项目全局 Gradle 设置，如 Gradle 守护进程的最大堆大小。如需了解详情，请参阅构建环境 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-Android插件.html":{"url":"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-Android插件.html","title":"Gradle-android插件","keywords":"","body":"Android Gradle插件 从Gradle的角度看，Android其实就是Gradle的一个第三方插件，它是由Google的Android团队开发的，Android 开发 IDE Android Studio 就采用 Gradle 构建项目。 Android Gradle插件分类 App应用工程：生成可运行apk应用；插件id: com.android.application Library库工程：生成AAR包给其他的App工程公用，其使用方式和jar包一样，里面有相关的 Android 资源文件；插件id: com.android.library Test测试工程：对App应用工程或Library库工程进行单元测试；插件id: com.android.test No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-DSL语言.html":{"url":"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-DSL语言.html","title":"Gradle-dsl语言","keywords":"","body":"上面我们针对 Groovy 语言进行简单的学习，接下来就是 Gradle DSL 语言的学习。Gradle 是 Android Studio 中采用的全新项目构建方式。 Gradle 是一个开源的自动化构建工具，提供更高的灵活和体验。Gradle 脚本采用 Groovy 或 Kotlin 进行编写。 官方文档：https://docs.gradle.org/current/dsl/index.html 基本概念 Gradle 是一种脚本配置，所以当它执行的时候，它需要跟对应的类型相对应。在 Gradle 中存在以下三种类型： 脚本类型 委托的实例 Build script Project Init script Gradle Settings script Settings Gradle 围绕项目 Project，所以 Project 是我们最重要的接口,通过 Project 接口，我们可以获取整个 Gradle 的属性。通常我们的项目在 Project 模式的下结构是： ├── app #Android App目录 │ ├── app.iml │ ├── build #构建输出目录 │ ├── build.gradle #构建脚本 │ ├── libs #so相关库 │ ├── proguard-rules.pro #proguard混淆配置 │ └── src #源代码，资源等 ├── build │ └── intermediates ├── build.gradle #工程构建文件 ├── gradle │ └── wrapper ├── gradle.properties #gradle的配置 ├── gradlew #gradle wrapper linux shell脚本 ├── gradlew.bat ├── LibSqlite.iml ├── local.properties #配置Androod SDK位置文件 └── settings.gradle #工程配置 Project 1.生命周期 Lifecycle Project 与 build.gradle 文件是一对一的关系，在初始化脚本构建的过程中，Gradle 为每一个项目创建 Project对象。步骤如下： 初始化阶段 在初始化阶段，构建工具根据每个 build.gradle 文件创建出每个项目对应的 Project，同时会执行项目根目录下的 settings.gradle 分析需要参与编译的项目。 比如我们常见的 settings.gradle 配置文件： include ':app', ':groovydemo' 指明了需要编译的项目。 配置阶段 配置阶段为每个 Project 创建并配置 Task，配置阶段会去加载所有参与构建项目的 build.gradle 文件，将每个 build.gradle 文件转换为一个 Gradle 的 Project 对象，分析依赖关系，下载依赖。 执行阶段 Gradle 根据 Task 之间的依赖关系，决定哪些 Task 需要执行，以及 Task 之间的先后顺序。 Task Task 是 Gradle 中的最小执行单元，所有的构建、编译、打包、debug、test 等都是执行了某一个 task，一个 Project 可以有多个 Task，Task 之间可以互相依赖。例如我有两个 Task，TaskA 和 TaskB，指定 TaskA 依赖 TaskB，然后执行 TaskA，这时会先去执行 TaskB，TaskB 执行完毕后在执行 TaskA。 同时，我们也可以自定义 Task，也可以查找 Task 是否存在。站在编程的角度来看 Task 同样是一个类，核心方法： String getName()：获取任务名称 Project getProject()：获取任务所在的 Project 对象 List> getActions()：获取 Action TaskDependency getTaskDependencies()：获取任务依赖 Task dependsOn(Object... var1)：任务依赖关系函数 void onlyIf(Closure var1) TaskState getState()：获取任务的状态 Task doFirst(Closure var1)：任务先执行.. Task doLast(Closure var1)：任务后执行.. String getDescription()：获取任务描述 String getGroup()：获取任务分组 1. 任务的创建 Task 是 Gradle 中最小执行基本单元，创建任务的方式有以下几种： Project.task(String name) Project.task(String name, Closure configureClosure) Project.task(Map args, String name, Closure configureClosure) Project.task(Map args, String name) TaskContainer.create(String name) TaskContainer.create(Map options) 前面三种都是基于 Project 提供的 task 重载方法进行创建。这里需要着重介绍下里面的 Map 参数，Map 参数选项用于控制 Task 的创建以及属性。 配置项 描述 默认值 type 任务创建的类型 DefaultTask overwrite 是否重写已存在的任务 false dependsOn 添加任务的依赖 [] action 添加任务中的 Action null description 任务的描述 null group 配置任务的分组 null 第一种：直接以任务名称创建任务 Task copyTask = task(\"copyTask\") copyTask.description = \"Copy Task\" copyTask.group = \"custom\" copyTask.doLast { print(\"Copy Task Create\") } 这种方式跟 Java 中的创建对象的方式非常相似，这种方式的本质是调用 Project 类中的 task(String name) 方法进行对象的创建。 第二种：task + 闭包的方式 Task taskClosure = project.task(\"taskClosure\"){ print(\"Task Closure\") } 这种写法利用闭包是最后一个参数的时候，可以抽取到外部写。上面的这种写法也可以精简： task taskClousre { print(\"Task Closure\") } 这种形式的在 .gradle 脚本文件中用的非常多，所以大家也写这种吧！ 第三种：task + Map Task mapTask = project.task(dependsOn: copyTask,description: \"mapTask\",group: \"mapTask\", \"mapTask\"){ println(\"Map Task Create\") } 这里通过 Map 进行 Task 的一些设置，这里我们可以同样以方式一一样，单独进行设置。 第四种：TaskContainer 创建任务 project.tasks.create(\"TaskContainer\") { description \"TaskContainer\" group \"TaskContainer\" doLast { println(\"TaskContainer\") } } 在上面的演示例子中，我们也介绍了任务的分组和描述的使用，可以在 Gradle Pojects 栏中进行查看任务的分组和描述。 2. 任务之间的关系 dependsOn(Task task) 任务依赖,通过 dependsOn 可以建立任务之间的执行依赖关系，先执行依赖的任务。 def name = \"Hello World from\" task checkName { if (name.length() > 0){ name = name.replace(\"from\", \"\") } } task printName() { println(name) } printName.dependsOn(checkName) mustRunAfter(Task task) 必须在添加的任务之后执行。 def name = \"Hello World from\" task checkName { if (name.length() > 0){ name = name.concat(\" China\") } } task printName() { println(name) } printName.mustRunAfter(checkName) 3. 任务类型 在 1 节中，我们提到了创建任务时可以通过 Map 配置任务的依赖属性关系，里面涉及到 任务类型（type），默认值是 DefaultTask 类型，关于 type，我的理解是 Groovy 系统的 Task 类型，我们查看官方文档，可以看到有很多 Task 类的子类，这些应该都可以作为 type 值进行设置？那么常见的任务类型有哪些呢？ 官方 Task API：https://docs.gradle.org/current/javadoc/org/gradle/api/Task.html Copy 类型 Task，Copy 任务的方法： eachFile：遍历文件 exclude(Closure excludeSpec)：去除包含的内容 filter(Closure closure)：过滤 from(Object... sourcePaths)：源目录 include(Closure includeSpec)：包含内容 into(Object destDir)：目标目录 rename(Closure closure)：重命名 with(CopySpec... sourceSpecs) 通过 Copy 任务，我们可以更方面实现文件的拷贝复制类操作，因为它提供了一些封装好的方法，不需要我们在通过 File 的操作进行。常见的就是创建的 makeJar 任务,拷贝系统编译的 jar 包到指定目录。 task makeJar(type: Copy) { def jarName = 'SensorsAnalytics-Android-SDK-Release-' + version + '.jar'; delete 'build/libs/' + jarName from('build/intermediates/bundles/release/') into('build/libs/') include('classes.jar') rename('classes.jar', jarName) } makeJar 的任务执行步骤：首先设置 type 是 Copy 类型任务，定义拷贝目标的 jar 名称，接着删除 目标目录已存在的 jar 文件，from 从源目录拷贝到 into 的目标目录，包含 include 的 classes.jar，最后给文件重命名。 在 Android Studio 的 2.X 版本中自动生成的 jar 包路径在：build/intermediates/bundles/release/ 目录，在 3.X 中目录：build/intermediates/packaged-classes/release/。 Jar 类型 Task task makeJar(type: Jar, dependsOn: build) { delete 'build/libs/sensorsdata.jar' from('build/intermediates/classes/release') into('build/libs/') exclude('android/', 'androidx/','BuildConfig.class', 'R.class') exclude { it.name.startsWith('R$') } } Jar 任务的作用就是打包 jar 包，比如我们通过 from 指定工程目录中的源码进行打包，这样我们就可以实现高度的定制化，不像通过 Copy 任务复制系统根据整个目录生成的 Jar 包一样。比如下面的 task 生成 Jar 包。 task makeJars(type: org.gradle.jvm.tasks.Jar) { from(android.sourceSets.main.java.srcDirs) } 在 Gradle 中提供了很多常见的任务： Gradle System Tasks 常见脚本块 Gradle 支持 Groovy 语言进行编写，非常灵活支持各种插件。比如你想在脚本中使用一些第三方的插件、类库等，就需要自己手动添加对这些插件、类库的引用，而这些插件、类库又不是直接服务于项目的，而是支持其它 build 脚本的运行，所以你应当将这部分的引用放置在 buildscript 代码块中。 gradle 在执行脚本时，会优先执行buildscript代码块中的内容，然后才会执行剩余的build脚本。所以需要我们了解常见的脚本块配置。 1. allprojects { } 配置整个 Project 和子项目的配置。 allprojects { repositories { google() jcenter() } } 比如我们在 allprojects 内部定义的 Task 任务，就会用于根目录和子项目。比如下面的例子，我们执行：./gradlew print 任务，打印的结果如下： allprojects { task print { println project.name } } 输出结果： GradlePlugin(根目录) app groovydemo sensorsdatalibrary 2. buildscript { } buildscript 中的声明是 gradle 脚本自身需要使用的资源。 buildscript { repositories { google() jcenter() mavenCentral() } //格式为-->group:module:version dependencies { classpath 'com.android.tools.build:gradle:3.1.2' classpath 'com.qihoo360.replugin:replugin-plugin-gradle:2.2.4' } } 3. configurations { } 配置整个 Project 的 dependency 属性，与之对应的是 ConfigurationContainer，在 Project 项目中可以通过以下方法获取 ConfigurationContainer 对象： Project.getConfigurations() configurations 通常使用最多的就是去除依赖，比如我们添加的依赖中也依赖某个库，这种间接依赖的冲突，transitive dependencies 被称为依赖的依赖，称为“间接依赖”比较合适。 configurations { compile.exclude module: 'commons' all*.exclude group: 'org.gradle.test.excludes', module: 'reports' } 4. dependencies { } 配置项目的依赖库，与之对应的是 DependencyHandler 类。 在 dependencies{} 脚本块中有不同的依赖方式，这里在 Android Studio 的 2.X 版本与 3.X 版本中差别还是挺大的，Android Studio3.0 中，compile 依赖关系已被弃用，被 implementation 和 api 替代，provided 被 compile only 替代，apk 被 runtime only 替代。为了比较方便，前面写是 3.X 版本，括号是 2.X。 implementation：依赖的库只能在本项目使用，外部无法使用。比如我在一个 library 中使用 implementation 依赖了 gson 库，然后我的主项目依赖了 library，那么，我的主项目就无法访问 gson 库中的方法。这样的好处是编译速度会加快，推荐使用 implementation 的方式去依赖，如果你需要提供给外部访问，那么就使用 api 依赖即可 api(compile)：使用该方式依赖的库将会参与编译和打包 testImplementation(testCompile)：只在单元测试代码的编译以及最终打包测试 Apk 时有效 debugImplementation(debugCompile)：只在 debug 模式的编译和最终的 debug Apk 打包时有效 releaseImplementation(releaseCompile)：仅仅针对 Release 模式的编译和最终的 Release Apk 打包 compileOnly(provided)：只在编译时有效，不会参与打包，可以在自己的moudle中使用该方式依赖。比如 com.android.support，gson 这些使用者常用的库，避免冲突。 runtimeOnly(apk)：只在生成 Apk 的时候参与打包，编译时不会参与，很少用。 下面是一些常见的依赖使用方式： apply plugin: 'java' //so that we can use 'compile', 'testCompile' for dependencies dependencies { //for dependencies found in artifact repositories you can use //the group:name:version notation compile 'commons-lang:commons-lang:2.6' testCompile 'org.mockito:mockito:1.9.0-rc1' //map-style notation: compile group: 'com.google.code.guice', name: 'guice', version: '1.0' //declaring arbitrary files as dependencies compile files('hibernate.jar', 'libs/spring.jar') //putting all jars from 'libs' onto compile classpath compile fileTree('libs') } 在实际项目开发中，我们会引入很多第三方开源库，自然就会造成依赖冲突，这里就涉及到在 dependencies 提供的配置字段： force = true：即使在有依赖库版本冲突的情况下坚持使用被标注的这个依赖库版本 transitive = true：依赖的依赖是否可用，举个例子，使用的三方库中可能也依赖别的库，我们称之为“间接依赖” exclude：用于排除指定版本库，通常用于排除冲突依赖库 dependencies { compile('com.sensorsdata.analytics.android:SensorsAnalyticsSDK:2.0.2') { //强制使用我们依赖的 2.0.2 版本库 force = true //剔除间接依赖的库,可以通过这三种方式，后面再讲解自定义插件的时候就能看懂这三种方式了。 exclude module: 'cglib' //by artifact name exclude group: 'org.jmock' //by group exclude group: 'org.unwanted', module: 'iAmBuggy' //by both name and group //禁用所有的间接依赖库 transitive = false } } 5. repositories { } 配置 Project 项目所需的仓库地址，Gradle 必须知道从哪里下载外部依赖，这是由仓库配置来指定的，比如 google()、jcenter() 或 mavenCentral()。通常在 buildscript 脚本块中也能看到配置的 repositories 属性，buildscript 中的声明是 gradle 脚本自身需要使用的资源，可以声明的资源包括依赖项、 第三方插件、 maven 仓库地址等。而在 build.gradle 文件中直接声明的依赖项、仓库地址等信息是项目自身需要的资源。 repositories { //Maven本地仓库，寻找本地仓库的逻辑与Maven相同 mavenLocal() //Maven中心仓库 mavenCentral() //JCenter仓库 jcenter() //其它Maven远程仓库 maven { //可以指定身份验证信息 credentials { username 'user' password 'password' } url \"http://repo.mycompany.com/maven2\" //如果上面的URL找不到构件，则在下面找 artifactUrls \"http://repo.mycompany.com/jars\" } //Ivy远程仓库 ivy { url \"http://repo.mycompany.com/repo\" } //Ivy本地仓库 ivy { url \"../local-repo\" } //扁平布局的文件系统仓库 flatDir { dirs 'lib' } flatDir { dirs 'lib1', 'lib2' } } 6. sourceSets { } 配置项目的源码目录结构。 sourceSets { main { java { srcDirs = ['src/java'] } resources { srcDirs = ['src/resources'] } } } 7. subprojects { } 用于配置子项目的脚本块。比如我们在 subprojects 中配置 print 任务，则只会作用于子目录。 subprojects { task print { println project.name } } 输出结果： app groovydemo sensorsdatalibrary 8. publishing { } 用于发布构建。 publishing { publications { myPublication(MavenPublication) { from components.java artifact sourceJar pom { name = \"Demo\" description = \"A demonstration of Maven POM customization\" url = \"http://www.example.com/project\" licenses { license { name = \"The Apache License, Version 2.0\" url = \"http://www.apache.org/licenses/LICENSE-2.0.txt\" } } developers { developer { id = \"johnd\" name = \"John Doe\" email = \"john.doe@example.com\" } } scm { connection = \"scm:svn:http://subversion.example.com/svn/project/trunk/\" developerConnection = \"scm:svn:https://subversion.example.com/svn/project/trunk/\" url = \"http://subversion.example.com/svn/project/trunk/\" } } } } } No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-Gradlew命令.html":{"url":"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-Gradlew命令.html","title":"Gradle-gradlew命令","keywords":"","body":"查看项目中jar包依赖关系 依赖树 父子级 gradlew -q app:dependencies > report.txt No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-插件.html":{"url":"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-插件.html","title":"Gradle-插件","keywords":"","body":"Gradle插件 插件介绍 Gradle的设计非常好，本身提供一些基本的概念和整体核心的框架，其他用于描述真实使用场景逻辑的都以插件扩展的方式来实现，比如构建Java应用，就通过Java插件来实现，那么自然构建Android应用，就通过Android Gradle插件来实现。 Gradle 提供了很多官方插件，用于支持Java、Groovy等工程的构建和打包。同时也提供了自定义插件机制，让每个人都可以通过插件来实现特定的构建逻辑，并可以把这些逻辑打包起来，分享给其他人。 Android Gradle插件是基于内置的Java插件实现的。Gradle插件的作用如下： 可以添加任务到项目，比如测试、编译、打包等 可以添加依赖配置到项目，帮助配置项目构建过程中需要的依赖，比如第三方库等 可以向项目中现有的对象类型添加新的扩展属性和方法等，帮助配置和优化构建 可以对项目进行一些约定，比如约定源代码存放位置等 ?Gradle插件 通过使用插件可以扩展项目的功能，帮助我们做很多任务，比如编译、打包，Gradle 插件可以分为两类： 二进制插件：继承 org.gradle.api.Plugin 接口实现的插件 脚本插件：直接在 build.gradle 配置文件 二进制插件 二进制插件：实现了org.gradle.api.Plugin接口的插件，拥有plugin id，这个 id 是插件全局唯一的标识或名称 常见的二进制插件 com.android.application，这里的 ‘com.android.application’ 就是插件的 plugin id，二进制插件的使用形式: apply plugin： plugin id apply plugin : 'java' id式：apply plugin:'plugin id' 类型式：apply plugin:org.gradle.api.plugins.JavaPlugin 简写式：apply plugin:JavaPlugin 脚本插件 脚本插件：严格上只是一个脚本，即自定义的以 .gradle 为后缀的脚本文件，可以来自本地或网络 通常脚本插件用于本地的配置存储，使用格式： apply from： ‘fileName’ // config.gradle rootProject.ext { android = [ compileSdkVersion : 28, buildToolsVersion : \"28.0.0\", applicationId : \"sw.andoter.com.gradleplugindemo\", minSdkVersion : 18, targetSdkVersion : 28, versionCode : 1, versionName : \"1.0\" ] sdkVersion = 13 apkPath = [ apkPath : \"/Users/dengshiwei/Desktop/*.apk\" ] } apply from: \"../config.gradle\" 第三方发布插件 第三方发布插件：apply plugin:'com.android.application' ?Gradle 自定义插件 方式一：Build script脚本方式 apply plugin: MyPlugin class MyPlugin implements Plugin{ @Override void apply(Project project) { println \"this is my plugin\" } } 运行结果： 详细介绍？ 创建一个 module，什么样的都可以，不管是 Phone&Tablet Module 或 Android Librarty 都可以，然后只留下 src/main 和 build.gradle，其他的文件全部删除。 在main 目录下创建 groovy 文件夹，然后在 groovy 目录下就可以创建我们的包名和 groovy 文件了,记得后缀要以 .groovy 结尾。在这个文件中引入创建的包名，然后写一个 Class 继承于 Plugin 并重写 apply 方法。 class MyPlugin implements Plugin { @Override void apply(Project project) { System.out.println(\"-----------插件开始-----------\") System.out.println(\"---这是我们的自定义插件---\") System.out.println(\"-----------插件结束-----------\") } } 在 main 目录下创建 resources文件夹，继续在 resources 下创建 META-INF 文件夹，继续在 META-INF 文件夹下创建 gradle-plugins 文件夹，最后在 gradle-plugins 文件夹下创建一个 xxx.properties 文件，注意：这个 xxx 就是在 app 下的 build.gradle 中引入时的名字，例如：apply plugin: ‘xxx’。在文件中写 implementation-class=implementation-class=com.andoter.customplugin.MyPlugin。 implementation-class=com.andoter.customplugin.MyPlugin 打开 build.gradle 删除里面所有的内容。然后格式按这个写，uploadArchives 是上传到 maven 库，然后执行 uploadArchives 这个 task，就将我们的这个插件打包上传到了本地 maven 中，可以去本地的 Maven 库中查看。 apply plugin: 'groovy' apply plugin: 'maven' dependencies { compile gradleApi() compile localGroovy() } repositories { mavenCentral() } group = 'com.andoter.customplugin' version = '1.0' uploadArchives { repositories { mavenDeployer { repository(url: uri('../repo')) } } } 在上面的实现中，我们也可以把 group、version 字段配置在内部: uploadArchives { repositories { mavenDeployer { repository(url: uri('../repo')) pom.groupId = \"com.andoter.customplugin\" pom.artifactId = \"groovydemo\" pom.version = \"1.0\" } } } 应用 gradle 插件：在项目下的 build.gradle（也可以在 module 中）中的 repositories 模块中定义本地 maven 库地址。在 dependencies 模块中引入我们的插件的路径。 // 根目录 .gradle 文件配置插件的地址 buildscript { repositories { google() jcenter() mavenCentral() maven { url './repo' } } //格式为-->group:module:version dependencies { classpath 'com.android.tools.build:gradle:3.1.2' classpath 'com.andoter.customplugin:groovydemo:1.0' } } // 子项目使用插件 apply plugin: 'com.andoter.customplugin' 这样就完成一个自定义插件的使用步骤，自定义插件的核心开发一个什么样的插件，比如结合 Transform 开发一个编译时框架。 方式二：buildSrc目录 1、新建一个 buildSrc 文件夹 2、新建一个 build.gradle 文件，里面添加如下代码，然后点击 sync now，你就会发现 buildSrc 文件夹多了一个绿标 apply plugin: \"java\" apply plugin: 'java-gradle-plugin' 3、新建子目录 src/main/java ,并编写一个插件类 import org.gradle.api.Plugin; import org.gradle.api.Project; public class MyPlugin implements Plugin { @Override public void apply(Project project) { } } 4、在app下的build.gradle里面应用 运行结果展示： 方式三：独立项目 1、新建一个独立的module，不要选错了！！！， 2、在该模块下的build.gradle里添加依赖 dependencies { implementation gradleApi() } 可能出现的报错 Build was configured to prefer settings repositories over project repositories but repository 'Gradle Libs' was added by unknown code 解决方法： 3、编写插件类 package com.example.secondplugin; import org.gradle.api.Plugin; import org.gradle.api.Project; public class MyClass implements Plugin { @Override public void apply(Project project) { System.out.println(\"this is third plugin\"); } } 4、 编写插件配置文件 层级结构不能错 5、发布插件任务代码的编写 groupId、artifactId、version根据自己实际情况来写 如果有小伙伴没找到task视图，解决方法如下： 6、点击如下按钮，发布到本地仓库 7、使用 运行效果： No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-问题解决.html":{"url":"04_Android/应用层/工程/1.工程-Gradle-Groovy/Gradle-问题解决.html","title":"Gradle-问题解决","keywords":"","body":"多渠道打包如何使用不同的签名？ 在android{signingConfigs{}}中定义多个签名配置 signingConfigs { config_m { keyAlias 'androiddebugkey' keyPassword 'android' storeFile file('../key_m/platform.jks') storePassword 'android' } config_t6y { keyAlias 'androiddebugkey' keyPassword 'android' storeFile file('../key_t6y/platform.jks') storePassword 'android' } } 在多渠道配置时，使用不用的签名，这样打包时会根据渠道自动使用签名 productFlavors { M { minSdkVersion 29 dimension \"model\" signingConfig signingConfigs.config_m } T6Y { minSdkVersion 30 dimension \"model\" signingConfig signingConfigs.config_t6y } } 另外 需要在 buildTypes{debug{}}中设置 signingConfig null，否则debug会使用默认的签名文件 相关链接：https://blog.csdn.net/liuyu0915/article/details/90485863 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-Gradle-Groovy/Groovy基础.html":{"url":"04_Android/应用层/工程/1.工程-Gradle-Groovy/Groovy基础.html","title":"Groovy基础","keywords":"","body":"Groovy基础 Groovy是个灵活的动态脚本语言，基于JVM虚拟机，语法和Java很相似，又兼容Java，且在此基础上增加了很多动态类型和灵活的特性，如支持闭包和DSL。Groovy的开发环境配置可以参考Groovy 环境配置，具体语言特性教程可以参考-Groovy教程。 Groovy基于Java，又扩展了Java，运行过程中首先会先将其编译成Java类字节码，然后通过JVM来执行这个Java类。 1.数据类型 Groovy是弱化类型语言，但是实现上还是强类型相关，如果类型不对，还是会报错。Groovy 中的基本数据类型有 byte -这是用来表示字节值。例如2。 short -这是用来表示一个短整型。例如10。 int -这是用来表示整数。例如1234。 long -这是用来表示一个长整型。例如10000090。 float -这是用来表示32位浮点数。例如12.34。 double -这是用来表示64位浮点数，这些数字是有时可能需要的更长的十进制数表示。例如12.3456565。 char -这定义了单个字符文字。例如“A”。 Boolean -这表示一个布尔值，可以是true或false。 String -这些是以字符串的形式表示的文本。例如，“Hello World”的。 int a = 4; float b = 1.0; double c = 2.1; byte te = 4; char ch = 'c'; String str = \"abcd\"; 2.变量和方法的声明 在 Groovy 中通过 def 关键字进行变量和方法的声明。 def a = 1 def b = 1.0 def str = \"Hello World\" def output() { print 'Hello World' } Groovy 类似脚本，所以有很多都可以省略： 语句后的分号;可以省略 变量的类型可以省略 方法返回值 return 语句可以省略 方法的声明： Groovy 也是一门 JVM 语言，所以在语法上与 Java 有很多相通的地方，这样在方法的声明时候格式也比较随意，所以作为 Android 程序员，我们可以选择靠拢 Java 语法格式的风格。 def methodName() { print(\"HelloWorld\") } def int sum2Number(a, b) { return a + b } def sum(a, b) { return a+b } int add(a ,b) { return a + b } 3.循环 Groovy 中循环控制语句与 Java 中的类似，有以下三种： for 语句 while 语句 for-in 语句 for(int i = 0 ;i 同样，针对循环也有循环控制语句： break：break语句用于结束循环和switch语句内的控制流。 continue：结束本次循环，进行下次循环，仅限于while和for循环。 for(int i = 0 ;i 4.条件判断语句 Groovy 中的条件判断语句与 Java 中的类似，有： if if...else if...else if...else switch 例子就不演示了，语法跟 Java 相同。 在上面的 Groovy 基础介绍中，形式上跟 Java 语言非常相似，没有太大的变化，针对 Java 、Android 程序员来说应该非常容易上手。 Groovy中的集合 1.List列表 基本语法：List 列表使用[ ] 进行声明，并通过索引进行区分。 def listEmpty = [] //空列表 def list = [1,2,3,4,5] //整数值列表 def listInt = [1,[2,3],4,5] //列表嵌套列表 def listString = [\"andoter\",\"note\"] //字符串列表 def listNone = [\"andoter\",1,4] //异构对象列表 列表中的方法： boolean add(E e) void add(int index, E element) boolean addAll(Collection c) void clear() boolean contains(Object o) Iterator iterator() Object[] toArray() int lastIndexOf(Object o) E set(int index, E element) 这些方法都跟 Java 中的类似，打开对应的类型查看后，发现通过 def 声明的列表竟然是 java.util.List 下面的。 def listEmpty = [] //空列表 def list = [1,2,3,4,5] //整数值列表 def listInt = [1,[2,3],4,5] //列表嵌套列表 def listString = [\"andoter\",\"note\"] //字符串列表 def listNone = [\"andoter\",1,4] //异构对象列表 listEmpty.add(1) listEmpty 需要注意，在 groovyjarjarantlr.collections.List 包下同样存在 List，所以使用的时候需要注意。 关于列表 List 的遍历，我们可以参照 Java 中的 Iterator 接口去遍历，或者使用 Groovy 系统提供的 each 方法进行遍历。在 Groovy 中提供 DefaultGroovyMethods 类，该类定义很多快捷使用方法： abs：取绝对值计算 addAll(Collection) each：遍历 eachWithIndex：带 index 的遍历 grep：符合条件的element会被提取出来，形成一个list every：所有的element都满足条件才返回true，否则返回false any：只要存在一个满足条件的element就返回true，否则返回false join：用指定的字符连接collection中的element sort：根据指定条件进行排序 find：查找collection中满足条件的‘第一个’element findAll：查找collection中满足条件的‘所有’element 很多使用的方法，可参照源码查看。 def listString = [\"andoter\",\"note\"] listString.each { println(it) } listString.each { value -> println(value) } 2.Map 映射 Map集合中的元素由键值访问。 Map中使用的键可以是任何类。当我们插入到Map集合中时，需要两个值：键和值。 def mapEmpty = [ : ] def mapString = [\"name\":\"andoter\",\"email\" : \"andoter0504@gmail.com\"] def mapInt = [\"name\" : 123, \"age\" : 26] 映射中的方法： void clear() boolean containsValue(Object value) Map.Entry eldest() Set> entrySet() void forEach(BiConsumer action) V get(Object key) Set keySet() Collection values() 总体上方法与 Java 中的 Map 相同。 def mapEmpty = [ : ] def mapString = [\"name\":\"andoter\", \"email\" : \"andoter0504@gmail.com\"] def mapInt = [\"name\" : 123, \"age\" : 26] mapEmpty.put(\"name\",\"andoter\") mapEmpty.values() mapString.get(\"name\") mapInt.containsValue(\"123\") mapString.each {key, value -> if(key == null || key.length() == 0) { println(\"Null Object\") } if(key.equals(\"name\")){ println(key + \"=\" + value) }else{ println(key + \":\" + value) } } Groovy中的IO操作 Java 提供了 java.io.* 一系列方法用于文件的操作，这些方法在 Groovy 中也适用。Groovy 针对 Java 提供的方法做了增强处理，更方便使用。 def file = new File(\"/Users/dengshiwei/WorkProject/GradlePlugin/groovydemo/src/main/groovy/TestGroovy.groovy\") if (file.exists()) { file.eachLine { line -> println(line) } } else { print(\"File not exist\") } 这里简单的示例下，更多的内容请参照官方 API 接口。 闭包 闭包作为 Groovy 中非常重要的特性，它使得 Groovy 语言更加灵活，在 Gradle 项目构建中，更是在 DSL 中大量被使用，所以掌握闭包的使用对掌握 Android 项目构建有非常重要的作用。 1.闭包的定义 闭包的定义格式： { parameters -> statements } 从形式上来看与 Lambda 表达式非常类似，所以熟悉 Lambda 表达式的同学上手闭包非常简单。如果闭包没有定义参数，它隐含一个参数 it,类似 Java 中的 this，假设你的闭包不需要接受参数，但是还是会生成一个隐式参数 it，只不过它的值为 null,也就是说，闭包至少包含一个参数。 无参数的闭包 def closure = { println(\"No Parameters\") } 一个参数的闭包 def closureOneParameters = { key -> println(key) } 两个参数的闭包 def closure2Parameter = { key,value-> if (key == 1) { key = key + 1 println(key + \":\" + value) } else if (key == 2) println(key + \":\" + value) } 2.闭包的特性 闭包的引入让 Groovy 语言更加简单、方便，比如作为函数的最后一个参数，闭包可以单独写在函数，本小节中介绍一下闭包常见的使用形式。 闭包特性： 闭包可以访问外部的变量，方法是不能访问外部变量的。 闭包中可以包含代码逻辑，闭包中最后一行语句，表示该闭包的返回值，不论该语句是否冠名return关键字，如果最后一行语句没有不输入任何类型，闭包将返回null。 闭包的参数声明写在‘->’符号前，调用闭包的的标准写法是：闭包名.call(闭包参数)。 闭包的一些快捷写法，当闭包作为闭包或方法的最后一个参数。可以将闭包从参数圆括号中提取出来接在最后，如果闭包是唯一的一个参数，则闭包或方法参数所在的圆括号也可以省略。对于有多个闭包参数的，只要是在参数声明最后的，均可以按上述方式省略。 闭包作为函数参数 闭包作为函数参数时，跟普通的变量参数使用方式相同。 def checkKey = { map -> if (map.size() == 0) { println(\"Parametes is Null or Empty\") } println(map) } def enqueue(key, value, closure) { def map = [:] map.put(key, value) closure(map) } enqueue(1, 2, checkKey) 通常情况下，在函数具有闭包作为参数的时候，会将闭包放在最后一个参数的位置，当闭包作为最后一个参数的时候，闭包可以抽离到函数体之外，提高函数的简洁性。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-构建/AndroidGradle插件构建流程.html":{"url":"04_Android/应用层/工程/1.工程-构建/AndroidGradle插件构建流程.html","title":"Androidgradle插件构建流程","keywords":"","body":"Android Studio Gradle插件构建流程 Gradle生命周期 Initialization（初始化阶段）：Gradle支持单项目和多项目构建。在初始化阶段，Gradle确定将要参与构建的项目，并为每个项目创建一个Project对象。通俗的说就是执行上述settings.gradle文件。 Configuration（配置阶段）：在此阶段，解析每个Project中的build.gradle文件，并生成将要执行的task。 Execution（执行阶段）：执行 task，进行主要的构建工作 APK构建流程 构建流程涉及许多将项目转换成 Android 应用软件包 (APK)的工具和流程，具体如下图所示： Android 应用模块的构建流程通常按照以下步骤执行： 编译器将您的源代码转换成 DEX 文件（Dalvik 可执行文件，其中包括在 Android 设备上运行的字节码），并将其他所有内容转换成编译后的资源； APK 打包器将 DEX 文件和编译后的资源合并到一个 APK 中。不过，在将应用安装并部署到 Android 设备之前，必须先为 APK 签名。 APK 打包器使用调试或发布密钥库为 APK 签名： a. 如果构建的是调试版应用（即专用于测试和分析的应用），则打包器会使用调试密钥库为应用签名。Android Studio 会自动使用调试密钥库配置新项目。 b. 如果构建的是打算对外发布的发布版应用，则打包器会使用发布密钥库为应用签名 在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，以减少其在设备上运行时所占用的内存。 构建流程结束时，将获得应用的调试版 APK 或发布版 APK，以用于部署、测试或发布给外部用户。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-构建/pk8&pem签名.html":{"url":"04_Android/应用层/工程/1.工程-构建/pk8&pem签名.html","title":"Pk8&pem签名","keywords":"","body":".pk8 和 .pem 文件通常用于数字证书和密钥管理，特别是在 Android 应用程序签名时，这些文件可以用来对 APK 进行签名。具体来说： .pk8 文件 .pk8 文件通常包含 私钥，即用于签名 APK 的私钥文件。私钥是一种加密密钥，它用于对数据（如 APK 文件）进行数字签名。私钥必须保持安全，只有拥有私钥的人可以签名 APK。 用途：用于数字签名。私钥和公钥配对使用，签名是由私钥完成的。 格式：.pk8 是一种二进制编码格式的私钥文件，通常由 OpenSSL 或 Android 生成。 .pem 文件 .pem 文件是一种通用的容器格式，可以包含多种类型的加密数据。通常，它用于存储 公钥、私钥、或 证书。在你的情况下，.pem 文件可能包含的是 X.509 证书（即 .x509.pem），其中包含与私钥相关联的公钥和签名。 用途： 证书：验证签名的真实性和完整性。它包含公钥和一些附加信息（如颁发者、有效期等）。 私钥/公钥：也可以用 .pem 格式保存公钥或私钥，不过通常 .pem 文件中保存的内容是以 Base64 编码的。 格式：.pem 文件是基于文本的，可以通过任何文本编辑器查看。它通常以 -----BEGIN CERTIFICATE----- 或 -----BEGIN PRIVATE KEY----- 等标识符开头。 .pk8 和 .pem 文件的关系 .pk8 (私钥)：用于签名 APK。 .pem (公钥/证书)：用于验证签名。 在 Android APK 签名的过程中，私钥用于对 APK 进行签名，而 .pem 文件（通常是 X.509 证书）则包含公钥，用来在 APK 的安装或分发过程中验证签名的有效性。 签名过程 APK 签名的过程大致如下： 使用 .pk8（私钥）对 APK 进行签名：开发者通过私钥对 APK 文件签名。 附加 .pem（证书）到 APK：公钥或证书文件会与签名信息一起附加到 APK 文件中，以便用户或设备在安装时能够验证签名。 验证签名：APK 安装时，系统会使用 .pem 中的公钥来验证该 APK 是否由拥有私钥的实体签名，并确认 APK 未被篡改。 总结 .pk8 文件：存储私钥，用于签名 APK。 .pem 文件：存储公钥（通常是 X.509 证书），用于验证签名的有效性。 在 Android 签名过程中，私钥和公钥一起确保了应用程序的安全性和完整性。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-构建/基于编译时注解的项目.html":{"url":"04_Android/应用层/工程/1.工程-构建/基于编译时注解的项目.html","title":"基于编译时注解的项目","keywords":"","body":"Fantasy Home Archives Tags Categories About Android 如何编写基于编译时注解的项目 2018-05-02 android 约 4578 字 预计阅读 10 分钟 文章目录 一、概述 在Android应用开发中，我们常常为了提升开发效率会选择使用一些基于注解的框架，但是由于反射造成一定运行效率的损耗，所以我们会更青睐于编译时注解的框架，例如： butterknife免去我们编写View的初始化以及事件的注入的代码。 EventBus3方便我们实现组建间通讯。 fragmentargs轻松的为fragment添加参数信息，并提供创建方法。 ParcelableGenerator可实现自动将任意对象转换为Parcelable类型，方便对象传输。 类似的库还有非常多，大多这些的库都是为了自动帮我们完成日常编码中需要重复编写的部分（例如：每个Activity中的View都需要初始化，每个实现Parcelable接口的对象都需要编写很多固定写法的代码）。 这里并不是说上述框架就一定没有使用反射了，其实上述其中部分框架内部还是有部分实现是依赖于反射的，但是很少而且一般都做了缓存的处理，所以相对来说，效率影响很小。 但是在使用这类项目的时候，有时候出现错误会难以调试，主要原因还是很多用户并不了解这类框架其内部的原理，所以遇到问题时会消耗大量的时间去排查。 那么，于情于理，在编译时注解框架这么火的时刻，我们有理由去学习： 如何编写一个机遇编译时注解的项目 首先，是为了了解其原理，这样在我们使用类似框架遇到问题的时候，能够找到正确的途径去排查问题；其次，我们如果有好的想法，发现某些代码需要重复创建，我们也可以自己来写个框架方便自己日常的编码，提升编码效率；最后也算是自身技术的提升。 注：以下使用IDE为Android Studio. 本文将以编写一个View注入的框架为线索，详细介绍编写此类框架的步骤。 二、编写前的准备 在编写此类框架的时候，一般需要建立多个module，例如本文即将实现的例子： ioc-annotation 用于存放注解等，Java模块 ioc-compiler 用于编写注解处理器，Java模块 ioc-api 用于给用户提供使用的API，本例为Andriod模块 ioc-sample 示例，本例为Andriod模块 那么除了示例以为，一般要建立3个module，module的名字你可以自己考虑，上述给出了一个简单的参考。当然如果条件允许的话，有的开发者喜欢将存放注解和API这两个module合并为一个module。 对于module间的依赖，因为编写注解处理器需要依赖相关注解，所以： ioc-compiler依赖ioc-annotation 我们在使用的过程中，会用到注解以及相关API 所以ioc-sample依赖ioc-api；ioc-api依赖ioc-annotation 三、注解模块的实现 注解模块，主要用于存放一些注解类，本例是模板butterknife实现View注入，所以本例只需要一个注解类： 1 2 3 4 5 6 @Retention(RetentionPolicy.CLASS) @Target(ElementType.FIELD) public @interface BindView { int value(); } 我们设置的保留策略为Class，注解用于Field上。这里我们需要在使用时传入一个id，直接以value的形式进行设置即可。 你在编写的时候，分析自己需要几个注解类，并且正确的设置@Target以及@Retention即可。 四、注解处理器的实现 定义完成注解后，就可以去编写注解处理器了，这块有点复杂，但是也算是有章可循的。 该模块，我们一般会依赖注解模块，以及可以使用一个auto-service库 build.gradle的依赖情况如下： 1 2 3 4 dependencies { compile 'com.google.auto.service:auto-service:1.0-rc2' compile project (':ioc-annotation') } auto-service库可以帮我们去生成META-INF等信息。 （1）基本代码 注解处理器一般继承于AbstractProcessor，刚才我们说有章可循，是因为部分代码的写法基本是固定的，如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @AutoService(Processor.class) public class IocProcessor extends AbstractProcessor{ private Filer mFileUtils; private Elements mElementUtils; private Messager mMessager; @Override public synchronized void init(ProcessingEnvironment processingEnv){ super.init(processingEnv); mFileUtils = processingEnv.getFiler(); mElementUtils = processingEnv.getElementUtils(); mMessager = processingEnv.getMessager(); } @Override public Set getSupportedAnnotationTypes(){ Set annotationTypes = new LinkedHashSet(); annotationTypes.add(BindView.class.getCanonicalName()); return annotationTypes; } @Override public SourceVersion getSupportedSourceVersion(){ return SourceVersion.latestSupported(); } @Override public boolean process(Set annotations, RoundEnvironment roundEnv){ } 在实现AbstractProcessor后，process()方法是必须实现的，也是我们编写代码的核心部分，后面会介绍。 我们一般会实现getSupportedAnnotationTypes()和getSupportedSourceVersion()两个方法，这两个方法一个返回支持的注解类型，一个返回支持的源码版本，参考上面的代码，写法基本是固定的。 除此以外，我们还会选择复写init()方法，该方法传入一个参数processingEnv,可以帮助我们去初始化一些父类类： Filer mFileUtils; 跟文件相关的辅助类，生成JavaSourceCode. Elements mElementUtils;跟元素相关的辅助类，帮助我们去获取一些元素相关的信息。 Messager mMessager;跟日志相关的辅助类。 这里简单提一下Elemnet，我们简单认识下它的几个子类，根据下面的注释，应该已经有了一个简单认知。 1 2 3 4 5 Element - VariableElement //一般代表成员变量 - ExecutableElement //一般代表类中的方法 - TypeElement //一般代表代表类 - PackageElement //一般代表Package （2）process的实现 process中的实现，相比较会比较复杂一点，一般你可以认为两个大步骤： 收集信息 生成代理类（本文把编译时生成的类叫代理类） 什么叫收集信息呢？就是根据你的注解声明，拿到对应的Element，然后获取到我们所需要的信息，这个信息肯定是为了后面生成JavaFileObject所准备的。 例如本例，我们会针对每一个类生成一个代理类，例如MainActivity我们会生成一个MainActivity$$ViewInjector。那么如果多个类中声明了注解，就对应了多个类，这里就需要： 一个类对象，代表具体某个类的代理类生成的全部信息，本例中为ProxyInfo 一个集合，存放上述类对象（到时候遍历生成代理类），本例中为Map，key为类的全路径。 这里的描述有点模糊没关系，一会结合代码就好理解了。 a.收集信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private Map mProxyMap = new HashMap(); @Override public boolean process(Set annotations, RoundEnvironment roundEnv){ mProxyMap.clear(); Set elements = roundEnv.getElementsAnnotatedWith(BindView.class); //一、收集信息 for (Element element : elements){ //检查element类型 if (!checkAnnotationUseValid(element)){ return false; } //field type VariableElement variableElement = (VariableElement) element; //class type TypeElement typeElement = (TypeElement) variableElement.getEnclosingElement();//TypeElement String qualifiedName = typeElement.getQualifiedName().toString(); ProxyInfo proxyInfo = mProxyMap.get(qualifiedName); if (proxyInfo == null){ proxyInfo = new ProxyInfo(mElementUtils, typeElement); mProxyMap.put(qualifiedName, proxyInfo); } BindView annotation = variableElement.getAnnotation(BindView.class); int id = annotation.value(); proxyInfo.mInjectElements.put(id, variableElement); } return true; } 首先我们调用一下mProxyMap.clear();，因为process可能会多次调用，避免生成重复的代理类，避免生成类的类名已存在异常。 然后，通过roundEnv.getElementsAnnotatedWith拿到我们通过@BindView注解的元素，这里返回值，按照我们的预期应该是VariableElement集合，因为我们用于成员变量上。 接下来for循环我们的元素，首先检查类型是否是VariableElement. 然后拿到对应的类信息TypeElement，继而生成ProxyInfo对象，这里通过一个mProxyMap进行检查，key为qualifiedName即类的全路径，如果没有生成才会去生成一个新的，ProxyInfo与类是一一对应的。 接下来，会将与该类对应的且被@BindView声明的VariableElement加入到ProxyInfo中去，key为我们声明时填写的id，即View的id。 这样就完成了信息的收集，收集完成信息后，应该就可以去生成代理类了。 b.生成代理类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Override public boolean process(Set annotations, RoundEnvironment roundEnv){ //...省略收集信息的代码，以及try,catch相关 for(String key : mProxyMap.keySet()){ ProxyInfo proxyInfo = mProxyMap.get(key); JavaFileObject sourceFile = mFileUtils.createSourceFile( proxyInfo.getProxyClassFullName(), proxyInfo.getTypeElement()); Writer writer = sourceFile.openWriter(); writer.write(proxyInfo.generateJavaCode()); writer.flush(); writer.close(); } return true; } 可以看到生成代理类的代码非常的简短，主要就是遍历我们的mProxyMap，然后取得每一个ProxyInfo，最后通过mFileUtils.createSourceFile来创建文件对象，类名为proxyInfo.getProxyClassFullName()，写入的内容为proxyInfo.generateJavaCode(). 看来生成Java代码的方法都在ProxyInfo里面。 c.生成Java代码 这里我们主要关注其生成Java代码的方式。 下面主要看生成Java代码的方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #ProxyInfo //key为id，value为对应的成员变量 public Map mInjectElements = new HashMap(); public String generateJavaCode(){ StringBuilder builder = new StringBuilder(); builder.append(\"package \" + mPackageName).append(\";\\n\\n\"); builder.append(\"import com.zhy.ioc.*;\\n\"); builder.append(\"public class \").append(mProxyClassName).append(\" implements \" + SUFFIX + \"\"); builder.append(\"\\n{\\n\"); generateMethod(builder); builder.append(\"\\n}\\n\"); return builder.toString(); } private void generateMethod(StringBuilder builder){ builder.append(\"public void inject(\"+mTypeElement.getQualifiedName()+\" host , Object object )\"); builder.append(\"\\n{\\n\"); for(int id : mInjectElements.keySet()){ VariableElement variableElement = mInjectElements.get(id); String name = variableElement.getSimpleName().toString(); String type = variableElement.asType().toString() ; builder.append(\" if(object instanceof android.app.Activity)\"); builder.append(\"\\n{\\n\"); builder.append(\"host.\"+name).append(\" = \"); builder.append(\"(\"+type+\")(((android.app.Activity)object).findViewById(\"+id+\"));\"); builder.append(\"\\n}\\n\").append(\"else\").append(\"\\n{\\n\"); builder.append(\"host.\"+name).append(\" = \"); builder.append(\"(\"+type+\")(((android.view.View)object).findViewById(\"+id+\"));\"); builder.append(\"\\n}\\n\"); } builder.append(\"\\n}\\n\"); } 这里主要就是靠收集到的信息，拼接完成的代理类对象了，看起来会比较头疼，不过我给出一个生成后的代码，对比着看会很多。 1 2 3 4 5 6 7 8 9 10 11 12 13 package com.zhy.ioc_sample; import com.zhy.ioc.*; public class MainActivity$$ViewInjector implements ViewInjector{ @Override public void inject(com.zhy.sample.MainActivity host , Object object ){ if(object instanceof android.app.Activity){ host.mTv = (android.widget.TextView)(((android.app.Activity)object).findViewById(2131492945)); } else{ host.mTv = (android.widget.TextView)(((android.view.View)object).findViewById(2131492945)); } } } 这样对着上面代码看会好很多，其实就死根据收集到的成员变量（通过@BindView声明的），然后根据我们具体要实现的需求去生成java代码。 这里注意下，生成的代码实现了一个接口ViewInjector，该接口是为了统一所有的代理类对象的类型，到时候我们需要强转代理类对象为该接口类型，调用其方法；接口是泛型，主要就是传入实际类对象，例如MainActivity，因为我们在生成代理类中的代码，实际上就是实际类.成员变量的方式进行访问，所以，使用编译时注解的成员变量一般都不允许private修饰符修饰（有的允许，但是需要提供getter,setter访问方法）。 这里采用了完全拼接的方式编写Java代码，你也可以使用一些开源库，来通过Java api的方式来生成代码，例如： javapoet. A Java API for generating .java source files. 到这里我们就完成了代理类的生成，这里任何的注解处理器的编写方式基本都遵循着收集信息、生成代理类的步骤。 五、API模块的实现 有了代理类之后，我们一般还会提供API供用户去访问，例如本例的访问入口是 1 2 3 4 //Activity中 Ioc.inject(Activity); //Fragment中，获取ViewHolder中 Ioc.inject(this, view); 模仿了butterknife，第一个参数为宿主对象，第二个参数为实际调用findViewById的对象；当然在Actiivty中，两个参数就一样了。 API一般如何编写呢？ 其实很简单，只要你了解了其原理，这个API就干两件事： 根据传入的host寻找我们生成的代理类：例如MainActivity->MainActity$$ViewInjector。 强转为统一的接口，调用接口提供的方法。 这两件事应该不复杂，第一件事是拼接代理类名，然后反射生成对象，第二件事强转调用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Ioc{ public static void inject(Activity activity){ inject(activity , activity); } public static void inject(Object host , Object root){ Class clazz = host.getClass(); String proxyClassFullName = clazz.getName()+\"$$ViewInjector\"; //省略try,catch相关代码 Class proxyClazz = Class.forName(proxyClassFullName); ViewInjector viewInjector = (com.zhy.ioc.ViewInjector) proxyClazz.newInstance(); viewInjector.inject(host,root); } } public interface ViewInjector{ void inject(T t , Object object); } 代码很简单，拼接代理类的全路径，然后通过newInstance生成实例，然后强转，调用代理类的inject方法。 这里一般情况会对生成的代理类做一下缓存处理，比如使用Map存储下，没有再生成，这里我们就不去做了。 这样我们就完成了一个编译时注解框架的编写。 六、总结 本文通过具体的实例来描述了如何编写一个基于编译时注解的项目，主要步骤为：项目结构的划分、注解模块的实现、注解处理器的编写以及对外公布的API模块的编写。通过文本的学习应该能够了解基于编译时注解这类框架运行的原理，以及自己如何去编写这样一类框架。 *源码地址: https://github.com/hymanAndroid/ioc-apt-sample 文章作者 Fantasy 上次更新 2018-05-02 许可协议 CC BY-NC-ND 4.0 android 注解 Android AbstractProcessor和apt环境配置Android USB 冲突问题 LikeIssue Page Error: Comments Not Initialized Write Preview Login with GitHub Styling with Markdown is supportedComment Powered by Gitment Powered by Hugo | Theme - Jane© 2018 - 2019 Fantasy No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/工程/1.工程-构建/签名-问题解决.html":{"url":"04_Android/应用层/工程/1.工程-构建/签名-问题解决.html","title":"签名-问题解决","keywords":"","body":"Gradle使用pk8&x509.pem进行签名的方法 将pk8&pem转换为p12文件，使用android{signingConfigs{}}配置 用pk8生成pem文件 openssl pkcs8 -inform DER -nocrypt -in platform.pk8 -out platform.pem 用x509.pem和pk8生成p12文件 openssl pkcs12 -export -in platform.x509.pem -inkey platform.pem -out platform.p12 -name androiddebugkey 用p12生成keystore文件 keytool -importkeystore -srckeystore platform.p12 -srcstoretype PKCS12 -destkeystore platform.jks -deststoretype JKS 第二步输入的密钥库口令在第三步不可用，在gradle中也不可用 --> keytool有问题，相关链接：Gradle使用pk8&pem进行签名的方法：https://blog.csdn.net/wengliuhu/article/details/128186229 新建Gradle Task用Cmd命令进行签名，这个Task也要配置到yml里，让CICD生成的apk最后签名正确 --> 找不到apksigner，报错： Caused by: java.io.IOException: Cannot run program \"apksigner\" (in directory \"D:.demo\\ControlProxy\\CICD_T6Y\\ControlProxy4China\\app\"): CreateProcess error=2, 系统找不到指定的文件。 at net.rubygrapefruit.platform.internal.DefaultProcessLauncher.start(DefaultProcessLauncher.java:25) No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/常用代码.html":{"url":"04_Android/应用层/常用代码.html","title":"常用代码","keywords":"","body":"if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { // 在API级别21及以上执行的代码 } else { // 在API级别21以下执行的代码 } No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/应用架构/Android单例模式.html":{"url":"04_Android/应用层/应用架构/Android单例模式.html","title":"Android单例模式","keywords":"","body":"android 单例模式 单例模式的实现方式有懒汉，饿汉，双重校验锁，枚举，内部类等等，写法就不全部列举了。Android源码中一个单例辅助类/frameworks/base/core/java/android/util/Singleton.java，可以实现懒汉式单例，写法挺奇特的，虽然是个hide类，不过拷贝出来就可以用了。 package android.util; /** * Singleton helper class for lazily initialization. * * Modeled after frameworks/base/include/utils/Singleton.h * * @hide */ public abstract class Singleton { private T mInstance; protected abstract T create(); public final T get() { synchronized (this) { if (mInstance == null) { mInstance = create(); } return mInstance; } } } 正常懒汉单例 public class SingletonDemo { private static SingletonDemo mInstance; public static final SingletonDemo get() { synchronized (SingletonDemo.class) { if (mInstance == null) { mInstance = new SingletonDemo(); } return mInstance; } } } 懒汉+双重校验单例 public class SingletonDemo { private static SingletonDemo mInstance; public static final SingletonDemo get() { if (mInstance == null) { synchronized (SingletonDemo.class) { if (mInstance == null) { mInstance = new SingletonDemo(); } } } return mInstance; } } 变种懒汉单例 `` public class SingletonDemo { public static final SingletonDemo get() { return INSTANCE.get(); } private static final Singleton INSTANCE = new Singleton() { protected SingletonDemo create() { return new SingletonDemo(); } }; } ``` 懒汉式单例一般都会再加个双重校验的判断，避免每次调用get()都加锁，影响性能，Android源码中Singleton.java工具类并没有做双重校验（看了下googlesource中的Singleton.java，也是6年前提交的代码了），所以我们在将Singleton.java拷贝出来使用的时候可以加个双重校验优化下。Singleton.java封装了create，get模版，及get中的校验逻辑，从而SingletonDemo中的实现代码就可以更加的简单：1.create()一个单例对象，2.在需要的时候get()。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/应用架构/App的几种架构.html":{"url":"04_Android/应用层/应用架构/App的几种架构.html","title":"App的几种架构","keywords":"","body":"前言 复杂的软件必须有清晰合理的架构，否则无法开发和维护。你能想象你把一个软件的几乎所有代码都堆在一个文件里吗？一个文件上万行，你让后期的人员如何开发维护呢？ MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解。同时它与衍生的 MVP 和 MVVM 架构也有着一定的区别。 MVC MVC最最主要的思想就是分层，不再大杂烩了。MVC模式的意思是，软件可以分成三个部分： 视图（View）：用户界面，专门用来控制页面的。 控制器（Controller）：业务逻辑，用来获取用户的输入，操作 M 和 V，说白了就是调用 M 和 V 中的方法。 模型（Model）：用来专门用来做一些和数据（增删改查）有关的逻辑。 MVC互动方式 至于它们之间的具体相互关系，就看你具体代码的体现，并没有一个书面话的定义，最常见的是这种： 所有通信都是单向的： View ：接受用户指令，传送指令到 Controller。 Controller ：完成业务逻辑后，要求 Model 改变状态。 Model ：将新的数据发送到 View，用户得到反馈。 但MVC在真正大型运用的时候，最接近这种： 也就是说如果不触及复杂逻辑或者数据的情况下，一些简单逻辑就直接在Controller处理了，然后 Controller 再作用于 View 。还有一点就是MVC中View是可以和 Model 直接进行交流的。 MVP 如果非要切断 Model 和 View 之间的关系的话，那样就演变成 MVP 了。MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为\"被动视图\"（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 MVP产生的原因 MVC 架构方式虽然比之前的大杂烩好很多，但是 M C 之间相互依赖过多，由于 View 可以和 Model 直接通信，这就造成了 View 既依赖于 Controller 又依赖于 Model 。Controller 同样依赖于 View 和 Model。耦合性还是太高，于是进行了进一步的优化处理。让 M 和 V 彻底断了联系，只通过 P 来进行通信。 MVVM MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding），View的变动，自动反映在 ViewModel，反之亦然。 举个例子，用户登录时，ViewModel差不多是这个样子的： java复制代码public class UserViewModel(){ String username; String password; } 当用户在界面上点击「登录」按钮的时候，只需要对 UserViewModel 做出改变就行了。View 会根据 ViewModel 的变化自动更新，不用手工去设置。 MVVM产生的原因 MVP 使用一段时间后，发现让 View 调用 Presenter 的方法去设置界面，仍然需要大量的、烦人的代码。 于是提出：能不能告诉 View 一个数据结构，然后 View 就能根据这个数据结构变化而自动随之变化呢？ 于是有了一个叫 ViewModel 的东西，它可以和 View 层绑定。ViewModel 的变化，View 立刻就会变化。 总结 再次强调上面讲的都是 MVC MVP MVVP 大的设计思路，具体到不同的语言程序体现起来是不同的，没有准确的定义，具体的书写方式要根据开发者自己的思想来定义。目的就是让代码不同功能间相互独立，可阅读性强，便于扩充和重复利用。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/应用架构/MVVM和MVP.html":{"url":"04_Android/应用层/应用架构/MVVM和MVP.html","title":"Mvvm和mvp","keywords":"","body":"MVVM（Model-View-ViewModel） MVVM 模式包括以下三个主要组件： Model（模型）： 负责处理数据和业务逻辑。 View（视图）： 用户界面，负责显示数据并与用户交互。 ViewModel（视图模型）： 作为 View 和 Model 之间的中介，处理 View 的展示逻辑和用户输入，并与 Model 进行交互。 在 MVVM 中，View 和 ViewModel 之间通过数据绑定进行通信，这意味着 View 的状态会自动更新以反映 ViewModel 中的状态，反之亦然。 下面是一个简单的 Android 示例： public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } } // ViewModel public class UserViewModel extends ViewModel { private MutableLiveData userLiveData = new MutableLiveData<>(); public void setUser(String name) { User user = new User(name); userLiveData.setValue(user); } public LiveData getUser() { return userLiveData; } } // View (Activity) public class MainActivity extends AppCompatActivity { private TextView textView; private UserViewModel viewModel; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); viewModel = new ViewModelProvider(this).get(UserViewModel.class); viewModel.getUser().observe(this, user -> { textView.setText(user.getName()); }); viewModel.setUser(\"John Doe\"); } } MVP（Model-View-Presenter） MVP 模式包括以下三个主要组件： Model（模型）： 负责处理数据和业务逻辑。 View（视图）： 用户界面，负责显示数据并与用户交互。 Presenter（主持人）： 作为 View 和 Model 之间的中介，负责处理用户输入，并根据需要更新 View 和 Model。 在 MVP 中，View 通常会持有 Presenter 的引用，并通过接口与 Presenter 进行通信，Presenter 则通过接口与 View 进行通信。 下面是一个简单的 Android 示例： public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } } // Presenter public class UserPresenter { private User user; private UserView view; public UserPresenter(UserView view) { this.view = view; } public void setUser(String name) { user = new User(name); view.updateUserInfo(user); } } // View (Activity) public class MainActivity extends AppCompatActivity implements UserView { private TextView textView; private UserPresenter presenter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); presenter = new UserPresenter(this); presenter.setUser(\"John Doe\"); } @Override public void updateUserInfo(User user) { textView.setText(user.getName()); } } // View 接口 public interface UserView { void updateUserInfo(User user); } 总的来说，MVVM 和 MVP 都旨在通过解耦视图逻辑和业务逻辑来提高应用程序的可维护性和可测试性，但它们的实现方式略有不同。MVVM 通过数据绑定来实现视图和视图模型之间的通信，而 MVP 则通过接口来实现视图和主持人之间的通信。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/应用层/应用架构/REFERS.html":{"url":"04_Android/应用层/应用架构/REFERS.html","title":"Refers","keywords":"","body":" 21世纪高等学校计算机类课程创新规划教材 Android Studio应用程序设计 第2版 微课版_14332842 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/":{"url":"04_Android/框架层/","title":"4-1.框架层-基础与源码","keywords":"","body":"框架层 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-1.框架层-基础与源码/1-1.Android系统流程.html":{"url":"04_Android/框架层/4-1.框架层-基础与源码/1-1.Android系统流程.html","title":"1-1.android系统流程","keywords":"","body":"Android系统启动的流程 Step1：启动电源及系统启动 当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行。 Step2：引导程序 引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针对特定的主板与芯片的。设备制造商要么使用很受欢迎的引导程序比如redboot、uboot、qibootloader或者开发自己的引导程序，它不是Android操作系统的一部分。引导程序是OEM厂商或者运营商加锁和限制的地方。 引导程序分两个阶段执行： 第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序； 第二个阶段，引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。 Android引导程序可以在\\bootable\\bootloader\\legacy\\usbloader找到。传统的加载器包含两个文件，需要在这里说明： init.s初始化堆栈，清零BBS段，调用main.c的_main()函数； 初始化堆栈：在系统启动时，处理器需要有一个堆栈来执行函数调用。init.s中的代码会在开始时设置处理器的堆栈指针，以确保后续的代码有足够的栈空间进行正常操作。 清零BSS段：BSS段是用于存储未初始化的全局变量的内存区域。清零BSS段确保所有变量在首次使用之前为零，避免残留的数据导致意外行为。 调用_main()函数：完成初始化后，init.s会调用main.c文件中的_main()函数，这样可以将控制权传递给更高级别的启动逻辑。 main.c初始化硬件（闹钟、主板、键盘、控制台），创建Linux标签 初始化硬件：main.c文件主要负责设备的硬件初始化，包括设置关键的外设和子系统。 闹钟：初始化时钟模块，使系统拥有一个基本的计时功能，保证各模块能够正确同步。 主板：初始化主板上的关键部件，以保证基本硬件可以被正确识别和使用。 键盘：如果系统有键盘设备，在这里进行初始化，以便后续用户交互。 控制台：初始化控制台，通常是串口或显示输出，用于显示调试信息或者状态信息。 创建Linux标签：在启动完成硬件初始化后，main.c会创建Linux标签（boot tags）。这些标签包含了启动内核所需的关键信息，比如内存布局、根文件系统位置等。标签通常被传递给Linux内核，以便内核可以正确解析系统状态并完成启动过程。 Step3：内核 Android内核与桌面Linux内核的启动方式差不多。内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找“init”文件，然后启动root进程或者系统的第一个进程 Step4：init进程 init进程时Linux系统中用户空间的第一个进程，进程号固定为1。Kernel启动后，在用户空间启动init进程，并调用init中的main() 方法执行init进程的职责。 Step5：启动Launcher App No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-1.框架层-基础与源码/1-2.init.c.html":{"url":"04_Android/框架层/4-1.框架层-基础与源码/1-2.init.c.html","title":"1-2.init.c","keywords":"","body":"概念解析 1. init 进程 定义：init 是 Android 的第一个用户态进程（PID 为 1），由内核启动。它是系统启动流程的起点，负责初始化系统的基本资源和服务。 功能： 挂载必要的文件系统。 解析配置文件（通常是 init.rc 文件及其包含的脚本）。 启动必要的守护进程和服务（如 zygote、surfaceflinger 等）。 设置系统属性和环境变量。 管理系统服务的生命周期。 2. init.c 定义：init.c 是 Android 中 init 进程的实现文件，通常位于 Android 源码的 system/core/init/ 路径下。 作用： 定义了 init 进程的主逻辑，包括初始化、解析配置文件、启动服务等核心功能。 包含与设备初始化相关的关键代码，比如： 文件系统挂载。 系统属性设置。 解析 .rc 文件（如 init.rc）。 通过事件循环机制监控服务状态，并根据需求重启服务或执行其他动作。 核心函数： main()：init 进程的入口函数。 init_parse_config_file()：解析 .rc 文件。 service_start() 和 service_stop()：启动或停止服务。 3. init.rc 定义：init.rc 是 init 进程的配置文件，使用了一种专门的语法，用于定义系统初始化的行为。 作用： 指定系统服务的启动顺序、依赖关系和启动条件。 定义环境变量和系统属性。 配置挂载点和文件系统权限。 管理服务生命周期（如 on, service, import 指令）。 典型结构： on boot # 定义在引导阶段执行的操作 mount all /fstab.xxx start zygote service zygote /system/bin/app_process class main user root group system seclabel u:r:zygote:s0 import /init.xxx.rc 常见指令： on: 定义触发条件（如 on boot）。 service: 定义服务，包括服务路径、运行参数、权限等。 import: 导入其他配置文件。 setprop: 设置系统属性。 三者关系 init.c 是 init 进程的代码实现，是程序逻辑的核心。 init 进程是由 init.c 编译生成的可执行程序，负责执行系统初始化任务。 init.rc 是 init 进程的配置文件，定义了初始化流程和服务管理的具体行为。 init进程分析 服务启动机制 system/core/init/init.c文件main函数中parse_config_file(init.rc)读取并解析init.rc文件内容。将service信息放置到system/core/init/init_parser.cpp的service_list中 system/core/init/init.c文件main函数继续执行restart_service_if_needed(…) -> service_start(…) -> Execve(…)建立service进程； 总体启动框架图： init进程承担了在用户空间和内核空间建立通讯的初始工作 在Linux系统中，init程序是操作系统启动过程中非常重要的一环，承担了在用户空间和内核空间之间建立通讯的初始工作。 内核空间（Kernel Space） 操作系统核心代码运行的区域，拥有对硬件资源的完全控制权限。 内核空间包含了操作系统的内核代码，包括管理硬件资源、处理系统调用、管理内存、调度进程、处理中断等。 权限级别为Ring 0 用户空间（User Space） 用户应用程序运行的区域，用户程序在该区域中执行并访问资源。 用户空间运行普通应用程序，比如浏览器、文本编辑器、命令行工具等。它隔离于内核空间，用户程序通常不能直接访问硬件资源。 用户空间的权限级别较低（Ring 3） 用户空间中的程序需要通过系统调用向内核请求资源（例如文件读写、内存分配、网络访问等）。系统调用是一种接口，用于桥接用户空间和内核空间的交互。 用户空间和内核空间之间的通讯机制多种多样，包括： 设备文件（位于/dev目录）：设备驱动程序通过这些文件来与硬件交互。 内存文件系统（如/proc和/sys）：这些目录下的文件和目录提供系统的内存信息、进程信息、配置参数等，通过这些接口，用户可以读取和修改系统状态。 这些文件都是在用户空间中提供的接口，但背后的数据和逻辑是由内核空间支持的。通过这种设计，用户可以简单地通过读取或写入文件来与内核交互，而不需要直接调用内核函数。 一切皆文件的特性 Linux系统的一个重要设计理念是“一切皆文件”。这意味着系统中的所有资源，包括硬件设备、内存、系统信息等，都通过文件的形式呈现给用户。通过这种设计，用户和应用程序可以通过文件接口与硬件和内核进行交互，提供了高度的抽象和便利。 例如，设备通常通过文件的形式来访问，比如/dev/sda代表一个磁盘设备，/dev/tty代表一个终端设备。内存信息、系统状态等也通过/proc和/sys目录提供给用户。 终端设备的类型 物理终端（硬件终端）： 传统上，终端设备是指像键盘、显示器或串行接口设备这样的物理硬件。 这些设备通过串口（如 /dev/ttyS0）或其他接口连接到计算机，用于输入和输出数据。 虚拟终端（伪终端）： 在现代系统中，大多数终端是虚拟的，运行在软件层之上。 常见的虚拟终端包括： 文本控制台：如通过快捷键 Ctrl+Alt+F1 切换到的 TTY（如 /dev/tty1, /dev/tty2）。 伪终端（Pseudo Terminal, PTY）：如通过 SSH、telnet 等远程登录工具建立的终端会话（如 /dev/pts/0, /dev/pts/1）。 终端模拟器：图形界面中的终端，如 GNOME Terminal、xterm 等，它们通过伪终端设备提供终端功能。 串行设备终端： 通过串行接口（如 RS-232）连接的设备，通常用于调试嵌入式系统或其他硬件（如 /dev/ttyS0, /dev/ttyUSB0）。 init 程序的组成和源代码目录 init 程序是由多组源代码文件编译生成的一个可执行程序，其中的核心文件是 system/core/init/init.c。这个文件是 init 程序的入口点，定义了启动过程中的关键函数和逻辑，尤其是 main 函数。 init.c 文件非常大，包含了服务启动、属性设置、系统调用、文件系统挂载等众多功能模块，因此代码相对复杂。 除了 init.c 文件外，init 程序还依赖多个其他源文件，这些文件在 system/core/init/ 目录中，处理不同的功能，如属性服务管理、资源管理、进程监控等。 init.c 是 Android init 程序的主入口文件，其中的 main 函数是 init 的启动流程的核心部分。 main 函数负责从根本上完成系统的初始化工作，包括： 文件系统的挂载：根据 init.rc 文件的定义，挂载根目录和其他必要的文件系统。 系统属性的加载和设置：解析 init.rc 文件中的属性设置，并应用到系统中。 启动关键服务：如启动 servicemanager、zygote、logd 等，确保系统服务的正常运行。 进程和资源管理：初始化进程间通信、创建子进程、管理内存等。 启动过程 Boot Timing（启动时间） init 记录了启动过程中的一些重要时间信息，并将其保存在系统属性中。这些信息有助于分析系统启动过程中的不同阶段所消耗的时间。 系统属性： ro.boottime.init 启动后，init 程序的第一阶段启动时间（以纳秒为单位，通过 CLOCK_BOOTTIME 时钟）。 ro.boottime.init.first_stage 第一步启动（即第一阶段）的持续时间，以纳秒为单位。 ro.boottime.init.selinux SELinux 阶段的运行时间，以纳秒为单位。该阶段通常涉及加载和配置 SELinux 策略。 ro.boottime.init.modules 加载内核模块的时间，以毫秒为单位。 ro.boottime.init.cold_boot_wait init 等待 ueventd 的冷启动阶段完成的时间，以纳秒为单位。 ro.boottime. 启动指定服务的时间（以纳秒为单位）。service-name 代表服务的名称，启动时间是指从系统启动后到服务首次启动的时间。 这些时间属性帮助开发者和系统管理员了解每个阶段和服务启动的时间，便于优化启动过程。 Bootcharting（启动图生成） Bootcharting 是一种记录启动过程的日志工具，能生成启动过程的图表，以便后续分析。 如何启用 Bootcharting： 在模拟器上： 使用 -bootchart timeout 选项，在启动时启用启动图生成（timeout 是以秒为单位的超时设置）。 在设备上： 通过以下命令启用 bootcharting： adb shell 'touch /data/bootchart/enabled' 启用后，日志文件将会写入 /data/bootchart/ 目录。启用后记得删除该文件： rm /data/bootchart/enabled 如何获取启动图： 启动图数据会被保存在 /data/bootchart/，可以使用提供的脚本来提取数据并创建 bootchart.tgz 文件，供 bootchart 工具使用： sudo apt-get install pybootchartgui $ANDROID_BUILD_TOP/system/core/init/grab-bootchart.sh grab-bootchart.sh 会使用 $ANDROID_SERIAL 环境变量，因此需要确保正确设置。如果没有在启动过程中看到 init 从零秒开始运行，需要参考 dmesg 输出来确定内核实际启动 init 的时间。 比较两个 Bootcharts（比较两个启动图） compare-bootcharts.py 是一个实用脚本，用于比较两个启动图的时间差。通过该脚本，可以看到在两个不同启动实例之间，进程启动的时间差异。 使用方法： system/core/init/compare-bootcharts.py base-bootchart-dir exp-bootchart-dir 其中，base-bootchart-dir 和 exp-bootchart-dir 是存放两个 bootchart 文件的目录，脚本会显示每个进程的启动时间差异。 示例输出： process: baseline experiment (delta) - Unit is ms (a jiffy is 10 ms on the system) ------------------------------------ /init: 50 40 (-10) /system/bin/surfaceflinger: 4320 4470 (+150) ... bootanimation ends at: 33790 31230 (-2560) 每一行显示了进程的启动时间差异（单位为毫秒）。 负数表示实验版本启动较快，正数表示实验版本启动较慢。 通过比较，可以直观地看出哪些进程启动时间有明显变化，这对于优化系统启动过程非常有帮助。 调试 Systrace (系统追踪) Systrace 是一种用于在 Android 设备的启动过程中进行性能分析的工具。它可以生成启动期间的性能报告，并帮助开发者定位系统启动中的瓶颈。Systrace 在 userdebug 或 eng 构建版本中可用。 使用方法： 例如，执行以下命令可以追踪与 wm（窗口管理器）和 am（活动管理器）相关的事件： $ANDROID_BUILD_TOP/external/chromium-trace/systrace.py wm am --boot 命令解释： wm am：表示追踪窗口管理器 (wm) 和活动管理器 (am) 事件。 --boot：表示追踪启动过程中的事件。 执行该命令时，设备会重启。设备重启并完成启动序列后，命令会结束，生成的跟踪报告会以 trace.html 格式写入主机，按下 Ctrl+C 即可完成。 限制： 跟踪的开始时间： 跟踪事件是在持久属性加载之后开始记录的，因此，在此之前触发的事件不会被记录。包括 vold、surfaceflinger 和 servicemanager 等服务的启动，通常会在持久属性加载之前启动，因此它们的事件不会被记录。 影响： 例如，Zygote 初始化和从 Zygote 派生的进程不受此限制影响，因为它们的事件会在持久属性加载后被记录。 Debugging Init（调试 Init） init 启动的服务有时可能无法正常执行（execv()），这通常意味着在启动新服务时，链接器出现了问题。Android 的链接器会将其日志输出到 logd 和标准错误流（stderr），这些日志可以通过 logcat 访问。如果在访问 logcat 之前发生错误，可以使用 stdio_to_kmsg 服务选项，将链接器打印的日志转储到 kmsg，这样可以通过串口读取。 调试服务启动： 启动 init 服务时，通常不建议绕过 init 来启动服务，因为 init 会设置重要的环境变量（如用户、组、安全标签、能力等），这些环境变量不容易手动复制。 如果确实需要调试某个服务的启动，可以使用 sigstop 服务选项。这将使 init 在调用 exec 前向该服务发送 SIGSTOP 信号。这样可以给开发者一个机会，在继续执行服务之前，使用调试器（如 gdb 或 strace）进行调试。 示例： 调试 logd 服务，使用 sigstop 标记： stop logd setprop ctl.sigstop_on logd start logd ps -e | grep logd 这时可以用 gdb 或 strace 附加到该进程： gdbclient.py -p 4343 或者使用 strace： strace -p 4343 kill -SIGCONT 4343 通过这种方式，开发者可以在服务启动之前进行详细调试。 Host Init Script Verification（主机端初始化脚本验证） 在构建期间，init 脚本会经过以下几个方面的检查，以确保其正确性： 格式检查： 确保每个 action、service 和 import 部分格式正确。例如，action 需要在前面有 on 行，import 语句后不能有额外的行。 命令和参数检查： 检查命令是否映射到有效的关键字，并且参数数量是否在正确范围内。 服务选项有效性检查： 需要确保服务选项有效。比如 UID 和 GID 必须能解析。 但以下部分只会在运行时进行检查，因此构建时不会进行验证： 命令参数的有效性检查： 比如不会检查文件路径是否存在、SELinux 是否允许该操作，或者 UID 和 GID 是否能够解析。 服务存在性检查： 不会检查服务是否存在或者是否有有效的 SELinux 域定义。 多次定义检查： 不会检查某个服务是否已经在不同的 init 脚本中定义过。 Early Init Boot Sequence（早期初始化启动序列） Android 的启动过程分为三个主要阶段： 第一阶段初始化（First Stage Init） 负责设置加载其余系统所需的最小环境。具体包括： 挂载 /dev、/proc 等虚拟文件系统。 挂载“早期挂载”分区（例如包含系统代码的 system 和 vendor 分区）。 如果设备有 ramdisk，则将 system.img 挂载到 /。 SELinux 设置 在第一阶段初始化完成后，init 执行 SELinux 设置，这一步是可选的，取决于设备是否启用了 SELinux。 第二阶段初始化（Second Stage Init） 当 SELinux 设置完成后，init 会再次执行，进入第二阶段。此时，init.rc 脚本开始执行，继续完成启动过程。 设备配置： System-as-Root 设备： 这些设备的第一阶段 init 是 /system/bin/init，并且 /init 是指向 /system/bin/init 的符号链接。 带 ramdisk 的设备： 第一阶段 init 是一个静态可执行文件，位于 /init，该设备会先挂载 system.img，然后执行 root 切换操作，将 /system 移动到 /。 使用恢复模式作为 ramdisk 的设备： 第一阶段 init 包含在恢复 ramdisk 内，设备先切换根目录到 /firststageramdisk，然后再按第二阶段的步骤进行启动。 通过这些阶段，init 确保了系统能够顺利启动并加载必要的服务和配置。 init.c源码分析 精炼源码分析（以后在更新的源码上再看一次）： ueventd主要负责设备节点的创建、权限设定等一系列工作；watchdogd用于系统出问题时重启系统 如果参数同时从命令行和DT传过来，DT的优先级总是大于命令行的 在 Android 中，\"Device Tree\"（设备树）通常是指 Android 操作系统的设备树机制。设备树是一种用于描述硬件设备和其连接关系的数据结构，它被广泛用于嵌入式系统中，包括 Android 设备。 Android 设备树的主要目的是为了在 Linux 内核中动态描述和配置硬件设备。设备树通常以一种类似于 XML 的结构进行描述，其中包含了有关系统硬件、设备、中断、总线等信息的详细描述。 主要的 Android 设备树文件是 dts（设备树源）文件，它们编译成 dtb（设备树二进制）文件，然后由 Linux 内核加载并解释。设备树的使用允许 Android 操作系统在多种硬件平台上运行，而无需为每个平台定制和编译一个特定的内核。 Android 设备树包括以下方面的信息： 硬件组件： 描述了处理器、内存、外设等硬件组件的信息。 中断： 描述了系统中各种中断的分配和连接。 总线： 描述了系统中使用的总线，如 I2C、SPI、PCI 等。 设备： 描述了连接到系统的各种设备，如传感器、摄像头、显示器等。 通过使用设备树，Android 能够更容易地适应各种硬件配置，使其更加灵活和可移植。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-1.框架层-基础与源码/1-3.init.rc.html":{"url":"04_Android/框架层/4-1.框架层-基础与源码/1-3.init.rc.html","title":"1-3.init.rc","keywords":"","body":"init.rc 简介 init.rc 文件是 Android 系统初始化过程中必不可少的配置文件，它并不是程序代码文件，而是一个基于特定语法的配置文件，用于定义系统启动时需要初始化的进程和服务。 这些 .rc 文件包含了一些系统服务和守护进程的启动命令、系统属性的设定、文件系统的挂载信息等，init 程序会解析这些配置文件并根据内容执行相应的操作。 Init .rc 文件的组织结构 核心文件： /system/etc/init/hw/init.rc 是系统启动时加载的第一个文件，负责初始化系统。 扩展文件： Init 会从以下目录加载其他 .rc 文件： /system/etc/init/：核心系统服务（如 SurfaceFlinger、MediaService）。 /vendor/etc/init/：SoC 供应商相关服务（如硬件驱动相关的守护进程）。 /odm/etc/init/：设备制造商相关服务（如传感器驱动相关服务）。 不同的 init.rc 文件 在 Android 系统中，存在多个不同的 init.rc 文件，每个文件用于不同的启动场景。主要有以下两个关键的 init.rc 文件： ./system/core/rootdir/init.rc 这是系统正常启动时使用的主要配置文件。它定义了 Android 系统正常启动时的初始化流程，包括挂载文件系统、启动关键服务（如 zygote、surfaceflinger）、设置系统属性等。 当系统正常启动时，init 程序会读取和解析该文件，按照其中的定义逐步完成系统初始化并进入主界面。 ./bootable/recovery/etc/init.rc 这是用于“恢复模式”（Recovery Mode）启动时的配置文件，系统在进入恢复模式时会使用它。恢复模式一般用于系统刷机、数据恢复、工厂重置等操作，因此其中定义的服务和进程相对简单，主要集中在设备初始化和恢复操作相关的服务上。 当用户选择进入恢复模式时，init 程序会加载和执行该 init.rc 文件中的配置，进入恢复模式环境。 Android Init Language 简介 Android Init Language 是一种用于定义系统启动和服务配置的语言，主要用于 .rc 文件中。它由以下五种语法组成： 语法规则 基于行的结构：每行由空格分隔的 token 组成。 支持转义符：使用 C 风格的 \\ 转义空格。 支持双引号：防止空格分割 token。 支持行折叠：行末 \\ 表示续行。 注释：以 # 开头的行（包括前导空格）为注释。 属性扩展：使用 ${property.name} 动态替换系统属性值。 命令 (Actions) Actions 是一系列命令的有序集合。每个 Action 都有一个触发器 (trigger)，用来决定何时执行该动作。当一个事件与某个 Action 的触发器匹配时，该 Action 会被添加到待执行队列中（如果队列中没有该 Action）。 队列中的 Actions 按顺序出队并逐个执行其中的命令。init 会在命令之间处理其他活动（如设备创建/销毁、属性设置、进程重启等）。 语法结构 plaintext复制代码on [&& ]* ... : 定义触发条件，支持单一或多个触发条件组合（通过 &&）。 : 在触发条件满足时执行的命令。 执行顺序 init 按 .rc 文件的解析顺序加载并执行 Actions。 在同一个文件中，Actions 按定义的先后顺序依次执行。 如果触发多个 Actions，它们的命令也按解析顺序执行。 示例： plaintext复制代码on boot setprop a 1 setprop b 2 on boot && property:true=true setprop c 1 setprop d 2 on boot setprop e 1 setprop f 2 执行顺序： 假设事件 boot 触发，且属性 property:true=true ，命令的执行顺序为： plaintext复制代码setprop a 1 setprop b 2 setprop c 1 setprop d 2 setprop e 1 setprop f 2 触发器 (Triggers) 触发器是一个事件表达式，init 根据事件是否匹配触发器来决定是否执行相应 Action。 当前AIL中常用的有以下几种事件触发器: 类型 说明 ------------------------------------------------- boot init.rc被装载后触发 device-added- 指定设备被添加时触发 device-removed- 指定设备被移除时触发 service-exited- 在特定服务(service)退出时触发 early-init 初始化之前触发 late-init 初始化之后触发 init 初始化时触发（在 /init.conf （启动配置文件）被装载之后） Init的触发是由init.c里的函数action_for_each_trigger来决定的（在main函数中被调用）。 命令 (Commands) 在 Action 中的命令是实际执行的操作指令，例如设置属性、启动服务等。 常见命令示例： setprop: 设置系统属性。 setprop start 和 stop: 启动或停止指定服务。 start stop exec: 执行指定的命令。 exec 服务（Services） Services 是由 init 启动并（可选）在退出时重新启动的程序。 定义形式： plaintext复制代码service [*] ... ：服务的名称。 ：可执行程序的路径。 ：传递给程序的参数。 ：服务的配置选项，用来控制其行为。 配置选项（Options） 这些选项定义服务的启动条件、资源限制、日志行为等。以下是一些重要选项的解释： 通用选项 capabilities [\\*] 设置服务运行时的 Linux 权限。 示例：capabilities NET_ADMIN 允许服务使用网络管理权限。 权限列表详见 man7 capabilities。 class [\\*] 指定服务所属的类别（class）。 这些类别用于统一管理服务（例如启动/停止某一类别的所有服务）。 默认类别为 default。 critical [window=] [target=] 标记服务为设备关键服务。 如果服务在指定时间内崩溃超过 4 次，设备会重启（默认进入 bootloader 模式）。 disabled 设置服务为禁用状态，不会随类别启动，需显式启动。 oneshot 设置服务为一次性服务，退出后不会自动重启。 reboot_on_failure 服务启动失败或退出时，重启设备并进入指定目标模式。 资源与权限相关选项 group [\\*] 设置服务运行时的用户组（包括主组和附加组）。 memcg.\\* 配置内存 cgroup 的限制，例如： memcg.limit_in_bytes ：内存限制值。 memcg.swappiness ：内存交换行为。 namespace 指定服务在新的 PID 或挂载命名空间中运行。 priority 设置服务进程的调度优先级（范围：-20 到 19，默认 0）。 rlimit 设置服务的资源限制，例如文件句柄、内存等。 user 设置服务运行的用户，推荐避免直接运行为 root。 I/O 与日志相关选项 console [] 指定服务绑定到控制台（默认 /dev/console），用于调试。 stdio_to_kmsg 将标准输出和错误输出重定向到内核日志（/dev/kmsgdebug）。 socket [ [ []] 创建 UNIX 域套接字，允许服务监听/通信。 启动和停止相关选项 enter_namespace 进入指定类型的命名空间（如网络）。 keycodes \\* 配置按键触发服务启动。 onrestart 当服务重启时，执行额外命令。 shutdown 指定服务在关机过程中的行为（如延迟关闭）。 调试选项 sigstop 在服务启动前发送 SIGSTOP 信号，用于调试。 task_profiles \\* 为服务设置任务配置文件，便于调试或资源管理。 以下是关于 Imports 和 Properties 部分的解析和简化说明： Imports（导入机制） import 关键字用于将其他配置文件或目录的内容纳入当前配置中，以扩展 init 的配置能力。 导入的用法 语法: import 可以是一个具体的文件路径，也可以是一个目录。 如果 是目录，则该目录下的所有文件会被解析，但不会递归解析子目录。 导入的时机 init 程序在以下三个阶段导入 .rc 文件： 初始启动时： 导入 /system/etc/init/hw/init.rc 或由 ro.boot.init_rc 属性指定的脚本。 主配置文件解析后： 依次导入 /system/etc/init/、/system_ext/etc/init/、/vendor/etc/init/、/odm/etc/init/、/product/etc/init/ 目录下的文件。 挂载阶段（已废弃）： 在 mount_all 指令中导入指定路径的 .rc 文件（仅适用于 Android Q 之前的设备）。 导入顺序 导入顺序基于文件结构及字母序。 每个导入文件解析后，其包含的 import 子文件递归导入。 导入和动作的执行顺序直接影响设备启动行为。 伪代码说明 plaintext复制代码fn Import(file) Parse(file) for (import : file.imports) Import(import) Import(/system/etc/init/hw/init.rc) Directories = [/system/etc/init, /system_ext/etc/init, /vendor/etc/init, /odm/etc/init, /product/etc/init] for (directory : Directories) files = for (file : files) Import(file) Properties（属性） init 使用属性提供系统状态信息，并响应部分属性命令来控制服务行为。 状态属性 服务状态: init.svc. 指定服务的状态： stopped：服务已停止。 stopping：服务正在停止。 running：服务正在运行。 restarting：服务正在重启。 挂载点块设备: dev.mnt.blk. 关联挂载点的块设备。例如： dev.mnt.blk.root 表示根挂载点（/）。 用于设备无关地调整块设备特性。 响应属性 命令属性: ctl. 格式：ctl.[_]。 目标: 可选参数，仅用于指定服务关联的接口（例如 ctl.interface_start）。 命令类型： start：启动服务。 restart：重启服务。 stop：停止服务。 oneshot_on / oneshot_off：开启或关闭服务的 oneshot 标志。 sigstop_on / sigstop_off：开启或关闭服务的 sigstop 特性（用于调试）。 示例 启动 logd 服务： ``` plaintext 复制代码 SetProperty(\"ctl.start\", \"logd\") - 启动名为 aidl_lazy_test_1 的 AIDL 服务： plaintext 复制代码 SetProperty(\"ctl.interface_start\", \"aidl/aidl_lazy_test_1\") ## init.rc文件详解 为了方便理解，我把整个init.rc解析一边，便于大家了解整个流程；如果想要了解recovery下的init语法解析，参考这篇文章《recovery下的init.rc语法解析》 ```c++ \"【import 一个init配置文件，扩展当前配置。】\" import /init.environ.rc import /init.usb.rc import /init.${ro.hardware}.rc import /init.${ro.zygote}.rc import /init.trace.rc \"【触发条件early-init，在early-init阶段调用以下行】\" on early-init # Set init and its forked children's oom_adj. write /proc/1/oom_score_adj -1000 \"【打开路径为的一个文件，并写入一个或多个字符串】\" # Apply strict SELinux checking of PROT_EXEC on mmap/mprotect calls. write /sys/fs/selinux/checkreqprot 0 # Set the security context for the init process. # This should occur before anything else (e.g. ueventd) is started. \"【这段脚本的意思是init进程启动之后就马上调用函数setcon将自己的安全上下文设置为“u:r:init:s0”，即将init进程的domain指定为init。】\" setcon u:r:init:s0 # Set the security context of /adb_keys if present. \"【恢复指定文件到file_contexts配置中指定的安全上线文环境】\" restorecon /adb_keys \"【执行start ueventd的命令。ueventd是一个service后面有定义】 \" start ueventd \"【mkdir [mode] [owner] [group] //创建一个目录，可以选择性地指定mode、owner以及group。如果没有指定，默认的权限为755，并属于root用户和root组。】\" # create mountpoints mkdir /mnt 0775 root system on init \"【设置系统时钟的基准,比如0代表GMT,即以格林尼治时间为准】\" sysclktz 0 \"【设置kernel日志等级】\" loglevel 6 #### write /proc/bootprof \"INIT: on init start\" #### \"【symlink //创建一个指向的软连接。】\" # Backward compatibility symlink /system/etc /etc symlink /sys/kernel/debug /d # Right now vendor lives on the same filesystem as system, # but someday that may change. symlink /system/vendor /vendor \"【创建一个目录，可以选择性地指定mode、owner以及group。】\" # Create cgroup mount point for cpu accounting mkdir /acct mount cgroup none /acct cpuacct mkdir /acct/uid \"【mount [ ] //在目录挂载指定的设备。 可以是以 mtd@name 的形式指定一个mtd块设备。包括 ro、rw、remount、noatime、 ...】\" # Create cgroup mount point for memory mount tmpfs none /sys/fs/cgroup mode=0750,uid=0,gid=1000 mkdir /sys/fs/cgroup/memory 0750 root system mount cgroup none /sys/fs/cgroup/memory memory write /sys/fs/cgroup/memory/memory.move_charge_at_immigrate 1 \"【chown //改变文件的所有者和组。】\" \"【后面的一些行因为类似，就省略了】\" ..... # Healthd can trigger a full boot from charger mode by signaling this # property when the power button is held. on property:sys.boot_from_charger_mode=1 \"【停止指定类别服务类下的所有已运行的服务】\" class_stop charger \"【触发一个事件,将该action排在某个action之后(用于Action排队)】\" trigger late-init # Load properties from /system/ + /factory after fs mount. on load_all_props_action \"【从/system，/vendor加载属性。默认包含在init.rc】\" load_all_props # Indicate to fw loaders that the relevant mounts are up. on firmware_mounts_complete \"【删除指定路径下的文件】\" rm /dev/.booting # Mount filesystems and start core system services. on late-init \"【触发一个事件。用于将一个action与另一个action排列。】\" trigger early-fs trigger fs trigger post-fs trigger post-fs-data # Load properties from /system/ + /factory after fs mount. Place # this in another action so that the load will be scheduled after the prior # issued fs triggers have completed. trigger load_all_props_action # Remove a file to wake up anything waiting for firmware. trigger firmware_mounts_complete trigger early-boot trigger boot on post-fs ... \"【一些创造目录，建立链接，更改权限的操作，这里省略】\" on post-fs-data ... \"【一些创造目录，建立链接，更改权限的操作，这里省略】\" \"【恢复指定文件到file_contexts配置中指定的安全上线文环境】\" restorecon /data/mediaserver \"【将系统属性的值设置为,即以键值对的方式设置系统属性】\" # Reload policy from /data/security if present. setprop selinux.reload_policy 1 \"【以递归的方式恢复指定目录到file_contexts配置中指定的安全上下文中】\" # Set SELinux security contexts on upgrade or policy update. restorecon_recursive /data # If there is no fs-post-data action in the init..rc file, you # must uncomment this line, otherwise encrypted filesystems # won't work. # Set indication (checked by vold) that we have finished this action #setprop vold.post_fs_data_done 1 on boot \"【初始化网络】\" # basic network init ifup lo \"【设置主机名为localhost】\" hostname localhost \"【设置域名localdomain】\" domainname localdomain \"【设置资源限制】\" # set RLIMIT_NICE to allow priorities from 19 to -20 setrlimit 13 40 40 \"【这里省略了一些chmod,chown,等操作，不多解释】\" ... # Define default initial receive window size in segments. setprop net.tcp.default_init_rwnd 60 \"【重启core服务】\" class_start core on nonencrypted class_start main class_start late_start on property:vold.decrypt=trigger_default_encryption start defaultcrypto on property:vold.decrypt=trigger_encryption start surfaceflinger start encrypt on property:sys.init_log_level=* loglevel ${sys.init_log_level} on charger class_start charger on property:vold.decrypt=trigger_reset_main class_reset main on property:vold.decrypt=trigger_load_persist_props load_persist_props on property:vold.decrypt=trigger_post_fs_data trigger post-fs-data on property:vold.decrypt=trigger_restart_min_framework class_start main on property:vold.decrypt=trigger_restart_framework class_start main class_start late_start on property:vold.decrypt=trigger_shutdown_framework class_reset late_start class_reset main on property:sys.powerctl=* powerctl ${sys.powerctl} # system server cannot write to /proc/sys files, # and chown/chmod does not work for /proc/sys/ entries. # So proxy writes through init. on property:sys.sysctl.extra_free_kbytes=* write /proc/sys/vm/extra_free_kbytes ${sys.sysctl.extra_free_kbytes} # \"tcp_default_init_rwnd\" Is too long! on property:sys.sysctl.tcp_def_init_rwnd=* write /proc/sys/net/ipv4/tcp_default_init_rwnd ${sys.sysctl.tcp_def_init_rwnd} \"【守护进程】\" ## Daemon processes to be run by init. service ueventd /sbin/ueventd class core critical seclabel u:r:ueventd:s0 \"【日志服务进程】\" service logd /system/bin/logd class core socket logd stream 0666 logd logd socket logdr seqpacket 0666 logd logd socket logdw dgram 0222 logd logd seclabel u:r:logd:s0 \"【Healthd是android4.4之后提出来的一种中介模型，该模型向下监听来自底层的电池事件，向上传递电池数据信息给Framework层的BatteryService用以计算电池电量相关状态信息】\" service healthd /sbin/healthd class core critical seclabel u:r:healthd:s0 \"【控制台进程】\" service console /system/bin/sh \"【为当前service设定一个类别.相同类别的服务将会同时启动或者停止,默认类名是default】\" class core \"【服务需要一个控制台】\" console \"【服务不会自动启动,必须通过服务名显式启动】\" disabled \"【在执行此服务之前切换用户名,当前默认的是root.自Android M开始,即使它要求linux capabilities,也应该使用该选项.很明显,为了获得该功能,进程需要以root用户运行】\" user shell seclabel u:r:shell:s0 on property:ro.debuggable=1 start console # adbd is controlled via property triggers in init..usb.rc service adbd /sbin/adbd --root_seclabel=u:r:su:s0 class core \"【创建一个unix域下的socket,其被命名/dev/socket/. 并将其文件描述符fd返回给服务进程.其中,type必须为dgram,stream或者seqpacke,user和group默认是0.seclabel是该socket的SELLinux的安全上下文环境,默认是当前service的上下文环境,通过seclabel指定】\" socket adbd stream 660 system system disabled seclabel u:r:adbd:s0 # adbd on at boot in emulator on property:ro.kernel.qemu=1 start adbd \"【内存管理服务，内存不够释放内存】\" service lmkd /system/bin/lmkd class core critical socket lmkd seqpacket 0660 system system \"【ServiceManager是一个守护进程，它维护着系统服务和客户端的binder通信。在Android系统中用到最多的通信机制就是Binder，Binder主要由Client、Server、ServiceManager和Binder驱动程序组成。其中Client、Service和ServiceManager运行在用户空间，而Binder驱动程序运行在内核空间。核心组件就是Binder驱动程序了，而ServiceManager提供辅助管理的功能，无论是Client还是Service进行通信前首先要和ServiceManager取得联系。而ServiceManager是一个守护进程，负责管理Server并向Client提供查询Server的功能。】\" service servicemanager /system/bin/servicemanager class core user system group system critical onrestart restart healthd \"【servicemanager 服务启动时会重启zygote服务】\" onrestart restart zygote onrestart restart media onrestart restart surfaceflinger onrestart restart drm \"【Vold是Volume Daemon的缩写,它是Android平台中外部存储系统的管控中心,是管理和控制Android平台外部存储设备的后台进程】\" service vold /system/bin/vold class core socket vold stream 0660 root mount ioprio be 2 \"【Netd是Android系统中专门负责网络管理和控制的后台daemon程序】\" service netd /system/bin/netd class main socket netd stream 0660 root system socket dnsproxyd stream 0660 root inet socket mdns stream 0660 root system socket fwmarkd stream 0660 root inet \"【debuggerd是一个daemon进程，在系统启动时随着init进程启动。主要负责将进程运行时的信息dump到文件或者控制台中】\" service debuggerd /system/bin/debuggerd class main service debuggerd64 /system/bin/debuggerd64 class main \"【Android RIL (Radio Interface Layer)提供了Telephony服务和Radio硬件之间的抽象层】\" # for using TK init.modem.rc rild-daemon setting #service ril-daemon /system/bin/rild # class main # socket rild stream 660 root radio # socket rild-debug stream 660 radio system # user root # group radio cache inet misc audio log \"【提供系统 范围内的surface composer功能，它能够将各种应用程序的2D、3D surface进行组合。】\" service surfaceflinger /system/bin/surfaceflinger class core user system group graphics drmrpc onrestart restart zygote \"【DRM可以直接访问DRM clients的硬件。DRM驱动用来处理DMA，内存管理，资源锁以及安全硬件访问。为了同时支持多个3D应用，3D图形卡硬件必须作为一个共享资源，因此需要锁来提供互斥访问。DMA传输和AGP接口用来发送图形操作的buffers到显卡硬件，因此要防止客户端越权访问显卡硬件。】\" #make sure drm server has rights to read and write sdcard #### service drm /system/bin/drmserver class main user drm # group drm system inet drmrpc #### group drm system inet drmrpc sdcard_r #### \"【媒体服务，无需多说】\" service media /system/bin/mediaserver class main user root #### # google default #### # user media #### group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm media sdcard_r system net_bt_stack #### # google default #### # group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm #### ioprio rt 4 \"【设备加密相关服务】\" # One shot invocation to deal with encrypted volume. service defaultcrypto /system/bin/vdc --wait cryptfs mountdefaultencrypted disabled \"【当服务退出时,不重启该服务】\" oneshot # vold will set vold.decrypt to trigger_restart_framework (default # encryption) or trigger_restart_min_framework (other encryption) # One shot invocation to encrypt unencrypted volumes service encrypt /system/bin/vdc --wait cryptfs enablecrypto inplace default disabled oneshot # vold will set vold.decrypt to trigger_restart_framework (default # encryption) \"【开机动画服务】\" service bootanim /system/bin/bootanimation class core user graphics # group graphics audio #### group graphics media audio #### disabled oneshot \"【在Android系统中，PackageManagerService用于管理系统中的所有安装包信息及应用程序的安装卸载，但是应用程序的安装与卸载并非PackageManagerService来完成，而是通过PackageManagerService来访问installd服务来执行程序包的安装与卸载的。】\" service installd /system/bin/installd class main socket installd stream 600 system system service flash_recovery /system/bin/install-recovery.sh class main seclabel u:r:install_recovery:s0 oneshot \"【vpn相关的服务】\" service racoon /system/bin/racoon class main socket racoon stream 600 system system # IKE uses UDP port 500. Racoon will setuid to vpn after binding the port. group vpn net_admin inet disabled oneshot \"【android中有mtpd命令可以连接vpn】\" service mtpd /system/bin/mtpd class main socket mtpd stream 600 system system user vpn group vpn net_admin inet net_raw disabled oneshot service keystore /system/bin/keystore /data/misc/keystore class main user keystore group keystore drmrpc \"【可以用dumpstate 获取设备的各种信息】\" service dumpstate /system/bin/dumpstate -s class main socket dumpstate stream 0660 shell log disabled oneshot \"【mdnsd 是多播 DNS 和 DNS 服务发现的守护程序。】\" service mdnsd /system/bin/mdnsd class main user mdnsr group inet net_raw socket mdnsd stream 0660 mdnsr inet disabled oneshot \"【触发关机流程继续往下走】\" service pre-recovery /system/bin/uncrypt class main disabled \"【当服务退出时,不重启该服务】\" oneshot No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-1.框架层-基础与源码/1-4.Zygote.html":{"url":"04_Android/框架层/4-1.框架层-基础与源码/1-4.Zygote.html","title":"1-4.zygote","keywords":"","body":"系统中运行的第一个Dalvik虚拟机程序叫作zygote，该名称的意义是“一个卵”，因为接下来的所有 Dalvik虚拟机进程都是通过这个“卵” 孵化出来的。 zygote进程对应的具体程序是app_process，该程序存在于system/bin目录下，启动该程序的指令是在init.rc中进行配置的。 Zygote进程中包含两个主要模块，分别如下： Socket服务端。该Socket服务端用于接收启动新的Dalvik进程的命令。 Framework共享类及共享资源。当Zygote进程启动后，会装载一些共享的类及资源，其中共享类是在preload-classes文件中被定义，共享资源是在preload-resources中被定义。因为zygote进程用于孵化出其他Dalvik进程，因此，这些类和资源装载后，新的Dalvik进程就不需要再装载这些类和资源了，这就是所谓的共享。--> zygote进程预先会装载共享类和共享资源，这些类及资源实际上就是SDK中定义的大部分类和资源。因此，当通过zygote孵化出新的进程后，新的APK进程只需要去装载APK自身包含的类和资源即可，这就有效地解决了多个APK共享Framework资源的问题。 在Android系统中有以下两种程序： Java应用程序，主要基于ART虚拟机，所有的应用程序APK都属于这类Native程序，也就是利用C或C++语言开发的程序，如bootanimation。所有的Java应用程序进程及系统服务SystemServer进程都由Zygote进程通过Linux的fork()函数孵化出来的。 --> 每fork出的一个进程都是一个Dalvik虚拟机，独立的进程可以防止一个程序的崩溃导致所有程序都崩溃，这种虚拟机类似Java虚拟机，对于程序员来说，可以直接使用Java开发应用。 每个Android进程里都有一个fork出来的Zygote吗？ 使用 fork()： Zygote 会通过 fork() 系统调用复制出新的进程。这个新进程继承了 Zygote 进程的内存空间、资源等。 但是，Zygote 和新创建的进程并不完全相同，新进程在启动时可以进行不同的初始化，以启动特定的应用或服务。 虽然大部分的 Android 应用进程（如每个应用的 Activity）都是通过 Zygote 启动的，但并不是所有的进程都由 Zygote 创建。例如： 系统服务进程： 一些系统服务进程，如 SystemServer，通常是由 init 进程启动的。 后台进程和守护进程： 一些后台进程或守护进程可能并不是通过 Zygote 启动，而是直接由 init 或其他系统进程启动。 为什么通过 Zygote fork 而非直接创建？ 提高性能：Zygote 预加载了大量的系统类和资源（如 Java 核心库、常用的 Android 类），这些资源在 fork 时会被子进程共享，从而加速启动。 节省内存：通过 Copy-on-Write（COW）机制，共享未修改的内存页，减少系统资源的浪费。 而native程序则由Init程序创建启动。 尽管 Java 应用程序运行在虚拟机上，但其最终是通过 ART 将代码转化为本地机器码（native code）执行。相比之下，纯 C/C++ 程序（如 bootanimation）是直接用 C/C++ 开发的，运行时不依赖虚拟机。 ART将代码转换为本地机器码就是取决于arm，x86，x64这些架构对吗？ 是的，ART（Android Runtime）将代码转换为本地机器码时，确实依赖于目标设备的处理器架构（如 ARM、x86、x64 等）。具体来说，ART 在将字节码转换为本地机器码的过程中，需要针对设备所运行的 CPU 架构生成相应的指令集。以下是详细的解释： 1. 为什么需要转换为本地机器码？ 本地机器码是特定处理器架构（如 ARM、x86、x64）能够直接执行的指令集合。 字节码（如 .dex 文件中的代码）是一种与平台无关的中间表示，不能直接在处理器上运行。 为了提升性能，ART 会在应用安装或首次运行时，通过Ahead-of-Time (AOT) 编译，将这些字节码编译成本地机器码，以便后续能够直接在设备上执行。 2. 处理器架构与机器码的关系 每种处理器架构都有自己独特的指令集，因此机器码必须与设备的 CPU 架构匹配： ARM： ARM 是移动设备中最常见的处理器架构。 常见的指令集包括 ARMv7（32 位）和 ARMv8（64 位，也称为 AArch64）。 大多数 Android 设备（特别是手机和平板）都使用 ARM 架构。 x86 和 x86_64： x86 是 Intel 和 AMD 处理器的传统架构。 x86_64 是其 64 位扩展版本。 一些 Android 模拟器和少数设备（如某些平板电脑）可能使用 x86 架构。 其他架构： RISC-V：近年来逐渐兴起，但在 Android 生态系统中尚不广泛使用。 MIPS：过去有少量设备使用，但几乎被淘汰。 init 进程启动的 Native 程序通常是系统层级的核心服务，如守护进程、启动动画、硬件抽象层（HAL）模块等。 Zgyote是Android中的第一个ART虚拟机，他通过socket的方式与其他进程进行通信。这里的其他进程主要指系统进程——SystemServer。 特性 Socket AIDL 通信范围 跨设备或同设备 同一设备内，基于 Android 系统 通信模型 基于网络协议（如 TCP/IP、UDP） 基于 Binder 驱动 数据格式 原始字节流 强类型（基本类型、Parcelable） 适用场景 分布式系统，远程通信 Android 进程间通信（IPC） 平台限制 通用（任何操作系统都支持） Android 特定 实现复杂度 通信双方需定义协议和解析逻辑 自动生成接口实现，开发简单 效率 取决于网络传输速度和实现 高效（Binder 驱动内核级支持） Zygote是一个C/S模型，Zygote进程作为服务端，它主要负责创建java虚拟机，加载系统资源，启动SystemServer进程，以及在后续运行过程中启动普通的应用程序，其他进程作为客户端向它发出孵化请求，而Zygote接收到这个请求后就“孵化”出一个新的进程。比如，当点击Launcher里的应用程序图标去启动一个新的应所以程序进程时，这个请求会到达框架层的核心服务ActivityManagerService中，当AMS收到这个请求后，它通过调用Process类发出一个“孵化”紫禁城的Socket请求，而Zygote监听到这个请求后就立刻fork一个新的进程出来。 init.rc init进程启动后，对init.rc文件进行了解析并执行了各个阶段的动作，而zygote进程就是这个过程中被触发启动的。直接看代码直观点： /system/core/rootdir/init.rc on late-init ... # Now we can start zygote for devices with file based encryption trigger zygote-start ... on zygote-start && property:ro.crypto.state=encrypted && property:ro.crypto.type=file # A/B update verifier that marks a successful boot. exec_start update_verifier_nonencrypted start netd start zygote start zygote_secondary ... zygote在init.rc中被触发并通过【start zygote】的方式启动，而这里的zygote是init.rc文件中的服务，如下： service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main priority -20 user root group root readproc reserved_disk socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd onrestart restart wificond writepid /dev/cpuset/foreground/tasks 可见zygote服务最终调用了app_process这个可执行文件，并传入【--zygote】和【--start-system-server】这两个参数。 app_main app_main是一个可执行文件，入口是main函数，具体源码如下： /frameworks/base/cmds/app_process/app_main.cpp int main(int argc, char* const argv[]) { ... AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); ... while (i 专注zygote相关的关键代码，在这个main函数中，主要做了三件事： 1.使用AppRuntime类实例化了一个虚拟机runtime，而AppRuntime则继承AndroidRuntime; 2.解析传给app_main的参数，主要是zygote和start_system_server； 3.启动虚拟机。启动的方法start是父类AndroidRuntime的方法。注意第一个传参的参数。 zygote启动方法在AndroidRuntime中，进入观摩下。 AndroidRuntime frameworks/base/core/jni/AndroidRuntime.cpp void AndroidRuntime::start(const char* className, const Vector& options, bool zygote) { ... JniInvocation jni_invocation; jni_invocation.Init(NULL); //加载libart.so JNIEnv* env; if (startVm(&mJavaVM, &env, zygote) != 0) { return; } onVmCreated(env); /* * Register android functions. */ if (startReg(env) FindClass(slashClassName); if (startClass == NULL) { ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ } else { jmethodID startMeth = env->GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) { ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ } else { env->CallStaticVoidMethod(startClass, startMeth, strArray); } } ... } start方法中，主要做了四件事： 1.加载libart.so，否则不能启动虚拟机； 2.启动虚拟机； 3.加载注册JNI方法； 4.根据传递给start方法的第一个参数，去寻找ZygoteInit类，找到类之后，找到该类的main方法，然后调用，在这之后就进入了Java的世界。 start方法的第一个参数为\"com.android.internal.os.ZygoteInit\"，然后通过FindClass方法找到ZygoteInit类，然后再调用相应的main方法进入到Java世界。 ZygoteInit 到了这里，就已经进入到了Java的世界，虚拟机已经运行起来，接下来要做的事就是启动system_server，然后做好自己的本分，等待孵化app的指令。具体详见main方法： frameworks/base/core/java/com/android/internal/os/ZygoteInit.java public static void main(String argv[]) { ... if (startSystemServer) { Runnable r = forkSystemServer(abiList, socketName, zygoteServer); // {@code r == null} in the parent (zygote) process, and {@code r != null} in the // child (system_server) process. if (r != null) { r.run(); return; } } Log.i(TAG, \"Accepting command socket connections\"); // The select loop returns early in the child process after a fork and // loops forever in the zygote. caller = zygoteServer.runSelectLoop(abiList); if (caller != null) { caller.run(); } ... } 主要做了三件事： 1.解析参数； 2.fork system_server; 3.调用runSelectLoop方法，等待进程孵化请求； 每个main方法一定会做的事情，那就是解析传入给它的参数，这里主要解析了start_system_server的创建需求，这个参数事从init.rc中传下来的。如果init.rc中有创建的system_server的需求，那么就会在这里被解析，然后进行创建。zygote在完成了system_server的创建后，调用runSelectLoop方法进行等待，响应app进程的创建请求，创建成功后，再调用run方法执行。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-1.框架层-基础与源码/Android架构.html":{"url":"04_Android/框架层/4-1.框架层-基础与源码/Android架构.html","title":"Android架构","keywords":"","body":"Android架构 LINUX KERNEL Linux core, the Android system is modified based on the Linux system. The bottom layer of Android is Linux, and most of them are some drivers for operating hardware, such as Display Driver, Audio Drivers, and so on. HAL(硬件抽象层) 提供标准界面，向更高级别的Java API框架显示设备硬件功能。 HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。当框架API要求访问设备硬件时，Android系统将为该硬件组件加载库模块。 ANDROID RUNTIME Core Libraries: core library. Dalvik Virtual Machine: Android bottom layer is a Linux system, written in C and C ++ language, so Android program (written in Java language) needs a virtual machine to run on Linux, that is, DVM. 对于运行Android5.0(API 21)或更高版本的设备，每个应用都在其自己的进程中运行，并且有其自己的AndroidRuntime（ART）实例。ART编写为通过执行DEX文件在低内存设备上运行多个虚拟机，DEX未见时一种专为Android设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如Jack）将Java源代码编译为DEX字节码，使其可在Android平台上运行。 ART的部分主要功能包括： 预先（AOT）和即时（JIT） 编译优化的垃圾回收（GC） 在Android 9 （API 28）及更高版本的系统中，支持将应用软件包中的Dalvik Executable格式（DEX）文件转换为更紧凑的机器代码 在Android 5.0 （API 21）之前，Dalvik是AndroidRuntime。如果您的应用在ART上运行效果很少，那么它应该也可以在Dalvik上运行，但反过来不一定。 Dalvik 是 Android 操作系统中用于执行应用程序的一个虚拟机（VM）。Dalvik 虚拟机是为了在资源受限的移动设备上运行效率更高的 Java 程序而设计的。 主要特点和作用包括： 优化内存和性能： Dalvik 虚拟机被设计为在移动设备上更高效地使用内存和处理器资源。它使用基于寄存器的指令集，与传统的 Java 虚拟机（如 Java SE 中的 JVM）不同。 DEX 文件格式： Android 应用程序的 Java 代码经过编译后会生成 Dalvik 可执行文件，通常以 .dex 扩展名结尾。这个文件格式是为了在 Dalvik VM 上执行而优化过的。 运行在沙盒环境中： Dalvik 虚拟机使得每个 Android 应用程序运行在其独立的进程中，并在沙盒环境中，这有助于提高系统的安全性和稳定性。 支持多任务处理： Android 设备通常需要同时运行多个应用程序。Dalvik 虚拟机能够有效地管理多个应用程序的同时运行，通过使用不同的进程和线程来实现。 预编译和即时编译： Dalvik 虚拟机支持预编译和即时编译技术，以提高应用程序的启动速度和运行效率。 需要注意的是，从 Android 5.0（Lollipop）版本开始，Android 引入了新的运行时环境，称为 ART（Android Runtime），取代了 Dalvik。ART 在性能和优化方面带来了更多的改进，包括提供了更快的应用启动速度和更低的内存占用。因此，Dalvik 在较新的 Android 版本中逐渐被淘汰。 Native C/C++ Libraries Some libraries written in C language to complete the core functions of Android, such as OpenGL | ES (Simplified Graphic Image Engine), WebKit (browser kernel), SQLite (lightweight database), Surface Manager ), Media Framework (Multimedia Framework), FreeType (font library), SGL (another graphics and image engine), SSL (TCP-based security protocol), libc (fragmented library). 可提供Java API框架所使用的Java编程语言中的大部分功能，包括一些Java8语言功能， 许多核心Android系统组件和服务（例如ART和HAL）构建自原生代码，需要以C和C++编写的原生库。Android平台提供Java框架API以向应用显示其中部分原生库的功能。例如，您也可以通过Android框架的Java OpenGL API访问 OpenGL ES，以支持在应用中绘制和操作2D和3D图形。 如果开发的是需要C或C++代码的应用，可以使用Android NDK直接从原生代码访问某型原生平台库。 什么情况下开发Android应用会需要C、C++代码？ 在Android应用开发中，通常使用Java或Kotlin等高级编程语言来编写应用程序的逻辑和用户界面。然而，有些情况下，可能会需要使用C或C++等底层语言编写一部分代码。以下是一些情况下可能需要使用C、C++代码的情况： 性能优化： 如果你的应用对性能要求极高，特别是需要进行大量计算或处理大量数据的情况下，使用C或C++可以更好地控制底层资源，以提高执行效率。 现有库或代码： 如果你要使用已有的C/C++库或代码，可以通过JNI（Java Native Interface）来调用这些库。这是一种使用Java代码调用本地（C/C++）代码的机制，使得你可以在Android应用中使用现有的本地库。 跨平台开发： 如果你计划在多个平台上共享代码，尤其是在Android和iOS之间，可以考虑使用C++开发核心逻辑，然后在Android和iOS上通过相应的桥接层进行调用。 硬件相关操作： 有些应用可能需要直接访问设备硬件或执行底层操作，这时候使用C或C++可能更为合适。例如，游戏引擎通常会使用C++来实现性能关键的游戏逻辑。 系统级开发： 在一些特殊的应用场景，比如系统级应用或者需要操作底层系统资源的应用，可能需要使用C或C++。 图像处理、信号处理： 对于需要高效处理图像、音频或其他信号的应用，C/C++的性能通常比Java更好，因此可能选择使用底层语言来实现这些部分。 请注意，尽管使用C或C++可以提供更高的性能和更多的底层控制权，但也增加了开发的复杂性。在选择使用底层语言之前，建议评估应用的性能需求，并确保确实需要使用底层语言来解决问题。 APPLICATION FRAMEWORK Application framework layer, all written in Java language for developers to call. APPLICATIONS Application layer, all the applications we install belong to this layer, such as WeChat, Plants vs. Zombies. Framework 层级 1. Framework function Framework可以被简单地理解成API的仓库，这些API由Java写成，包含JNI方法。JNI会根据 core library 调用C/C++方法，最终访问到Linux Kernel。 Framework层有两个角色： Write some standardized modules in Java and encapsulate them into a framework for APP layer developers to call and develop mobile applications with special services. Use the Java Native Interface to call the native method of the core lib layer. The JNI library is loaded when the Dalvik virtual machine is started. Dalvik will directly address this JNI method and then call it. 一些重要的Framework层服务： Activity Manager: Used to manage the application life cycle and provide commonly used navigation and rollback functions. Window Manager: Provides some methods for us to access the mobile phone screen. Screen transparency, brightness, background. Content Providers: Allows applications to access the data of another application (such as a contact database), or share their own data. View System: Can be used to build applications. It includes Lists, Grids, Textboxes, Buttons, and even an embedded web browser. Notification Manager: Allows the application to display customized prompt information in the status bar. Package Manager: Provides access to system installation packages. Including installing and uninstalling applications, querying permission-related information, and querying Application-related information. Resource Manager: Provides access to non-code resources, such as local strings, graphics, and layout files (Layout files). Location Manager: Provides a way to obtain the address and location of the device. Obviously, GPS navigation can definitely use location services. 其他： Telephony Manager: It mainly provides a series of methods for accessing the status and information related to mobile phone communication, querying telecommunications network status information, sim card information, etc. XMPP: Extensible communication and presentation protocol. Formerly known as Jabber, it provides instant messaging services. For example, push function, Google Talk. 2. Activity Framework structure and running framework Activity creation will create PhoneWindow, PhoneWindow will create DocerView, and DocerView will create View and ViewGroup. The application adds and deletes windows in the Activity by calling the addView and RemoveView functions of the WindowManager class. The specific implementation is achieved by the WindowManagerImpl implemented in the bridge mode. Then turn to call setView and removeViewLocked of ViewRoot class, and then call addWindow and removeWindow in WMS (WindowManagerService) through IPC mechanism to complete. When AMS (ActivityManagerService) informs ActivityThread to destroy an Activity, ActivityThread will directly call WindowManager’s removeView method to delete the window, implemented in WindowManagerImpl class. AMS calls WMS (WindowManagerService), the general situation is to tell WMS some messages, such as a new Activity to start so that WMS will save a reference to the Activity record, and sometimes will also directly call the WMS interface, such as switching windows When the switch window is started, the setAppStartingWindow of WMS is called directly. WMS internally takes over the processing of input messages and drawing of the screen. The processing of input messages is completed with the help of the InputManager class. The InputManger class generates two threads, InputReaderThread and InputDispatcherThread. InuptReaderThread reads input messages from EventHub cyclically. Non - big data is distributed through the channel (InputChannel will generate ServerChannel and ClientChannel), and the corresponding big data is distributed through the shared cache ShareMemory; InputDispatcherThread will get the message from the Channel or ShareMemory and distribute, the distribution is through InputPublisher, application-layer client Through the InputConsumer, it continuously obtains the distributed messages from Channel or ShareMemory, and then passes them to ViewRoot for processing. InputPublisher, InputPublisher, and InputConsumer are generated by InputMoniter. So InputReaderThread and EventHub are producers, InputDispatcherThread is a consumer, InputMoniter is a consumption channel, ViewRoot is a bridge between consumers and producers, and WMS and AMS are family butlers. 3. FrameWork startup process The Android startup process includes the entire process of loading from the Linux kernel to starting the Home application. The overall process is as follows: Android is a system platform based on the Linux kernel. When booting, first load the Linux kernel through the bootloader (system loader). When Linux is loaded and started, it is the same as the ordinary Linux startup process. Initialize the kernel first, and then call the init process. Init process starts zygote: parsing configuration files: init.rc (system configuration file) and initXXX.rc (hardware platform-related files) content to execute a series of commands, including creating mount directory, installing file system, setting properties, starting Attribute server, start Socket service port-”Load preload-classes and preload-resources (Most of the Framework’s classes and resources)-” Fork start a new process Zygote (actually created by fork and execv). Zygote incubates the first process, SystemServer, which starts various system service threads. The SystemServer process plays the role of a “nerve center” in the Android operating environment. Most of the system services that can be directly interacted with in the APK application are running in this process. Common systems such as WMS, AMS, PackageManagerServer (PmS), etc. Services exist in the SystemServer process as a thread. The main () function of SystemServer first calls the init1 () function, which is a native function, and some initialization work related to the Dalvik virtual machine will be carried out internally. After the function is executed, it will call the init2 () function on the Java side. The function first creates a ServerThread object, which is a thread, and then directly runs the thread. So, from the run () method of ServerThread, the real Start various service threads. Basically, each service has a corresponding Java class. From the perspective of coding standards, the modes for starting these services can be categorized into three types: Mode one refers to the use of a constructor to construct a service because most services correspond A thread, therefore, a thread will be created and run automatically inside the constructor. Mode two refers to the service class that will provide a getInstance () method, through which to obtain the service object, this advantage is to ensure that the system contains only one service object. Mode three refers to the execution from the main () function of the service class. Regardless of the above mode, after the service object is created, sometimes it may be necessary to call the init () or systemReady () function of the service class to complete the startup of the object After the above service threads are started, AMS calls systemReady to complete the final start, mMainStack.resumeTopActivityLocked (null)-”mService.startHomeActivityLocked starts the first Activity. At this point, the framework started to complete. Framework 概述 Server 主要是ActivityManagerService（AMS）、WindowManagerService（WMS），PackageManagerService（PMS） AMS：用于管理所有应用程序的Activity WMS：管理各个窗口、隐藏、显示等 PMS：用来管理跟踪所有应用APK的安装、解析、控制权限等 还有用来处理触摸消息的两个类KeyInputQueue和InputDispatchThread，一个用来读消息，一个用来分发消息。 Client The client contains the following classes: ActivityThread: is the main thread class of Android applications, that is, the UI thread or the main thread. All the work of processing user messages and drawing pages are completed in this thread. Activity: ActivityThread will choose which Activity object to put on its boat according to the user’s operation. PhoneWindow: Rich second-generation, inherited from the bullish Window class, owns a DecorView object in his house like his father likes to make rules to provide some general window operation API. Window: The rich generation, which looks more abstract, likes to make rules, and provides some general window operation APIs. It doesn’t like being managed. So, note: the window managed by WindowManagerService is not the Window class, but it is actually View and ViewGroup. DecorView: A very capable guy, the family property comes from FrameLayout, and pays more attention to external dressing. DecorView is a modification of FrameLayout, which can be seen from the name. ViewRoot: Little housekeeper. Inherited from Handler, the main function is to convert WMS IPC call to a local asynchronous call. Class W: ViewRoot assistant, inherited from the binder, is an internal class of ViewRoot. It mainly helps ViewRoot to convert the WMS IPC call into a local asynchronous call. WindowManager: If the client wants to create a window, it must first tell WindowManager, and then it communicates with WindowManagerService to see if it can be created, and the client cannot directly interact with WMS. Linux driver 主要是SurfaceFlingger（SF）和Binder驱动 SurfaceFlingger(The painter)：每一个窗口都对应一个Surface，SF驱动的作用就是把每个Surface显示到同一个屏幕上。 Binder(The courier)：为上面的服务端和客户端提供IPC通讯 From the running process of the apk program to see when the above components are doing. ActivityThread starts moving from the main () function and then calls prepareMainLooper () to create a message express channel, MessageQueue, for the UI thread. Then create ActivityThread object, the creation process will create a message handler Handler object and a courier Binder object, in which Binder is responsible for receiving the remote Ams IPC call, after receiving the call, let Handler load the message to the message express queue, the UI thread is busy It is asynchronous to take messages from the message express queue and perform corresponding operations, such as start, stop, pause. Then the UI thread allows the queue to call the Looper.loop () method to enter the message loop body. After entering, it will continuously read and process messages from the message queue. When ActivityThread receives the express delivery of an Activity sent by Ams, it will create the specified Activity object. Activity will first press the window and then press the glass and window grille, so first create PhoneWindow-> DecorView-> create the corresponding View or ViewGroup. After the creation is complete, you can enjoy it, call WindowManager to display the interface on the screen, then create ViewRoot, and then call the remote interface provided by Wms to add a window and display it on the screen. The next step is the user’s operation. The event thread continuously sends the message to the event queue, and then the secretary of the event distribution thread takes out the messages one by one and then calls the corresponding function in Wms to process the message. Difference between custom thread and UI thread The UI thread is run from ActivityThread. In the main () method of this class, Looper.prepareMainLooper () has been used to add a Looper object to this thread. A message queue has been created for this thread, which comes with a secretary halo. Therefore, we can define the Handler object in the Activity, because the thread must have created the message queue when the Handler object is created, and the loading and unloading work must be equipped with the transport belt or the work will not work. The ordinary Thread does not create a message queue by default, so you cannot directly define the Handler directly in the Thread. This is the confusion caused by the fact that we do not understand the principle of program operation. I have been listening to the user’s voice, and all the work of processing user messages and drawing pages is completed in the UI thread. The client buddy contains at least three thread brothers. After the Activity starts, it creates a ViewRoot.W object, and ActivityThread creates an ApplicationThread object. These two objects inherit the message manager Binder. Each Binder corresponds to a thread and is responsible for receiving the Linux Binder IPC call sent by the driver. The other is the UI thread. SystemServer zygote孵化出的第一个Dalvik进程叫做SystemServer，SystemServer仅仅是该进程的别名，而该进程具体对应的程序依然是app_process，因为SystemServer是从app_process中孵化出来的。 SystemServer中创建了一个Socket客户端，并用AMS负责管理该客户端，之后所有的Dalvik进程都将通过该Socket客户端间接被启动。当需要启动新的APK进程时，AMS中会通过该Socket客户端向Zygote进程的Socket服务端发送一个启动命令，然后Zygote会孵化出新的进程。 上面提到的服务端、AMS、PMS、WMS等都是在SystemServer中启动的。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-1.框架层-基础与源码/Android目录.html":{"url":"04_Android/框架层/4-1.框架层-基础与源码/Android目录.html","title":"Android目录","keywords":"","body":"Android 2.1 . |-- Makefile |-- bionic （bionic C库） |-- bootable （启动引导相关代码） |-- build （存放系统编译规则及generic等基础开发包配置） |-- cts （Android兼容性测试套件标准） |-- dalvik （dalvik JAVA虚拟机） |-- development （应用程序开发相关） |-- external （android使用的一些开源的模组） |-- frameworks （核心框架——java及C++语言） |-- hardware （部分厂家开源的硬解适配层HAL代码） |-- out （编译完成后的代码输出与此目录） |-- packages （应用程序包） |-- prebuilt （x86和arm架构下预编译的一些资源） |-- sdk （sdk及模拟器） |-- system （底层文件系统库、应用及组件——C语言） `-- vendor （厂商定制代码） bionic 目录 . |-- libc （C库） | |-- arch-arm （ARM架构，包含系统调用汇编实现） | |-- arch-x86 （x86架构，包含系统调用汇编实现） | |-- bionic （由C实现的功能，架构无关） | |-- docs （文档） | |-- include （头文件） | |-- inet （？inet相关，具体作用不明） | |-- kernel （Linux内核中的一些头文件） | |-- netbsd （？nesbsd系统相关，具体作用不明） | |-- private （？一些私有的头文件） | |-- stdio （stdio实现） | |-- stdlib （stdlib实现） | |-- string （string函数实现） | |-- tools （几个工具） | |-- tzcode （时区相关代码） | |-- unistd （unistd实现） | `-- zoneinfo （时区信息） |-- libdl （libdl实现，dl是动态链接，提供访问动态链接库的功能） |-- libm （libm数学库的实现，） | |-- alpha （apaha架构） | |-- amd64 （amd64架构） | |-- arm （arm架构） | |-- bsdsrc （？bsd的源码） | |-- i386 （i386架构） | |-- i387 （i387架构？） | |-- ia64 （ia64架构） | |-- include （头文件） | |-- man （数学函数，后缀名为.3，一些为freeBSD的库文件） | |-- powerpc （powerpc架构） | |-- sparc64 （sparc64架构） | `-- src （源代码） |-- libstdc++ （libstdc++ C++实现库） | |-- include （头文件） | `-- src （源码） |-- libthread_db （多线程程序的调试器库） | `-- include （头文件） `-- linker （动态链接器） `-- arch （支持arm和x86两种架构） bootable 目录 . |-- bootloader （适合各种bootloader的通用代码） | `-- legacy （估计不能直接使用，可以参考） | |-- arch_armv6 （V6架构，几个简单的汇编文件） | |-- arch_msm7k （高通7k处理器架构的几个基本驱动） | |-- include （通用头文件和高通7k架构头文件） | |-- libboot （启动库，都写得很简单） | |-- libc （一些常用的c函数） | |-- nandwrite （nandwirte函数实现） | `-- usbloader （usbloader实现） |-- diskinstaller （android镜像打包器，x86可生产iso） `-- recovery （系统恢复相关） |-- edify （升级脚本使用的edify脚本语言） |-- etc （init.rc恢复脚本） |-- minui （一个简单的UI） |-- minzip （一个简单的压缩工具） |-- mtdutils （mtd工具） |-- res （资源） | `-- images （一些图片） |-- tools （工具） | `-- ota （OTA Over The Air Updates升级工具） `-- updater （升级器） build目录 . |-- core （核心编译规则） |-- history （历史记录） |-- libs | `-- host （主机端库，有android “cp”功能替换） |-- target （目标机编译对象） | |-- board （开发平台） | | |-- emulator （模拟器） | | |-- generic （通用） | | |-- idea6410 （自己添加的） | | `-- sim （最简单） | `-- product （开发平台对应的编译规则） | `-- security （密钥相关） `-- tools （编译中主机使用的工具及脚本） |-- acp （Android \"acp\" Command） |-- apicheck （api检查工具） |-- applypatch （补丁工具） |-- apriori （预链接工具） |-- atree （tree工具） |-- bin2asm （bin转换为asm工具） |-- check_prereq （检查编译时间戳工具） |-- dexpreopt （模拟器相关工具，具体功能不明） |-- droiddoc （？作用不明，java语言，网上有人说和JDK5有关） |-- fs_config （This program takes a list of files and directories） |-- fs_get_stats （获取文件系统状态） |-- iself （判断是否ELF格式） |-- isprelinked （判断是否prelinked） |-- kcm （按键相关） |-- lsd （List symbol dependencies） |-- releasetools （生成镜像的工具及脚本） |-- rgb2565 （rgb转换为565） |-- signapk （apk签名工具） |-- soslim （strip工具） `-- zipalign （zip archive alignment tool） dalvik目录 dalvik虚拟机 . |-- dalvikvm （main.c的目录） |-- dexdump （dex反汇编） |-- dexlist （List all methods in all concrete classes in a DEX file.） |-- dexopt （预验证与优化） |-- docs （文档） |-- dvz （和zygote相关的一个命令） |-- dx （dx工具，将多个java转换为dex） |-- hit （？java语言写成） |-- libcore （核心库） |-- libcore-disabled （？禁用的库） |-- libdex （dex的库） |-- libnativehelper （Support functions for Android's class libraries） |-- tests （测试代码） |-- tools （工具） `-- vm （虚拟机实现） development 目录 （开发者需要的一些例程及工具） |-- apps （一些核心应用程序） | |-- BluetoothDebug （蓝牙调试程序） | |-- CustomLocale （自定义区域设置） | |-- Development （开发） | |-- Fallback （和语言相关的一个程序） | |-- FontLab （字库） | |-- GestureBuilder （手势动作） | |-- NinePatchLab （？） | |-- OBJViewer （OBJ查看器） | |-- SdkSetup （SDK安装器） | |-- SpareParts （高级设置） | |-- Term （远程登录） | `-- launchperf （？） |-- build （编译脚本模板） |-- cmds （有个monkey工具） |-- data （配置数据） |-- docs （文档） |-- host （主机端USB驱动等） |-- ide （集成开发环境） |-- ndk （本地开发套件——c语言开发套件） |-- pdk （Plug Development Kit） |-- samples （例程） | |-- AliasActivity （？） | |-- ApiDemos （API演示程序） | |-- BluetoothChat （蓝牙聊天） | |-- BrowserPlugin （浏览器插件） | |-- BusinessCard （商业卡） | |-- Compass （指南针） | |-- ContactManager （联系人管理器） | |-- CubeLiveWallpaper （动态壁纸的一个简单例程） | |-- FixedGridLayout （像是布局） | |-- GlobalTime （全球时间） | |-- HelloActivity （Hello） | |-- Home （Home） | |-- JetBoy （jetBoy游戏） | |-- LunarLander （貌似又是一个游戏） | |-- MailSync （邮件同步） | |-- MultiResolution （多分辨率） | |-- MySampleRss （RSS） | |-- NotePad （记事本） | |-- RSSReader （RSS阅读器） | |-- SearchableDictionary （目录搜索） | |-- SimpleJNI （JNI例程） | |-- SkeletonApp （空壳APP） | |-- Snake （snake程序） | |-- SoftKeyboard （软键盘） | |-- Wiktionary （？维基） | `-- WiktionarySimple（？维基例程） |-- scripts （脚本） |-- sdk （sdk配置） |-- simulator （？模拟器） |-- testrunner （？测试用） `-- tools （一些工具） external 目录 . |-- aes （AES加密） |-- apache-http （网页服务器） |-- astl （ASTL (Android STL) is a slimmed-down version of the regular C++ STL.） |-- bison （自动生成语法分析器，将无关文法转换成C、C++） |-- blktrace （blktrace is a block layer IO tracing mechanism） |-- bluetooth （蓝牙相关、协议栈） |-- bsdiff （diff工具） |-- bzip2 （压缩工具） |-- clearsilver （html模板系统） |-- dbus （低延时、低开销、高可用性的IPC机制） |-- dhcpcd （DHCP服务） |-- dosfstools （DOS文件系统工具） |-- dropbear （SSH2的server） |-- e2fsprogs （EXT2文件系统工具） |-- elfcopy （复制ELF的工具） |-- elfutils （ELF工具） |-- embunit （Embedded Unit Project） |-- emma （java代码覆盖率统计工具） |-- esd （Enlightened Sound Daemon，将多种音频流混合在一个设备上播放） |-- expat （Expat is a stream-oriented XML parser.） |-- fdlibm （FDLIBM (Freely Distributable LIBM)） |-- freetype （字体） |-- fsck_msdos （dos文件系统检查工具） |-- gdata （google的无线数据相关） |-- genext2fs （genext2fs generates an ext2 filesystem as a normal (non-root) user） |-- giflib （gif库） |-- googleclient （google用户库） |-- grub （This is GNU GRUB, the GRand Unified Bootloader.） |-- gtest （Google C++ Testing Framework） |-- icu4c （ICU(International Component for Unicode)在C/C++下的版本） |-- ipsec-tools （This package provides a way to use the native IPsec functionality ） |-- iptables （防火墙） |-- jdiff （generate a report describing the difference between two public Java APIs.） |-- jhead （jpeg头部信息工具） |-- jpeg （jpeg库） |-- junit （JUnit是一个Java语言的单元测试框架） |-- kernel-headers （内核的一些头文件） |-- libffi （libffi is a foreign function interface library.） |-- libpcap （网络数据包捕获函数） |-- libpng （png库） |-- libxml2 （xml解析库） |-- mtpd （一个命令） |-- netcat （simple Unix utility which reads and writes dataacross network connections） |-- netperf （网络性能测量工具） |-- neven （看代码和JNI相关） |-- opencore （多媒体框架） |-- openssl （SSL加密相关） |-- openvpn （VPN开源库） |-- oprofile （OProfile是Linux内核支持的一种性能分析机制。） |-- ping （ping命令） |-- ppp （pppd拨号命令，好像还没有chat） |-- proguard （Java class file shrinker, optimizer, obfuscator, and preverifier） |-- protobuf （a flexible, efficient, automated mechanism for serializing structured data） |-- qemu （arm模拟器） |-- safe-iop （functions for performing safe integer operations ） |-- skia （skia图形引擎） |-- sonivox （sole MIDI solution for Google Android Mobile Phone Platform） |-- speex （Speex编/解码API的使用(libspeex)） |-- sqlite （数据库） |-- srec （Nuance 公司提供的开源连续非特定人语音识别） |-- strace （trace工具） |-- svox （Embedded Text-to-Speech） |-- tagsoup （TagSoup是一个Java开发符合SAX的HTML解析器） |-- tcpdump （抓TCP包的软件） |-- tesseract （Tesseract Open Source OCR Engine.） |-- tinyxml （TinyXml is a simple, small, C++ XML parser） |-- tremor （I stream and file decoder provides an embeddable,integer-only library） |-- webkit （浏览器核心） |-- wpa_supplicant （无线网卡管理） |-- xmlwriter （XML 编辑工具） |-- yaffs2 （yaffs文件系统） `-- zlib （a general purpose data compression library） frameworks 目录 （核心框架——java及C++语言） . |-- base （基本内容） | |-- api （？都是xml文件，定义了java的api？） | |-- awt （AWT库） | |-- build （空的） | |-- camera （摄像头服务程序库） | |-- cmds （重要命令：am、app_proce等） | |-- core （核心库） | |-- data （字体和声音等数据文件） | |-- docs （文档） | |-- graphics （图形相关） | |-- include （头文件） | |-- keystore （和数据签名证书相关） | |-- libs （库） | |-- location （地区库） | |-- media （媒体相关库） | |-- obex （蓝牙传输库） | |-- opengl （2D-3D加速库） | |-- packages （设置、TTS、VPN程序） | |-- sax （XML解析器） | |-- services （各种服务程序） | |-- telephony （电话通讯管理） | |-- test-runner （测试工具相关） | |-- tests （各种测试） | |-- tools （一些叫不上名的工具） | |-- vpn （VPN） | `-- wifi （无线网络） |-- opt （可选部分） | |-- com.google.android （有个framework.jar） | |-- com.google.android.googlelogin （有个client.jar） | `-- emoji （standard message elements） `-- policies （Product policies are operating system directions aimed at specific uses） `-- base |-- mid （MID设备） `-- phone （手机类设备，一般用这个） hardware 目录 （部分厂家开源的硬解适配层HAL代码） |-- broadcom （博通公司） | `-- wlan （无线网卡） |-- libhardware （硬件库） | |-- include （头文件） | `-- modules （Default (and possibly architecture dependents) HAL modules） | |-- gralloc （gralloc显示相关） | `-- overlay （Skeleton for the \"overlay\" HAL module.） |-- libhardware_legacy （旧的硬件库） | |-- flashlight （背光） | |-- gps （GPS） | |-- include （头文件） | |-- mount （旧的挂载器） | |-- power （电源） | |-- qemu （模拟器） | |-- qemu_tracing （模拟器跟踪） | |-- tests （测试） | |-- uevent （uevent） | |-- vibrator （震动） | `-- wifi （无线） |-- msm7k （高通7k处理器开源抽象层） | |-- boot （启动） | |-- libaudio （声音库） | |-- libaudio-qsd8k （qsd8k的声音相关库） | |-- libcamera （摄像头库） | |-- libcopybit （copybit库） | |-- libgralloc （gralloc库） | |-- libgralloc-qsd8k （qsd8k的gralloc库） | |-- liblights （背光库） | `-- librpc （RPC库） |-- ril （无线电抽象层） | |-- include （头文件） | |-- libril （库） | |-- reference-cdma-sms （cdma短信参考） | |-- reference-ril （ril参考） | `-- rild （ril后台服务程序） `-- ti （ti公司开源HAL） |-- omap3 （omap3处理器） | |-- dspbridge （DSP桥） | |-- libopencorehw （opencore硬件库） | |-- liboverlay （overlay硬件库） | |-- libstagefrighthw （stagefright硬件库） | `-- omx （omx组件） `-- wlan （无线网卡） packages 目录 . |-- apps （应用程序库） | |-- AlarmClock （闹钟） | |-- Bluetooth （蓝牙） | |-- Browser （浏览器） | |-- Calculator （计算器） | |-- Calendar （日历） | |-- Camera （相机） | |-- CertInstaller （在Android中安装数字签名，被调用） | |-- Contacts （拨号(调用)、联系人、通话记录） | |-- DeskClock （桌面时钟） | |-- Email （Email） | |-- Gallery （相册，和Camera类似，多了列表） | |-- Gallery3D （？3D相册） | |-- GlobalSearch （为google搜索服务，提供底层应用） | |-- GoogleSearch （google搜索） | |-- HTMLViewer （浏览器附属界面，被浏览器应用调用，同时提供存储记录功能） | |-- IM （即时通讯，为手机提供信号发送、接收、通信的服务） | |-- Launcher （登陆启动项，显示图片框架等等图形界面） | |-- Launcher2 （登陆启动项，负责应用的调用） | |-- Mms （？彩信业务） | |-- Music （音乐播放器） | |-- PackageInstaller （安装、卸载程序的响应） | |-- Phone （电话拨号程序） | |-- Provision （预设应用的状态，使能应用） | |-- Settings （开机设定，包括电量、蓝牙、设备信息、界面、wifi等） | |-- SoundRecorder （录音机，可计算存储所需空间和时间） | |-- Stk （接收和发送短信） | |-- Sync （空） -------○1 | |-- Updater （空） | `-- VoiceDialer （语音识别通话） |-- inputmethods （输入法） | |-- LatinIME （拉丁文输入法） | |-- OpenWnn （OpenWnn输入法） | `-- PinyinIME （拼音输入法） |-- providers （提供器，提供应用程序、界面所需的数据） | |-- ApplicationsProvider （应用程序提供器，提供应用程序启动项、更新等） | |-- CalendarProvider （日历提供器） | |-- ContactsProvider （联系人提供器） | |-- DownloadProvider （下载管理提供器） | |-- DrmProvider （创建和更新数据库时调用） | |-- GoogleContactsProvider （联系人提供器的子类，用以同步联系人） | |-- GoogleSubscribedFeedsProvider（设置信息提供器） | |-- ImProvider （空） | |-- ManagementProvider （空） | |-- MediaProvider （媒体提供器，提供存储数据） | |-- TelephonyProvider （彩信提供器） | |-- UserDictionaryProvider （用户字典提供器，提供用户常用字字典） | `-- WebSearchProvider （空） |-- services | |-- EasService （空） | `-- LockAndWipe （空） `-- wallpapers （墙纸） |-- Basic （基本墙纸，系统内置墙纸） |-- LivePicker （选择动态壁纸） |-- MagicSmoke （壁纸特殊效果） `-- MusicVisualization （音乐可视化，图形随音乐而变化） ○1里面有一个隐藏的.git文件夹，内容都是一样的，没有有意义的代码，config看似乎是一个下载程序，因此认为这些文件夹下没有实质东西。 prebuilt 目录 （x86和arm架构下预编译的一些资源） . |-- android-arm （arm-android相关） | |-- gdbserver （gdb调试器） | `-- kernel （模拟的arm内核） |-- android-x86 （x86-android相关） | `-- kernel （空的） |-- common （通用编译好的代码，应该是java的） |-- darwin-x86 （drawin x86平台） | `-- toolchain （工具链） | |-- arm-eabi-4.2.1 | |-- arm-eabi-4.3.1 | `-- arm-eabi-4.4.0 |-- darwin-x86_64 （drawin x86 64bit平台） |-- linux-x86 （linux x86平台） | `-- toolchain （工具链，我们应该主要用这个） | |-- arm-eabi-4.2.1 | |-- arm-eabi-4.3.1 | |-- arm-eabi-4.4.0 | `-- i686-unknown-linux-gnu-4.2.1 （x86版编译器） |-- linux-x86_64 （linux x86 64bit平台） |-- windows （windows平台） `-- windows-x86_64 （64bit windows平台） system 目录 （底层文件系统库、应用及组件——C语言） . |-- Bluetooth （蓝牙相关） |-- core （系统核心工具盒接口） | |-- adb （adb调试工具） | |-- cpio （cpio工具，创建img） | |-- debuggerd （调试工具） | |-- fastboot （快速启动相关） | |-- include （系统接口头文件） | |-- init （init程序源代码） | |-- libacc （轻量级C编译器） | |-- libctest （libc测试相关） | |-- libcutils （libc工具） | |-- liblog （log库） | |-- libmincrypt （加密库） | |-- libnetutils （网络工具库） | |-- libpixelflinger （图形处理库） | |-- libsysutils （系统工具库） | |-- libzipfile （zip库） | |-- logcat （查看log工具） | |-- logwrapper （log封装工具） | |-- mkbootimg （制作启动boot.img的工具盒脚本） | |-- netcfg （网络配置netcfg源码） | |-- nexus （google最新手机的代码） | |-- rootdir （rootfs，包含一些etc下的脚本和配置） | |-- sh （shell代码） | |-- toolbox （toolbox，类似busybox的工具集） | `-- vold （SD卡管理器） |-- extras （额外工具） | |-- latencytop （a tool for software developers ，identifying system latency happen） | |-- libpagemap （pagemap库） | |-- librank （Java Library Ranking System库） | |-- procmem （pagemap相关） | |-- procrank （Java Library Ranking System相关） | |-- showmap （showmap工具） | |-- showslab （showslab工具） | |-- sound （声音相关） | |-- su （su命令源码） | |-- tests （一些测试工具） | `-- timeinfo （时区相关） `-- wlan （无线相关） `-- ti （ti网卡相关工具及库） vendor 目录 （厂家定制内容） 20 |-- aosp （android open source project） | `-- products （一些板级规则） |-- htc （HTC公司） | |-- common-open （通用部分） | | `-- akmd （解压img用的工具） | |-- dream-open （G1开放部分） | |-- prebuilt-open （预编译开放部分） | `-- sapphire-open （sapphire这款型号开放内容） |-- pv-open （没东西） |-- qcom （里面基本是空的） `-- sample （google提供的样例） |-- apps （应用） | |-- client （用户） | `-- upgrade （升级） |-- frameworks （框架） | `-- PlatformLibrary （平台库） |-- products （产品） |-- sdk_addon （sdk添加部分） `-- skins （皮肤） `-- WVGAMedDpi （WVGA适用的图片） No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-1.框架层-基础与源码/Android结构.html":{"url":"04_Android/框架层/4-1.框架层-基础与源码/Android结构.html","title":"Android结构","keywords":"","body":"API级别和版本号 https://source.android.com/setup/start/build-numbers Android系统架构 总的来说，Android的系统体系结构分为四层，自顶向下分别是： 应用程序(Applications) 应用程序框架(Application Frameworks) 系统运行库与Android运行环境(Libraris & Android Runtime) Linux内核(Linux Kernel) 安卓系统结构示意图 下面对每层进行详细说明 1. 应用程序(Applications) Android会同一系列核心应用程序包一起发布，该应用程序包包括email客户端，SMS短消息程序，日历，地图，浏览器，联系人管理程序等。所有的应用程序都是使用JAVA语言编写的。通常开发人员就处在这一层。 2. 应用程序框架(Application Frameworks) 提供应用程序开发的各种API进行快速开发，也即隐藏在每个应用后面的是一系列的服务和系统，大部分使用Java编写，所谓官方源码很多也就是看这里，其中包括： 丰富而又可扩展的视图（Views），可以用来构建应用程序， 它包括列表（lists），网格（grids），文本框（text boxes），按钮（buttons）， 甚至可嵌入的web浏览器。 内容提供器（Content Providers）使得应用程序可以访问另一个应用程序的数据（如联系人数据库）， 或者共享它们自己的数据 资源管理器（Resource Manager）提供 非代码资源的访问，如本地字符串，图形，和布局文件（ layout files ）。 通知管理器 （Notification Manager） 使得应用程序可以在状态栏中显示自定义的提示信息。 活动管理器（ Activity Manager） 用来管理应用程序生命周期并提供常用的导航回退功能。 3. 系统运行库与Android运行环境(Libraris & Android Runtime) 1) 系统运行库 Android 包含一些C/C++库，这些库能被Android系统中不同的组件使用。它们通过 Android 应用程序框架为开发者提供服务。以下是一些核心库： Bionic系统 C 库 - 一个从 BSD 继承来的标准 C 系统函数库（ libc ）， 它是专门为基于 embedded linux 的设备定制的。 媒体库 - 基于 PacketVideo OpenCORE；该库支持多种常用的音频、视频格式回放和录制，同时支持静态图像文件。编码格式包括MPEG4, H.264, MP3, AAC, AMR, JPG, PNG 。 Surface Manager - 对显示子系统的管理，并且为多个应用程序提 供了2D和3D图层的无缝融合。这部分代码 Webkit,LibWebCore - 一个最新的web浏览器引擎用，支持Android浏览器和一个可嵌入的web视图。鼎鼎大名的 Apple Safari背后的引擎就是Webkit SGL - 底层的2D图形引擎 3D libraries - 基于OpenGL ES 1.0 APIs实现；该库可以使用硬件 3D加速（如果可用）或者使用高度优化的3D软加速。 FreeType -位图（bitmap）和矢量（vector）字体显示。 SQLite - 一个对于所有应用程序可用，功能强劲的轻型关系型数据库引擎。 还有部分上面没有显示出来的就是硬件抽象层。其实Android并非讲所有的设备驱动都放在linux内核里面，而是实现在userspace空间，这么做的主要原因是GPL协议，Linux是遵循该 协议来发布的，也就意味着对 linux内核的任何修改，都必须发布其源代码。而现在这么做就可以避开而无需发布其源代码，毕竟它是用来赚钱的。 而 在linux内核中为这些userspace驱动代码开一个后门，就可以让本来userspace驱动不可以直接控制的硬件可以被访问。而只需要公布这个 后门代码即可。一般情况下如果要将Android移植到其他硬件去运行，只需要实现这部分代码即可。包括：显示器驱动，声音，相机，GPS,GSM等等 2) Android运行环境 该核心库提供了JAVA编程语言核心库的大多数功能。 每一个Android应用程序都在它自己的进程中运 行，都拥有一个独立的Dalvik虚拟 机实例。Dalvik被设计成一个设备可以同时高效地运行多个虚拟系统。 Dalvik虚拟机执行（.dex）的Dalvik可执行文件，该格式文件针对小内存使用做了 优化。同时虚拟机是基于寄存器的，所有的类都经由JAVA编译器编译，然后通过SDK中 的 \"dx\" 工具转化成.dex格式由虚拟机执行。 Dalvik 是 Android 操作系统早期版本中的应用程序运行时环境，它的主要职责是执行 Android 应用程序的字节码。具体来说： Dalvik 运行时简介 角色：Dalvik 是一种基于寄存器的虚拟机，专门为 Android 移动设备设计和优化。它负责解释和执行经过编译的应用程序字节码，确保应用程序能够在 Android 系统上运行。 工作原理： DEX 格式：与传统的 Java 虚拟机（JVM）不同，Dalvik 使用了一种称为 DEX（Dalvik Executable）格式的字节码文件。Java 编译器首先将 Java 源代码编译为标准的 Java 字节码（.class 文件），然后 Android 的编译工具将这些字节码转换为 DEX 格式，以便在 Dalvik 上执行。 内存优化：Dalvik 被设计为在内存受限的环境中运行，如智能手机和平板电脑，因此 DEX 文件格式比标准的 Java 字节码更紧凑，减少了内存占用。 多应用实例：Dalvik 虚拟机的一个关键特点是，它在每个 Android 应用程序中都运行一个独立的虚拟机实例，这种设计使得每个应用程序在其自己的进程中运行，具有独立的内存空间，从而增强了系统的稳定性和安全性。 Dalvik 的历史与演变 早期 Android 版本：Dalvik 是自 Android 1.0 版本以来的默认运行时环境，支持 Android 应用程序在移动设备上高效运行。 ART 的出现：随着 Android 4.4（KitKat）的发布，Google 引入了一个新的运行时环境，名为 Android Runtime（ART），它作为 Dalvik 的替代品。ART 提供了许多性能改进和新功能，如 Ahead-of-Time (AOT) 编译、更加高效的垃圾回收和更好的调试支持。 从 Dalvik 到 ART：自 Android 5.0（Lollipop）开始，ART 成为默认的运行时环境，逐步取代了 Dalvik。ART 的引入标志着 Android 应用程序运行效率的显著提升，因此 Dalvik 从 Android 5.0 版本之后逐渐被淘汰。 3) 关系 协作工作：ART 负责执行应用程序的 Java 字节码，而这些应用程序在运行时需要调用 Libraries 中的功能来完成各种任务。ART 通过 JNI 与 Libraries 交互，以便调用本地库提供的功能。 执行依赖：应用程序的许多功能依赖于 Libraries 提供的底层支持，而 ART 则确保这些库功能能够在运行时正确执行和管理。因此，ART 和 Libraries 共同为应用程序提供了一个完整的运行时环境。 4. Linux内核(Linux Kernel) Android的核心系统服务依赖于Linux 2.6 内核，如安全性，内存管理，进程管理， 网络协议栈和驱动模型。 Linux 内核也同时作为硬件和软件栈之间的抽象层。其外还对其做了部分修改，主要涉及两部分修改： Binder (IPC)：提供有效的进程间通信，虽然linux内核本身已经提供了这些功能，但Android系统很多服务都需要用到该功能，为了某种原因其实现了自己的一套。 电源管理：主要是为了省电，毕竟是手持设备嘛，低耗电才是我们的追求。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-1.框架层-基础与源码/PhoneWindowManager-Power键的处理.html":{"url":"04_Android/框架层/4-1.框架层-基础与源码/PhoneWindowManager-Power键的处理.html","title":"Phonewindowmanager-power键的处理","keywords":"","body":"Power按键如何分发给PhoneWindowManager 1.系统的核心进程SystemServer在run()方法中启动InputManagerService和WindowManagerService。创建WindowManagerService前，先创建InputManager，将其作为参数，且创建了PhoneWindowManager实例： 源码路径：frameworks/base/services/java/com/android/server/SystemServer.java private void startOtherServices() { ...... inputManager = new InputManagerService(context); //输入系统服务 【step_SystemServer_1】 ...... 　　　　//【step_SystemServer_2】 wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore, new PhoneWindowManager()); //PhoneWindowManager实例 ServiceManager.addService(Context.WINDOW_SERVICE, wm); ServiceManager.addService(Context.INPUT_SERVICE, inputManager); } 源码路径：frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java private WindowManagerService(Context context, InputManagerService inputManager, boolean haveInputMethods, boolean showBootMsgs, boolean onlyCore, WindowManagerPolicy policy) { ...... mPolicy = policy; //实例： PhoneWindowManager对象 【step_InputMonitor_2】　　　　　　　......} 2、启动inputManager之前，设置了一个回调接口： 　　　　　　//消息分发之前回调--->查看InputManagerService 　　　　　　inputManager.setWindowManagerCallbacks(wm.getInputMonitor()); 　　　　　　inputManager.start(); 3、InputMonitor.java： 底层收到按键会回调InputManagerService的dispatchUnhandledKey()--->InputMonitor的函数dispatchUnhandledKey()。具体由底层InputDispatcher.cpp调用。 源码路径： frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java //【Power键属于系统级按键，因此处理方法是dispatchUnhandledKey】 /* Provides an opportunity for the window manager policy to process a key that * the application did not handle. */ @Override public KeyEvent dispatchUnhandledKey( InputWindowHandle focus, KeyEvent event, int policyFlags) { WindowState windowState = focus != null ? (WindowState) focus.windowState : null; //此处 mservice: WindowManagerService 【step_InputMonitor_0】 return mService.mPolicy.dispatchUnhandledKey(windowState, event, policyFlags); } 由这三步可知，最终由PhoneWindowManager处理。将上述整理成时序图： PhoneWindowManager处理Power键的基本流程 1.拦截按键事件 PhoneWindowManager 使用 interceptKeyBeforeQueueing() 和 interceptKeyBeforeDispatching() 方法来拦截和处理按键事件。其中，电源键的事件会被系统识别为 KeyEvent.KEYCODE_POWER。 interceptKeyBeforeQueueing： 这个方法是在按键事件加入事件队列之前调用的，主要用于决定事件是否应该被进一步处理，或者应该被丢弃。 interceptKeyBeforeDispatching： 这个方法是在事件派发给窗口之前调用的，在这里可以处理具体的按键逻辑。对于电源键，系统在这个阶段会根据按键状态（按下或松开）进行特定操作。 2.按下电源键 当电源键被按下时，PhoneWindowManager 首先会捕获到 KeyEvent.ACTION_DOWN 事件。根据系统当前的状态，可能会触发以下几种不同的操作： 屏幕关闭（锁屏）：如果电源键按下时间较短，系统会触发屏幕熄灭和锁屏操作，调用 goToSleep()。 唤醒屏幕：如果屏幕处于关闭状态，按下电源键会唤醒屏幕并点亮显示器。 长按电源键：如果用户长按电源键，系统会启动电源菜单（Power Menu），用于显示重启、关机等选项。 3.松开电源键 当电源键被松开时，系统会捕获到 KeyEvent.ACTION_UP 事件。如果之前的按键被识别为短按，则不会触发长按逻辑；相反，如果长按时会弹出电源菜单。 4.电源键的特殊处理 在某些特定情况下，电源键还会触发其他行为，如： 快速双击电源键：启动相机或某些快捷操作。 电源键+音量键组合：用于截屏等功能。 这些行为通常由 PhoneWinterceptKeyBeforeQueueingindowManager 结合系统设置来进行配置和处理。 interceptKeyBeforeQueueing中对于Power键的处理 按键动作切割： 按下： interceptPowerKeyDown(KeyEvent event, boolean interactive) 释放： interceptPowerKeyUp(KeyEvent event, boolean interactive, boolean canceled) 参数含义： interactive：是否亮屏 KeyEvent.FLAG_FALLBACK：不被应用处理的按键事件或一些在 键值映射中不被处理的事件(例：轨迹球事件等)。 涉及到的配置信息的相关源码路径： (下述代码的执行过程中有对一些变量的判断，而这些值都是系统配置的，在config.xml中，因此具体执行哪个流程以当前平台配置为准) frameworks/base/core/java/android/view/ViewConfiguration.java frameworks/base/core/res/res/values/config.xml interceptPowerKeyDown 1 private void interceptPowerKeyDown(KeyEvent event, boolean interactive) { // ??? 2 //FACE_UNLOCK_SUPPORT start 3 Slog.i(\"FaceUnlockUtil\", \"interceptPowerKeyDown interactive = \" + interactive); 4 Settings.System.putInt(mContext.getContentResolver(), \"faceunlock_start\", 1); 5 //FACE_UNLOCK_SUPPORT end // 获得唤醒锁 6 // Hold a wake lock until the power key is released. 7 if (!mPowerKeyWakeLock.isHeld()) { 8 mPowerKeyWakeLock.acquire(); 9 } 10 // 取消连按超时检测 11 // Cancel multi-press detection timeout. 12 if (mPowerKeyPressCounter != 0) { 13 mHandler.removeMessages(MSG_POWER_DELAYED_PRESS); 14 } 15 16 // Detect user pressing the power button in panic when an application has 17 // taken over the whole screen. 18 boolean panic = mImmersiveModeConfirmation.onPowerKeyDown( // 屏幕是否点亮 interactive, // 用来获取当前的系统时间，可能用于判断按键按下的时间或按下的频率。 19 SystemClock.elapsedRealtime(), // 检查当前是否处于沉浸模式。沉浸模式会隐藏系统导航栏和状态栏，允许应用程序完全占据屏幕。 isImmersiveMode(mLastSystemUiFlags), // 检查导航栏是否为空，意味着是否有应用占据整个屏幕。 20 isNavBarEmpty(mLastSystemUiFlags)); // panic = true意味着用户可能是在全屏的应用中无法退出的紧急情况下按下电源键。例如，某些全屏应用可能让用户感觉到被\"锁定\"而不能正常退出，导致用户按下电源键寻求帮助。 21 if (panic) { // 一旦进入恐慌模式，代码会将 mHiddenNavPanic 事件通过 mHandler.post 提交到主线程去执行。这通常是为了确保导航栏或系统界面（如状态栏）恢复显示，以便用户可以退出当前全屏应用，避免陷入无法操作的情况。 22 mHandler.post(mHiddenNavPanic); 23 } 24 25 // Latch power key state to detect screenshot chord. // 条件1：亮屏 26 if (interactive && // 条件2：截屏组合键中Power键Trigger位未被设置 !mScreenshotChordPowerKeyTriggered && // 条件3：不为Fallback按键事件 (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) { // 标记按下power key，用于组合键截屏，具体参考下述3 28 mScreenshotChordPowerKeyTriggered = true; 29 mScreenshotChordPowerKeyTime = event.getDownTime(); 30 interceptScreenshotChord(); 31 } 32 33 // Stop ringing or end call if configured to do so when power is pressed. 34 TelecomManager telecomManager = getTelecommService(); 35 boolean hungUp = false; 36 if (telecomManager != null) { 37 if (telecomManager.isRinging()) { 38 // Pressing Power while there's a ringing incoming 39 // call should silence the ringer. 40 telecomManager.silenceRinger(); 41 } else if ((mIncallPowerBehavior 42 & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 43 && telecomManager.isInCall() && interactive) { 44 // Otherwise, if \"Power button ends call\" is enabled, 45 // the Power button will hang up any current active call. 46 hungUp = telecomManager.endCall(); 47 } 48 } 49 50 GestureLauncherService gestureService = LocalServices.getService( 51 GestureLauncherService.class); 52 boolean gesturedServiceIntercepted = false; 53 if (gestureService != null) { // gesturedServiceIntercepted 是一个标志变量，用来指示手势服务是否拦截了电源键的按下事件。默认值设为 false，表示事件尚未被拦截。 54 gesturedServiceIntercepted = gestureService.interceptPowerKeyDown(event, interactive, 55 mTmpBoolean); // 在设备即将进入睡眠状态时，用户的手势（如快速双击电源键启动相机）触发了相机启动操作。 56 if (mTmpBoolean.value && mRequestedOrGoingToSleep) { 57 mCameraGestureTriggeredDuringGoingToSleep = true; 58 } 59 } 60 61 // Inform the StatusBar; but do not allow it to consume the event. 62 sendSystemKeyToStatusBarAsync(event.getKeyCode()); // 63 64 // If the power key has still not yet been handled, then detect short 65 // press, long press, or multi press and decide what to do. 66 mPowerKeyHandled = hungUp || mScreenshotChordVolumeDownKeyTriggered 67 || mA11yShortcutChordVolumeUpKeyTriggered || gesturedServiceIntercepted; 68 if (!mPowerKeyHandled) { 69 if (interactive) { // 亮屏 70 // When interactive, we're already awake. 71 // Wait for a long press or for the button to be released to decide what to do. 72 if (hasLongPressOnPowerBehavior()) { //长按----判断是否为弹出操作界面的逻辑 73 Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS); 74 msg.setAsynchronous(true); 75 mHandler.sendMessageDelayed(msg, 76 ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); //500ms 77 } 78 } else { 79 wakeUpFromPowerKey(event.getDownTime()); //唤醒屏幕---...... 80 81 if (mSupportLongPressPowerWhenNonInteractive && hasLongPressOnPowerBehavior()) { //当前配置mSupportLongPressPowerWhenNonInteractive=false 82 Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS); 83 msg.setAsynchronous(true); 84 mHandler.sendMessageDelayed(msg, 85 ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); 86 mBeganFromNonInteractive = true; 87 } else { 88 final int maxCount = getMaxMultiPressPowerCount(); //当前配置不支持config.xml 89 90 if (maxCount (1) 亮屏 hasLongPressOnPowerBehavior()---mHandler发送消息(500ms)--powerLongPress() ------>getResolvedLongPressOnPowerBehavior()根据获取的值来 执行相应的流程：　　　　 LONG_PRESS_POWER_GLOBAL_ACTIONS：弹出操作界面---->showGlobalActionsInternal()--->sendCloseSystemWindows(String reason) /mGlobalActions.showDialog()---->PhoneWindow.sendCloseSystemWindows(mContext, reason).... LONG_PRESS_POWER_SHUT_OFF/LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM：直接关机，相当于点击上述弹框中的关机操作。此处可结合源码查看： 对应属性：factory.long_press_power_off 使用命令：adb shell getprop/setprop...即可测试效果。 (2) 灭屏 wakeUpFromPowerKey()---->wakeUp()---- >mPowerManager.wakeUp()....调用PowerManagerService唤醒屏幕. 1 private void wakeUpFromPowerKey(long eventTime) { 2 wakeUp(eventTime, mAllowTheaterModeWakeFromPowerKey, \"android.policy:POWER\"); 3 } 4 5 private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, String reason) { 6 ...... 10 final boolean theaterModeEnabled = isTheaterModeEnabled(); 11 if (!wakeInTheaterMode && theaterModeEnabled) { 12 return false; 13 } 14 15 // Settings.Global.THEATER_MODE_ON： 16 if (theaterModeEnabled) { 17 Settings.Global.putInt(mContext.getContentResolver(), 18 Settings.Global.THEATER_MODE_ON, 0); 19 } 20 21 mPowerManager.wakeUp(wakeTime, reason); 22 return true; 23 } interceptPowerKeyUp 1 private void interceptPowerKeyUp(KeyEvent event, boolean interactive, boolean canceled) { 2 final boolean handled = canceled || mPowerKeyHandled; 3 mScreenshotChordPowerKeyTriggered = false; 4 cancelPendingScreenshotChordAction(); 5 cancelPendingPowerKeyAction(); //取消长按事件---即500ms内未监听到释放，才执行长按事件 6 7 if (!handled) { //亮屏 短按Power释放时执行此处## 因mPowerKeyHandled=false 8 // Figure out how to handle the key now that it has been released. 9 mPowerKeyPressCounter += 1; 10 11 final int maxCount = getMaxMultiPressPowerCount(); //maxCount=1 12 final long eventTime = event.getDownTime(); 13 if (mPowerKeyPressCounter (1) 亮屏 powerPress()--->goToSleep()--- >mPowerManager.goToSleep()...调用PowerManagerService 使系统睡眠。 (2) 灭屏 finishPowerKeyPress()... 组合键（Power + 音量减）：功能就是我们常用的屏幕截图的快捷方式。 1 @Override 2 public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) { 3 if (!mSystemBooted) { 4 // If we have not yet booted, don't let key events do anything. 5 return 0; 6 } 7 8 ......//代码略 9 final int keyCode = event.getKeyCode(); 10 // Basic policy based on interactive state. 11 int result; 12 13 // Handle special keys. 14 switch (keyCode) { 15 ...... 16 case KeyEvent.KEYCODE_VOLUME_MUTE: { 17 if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) { //音量键减- 【Power + VOLUME_DOWN】截屏操作 18 if (down) { 19 if (interactive && !mScreenshotChordVolumeDownKeyTriggered 20 && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) { 21 mScreenshotChordVolumeDownKeyTriggered = true; 22 mScreenshotChordVolumeDownKeyTime = event.getDownTime(); 23 mScreenshotChordVolumeDownKeyConsumed = false; 24 cancelPendingPowerKeyAction(); 25 interceptScreenshotChord(); 26 interceptAccessibilityShortcutChord(); 27 } 28 } else { 29 mScreenshotChordVolumeDownKeyTriggered = false; 30 cancelPendingScreenshotChordAction(); 31 cancelPendingAccessibilityShortcutAction(); 32 } 33 } else if(...){ 34 ...... 35 } 36 ...... 37 break; 38 } 39 case KeyEvent.KEYCODE_POWER: { //POWER 键 40 if(SystemProperties.getBoolean(\"sys.requireKey\", false)) break; 41 // Any activity on the power button stops the accessibility shortcut 42 cancelPendingAccessibilityShortcutAction(); 43 result &= ~ACTION_PASS_TO_USER; //不分发按键至应用 44 isWakeKey = false; // wake-up will be handled separately 45 if (down) { 46 interceptPowerKeyDown(event, interactive); //在上述1中interceptPowerKeyDown()的第28行可见标记mScreenshotChordPowerKeyTriggered = true; 47 } else { 48 interceptPowerKeyUp(event, interactive, canceled); 49 } 50 break; 51 } 52 ...... 53 } 54 55 ...... 56 return result; 57 } 58 59 // 截屏 60 private void interceptScreenshotChord() { 61 if (mScreenshotChordEnabled 62 && mScreenshotChordVolumeDownKeyTriggered && mScreenshotChordPowerKeyTriggered //同时按下Volum_down + Power, 后执行的该方法 63 && !mA11yShortcutChordVolumeUpKeyTriggered) { 64 final long now = SystemClock.uptimeMillis(); 65 if (now 结合上述代码，可概括流程为： interceptScreenshotChord()：----->启动线程ScreenshotRunnable---->takeScreenshot()----可看出真正的截图操作是在SystemUI中。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-1.框架层-基础与源码/PhoneWindowManager.html":{"url":"04_Android/框架层/4-1.框架层-基础与源码/PhoneWindowManager.html","title":"Phonewindowmanager","keywords":"","body":"按键分发流程 1. 硬件层 当用户按下某个按键（例如电源键、音量键或返回键），这个动作首先在硬件层被捕捉。设备的按键与硬件 GPIO（通用输入输出端口）或其他电子线路相连，按下按钮会触发一个电信号。 2. Linux 内核层 硬件触发的电信号通过设备驱动程序进入 Linux 内核。Android 的输入系统基于 Linux 内核，按键事件最初会由内核中的输入子系统处理。 输入设备驱动：每个物理按键（如电源键、音量键）都有对应的设备驱动，它将按键事件转换成标准化的 Linux 输入事件 (evdev 事件)。 事件设备 (/dev/input/eventX)：内核通过输入设备驱动将按键事件写入 /dev/input/eventX 设备文件，该设备文件会把原始的硬件事件转化为操作系统层的输入事件。 3. Android 输入系统 Android 的输入系统位于 InputManagerService 中，负责从内核获取输入事件，并传递给系统中相应的模块。这个过程由以下两个主要组件完成： 3.1 InputReader 功能：InputReader 通过监听 /dev/input/eventX 设备文件，读取来自输入设备的原始事件（例如按键按下或松开）。 事件解析：InputReader 负责解析输入事件，将这些低级别的输入数据转化为 Android 中的 KeyEvent 事件。 3.2 InputDispatcher 功能：InputDispatcher 从 InputReader 获取处理后的按键事件，然后负责将事件分发到系统中合适的窗口或组件（如应用的 Activity 或系统界面）。 事件分发：InputDispatcher 根据当前的焦点窗口、系统状态（如锁屏状态、输入法弹出状态等），决定将按键事件分发给哪个窗口。例如，系统按键事件可能会先交给 PhoneWindowManager 进行处理。 4. Framework 层 4.1 WindowManagerService (WMS) WindowManagerService 是 Android 系统管理窗口的服务，负责处理系统的输入焦点、窗口层级等。InputDispatcher 会根据当前的窗口焦点和系统状态将按键事件交给 WindowManagerService，由它进一步处理。 PhoneWindowManager：对于电源键、音量键等系统级按键，WindowManagerService 中的 PhoneWindowManager 会首先拦截和处理这些事件。例如，按下电源键时，PhoneWindowManager 会决定是否唤醒屏幕或显示电源菜单。 1. 按键事件加入事件队列之前：interceptKeyBeforeQueueing() interceptKeyBeforeQueueing() 方法在按键事件被放入 输入事件队列 之前被调用。这是处理按键事件的第一个时机，主要用于决定是否允许事件继续进入队列，或在某些特殊情况下直接消耗掉事件。 时机： 当用户按下或松开按键时，输入子系统首先捕捉到硬件事件。 在事件被传递给系统事件队列之前，PhoneWindowManager 的 interceptKeyBeforeQueueing() 方法会被调用。 用途： 决定是否拦截事件或允许事件进入事件队列。 判断当前设备的状态（例如，屏幕是否点亮、设备是否处于锁屏状态等）来决定是否处理事件。 过滤不必要的事件，例如在某些特殊模式下禁用特定按键。 例子： 当设备屏幕关闭时按下电源键，系统会通过 interceptKeyBeforeQueueing() 直接唤醒屏幕，而不是将事件进一步传递给应用程序。 2. 事件派发给窗口之前：interceptKeyBeforeDispatching() interceptKeyBeforeDispatching() 方法是在按键事件从事件队列中取出，并准备派发给窗口之前调用的。此时，按键事件已经被系统接收并准备传递到前台活动（Activity）的输入系统。 时机： 事件已经进入输入事件队列并等待处理。 在事件被分发到对应的窗口（例如当前的 Activity 或 SystemUI）之前，PhoneWindowManager 会通过 interceptKeyBeforeDispatching() 方法再次拦截事件。 这一阶段可以根据具体的按键操作和系统状态来进一步处理事件。 用途： 可以根据具体的按键行为进行不同的操作处理，例如短按、长按等。 例如，长按电源键弹出电源菜单，或者组合按键触发截屏操作。 也可以根据当前活动窗口的类型决定是否将事件传递给应用层处理。 例子： 当电源键被长按超过特定时间时，interceptKeyBeforeDispatching() 可以识别出长按行为，并显示电源菜单。 如果是短按电源键，则在这个阶段可能直接处理唤醒或关闭屏幕，而不需要进一步派发给应用。 4.2 Activity 的事件处理 如果按键事件是应用级别的，比如返回键、菜单键，事件会被 WindowManagerService 分发到应用程序的窗口管理器 Window。 ViewRootImpl：每个应用窗口都对应一个 ViewRootImpl，它是应用窗口的根视图。ViewRootImpl 从 WindowManagerService 接收按键事件，并传递给应用层的 View 组件。 5. 应用层 5.1 Activity 和 View 的事件处理 按键事件最终被传递到应用层的 Activity 或 View 组件进行处理。应用层通过重写以下方法来处理按键事件： Activity.onKeyDown() 和 Activity.onKeyUp()：开发者可以在这些方法中处理按键按下和松开的事件。 View.onKeyDown() 和 View.onKeyUp()：每个视图组件也可以接收按键事件，开发者可以通过自定义视图组件来处理特定的按键输入。 5.2 事件冒泡 按键事件会在视图层次结构中进行冒泡传递（即从当前的焦点视图逐层向上传递），直到被某个视图处理或被最终的 Activity 接收。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-1.框架层-基础与源码/REFERS.html":{"url":"04_Android/框架层/4-1.框架层-基础与源码/REFERS.html","title":"Refers","keywords":"","body":" Android Framework 源码开发揭秘 xiangxue888 MIUI_ROM定制教程-移动开发 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-1.框架层-基础与源码/ueventd.html":{"url":"04_Android/框架层/4-1.框架层-基础与源码/ueventd.html","title":"Ueventd","keywords":"","body":"Ueventd Overview ueventd 是负责管理 /dev 目录中的设备节点、设置 /sys 文件的权限，并处理固件 uevents 的 Android 系统服务。它提供了默认行为，并且可以通过自定义脚本语言进行扩展和调整。这些脚本语言的解析器与 init 相同，允许开发者根据需要修改其行为。 主要功能 管理 /dev 设备节点： ueventd 监听内核的 uevent 套接字，并基于接收到的 add 或 remove uevent 来创建或删除设备节点。默认情况下，设备节点会以模式 0600 创建，用户和组都为 root，并会根据当前加载的 SELinux 策略设置 SELabel。 设置设备权限： ueventd 允许在 /dev 目录下为设备节点设置不同的权限。通过配置脚本，开发者可以指定设备节点的权限、用户和组。例如，使用以下配置可以为 /dev/null 设置权限： ``` bash 复制代码 /dev/null 0666 root root 3. **设备路径与设备名设置：** 默认情况下，`ueventd` 会根据设备类型来创建设备路径： - **块设备：** 创建为 `/dev/block/`，并在不同的路径下创建符号链接。 - **USB 设备：** 根据 uevent 中提供的 `DEVNAME`，创建 `/dev/`，否则创建 `/dev/bus/usb//`。 - **其他设备：** 根据设备的 `DEVPATH` 创建设备。 4. **子系统和路径配置：** 可以通过 `subsystem` 配置段来设置特定子系统（如 `sound`）的设备节点路径和目录： bash复制代码subsystem sound devname uevent_devpath dirname /dev/snd 这样所有 `SUBSYSTEM=sound` 的设备将被创建在 `/dev/snd/` 目录下。 ### **/sys 目录管理** `ueventd` 默认情况下不对 `/sys` 目录进行任何操作，但它可以根据匹配的 uevent 来设置 `/sys` 中文件的权限。通过 `ueventd.rc` 配置文件，可以为 `/sys` 中的特定文件设置权限和用户/组。例如： bash 复制代码 /sys/devices/system/cpu/cpu* cpufreq/scaling_max_freq 0664 system system 这表示当匹配 `/sys/devices/system/cpu/cpu*` 路径的 uevent 发送时，`cpufreq/scaling_max_freq` 文件将被设置为 `0664` 权限，用户和组为 `system`。 ### **固件加载** `ueventd` 负责加载内核固件。它默认会在多个固件目录中查找与 uevent 中的 `FIRMWARE` 名称匹配的文件，然后为内核提供固件。固件目录可以通过 `firmware_directories` 配置进行扩展。还可以通过 `external_firmware_handler` 配置，运行外部程序来处理固件请求。例如： bash 复制代码 external_firmware_handler /devices/leds/red/firmware/coeffs.bin system /vendor/bin/led_coeffs.bin 这会运行 `/vendor/bin/led_coeffs.bin` 程序而不是直接加载默认的固件。 ### **冷启动（Coldboot）** 当 `ueventd` 启动时，它会执行所谓的“冷启动”，即通过向 `/sys/class`、`/sys/block` 和 `/sys/devices` 中的每个 uevent 文件写入 `add`，让内核重新生成这些路径的 uevents，从而触发设备节点的创建。为了加速启动过程，这一过程会并行化。 ### **配置选项** 1. **`uevent_socket_rcvbuf_size`**：用来设置 ueventd 套接字的接收缓冲区大小。例如： bash 复制代码 uevent_socket_rcvbuf_size 16M 这会将接收缓冲区大小设置为 16MB。 2. **导入配置文件：** 可以使用 `import` 命令导入其他配置文件，扩展当前的配置。例如： bash 复制代码 import /path/to/another/config.rc ``` 如果指定的是目录，ueventd 会解析目录下的所有文件，但不会递归解析子目录。 路径匹配： 对于 /dev 或 /sys 条目的路径，ueventd 支持使用通配符 * 进行匹配。当通配符出现在路径结尾时，ueventd 会使用 fnmatch(entry_path, incoming_path, 0) 进行匹配，否则使用 fnmatch(entry_path, incoming_path, FNM_PATHNAME) 进行路径匹配。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-1.框架层-基础与源码/屏保在系统的相关处理.html":{"url":"04_Android/框架层/4-1.框架层-基础与源码/屏保在系统的相关处理.html","title":"屏保在系统的相关处理","keywords":"","body":"屏保在系统的相关处理 屏保设置 DaydreamFragment.java refreshActiveDreamPref() { // 获取屏保信息列表 final List infos = mBackend.getDreamInfos(); ...... // 根据获取信息展示屏保列表 ...... } DreamBackend.java public List getDreamInfos() { // Filter查询满足条件的APK ComponentName activeDream = getActiveDream(); PackageManager pm = mContext.getPackageManager(); Intent dreamIntent = new Intent(DreamService.SERVICE_INTERFACE); // DreamService.java // public static final String SERVICE_INTERFACE =\"android.service.dreams.DreamService\"; List resolveInfos = pm.queryIntentServices(dreamIntent,PackageManager.GET_META_DATA); List dreamInfos = new ArrayList<>(resolveInfos.size()); for (ResolveInfo resolveInfo : resolveInfos) { if (resolveInfo.serviceInfo == null) continue; DreamInfo dreamInfo = new DreamInfo(); dreamInfo.caption = resolveInfo.loadLabel(pm); dreamInfo.icon = resolveInfo.loadIcon(pm); dreamInfo.componentName = getDreamComponentName(resolveInfo); dreamInfo.isActive = dreamInfo.componentName.equals(activeDream); dreamInfo.settingsComponentName = getSettingsComponentName(pm, resolveInfo); dreamInfos.add(dreamInfo); } Collections.sort(dreamInfos, mComparator); return dreamInfos; } 列表中选择Bravia屏保时，会将screensaver_components设值为com.sony.dtv.braviashow/com.sony.dtv.braviashow.BraviaDayDreamService 启动屏保时会根据screensaver_components绑定对应的Service，打开选择的屏保 （adb shell settings list secure //查询系统设置值） 启动屏保 DreamManagerService.java private final class LocalService extends DreamManagerInternal { @Override public void startDream(boolean doze) { //启动屏保 startDreamInternal(doze); } @Override // 停止屏保：解绑DreamService public void stopDream(boolean immediate) { stopDreamInternal(immediate, \"requested stopDream\"); } } private void startDreamInternal(boolean doze) { final int userId = ActivityManager.getCurrentUser(); final ComponentName dream = chooseDreamForUser(doze, userId); // chooseDreamForUser从系统信息取值 // Settings.Secure.SCREENSAVER_COMPONENTS isEmpty ? Settings.Secure.SCREENSAVER_DEFAULT_COMPONENT : Settings.Secure.SCREENSAVER_COMPONENTS // 查看屏保设置的值 // adb shell settings list secure // screensaver_components=com.sony.dtv.braviashow/com.sony.dtv.braviashow.BraviaDayDreamService // screensaver_default_component=com.sony.dtv.braviashow/com.sony.dtv.braviashow.BraviaDayDreamService ...... startDreamLocked(dream, false /*isTest*/, doze, userId); } private void startDreamLocked(...){ ...... // DreamController // name = com.sony.dtv.braviashow/com.sony.dtv.braviashow.BraviaDayDreamService mController.startDream(newToken, name, isTest, canDoze, userId, wakeLock); } DreamController.java public void startDream(...) { ...... Intent intent = new Intent(DreamService.SERVICE_INTERFACE); // name = com.sony.dtv.braviashow/com.sony.dtv.braviashow.BraviaDayDreamService intent.setComponent(name); intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS); // 绑定BraviaDayDreamService mContext.bindServiceAsUser(intent, mCurrentDream, Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE, new UserHandle(userId))) { } No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-2.框架层-权限/Android权限管理-SELinux.html":{"url":"04_Android/框架层/4-2.框架层-权限/Android权限管理-SELinux.html","title":"Android权限管理-selinux","keywords":"","body":"SELinux运行的三种状态 状态 解析 Enforcing SELinux security policy is enforced. Permissive SELinux prints warnings instead of enforcing. Disabled SELinux is fully disabled. 查看SELinux运行状态 getenforce 切换到Permissive状态 setenforce 0 切换到Enforcing状态 setenforce 1 这种切换方式不用重启机器，但是该命令只能将SELinux在enforcing、permissive这两种模式之间切换，重启服务器后，又会恢复到etc/selinux/config下，也就是说setenforce的修改不能持久 另外就是修改/etc/selinux/config，如下所示，可以配置SELinux为enforcing、permissive、disabled三个值，修改后必须重启系统才能生效。 [root@DB-Server ~]# more /etc/selinux/config # This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - SELinux is fully disabled. SELINUX=enforcing # SELINUXTYPE= type of policy in use. Possible values are: # targeted - Only targeted network daemons are protected. # strict - Full SELinux protection. SELINUXTYPE=targeted You have new mail in /var/spool/mail/root 如果由 enforcing 或 permissive 改成 disabled，或由 disabled 改成其他两个，那也必须要重新开机。这是因为 SELinux 是整合到核心里面去的，你只可以在SELinux 运作下切换成为强制 (enforcing) 或宽容 (permissive) 模式，不能够直接关闭 SELinux 的！同时，由 SELinux 关闭 (disable) 的状态到开启的状态也需要重新开机啦。 查看avc log logcat | grep avc $ sudo grep \"avc:\" /var/log/audit/audit.log 查看文件的安全上下文 ls -Z 查看进程的安全上下文 ps -Z No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-2.框架层-权限/Android权限管理.html":{"url":"04_Android/框架层/4-2.框架层-权限/Android权限管理.html","title":"Android权限管理","keywords":"","body":"1.基本概念 安卓（Android）操作系统的权限控制机制旨在保护用户的隐私和数据安全。以下是关于安卓权限控制的基本信息： 权限级别：安卓将权限分为不同的级别，每个级别代表一组相关的功能或敏感数据。常见的权限级别包括正常（Normal）、危险（Dangerous）和特殊（Special）权限。 正常权限：不会直接访问用户敏感数据或系统资源的权限，系统会自动授予这些权限，无需用户确认。 危险权限：可能访问用户敏感数据或系统资源的权限，如读取联系人、访问相机等。用户在安装应用时会被要求授予或拒绝这些权限。 特殊权限：控制敏感系统功能的权限，如系统设置修改、安装应用等。用户通常需要在设备的设置中手动授予或拒绝这些权限。 权限请求：当应用需要访问敏感数据或系统资源时，它必须在AndroidManifest.xml文件中声明所需的权限。这样，用户在安装应用程序时将看到应用请求的权限列表。 运行时权限：在安卓6.0（Marshmallow）及更高版本中，安卓引入了运行时权限机制。这意味着危险权限不再在应用安装时全部授予，而是在应用运行时根据需要逐个向用户请求。用户可以选择授予或拒绝每个权限。 权限组：相关的危险权限被分组，用户在权限请求对话框中只会看到权限组的名称，而不是单独的权限。例如，如果应用请求访问相机和录音权限，用户只会看到一个名为\"相机和麦克风\"的权限组。 权限撤销：在安卓9.0（Pie）及更高版本中，引入了权限撤销功能。如果用户连续拒绝某个权限的请求，系统将假设用户不希望应用获取该权限，并将其撤销。当应用再次请求权限时，用户会被要求重新授予。 2.应用权限机制 权限机制 Android 是一个权限分离的系统。这是利用 Linux 已有的权限管理机制，通过为每一个 Application 分配不同的 uid(user id) 和 gid(group id)，从而使得不同的 Application 之间的私有数据和访问(native 以及 Java 层通过这种机制，都可以)达到隔离的目的。与此同时，Android 还在此基础上进行扩展，提供了permission机制，它主要是用来对 Application 可以执行的某些具体操作进行权限细分和访问控制，同时提供了URI permission机制，用来提供对某些特定的数据块进行专门权限进行限制。 Android Permission权限机制是对Android安全机制的一个重要补充，控制了应用对于系统接口或者对外接口的访问。 权限信息 可以使用adb shell pm list permissions -f 命令详细查看 Android 预定义的权限详细信息(危险权限组未在此列表中), 例如下所示： 系统目录下查看声明的权限信息路径： frameworks/base/core/res/AndroidManifest.xml 常用权限命令: 打印所有已知的权限组： pm list permission-groups 打印权限： pm list permissions [options] [GROUP] 例如：pm list permissions –g -d (危险权限组信息) 其它常用参数： 权限级别 描述权限中隐含的潜在风险，并指示系统在确定是否将权限授予请求它的应用程序时应遵循的程序。Standard permissions具有预定义的永久保护级别。如果您在应用程序中创建自定义权限，您可以使用下面列出的值之一定义 protectionLevel 属性。如果没有为自定义权限定义 protectionLevel，则系统分配默认值（“normal”）。 每个保护级别由基本权限类型和零个或多个标志组成(5个基本类型, 22个附加类型)。 使用以下函数来提取它们： int basePermissionType = permissionInfo.getProtection(); --- 基本权限类型 int permissionFlags = permissionInfo.getProtectionFlags(); --- 附加权限标志 基本权限类型： 其它附加权限标志,见如下google官网说明: https://developer.android.com/reference/android/R.attr?hl=zh-cn#protectionLevel 权限管理 应用安装时，就给权限赋予了对应的状态，系统是使用PMS来管理权限。PMS维护管理权限状态数据，Android6.0之前，保存在data/system/packages.xml中；6.0之后增加了data/*../runtime-permissions.xml,数据持久化存储文件，用于记录着运行时权限的授予和拒绝状态，当权限状态变更时，申请的结果会动态更新 granted 值和flags状态。 查看： Android12的runtime-permissions.xml被默认设置二进制xml格式，直接打开是乱码。 通过修改配置将其改为普通的xml格式: adb shell setprop persist.sys.binary_xml false 重启手机，再获取runtime-permissions.xml，就是普通xml格式。 权限授予 动态授权： Android6.0 此版本引入了一种新的权限模式，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，同时为应用开发者精简了安装和自动更新过程。用户可为所安装的各个应用分别授予或撤销权限。 动态权限申请： step1 检查是否具有权限 step2 请求权限（可以一次性请求多个） step3 检查权限请求返回代码 权限申请: 权限检查 检查用户是否已向您的应用授予特定权限，将该权限传入checkSelfPermission() 方法。根据您的应用是否具有相应权限，此方法会返回PackageManager.PERMISSION_GRANTED(0)或PackageManager.PERMISSION_DENIED(-1)。 检查权限方法： 检查应用自身权限，建议使用checkSelfPermission； 检查IPC的调用进程权限，建议使用checkCallingPermission(或者checkCallingOrSelfPermission); 指定PID、UID检查权限，建议使用checkPermission； 访问其它应用数据库，建议先检查访问的URI是否有权限； 底层进行权限检查： 我们了解了运行时权限在系统API接口调用的时候会去检查权限状态，但有些权限例如INTERNET、READ_LOGS、BLUETOOTH等调用框架层接口的时候并没有去检查权限，这类权限是如何检查授权的呢？ 在底层，Linux内核使用用户和用户组来实施权限控制，这套权限模型是从Linux继承过来的，用于对文件系统实体进行访问控制，也可以对其他Android特定资源进行控制。这一模型通常被称为Android沙箱。以DalvikVM和Android框架形式存在的Android运行时实施了第二套权限模型。这套模型在用户安装应用时是向用户公开的，定义了应用拥有的权限，从而限制Android应用的能力。事实上，第二套权限模型中的某些权限直接映射到底层操作系统上的特定用户、用户组和权能。 内核和系统守护进程通过进程分配的 GID、UID和补充 GID来决定是否要赋予进程权限。 Android的权限模型是多方面的，有API权限、文件系统权限和IPC权限。在很多情况下，这些权限都会交织在一起。一些高级权限会后退映射到低级别的操作系统权能，这可能包括打开套接字、蓝牙设备和文件系统路径等。 应用在AndroidMainfest.xml申明的权限如何映射到底层的UID、GID？ 内置权限到GID的映射定义在/etc/permissions/platform.xml 中 包管理器在启动时读取 platform.xml，并维护「permission-GID」对应的列表。当它给安装中的包授权时，会把权限对应的 GID 加入到该应用进程的补充 GID 中。 权限对应的 GID 加入到该应用进程的补充 GID 中，可以通过adb shell--cd proc--cd PID--cat status查看： system/core/libcutils/include/private/android_filesystem_config.h static const struct android_id_info android_ids[] = { { \"camera\", AID_CAMERA, }, { \"sdcard_r\", AID_SDCARD_R, }, { \"sdcard_rw\", AID_SDCARD_RW, }, { \"inet\", AID_INET}, ··· }; 注:AndroidN及之前android_ids放在android_filesystem_config.h中之后版本迁移到pwd/grp functionality. Android定义了从名称到独特标识符Android ID（AID）的映射表。初始的AID映射表包含了一些与特权用户及系统关键用户（如system用户/用户组）对应的静态保留条目。Android还保留了一段AID范围，用于提供原生应用的UID。Android 4.1之后的版本为多用户资料档案和隔离进程用户增加了额外的AID范围段（如Chrome沙箱）。 除了AID，Android还使用了辅助用户组机制，以允许进程访问共享或受保护的资源。例如，sdcard_rw用户组中的成员允许进程读写/sdcard目录，因为它的加载项规定了哪些用户组可以读写该目录。这与许多Linux发行版中对辅助用户组机制的使用是类似的。 注意　尽管所有的AID条目都映射到一个UID和GID，但是UID在描述系统上的一个用户时并不是必需的。例如，AID_SDCARD_RW映射到sdcard_rw，但是它仅仅用作一个辅助用户组，而不是系统上的UID。 在应用执行时，它们的UID、GID和辅助用户组都会被分配给新创建的进程。在一个独特UID和GID环境下运行，使得操作系统可以在内核中实施底层的限制措施，也让运行环境能够控制应用之间的交互。这就是Android沙箱的关键所在。 在应用包条目中定义的权限后面会通过两种方式实施检查：一种检查在调用给定方法时进行，由运行环境实施；另一种检查在操作系统底层进行，由库或内核实施。 权限对应的 GID 何时被加入到应用进程的补充 GID 中？ 每个应用都会运行在自己的 Dalvik 虚拟机进程中，但是为了提高启动效率，Android 不会为每个应用都新建一个 Dalvik 进程，而是采用 fork 的形式。每个进程都 fork form zygote 进程。 因为 zygote 进程已经预加载了大部分核心和 Java 应用框架库，fork 的子进程会继承 zygote 的进程空间，也就是说，fork 的子进程，可以共享这些预加载的副本（记住，是副本，不是直接共享。fork 时，会 copy-on-write 预加载的内容），减少了重新加载核心库的时间。 当 zygote 收到启动新进程的请求时，它会 fork 自身出一个子进程，并对该子进程做特殊化处理。其源代码位于 framework/base/core/jni/com_android_internal_os_Zygote.cpp 中。SpecializeCommon() 的主要代码如下： 这里设置进程的组 ID 和用户 ID，通过 fork 创建的子进程调用 setgroups Intarray 设置该进程所属的组，这样应用程序就拥有了该组的权限，并且可以通过 setgid() 及 setuid() 确定应用程序的 GID 及 UID 值。 *每个应用进程都分配好自己的 GID、UID和补充 GID，系统内核和守护进程就可以用这些标识来决定，是否要赋予进程权限。 3.Android版本权限变更 Android从1.0开始其根基Linux继承了已经深入人心的类Unix进程隔离机制与最小权限原则。引入了Android沙箱及扩展了Android使用的权限模型，包括Android对Unix系统UID/GID映射关系的特殊实现AID，以及在整个系统中实施的限制和权能。 目前到Android13.0各版本中有关权限变更的重要调整如下： 版本 重要变更 1.6 新增WRITE_EXTERNAL_STORAGE权限，允许程序写入外部存储 2.2 android.permission.KILL_BACKGROUND_PROCESSES— 允许应用程序调用killBackgroundProcesses(String)) 2.3 3.0 4.0 4.0.3 4.1 4.2 精细化区分ACCESS_COARSE_LOCATION权限和ACCESS_FINE_LOCATION,不请求FINE_LOCATION获取的位置结果可能不太准确 4.3 BIND_NOTIFICATION_LISTENER_SERVICE：需要使用新的 NotificationListenerService API 4.4 从 Android 4.4 开始，当您仅访问您的应用特定外部存储区域时，此平台不再要求您的应用获取 WRITE_EXTERNAL_STORAGE 或 READ_EXTERNAL_STORAGE。不过，如果您要访问 getExternalStoragePublicDirectory() 提供的外部存储空间的可共享区域，则需要这些权限 5.0 6.0 此版本引入了一种新的权限模式，如今，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，同时为应用开发者精简了安装和自动更新过程。用户可为所安装的各个应用分别授予或撤销权限。对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。要确定您的应用是否已被授予权限，请调用新增的 checkSelfPermission() 方法。要请求权限，请调用新增的 requestPermissions() 方法。即使您的应用并不以 Android 6.0（API 级别 23）为目标平台，您也应该在新权限模式下测试您的应用。 7.0 文件系统权限更改：为了提高隐私文件的安全性，Android 7.0 或更高版本的应用程序的隐私目录已限制访问。 8.0 在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。 9.0 为了增强用户隐私，Android 9 引入了若干行为变更，如限制后台应用访问设备传感器、限制通过 Wi-Fi 扫描检索到的信息，以及与通话、手机状态和 Wi-Fi 扫描相关的新权限规则和权限组。无论采用哪一种目标 SDK 版本，这些变更都会影响运行于 Android 9 上的所有应用。 10 11 Android 11 对应用授予权限的方式进行了多项更改。这些更改旨在通过更加有意地授予权限来保护用户。强制执行分区存储、单次授权、自动重置权限、后台位置信息访问权限、软件包可见性、前台服务等的调整。 12 在搭载 Android 12 或更高版本的设备上，用户可以要求您的应用只能访问大致位置信息。 13 存储权限变更、新增通知权限、后台使用身体传感器权限。 总结：从Android版本迭代有关权限变更来看，Android6.0之前基本是针对权限进行扩展调整，Android6.0之后加强了用户对系统的安全管控，Android10.0之后权限管控更加严格，进一步提升用户安全性。 Google各版本变更信息：https://developer.android.com/about/versions 应用权限变更适配实例 实例一：后台定位权限适配 为了让用户更好地控制应用对位置信息的访问权限，Android 10 引入了 ACCESS_BACKGROUND_LOCATION 权限。与 ACCESS_FINE_LOCATION 和 ACCESS_COARSE_LOCATION 权限不同，ACCESS_BACKGROUND_LOCATION 权限仅会影响应用在后台运行时对位置信息的访问权限。除非符合以下条件之一，否则应用将被视为在后台访问位置信息： .属于该应用的 Activity 可见。 .该应用运行的某个前台设备已声明前台服务类型为 location。 .要声明您的应用中的某个服务的前台服务类型，请将应用的 targetSdkVersion 或 compileSdkVersion 设置为 29 或更高版本。 定位权限状态 AndroidQ(10) 获取后台定位权限： Android 10 之前只有ACCESS_FINE_LOCATION和ACCESS_COARSE_LOCATION； Android 10 新增加了后台定位权限：ACCESS_BACKGROUND_LOCATION，该权限对应始终允许；老的权限： ACCESS_FINE_LOCATION和ACCESS_COARSE_LOCATION代表仅前台使用允许； 应用的targetSdkVersion 应用的targetSdkVersion>=Q，如果应用必须要始终定位，可以只申请ACCESS_BACKGROUND_LOCATION即可；如果应用只需要申请前台定位，则只需要申请老的定位权限即可。 如果用户选择仅前台使用允许，应用的页面退后台，通过启动前台服务让应用处于前台状态，必须把前台服务标为：foregroundServiceType=“location”，才能获取位置信息。 ... 定位权限授权对比 Android R(11) 获取后台位置权限： 当应用申请后台位置信息访问权限时，让用户授予权限的弹窗中，将不再提供“始终允许”的选项，这个选项只存在于设置中的应用权限授予页面，并且后台位置权限的申请需要应用已经拥有前台位置权限。 适配建议： 若您的应用确定需要获得后台位置信息访问的权限，现在则需要分为两个步骤，因为已无法在没有前台位置信息访问权限的时候直接申请后台位置信息访问权限。 先申请前台位置信息访问权限； 再申请后台位置信息访问权限，引导用户到设置中进行授予。 Android S(12) 获取后台位置权限： 在搭载 Android 12 或更高版本的设备上，用户可以要求您的应用只能访问大致位置信息。 确切位置：可访问确切位置信息(10英尺到160英尺)。 大致位置：只能访问大致位置信息(1 英里)。 注意：如果用户从权限对话框或在系统设置中将应用的位置信息使用权从确切位置降级到大致位置，系统会重启应用的进程。 实例二：存储权限适配 为了让用户更好地控制自己的文件并减少混乱，Android 10 针对应用推出了一种新的存储范例，称为分区存储。分区存储改变了应用在设备的外部存储设备中存储和访问文件的方式。 受影响的文件接口 AndroidQ(10) 获取外部存储: 1.应用targetSdkVersion 或者使用 MediaStore API 修改或删除媒体文件。 2.如果您的应用以 Android 10（API 级别 29）为目标平台targetSdkVersion=Q(29)，请停用分区存储,继续使用适用于 Android 9 及更低版本的方法来执行此操作。 如果您以 Android 10 为目标平台，则需要在应用的清单文件中将 requestLegacyExternalStorage 的值设置为 true： ... AndroidR(11) 及更高版本获取外部存储: 1.使用 MediaStore.createWriteRequest() 或 MediaStore.createTrashRequest() 为应用的写入或删除请求创建待定 intent，然后通过调用该 intent 提示用户授予修改一组文件的权限。 注意：在 Android 11 或更高版本（无论目标 SDK 级别是什么）中，其他应用无法访问外部存储设备上的应用专用目录中存储的文件。 Android 存储用例和最佳做法 : https://developer.android.com/training/data-storage/use-cases 实例三：获取应用列表 Android 11 更改了应用查询用户已在设备上安装的其他应用以及与之交互的方式。使用 元素，应用可以定义一组自身可访问的其他软件包。通过告知系统应向您的应用显示哪些其他软件包，此元素有助于鼓励最小权限原则。 受影响的接口: .PackageManager.getInstalledApplications .PackageManager.getInstalledPackages 只返回系统可见以及与应用交互授权的应用列表。 以 Android 11（API 级别 30）或更高版本为目标平台，部分类型的应用也始终对您的应用可见：详见以下文档 https://developer.android.com/training/basics/intents/package-visibility?hl=zh-cn#automatic 查询所有应用及与之交互： 在极少数情况下，您的应用可能需要查询设备上的所有已安装应用或与之交互，不管这些应用包含哪些组件。为了允许您的应用看到其他所有已安装应用，系统会提供 QUERY_ALL_PACKAGES 权限。 .如果应用的target .如果应用的target>=30，必须要申请android.permission.QUERY_ALL_PACKAGES这个权限, 才能查询所有应用。 注意：如果您的应用以 Android 10（API 级别 29）或更低版本为目标平台，那么全部应用均会自动对您的应用可见。 应用安装卸载广播，仍然受软件包可见性影响： 如果监听安装/卸载的应用不符合可见性原则，或者未声明QUERY_ALL_PACKAGES权限, onReceive将不会回调。 广播回调接口受影响 4.默认授权 手机第一次开机或者fota升级后第一次开机进行的默认授权: 系统预置的默认授权机制，在Pms systemReady里面会根据Build.FINGERPRINT来判断是不是第一次开机，来做默认授权。 share systemuid默认授权权限(一般是在Manifest中配置类似的 android:sharedUserId=”android.uid.system”) 系统特权应用并且是persistent进行默认授权危险权限； 系统默认应用进行局部权限授权（例如：开机向导、相机、下载的Provider等） 原生机制第一次开机默认授权类： ./frameworks/base/services/core/java/com/android/server/pm/DefaultPermissionGrantPolicy.java: public void grantDefaultPermissions(int userId) { grantPermissionsToSysComponentsAndPrivApps(userId); //授权系统&特权应用 grantDefaultSystemHandlerPermissions(userId); //授权默认应用 } 系统默认授权应用 新应用第一次安装授权: 应用安装会走Pms，应用安装的过程中Pms会根据应用声明权限的level（Normal、Dangerous、Signature），来决定是否允许应用使用该权限。 Normal：只要应用申请，就允许应用使用该权限； Signature：判断该应用签名是否和平台签名一样，如果一样就允许否则不允许使用该权限； Dangerous：不给应用授予该权限，需要应用在用的时候动态申请该权限。 5.AppOps机制 AppOps全称是Application Operations，类似我们平时常说的应用程序的操作（权限）管理。Google从4.3开始推出Appops, 在Settings里面未开放Appops的入口，但这套方案却一直在后台默默的运行着。 涉及的类: android.app.AppOpsManager com.android.server.AppOpsService 配置文件：appops.xml appops.xml位于/data/system/目录下，存储各个app的权限设置和操作信息。 Android提供了命令行的方式来更改某个应用的某个权限，进入adb shell可以查看相应用法： appops命令 AppOps权限检查流程: appops检查权限流程 6.Selinux权限介绍 为什么增加Selinux？ 进程理论上所拥有的权限与执行它的用户的权限相同。比如，以root用户启动FileManager，那么FileManager就有root用户的权限，在Linux系统上能干任何事情。也就是像4.4以前的版本，只要我们对结点给予足够的权限，就可以随意的进行任意的操作。 Linux DAC有明显的不足，其中一个重要点就是，Root权限几乎可以做任意事情，一旦入侵者拿到root权限，即已经完全掌控了系统。另外每一个进程默认都拿到对应这个用户的所有权限，可以改动/删除这个用户的所有文件资源，明显这个难以防止恶意软件。所以在DAC之外设计了一个新的安全模型，叫MAC（Mandatory Access control），强制性访问控制，即系统针对每一项访问都进行严格的限制，具体的限制策略由开发者给出。MAC：即任何进程想在SELinux系统中干任何事情，都必须先在安全策略配置文件中赋予权限。凡是没有出现在安全策略配置文件中的权限，进程就没有该权限。 打开和关闭selinux功能: 出现了selinux相关的权限拒绝，则在kernel log 或者android log中都有对应的”avc: denied”，当然也可能和selinux的模式有关系，我们需要首先要确认当时SELinux 的模式, 是enforcing mode 还是 permissve mode。 如果问题容易复现，我们可以先将SELinux 模式调整到Permissive mode，然后再测试确认是否与SELinux 约束相关。 可以通过以下命令设置: adb shell setenforce 0 setenforce 0 设置SELinux 成为permissive模式 临时关闭selinux setenforce 1 临时打开selinux 如何配置selinux权限： 例如报如下错误： TcmReceiver: type=1400 audit(0.0:4214): avc: denied { write } for name=\"tcmd\" dev=\"tmpfs\" ino=1301 scontext=u:r:remote_prov_app:s0:c162,c256,c512,c768 tcontext=u:object_r:vendor_dpmtcm_socket:s0 tclass=sock_file permissive=0 app=com.android.remoteprovisioner 具体参数表示： 权限: avc: denied { write } 表示缺少write权限 哪个te文件缺少权限: scontext=u:r:remote_prov_app:s0:c162,c256,c512,c768 ---- remote_prov_app缺少权限 哪个文件缺少权限: tcontext=u:object_r:vendor_dpmtcm_socket:s0 ---- remote_prov_app缺少对vendor_dpmtcm_socket的权限配置 文件类型: tclass=sock_file 权限文件类型 表达含义：remote_prov_app文件需要新增类型为sock_file的vendor_dpmtcm_socket的write权限。 如何修改：配置te文件,添加 tclass=sock_file，编译selinux_policy，把system/etc下面的selinux文件夹，push到手机syste/etc进行覆盖。然后重启验证修改是否生效。 注：不要修改neverallow，会导致CTS测试失败。如果修改了file_contexts, 替换selinux是不生效的。因为⽬标文件的context已经⽣成了，替换selinux并不会重新给⽬标文件设置context。这时可以通过chcon命令⼿动修改context。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-2.框架层-权限/Android运行时权限.html":{"url":"04_Android/框架层/4-2.框架层-权限/Android运行时权限.html","title":"Android运行时权限","keywords":"","body":"Dangerous Permissions: group:android.permission-group.CONTACTS group:android.permission-group.PHONE group:android.permission-group.CALENDAR group:android.permission-group.CALL_LOG group:android.permission-group.CAMERA group:android.permission-group.UNDEFINED permission:android.permission.READ_SMS permission:android.permission.READ_CALENDAR permission:android.permission.READ_CALL_LOG permission:android.permission.ACCESS_FINE_LOCATION permission:android.permission.ANSWER_PHONE_CALLS permission:android.permission.RECEIVE_WAP_PUSH permission:android.permission.BODY_SENSORS permission:android.permission.READ_PHONE_NUMBERS permission:android.permission.RECEIVE_MMS permission:android.permission.RECEIVE_SMS permission:android.permission.BLUETOOTH_CONNECT permission:android.permission.READ_EXTERNAL_STORAGE permission:android.permission.ACCESS_COARSE_LOCATION permission:android.permission.READ_PHONE_STATE permission:android.permission.SEND_SMS permission:android.permission.CALL_PHONE permission:android.permission.WRITE_CONTACTS permission:android.permission.ACCEPT_HANDOVER permission:android.permission.CAMERA permission:android.permission.WRITE_CALENDAR permission:android.permission.WRITE_CALL_LOG permission:android.permission.USE_SIP permission:android.permission.PROCESS_OUTGOING_CALLS permission:android.permission.READ_CELL_BROADCASTS permission:android.permission.BLUETOOTH_ADVERTISE permission:android.permission.GET_ACCOUNTS permission:android.permission.WRITE_EXTERNAL_STORAGE permission:android.permission.UWB_RANGING permission:android.permission.ACTIVITY_RECOGNITION permission:android.permission.RECORD_AUDIO permission:android.permission.READ_CONTACTS permission:android.permission.ACCESS_BACKGROUND_LOCATION permission:android.permission.BLUETOOTH_SCAN permission:android.permission.ACCESS_MEDIA_LOCATION permission:com.android.voicemail.permission.ADD_VOICEMAIL group:android.permission-group.ACTIVITY_RECOGNITION group:android.permission-group.SENSORS group:android.permission-group.LOCATION group:android.permission-group.STORAGE group:android.permission-group.MICROPHONE group:android.permission-group.NEARBY_DEVICES group:android.permission-group.SMS ungrouped: permission:android.permission.READ_TV_LISTINGS No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-2.框架层-权限/REFERS.html":{"url":"04_Android/框架层/4-2.框架层-权限/REFERS.html","title":"Refers","keywords":"","body":" Android Framework 源码开发揭秘 xiangxue888 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-2.框架层-权限/白名单和权限.html":{"url":"04_Android/框架层/4-2.框架层-权限/白名单和权限.html","title":"白名单和权限","keywords":"","body":"白名单和权限 在 Android 6.0 及更高版本中，应用会在运行时申请危险权限。Android 10 增加了具备活动识别 (AR) 能力的运行时权限机制，可提示用户修改或允许危险权限。 Android 8.0 要求您在系统配置 XML 文件（位于 /etc/permissions 目录下）中明确将特权应用列入白名单。在 Android 9 及更高版本中，特许权限必须列入白名单，否则设备无法启动。 为了限制内部 API 的可见性并防止应用意外地访问平台库，Android 7.0 推出了针对原生库的命名空间。这将系统库与应用库分离开来，而设备制造商可以添加自己的原生库。 从 Android 10 开始，应用必须拥有签名权限并征得用户同意才能访问设备的屏幕内容，两者缺一不可。依赖于静默捕获功能（如截取屏幕截图）的特权应用应改为使用 MediaProjection 类。 设备中...permissions.xml位于system_ext > etc > permissions 下 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-2.框架层-编译/Android.mk和Android.bp.html":{"url":"04_Android/框架层/4-2.框架层-编译/Android.mk和Android.bp.html","title":"Android.mk和android.bp","keywords":"","body":"Android.mk 编写 Android.mk 文件是 Android 工程中配置构建系统的关键部分，主要用于描述如何编译本地代码（如 C/C++ 代码）。以下是 Android.mk 文件的基本结构和常用指令的详细介绍。 1. Android.mk 的基本结构 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) # 定义模块名称 LOCAL_MODULE := your_module_name # 指定源文件 LOCAL_SRC_FILES := file1.c file2.cpp # 指定头文件路径（可选） LOCAL_C_INCLUDES := $(LOCAL_PATH)/include # 指定库依赖（可选） LOCAL_LDLIBS := -llog -landroid # 指定目标库类型（可选） LOCAL_MODULE_TAGS := optional # 可以是 \"optional\", \"debug\", 或 \"tests\" # 编译为共享库或可执行文件 include $(BUILD_SHARED_LIBRARY) # 共享库 #include $(BUILD_EXECUTABLE) # 可执行文件 2. 常用指令 1) LOCAL_PATH 定义当前 Android.mk 文件的目录： LOCAL_PATH := $(call my-dir) 2) include $(CLEAR_VARS) 清除之前的变量定义，避免变量污染。此命令必须包含在每个模块定义的开头。 3) LOCAL_MODULE 定义模块名称： LOCAL_MODULE := my_library 4) LOCAL_SRC_FILES 定义源码文件路径，可以是相对于 LOCAL_PATH 的路径： LOCAL_SRC_FILES := main.cpp helper.c 5) LOCAL_C_INCLUDES 定义头文件路径，支持绝对路径和相对路径： LOCAL_C_INCLUDES := $(LOCAL_PATH)/include 6) LOCAL_LDLIBS 定义链接的系统库，例如 -llog 用于 Android 日志库： LOCAL_LDLIBS := -llog -lz 7) 编译目标 共享库： include $(BUILD_SHARED_LIBRARY) 会生成一个以 .so 为后缀的共享库文件。 静态库： include $(BUILD_STATIC_LIBRARY) 会生成一个以 .a 为后缀的静态库文件。 可执行文件： include $(BUILD_EXECUTABLE) 3. 示例 LOCAL_PATH := $(call my-dir) # 当前 Android.mk 文件所在的路径，表示当前目录为基准，控制本目录下的编译。 ############################## include $(CLEAR_VARS) # 清除之前的变量定义，避免变量污染，确保每个模块的定义互不干扰。 LOCAL_MODULE := ChinaHome # 模块名称为 ChinaHome，编译输出的目标文件将以此名称命名。 LOCAL_SRC_FILES := ChinaHome.apk # 指定模块的源文件，这里是当前目录下的 ChinaHome.apk。 LOCAL_MODULE_CLASS := APPS # 指定模块类型为 APPS，表示这是一个应用程序模块。 LOCAL_PRIVILEGED_MODULE := true # 声明模块为特权应用，安装到系统分区并拥有额外权限。 LOCAL_SYSTEM_EXT_MODULE := true # 指定模块安装在 system_ext 分区，用于特定系统扩展功能。 LOCAL_CERTIFICATE := PRESIGNED # 指定 APK 已经预签名，构建系统不会对其重新签名。 LOCAL_OPTIONAL_USES_LIBRARIES := \\ # 声明可选使用的库，模块运行时可以选择性依赖这些库。'\\'为换行语法 org.apache.http.legacy # 使用 Apache HTTP 库，通常用于兼容老旧的网络请求接口。 LOCAL_NOTICE_FILE := $(LOCAL_PATH)/NOTICE.ChinaHome.json # 指定模块的许可证文件路径，用于开源合规。 include $(BUILD_PREBUILT) # 使用预构建模块规则，表示直接打包现有的 ChinaHome.apk，而不重新编译源代码。 ############################## include $(CLEAR_VARS) # 清除之前的变量定义，避免变量污染。 LOCAL_MODULE := AccountApp # 模块名称为 AccountApp，编译输出的目标文件将以此名称命名。 LOCAL_SRC_FILES := AccountApp.apk # 指定模块的源文件，这里是当前目录下的 AccountApp.apk。 LOCAL_MODULE_CLASS := APPS # 指定模块类型为 APPS，表示这是一个应用程序模块。 LOCAL_PRIVILEGED_MODULE := true # 声明模块为特权应用，安装到系统分区并拥有额外权限。 LOCAL_CERTIFICATE := sony-general-app # 指定 APK 使用 `sony-general-app` 的证书进行签名。 LOCAL_PRODUCT_MODULE := true # 指定模块安装到产品分区，用于设备的产品特定功能。 include $(BUILD_PREBUILT) # 使用预构建模块规则，表示直接打包现有的 AccountApp.apk，而不重新编译源代码。 ############################## Android.bp Android.bp 基于 Soong 构建系统，使用 JSON 类似的结构（基于 Blueprint 语法）来配置模块的构建规则。 1. Android.bp 的基本结构 一个典型的 Android.bp 文件： cc_library_shared { name: \"your_module_name\", // 模块名称 srcs: [\"file1.c\", \"file2.cpp\"], // 源文件列表 include_dirs: [\"include\"], // 头文件路径 shared_libs: [\"liblog\"], // 依赖的共享库 static_libs: [\"libutils\"], // 依赖的静态库 cflags: [\"-DMY_DEFINE=1\"], // 自定义编译宏 ldflags: [\"-Wl,--no-undefined\"],// 链接选项 } 2. 常用模块类型 1) cc_library_shared 构建共享库（.so）： cc_library_shared { name: \"my_shared_lib\", srcs: [\"src/main.c\", \"src/helper.c\"], include_dirs: [\"include\"], shared_libs: [\"liblog\"], } 2) cc_library_static 构建静态库（.a）： cc_library_static { name: \"my_static_lib\", srcs: [\"src/main.c\", \"src/helper.c\"], include_dirs: [\"include\"], } 3) cc_binary 构建可执行文件： cc_binary { name: \"my_executable\", srcs: [\"main.cpp\"], static_libs: [\"my_static_lib\"], shared_libs: [\"liblog\"], } 4) filegroup 定义文件组，便于复用： filegroup { name: \"common_headers\", srcs: [\"include/*.h\"], } 5) prebuilt_shared_library 预构建的共享库： prebuilt_shared_library { name: \"prebuilt_lib\", srcs: [\"libs/libprebuilt.so\"], export_include_dirs: [\"include\"], } 3. 关键字段说明 1) name 模块的唯一标识符。 2) srcs 源文件列表，支持通配符： srcs: [\"src/*.c\"], 3) include_dirs 指定头文件路径，相对于当前模块的路径： include_dirs: [\"include\"], 4) shared_libs 和 static_libs shared_libs：依赖的共享库模块。 static_libs：依赖的静态库模块。 例如： shared_libs: [\"liblog\"], static_libs: [\"libutils\"], 5) cflags 和 ldflags cflags：C/C++ 编译选项。 ldflags：链接选项。 cflags: [\"-DMY_DEFINE=1\", \"-Wall\"], ldflags: [\"-Wl,--no-undefined\"], 6) target 指定针对不同平台的配置： target: { android: { cflags: [\"-DANDROID\"], }, linux_glibc: { cflags: [\"-DLINUX\"], }, }, 7) compile_multilib 指定构建单个架构还是多架构： compile_multilib: \"both\", // 可选 \"32\", \"64\", 或 \"both\" 4. 示例 android_library { # 定义一个 Android 库模块，构建结果为 `.jar` 文件。 name: \"...\", # 模块的唯一名称，生成的目标文件也将以此命名。 platform_apis: true, # 允许使用 Android 平台私有 API，通常需要特权权限。 static_libs: [ # 声明此模块依赖的静态库（编译时依赖）。这些库会被链接到此模块中。 ... \"guava\", # Guava 是一个广泛使用的 Java 工具库，提供集合、字符串处理等功能。 ], # Requires uses-library in manifest libs: [ # 声明运行时依赖的动态库，通常需要在 `AndroidManifest.xml` 中添加 uses-library。 ], aidl: { # 配置 AIDL（Android 接口定义语言）相关的目录和文件。 local_include_dirs: [\"src\"], # 本地 AIDL 文件所在的路径。 include_dirs: [\"frameworks/base/core/java/android/service\"], # 引入外部 AIDL 文件的路径（例如系统服务接口）。 }, srcs: [ # 声明模块的源文件，包括 Java 和 AIDL 文件。 \"src/**/*.java\", \"src/....aidl\", ], resource_dirs: [ # 声明模块的资源目录，用于存放资源文件（XML、图片等）。 \"res\", ], manifest: \"AndroidManifest.xml\", # 指定模块的 AndroidManifest 文件路径。 java_version: \"1.8\", # 指定 Java 的编译版本为 1.8，确保与模块代码兼容。 } No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-2.框架层-编译/Repo工具的使用.html":{"url":"04_Android/框架层/4-2.框架层-编译/Repo工具的使用.html","title":"Repo工具的使用","keywords":"","body":"Android使用repo来管理多个Git项目。它需要一个manifest XML文件来指示这些git项目的属性。 Manifest repo manifest XML可以包含下面的元素。 以如下，manifest片段为例：（from https://github.com/CyanogenMod/android/blob/cm-14.1/default.xml) Manifest元素 最顶层的XML元素 remote元素 设置远程git服务器的属性，包括下面的属性： name: 远程git服务器的名字，直接用于git fetch, git remote 等操作 alias: 远程git服务器的别名，如果指定了，则会覆盖name的设定。在一个manifest中， name不能重名，但alias可以重名。 fetch: 所有projects的git URL 前缀 review: 指定Gerrit的服务器名，用于repo upload操作。如果没有指定，则repo upload没有效果。 一个manifest文件中可以配置多个remote元素，用于配置不同的project默认下载指向。 default元素 设定所有projects的默认属性值，如果在project元素里没有指定一个属性，则使用default元素的属性值。 remote: 之前定义的某一个remote元素中name属性值，用于指定使用哪一个远程git服务器。 revision: git分支的名字，例如master或者refs/heads/master sync_j: 在repo sync中默认并行的数目。 sync_c: 如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容。 sync_s: 如果设置为true，则会同步git的子项目 Example: project元素 指定一个需要clone的git仓库。 name: 唯一的名字标识project，同时也用于生成git仓库的URL。格式如下： ${remote_fetch}/${project_name}.git path: 可选的路径。指定git clone出来的代码存放在本地的子目录。如果没有指定，则以name作为子目录名。 remote: 指定之前在某个remote元素中的name。 revision: 指定需要获取的git提交点，可以是master, refs/heads/master, tag或者SHA-1值。如果不设置的话，默认下载当前project，当前分支上的最新代码。 groups: 列出project所属的组，以空格或者逗号分隔多个组名。所有的project都自动属于\"all\"组。每一个project自动属于name:'name' 和path:'path'组。 例如，它自动属于default, name:monkeys, and path:barrel-of组。如果一个project属于notdefault组，则，repo sync时不会下载。 sync_c: 如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容。 sync_s: 如果设置为true，则会同步git的子项目。 upstream: 在哪个git分支可以找到一个SHA1。用于同步revision锁定的manifest(-c 模式)。该模式可以避免同步整个ref空间。 annotation: 可以有多个annotation，格式为name-value pair。在repo forall 命令中这些值会导入到环境变量中。 remove-project: 从内部的manifest表中删除指定的project。经常用于本地的manifest文件，用户可以替换一个project的定义。 子元素 Project元素下面会有两个子元素。Copyfile和linkfile Copefile:复制，cp src dest Linkfile：软链接 ，ln -s src dest Repo 安装repo 在ubuntu中可以通过命令进行repo的安装： Sudo apt-get install repo 也可以直接下载repo文件，然后将路径配置到环境变量里面。 $ mkdir ~/bin $ PATH=~/bin:$PATH $ curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo $ chmod a+x ~/bin/repo Repo help 安装 Repo 后，您可以通过运行以下命令找到最新文档（开头是包含所有命令的摘要）： repo help 您可以通过在 Repo 树中运行以下命令来获取有关某个命令的信息： repo help 例如，以下命令会生成 Repo init 参数的说明和选项列表，该参数会在当前目录中初始化 Repo。（要了解详情，请参阅 init。） repo help init Repo init Usage repo init –u URL [OPTIONS] 在当前目录中安装 Repo。这会创建一个 .repo/ 目录，其中包含用于 Repo 源代码和标准 Android 清单文件的 Git 代码库。该 .repo/ 目录中还包含 manifest.xml，这是一个指向 .repo/manifests/ 目录中所选清单的符号链接。 Options: u：指定一个URL，其连接到一个manifest仓库 m：在manifest仓库中选择一个xml文件，如果未选择，默认指向default.xml b：选择一个maniest仓库中的一个特殊的分支 --mirror：下一步和源同步的时候，本地按照源的版本库组织方式进行组织 --reference=：path为一个镜像地址，从镜像同步代码。 --repo-url=：url为repo 库的位置，用于修改repo文件中REPO-URL参数的指向。 命令repo init 要完成如下操作： 完成repo工具的完整下载，执行的repo脚本只是引导程序 克隆清单库manifest.git (地址来自于-u 参数) 克隆的清单库位于manifest.git中，克隆到本地.repo/manifests.清单.repo/manifest.xml只是符号链接，它指.repo/manifests/default.xml 如果manifests中有多个xml文件，repo init 可以任意选择其中一个，默认选择是default.xml Repo sync Usage repo sync [] 下载新的更改并更新本地环境中的工作文件。如果您在未使用任何参数的情况下运行 repo sync，则该操作会同步所有项目的文件。 运行 repo sync 后，将出现以下情况： 如果目标项目从未同步过，则 repo sync 相当于 git clone。远程代码库中的所有分支都会复制到本地项目目录中。 如果目标项目已同步过，则 repo sync 相当于以下命令： git remote update git rebase origin/ 其中 是本地项目目录中当前已检出的分支。如果本地分支没有在跟踪远程代码库中的分支，则相应项目不会发生任何同步。 如果 git rebase 操作导致合并冲突，那么您需要使用普通 Git 命令（例如 git rebase --continue）来解决冲突。repo sync 运行成功后，指定项目中的代码会与远程代码库中的代码保持同步。 Option: d：将指定项目切换回清单修订版本。如果项目当前属于某个主题分支，但只是临时需要清单修订版本，则此选项会有所帮助。 s：同步到当前清单中清单服务器元素指定的一个已知的良好版本。 f：即使某个项目同步失败，系统也会继续同步其他项目。 Repo start Usage repo start [] 从清单中指定的修订版本开始，创建一个新的分支进行开发。 参数应简要说明您尝试对项目进行的更改。如果您不知道，则不妨考虑使用默认名称。 指定了将参与此主题分支的项目。 Repo diff Usage repo diff [] 使用 git diff 显示提交与工作树之间的明显更改。 Repo prune Usage repo prune [] 删减（删除）已合并的主题。 Repo status Usage repo status [] 对于每个指定的项目，将工作树与临时区域（索引）以及此分支 (HEAD) 上的最近一次提交进行比较。在这三种状态存在差异之处显示每个文件的摘要行。 要仅查看当前分支的状态，请运行 repo status。系统会按项目列出状态信息。对于项目中的每个文件，系统使用两个字母的代码来表示： 在第一列中，大写字母表示临时区域与上次提交状态之间的不同之处。 {| | 字母 || 含义 || 说明 |- | - || 无更改 || HEAD 与索引中相同 |- | A || 已添加 || 不存在于 HEAD 中，但存在于索引中 |- | M || 已修改 || 存在于 HEAD 中，但索引中的文件已修改 |- | D || 已删除 || 存在于 HEAD 中，但不存在于索引中 |- | R || 已重命名 || 不存在于 HEAD 中，但索引中的文件的路径已更改 |- | C || 已复制 || 不存在于 HEAD 中，已从索引中的另一个文件复制 |- | T || 模式已更改|| HEAD 与索引中的内容相同，但模式已更改 |- | U || 未合并 || HEAD 与索引之间存在冲突；需要解决方案 |} 在第二列中，小写字母表示工作目录与索引之间的不同之处。 {| | 字母 | 含义 | 说明 |- | - | 新/未知 | 不存在于索引中，但存在于工作树中 |- | m | 已修改 | 存在于索引中，也存在于工作树中（但已修改） |- | d | 已删除 | 存在于索引中，不存在于工作树中 |} Repo forall Usage repo forall [] -c 在每个项目中运行指定的 shell 命令。通过 repo forall 可使用下列额外的环境变量： REPO_PROJECT 可设为项目的具有唯一性的名称。 REPO_PATH 是客户端根目录的相对路径。 REPO_REMOTE 是清单中远程系统的名称。 REPO_LREV 是清单中修订版本的名称，已转换为本地跟踪分支。如果您需要将清单修订版本传递到某个本地运行的 Git 命令，则可使用此变量。 REPO_RREV 是清单中修订版本的名称，与清单中显示的名称完全一致。 Option： c：要运行的命令和参数。此命令会通过 /bin/sh 进行求值，它之后的任何参数都将作为 shell 位置参数传递。 p：在指定命令输出结果之前显示项目标头。这通过以下方式实现：将管道绑定到命令的 stdin、stdout 和 sterr 流，然后通过管道将所有输出结果传输到一个页面调度会话中显示的连续流中。 v：显示该命令向 stderr 写入的消息。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-2.框架层-编译/准备编译环境.html":{"url":"04_Android/框架层/4-2.框架层-编译/准备编译环境.html","title":"准备编译环境","keywords":"","body":"安装软件依赖 安装基本依赖： 执行以下命令安装必要的包： sudo apt update sudo apt install -y openjdk-11-jdk python3 git-core gnupg flex bison gperf build-essential \\ zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \\ lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev ccache \\ libgl1-mesa-dev libxml2-utils xsltproc unzip bc 安装 repo 工具： 下载 repo 工具并将其放到 ~/bin/ 目录： mkdir -p ~/bin curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo chmod a+x ~/bin/repo export PATH=~/bin:$PATH 安装 Python 依赖（如需要）： sudo apt install python3-distutils python3-venv 设置环境变量 配置 AOSP 编译所需的环境变量。 设置环境变量： 将以下内容添加到你的 ~/.bashrc 或 ~/.zshrc 文件中： # 设置 Java 环境 export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64 export PATH=$JAVA_HOME/bin:$PATH # 添加 repo 到 PATH export PATH=~/bin:$PATH # 启用 ccache（可选） export USE_CCACHE=1 export CCACHE_DIR=~/.ccache 保存后执行： source ~/.bashrc # 或 source ~/.zshrc No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-2.框架层-编译/几种不同解锁的区别.html":{"url":"04_Android/框架层/4-2.框架层-编译/几种不同解锁的区别.html","title":"几种不同解锁的区别","keywords":"","body":"几种不同解锁的区别：bootoader / avb / selinux / rel_dev-build & keystore / root bootloader(引导加载程序)解锁： android - https://source.android.com/docs/core/architecture/bootloader/locking_unlocking?hl=zh-cn bootloader是安卓设备启动过程中第一个被执行的软件组件,引导加载程序允许用户或系统选择启动模式。 例如，用户可以选择进入正常启动模式（启动安卓操作系统）、恢复模式（用于系统恢复和维护）、引导加载程序模式（用于解锁和调试）等。 出厂后的安卓设备bootloader都处于上锁状态，无法刷包。 avb(Android Verified Boot)解锁： android - https://source.android.com/docs/security/features/verifiedboot/avb?hl=zh-cn AVB确保设备启动过程中加载的每个分区（如系统、引导、供应商等）的完整性和签名。 解锁bootloader后，AVB仍然可以验证分区的完整性。 我们的应用处于的分区avb未解锁时不允许修改，所以我们需要在avb解锁后push我们的应用 selinux解锁： android - https://source.android.com/docs/security/features/selinux?hl=zh-cn selinux是linux自带的进程访问控制（读写、搜索）机制，相关BUG：CHINAUX-376 rel_dev-build & keystore解锁： android - https://source.android.com/docs/core/ota/sign_builds?hl=zh-cn release build 对应 release key？ develop build 对应 develop key? 此部分方法与结论待验证。 root解锁： 打开开发者模式后，就可以进行USB调试了，也就可以输入adb root命令，之后就可以以root权限运行adb sony设备打开开发者模式的方式和普通设备一样，连按10次系统版本号 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-2.框架层-编译/启动模拟器.html":{"url":"04_Android/框架层/4-2.框架层-编译/启动模拟器.html","title":"启动模拟器","keywords":"","body":"编译生成的img最终会在/aosp/out/target/product/配置名称/目录下 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-2.框架层-编译/编译aosp源码.html":{"url":"04_Android/框架层/4-2.框架层-编译/编译aosp源码.html","title":"编译aosp源码","keywords":"","body":"开始编译 1.加载源码编译环境 source build/envsetup.sh 2.选择编译目标 lunch 输入num选择 3.构建代码同时编译log输出到文件 make -j32 2>&1 | tee build.log make -j16 2>&1 | tee build.log 命令拆解： make: 这是 GNU Make 工具，用于自动化编译过程。在 AOSP 中，它会根据 Makefile 中的规则来编译源代码。 -j16: 这个选项告诉 Make 工具同时使用 16 个进程来进行编译。这可以显著加快编译速度，特别是在多核处理器上。 2>&1: 这个部分会将标准错误输出（文件描述符 2）重定向到标准输出（文件描述符 1）。也就是说，无论是编译过程中的正常输出还是错误信息，都会被输出到同一个地方。 |: 管道符号，将前一个命令的输出作为后一个命令的输入。 tee build.log: 这个命令会将管道过来的数据同时输出到终端和一个名为 build.log 的文件中。这样，你可以在终端实时查看编译进度，同时将所有输出保存到日志文件中，方便以后查看和分析。 make -jN N数量采用CPU核数的4倍 确认自己cpu的核数 lscpu 看下 CPU(s)的数量 重置编译环境 清除编译产物，out目录下的文件会被删除 make clean 重置源码 repo forall -c \"git add -A\" && repo forall -c \"git reset HEAD^^^ --hard\" && repo sync 清理 out/ 目录： rm -rf out/ 疑难解决 编译期间电脑很卡乃至于终端退出或电脑重启，因为交换内存不够，解决方法： https://blog.csdn.net/zxj2589/article/details/138728945 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-2.框架层-编译/获取aosp源码.html":{"url":"04_Android/框架层/4-2.框架层-编译/获取aosp源码.html","title":"获取aosp源码","keywords":"","body":"Manifest 初始化repo repo init -u https://android.googlesource.com/platform/manifest -b android-14.0.0_r28 android 14 有一个版本的revision是不可用的, 忘记了 (1) .repo 中的 manifest 将被覆盖 新的 repo init 会更新 .repo/manifest.xml 文件，以及 .repo/manifests 仓库的状态。 之前指定的分支、URL 或其他配置将被新的 repo init 覆盖。 (2) 本地代码不自动更新 repo init 只会更新 .repo 配置，不会直接修改已同步的代码。需要运行 repo sync 来应用新配置并同步新的代码分支。 后续查看源码来自的remote和branch 运行以下命令 repo info Download 开始进行同步 repo sync 使用八个线程 #j8代表使用8个线程 repo sync -j8 强制同步所有内容 repo sync --force-sync 踩坑 问题：Git缓存不够 报错： error: RPC 失败。curl 56 GnuTLS recv error (-9): Error decoding the received TLS packet. error: 预期仍然需要 45839 个字节的正文 fetch-pack: unexpected disconnect while reading sideband packet fatal: 过早的文件结束符（EOF） fatal: fetch-pack：无效的 index-pack 输出 解决： apt install gnutls-bin git config --global http.sslVerify false git config http.postBuffer 1048576000 git config https.postBuffer 1048576000 git config --system core.longpaths true root@aki-OptiPlex-7090:/aosp# git config --global http.postBuffer 10485760000 root@aki-OptiPlex-7090:/aosp# git config --global https.postBuffer 10485760000 root@aki-OptiPlex-7090:/aosp# git config --global http.lowSpeedLimit 0 root@aki-OptiPlex-7090:/aosp# git config --global https.lowSpeedLimit 0 root@aki-OptiPlex-7090:/aosp# git config --global https.lowSpeedTime 999999 root@aki-OptiPlex-7090:/aosp# git config --global http.lowSpeedTime 999999 问题： TLS（传输层安全性）连接问题 报错： fatal: 无法访问 'https://android.googlesource.com/platform/external/OpenCSD/'：gnutls_handshake() failed: The TLS connection was non-properly terminated. error: Cannot fetch platform/external/OpenCSD from https://android.googlesource.com/platform/external/OpenCSD 解决：Linux设置不锁屏（可能是锁屏了导致中断） gsettings set org.gnome.desktop.session idle-delay 0 同步源代码树时遇到的问题（TCP 问题） 症状：在同步时 repo sync 挂起，通常是在同步操作完成 99% 时出现这种情况。 原因：TCP/IP 堆栈中的某些设置在有些网络环境中会导致出现问题，使得 repo sync 既无法完成，也不会失败。 解决方法：在 Linux 中，请输入以下命令： sysctl -w net.ipv4.tcp_window_scaling=0 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-3.框架层-性能/REFERS.html":{"url":"04_Android/框架层/4-3.框架层-性能/REFERS.html","title":"Refers","keywords":"","body":" 【高性能Android应用开发】 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-3.框架层-性能/【高性能Android应用开发】读书笔记.html":{"url":"04_Android/框架层/4-3.框架层-性能/【高性能Android应用开发】读书笔记.html","title":"【高性能android应用开发】读书笔记","keywords":"","body":"第一章 Android的性能指标 1.1 性能很重要 电商APP购物流程的卡顿冗长将降低交易率和用户满意度。 APP频繁的网络请求会让服务器、网络的性能变差。 最恶劣的影响——网站宕机。而低性能就像持续的宕机。 1.2 电池寿命 移动设备上最耗电的就是屏幕、蜂窝式网络和Wi-Fi，以及其他的信号发射器（如蓝牙或GPS）。 第二章 构建Android设备实验室 2.1 了解用户都在使用什么设备 专门网站 在APP中植入？，通过数据分析出用户使用设备的分布。 2.2 了解用户设备的特性分布 有些设备没有摄像头，有些只有后置摄像头，有些前后置都有。还有些设备附带了NFC、温度传感器、加速度传感器…… 2.2.1 屏幕 分辨率 像素密度 2.2.2 SDK版本 2.2.3 CPU/内存和存储 2.3 用户使用的网络 2.4 设备差异 root设备 --> 用户查看敏感文件导致的安全问题 工程版本 开发者版本 2.5 创建设备实验室 需要用不同的设备来覆盖下面这些参数： 屏幕尺寸 小（4.4%） 中（82.9%） “巨屏手机”（8.6%） 平板电脑（4.1%） 特殊情况（穿戴设备、电视、汽车等） 屏幕分辨率 低（4.8%） 中（16.1%） 高（40.2%） 超高（36.6%） 处理器 双核 四核 多核 内存 RAM 存储（例如，对比容量可用很少和大量空闲的设备） 网络速度 3G LTE Wi-Fi SDK版本（陈旧了） Gingerbread（2.3、2.3.3、2.3.7） Ice Cream Sandwich Jelly Bean（4.1、4.3） KitKat Lollipop Marshmallow（或更高） 其他考虑 root设备 安全测试 原始设备制造商（OEM）差别 2.5.1 购买建议 选择了与从??年起历年高端的、特性相近的手机（之前流行的） 使用设备分析来推断现在流行的设备，并从这个列表中采购设备（目前流行的） Nexus设备会率先更新操作系统，这样一来就可以早于主流设备提前在最新的操作系统上测试App（以后流行的） 2.5.2 除了手机的设备 Android Wear APP在手表和手机上应该配有不同的界面。 Google将手表上的交互划分为下面两种： 建议：即时信息列表（消息、位置相关的数据等） 要求：允许语音命令控制Wear设备发出请求数据 2.5.3 AOSP设备 这些设备缺少以下组件： 分发App的Google Play Store Google Cloud Messenger推送消息 Google Play服务 Google产品，几乎所有Google定制的其他工具类App 常见的AOSP设备： Amazon电子阅读器 其他的Android手机/平板电脑（小米、华为） 2.5.4 其他选择 远程设备测试 有些在线服务提供了通过网络接口访问实际设备的API。但这些服务不太可能节省你的测试成本（事实上，它可能更贵）。这样做还有另一个缺点，没有实际的物理设备，你无法看到运行缓慢的情况或性能问题。这样你只是得到了测试结果，而不能真正看到App在这些设备上的运行状况。 Google云测试实验室 针对每一个品牌、每一个型号、每一个版本的物理设备，世界上的每一种语言、方向和网络状况下构建一种虚拟设备（网络物理设备）。 开放设备实验室 志愿构建，存放旧设备，与同行分享测试机（中国没有）。 2.5.5 注意事项 获得USB集线器以确保你的所有设备都能供上电 为你的移动设备建立一个专用Wi-Fi网络（以确保有足够的Wi-Fi吞吐量） 确保所有的设备在每次使用后都会擦除数据，而且不会意外升级系统 为每种设备准备合适的电缆和充电器 第三章 硬件性能和电池寿命 3.1 耗电原因 免费的、有广告的安卓游戏会在背后下载大量广告。 3.1.1 Android能耗统计文件 在Android操作系统内部，有一个XML文件描述了系统中主要硬件组件的电量消耗情况。 在/System/Frameworks/目录下，复制一份frameworks-res.apk到你的工作电脑中，然后反编译就可以导出/res/xml/power_profile.xml文件了。 3.1.2 屏幕 屏幕是耗电量最大的硬件之一。 LCD：每一个像素消耗的能量是相同的，和它们呈现的颜色无关。 LED：黑色不使用任何颜色，所以不消耗能量，而与此相对的白色，使用了所有颜色和最高亮度的光，所以会消耗更多的能量。 3.1.3 无线设备 蜂窝无线和Wi-Fi使用的电量相近。 蜂窝无线和Wi-Fi最大的不同点在于，蜂窝无线的持续时间要比Wi-Fi长很多，使用蜂窝无线的会话时间也会变长，结果便是比Wi-Fi消耗更多的电能。从根本上讲，若App要使用无线传输，最好的性能提升方式是一次下载尽可能多的数据，然后关闭无线设备。减少请求次数是一个一举两得的办法，不仅可以提升屏幕的加载速度，也可以节省电量。 避免使用GPS可以加快App的响应速度（设备的位置服务依然可用），同时节省电能。 GPS失效备援：当用户处于地下室时，设备可能接收不到GPS信号。如果在一段时间内你都接收不到GPS信号，那么请确保关闭GPS。 3.1.4 CPU CPU的占用率越高，电量消耗得就越快。 3.1.5 其他传感器 确保在调用完传感器之后将其注销。如果回调监听者保持活跃，传感器将继续报告数据，这势必会造成不必要的处理器负载、内存占用和电量消耗。 海森堡的测不准原理：观察世界必然干扰世界。监测设备在监测电量使用情况的同时也在消耗电量，从而对监测结果产生干扰。 3.1.6 休眠 App不工作的时候让其休眠是很重要的。释放传感器和信号发射器并允许屏幕休眠，会节省很多电量。让App休眠至关重要，算准时机激活App同样很重要。合适的唤醒频率可能会极大地延长电池的使用时间。 3.1.7 WakeLock和Alarm WakeLock WakeLock可以唤醒（保持唤醒状态）移动设备的部分组件。屏幕WakeLock就是电影流媒体App在播放电影期间保持屏幕点亮，或者是音乐流媒体App在播放期间保证音频频道正常运行。 WakeLock是电源管理API的一部分。这个API的使用会影响设备的电源寿命。除非真的需要，否则不要获取PowerManager.WakeLocks，要尽量少用WakeLock并确保使用之后尽快释放，只要屏幕休眠就要确保WakeLock被释放。 WakeLock 检测 API： adb shell dumpsys batterystats Alarm Alarm允许开发者设置时间执行特定的操作，特别是App在后台运行或者是设备处于休眠状态的时候。 有时间精确性要求的提醒应该设置一个准确的Alarm（例如，创建一个闹钟App）。其他的情况下可以使用不精确的Alarm，操作系统会自动协调、合并Alarm来节省电量。 3.1.8 Doze模式 Doze模式用来限制设备被唤醒的次数。（Marshmallow之后） 激活状态：屏幕点亮。 休眠状态：屏幕休眠，但是设备处于唤醒状态。 待闲置状态：准备进入闲置状态。 闲置状态：设备休眠。 闲置维护状态：队列中Alarm和更新任务的短暂的执行机会。 强制设备进入Marshmallow的这几种不同的状态的命令如下： adb shell dumpsys battery unplug //设备停止充电的命令 adb shell dumpsys deviceidle step //重复该命令，遍历各种状态 实际上，设备在灭屏的状态下从休眠状态到待闲置状态需要30分钟，并且需要再经过30分钟才会进入闲置模式。一旦进入了闲置模式，设备将推迟所有的Alarm直到下一个闲置维护期（60分钟后）。闲置维护期之间的延时是不断增加的（1小时、2小时、4小时、6小时），最大的间隔是6小时。 所有的Alarm和WakeLock都会被暂停直到维护期的到来，对于那些长期处于闲置状态的设备（像平板电脑），这无疑会节省大量的电量。 3.2 基本的电量消耗分析 3.2.1 电能统计 开启报告全部WakeLock的功能（这个功能只支持Lollipop及以上的系统） adb shell dumpsys batterystats --reset adb shell dumpsys batterystats --enable full-wake-history 开启电能统计转储（在这里，下载上次完全充电后的所有电能数据）： adb shell dumpsys batterystats --charged 3.2.2 Battery Historian atterystats可以在很大程度上帮助我们确定App消耗电量的原因。它有大量的、有用的、可深入研究的细节，可以用来了解App的表现以及潜在的问题。为了简化分析，Google开发出了Battery Historian（http://github.com/google/battery-historian），它将原始的batterystats输出文件以图形化的方式生成为一份HTML文档。 运行下面的命令，就可以根据batterystats创建一个可视化的网页： adb bugreport > bugreport.txt //download the output to your computer ./historian.py bugreport.txt > out.html //create the html file battery_level（剩余电量）：鼠标悬停在battery_level变化处，显示剩余电量，以及距上次battery_level变化的间隔 top（上栏）：列举了当前屏幕上显示的进程。 Battery info（电池信息） status（状态）：正在放电（与充电状态相对应）。 health（健康）：电池健康状态，来自电池管理器API。 plug（连接状态）：设备是否接通电源。 phone_signal_strength（无线网络信息）：显示信号变化（有差、中、好三种）。 wifi_suppl（Wi-Fi状态） wifi_signal_strength（Wi-Fi信号强度） phone_scanning（电话扫描）：如果没有信号，手机就会扫描信号（这样会导致更多的电量消耗）。 screen（屏幕）：屏幕开启的时长。 plugged（连接）：电量来源（类似于上面的电量信息）。 data_conn（数据连接） phone_state（手机状态）：可以看到蜂窝网络覆盖变化，或者你是否打了一个电话。 fg：这里指的是前台应用。前台程序很少被销毁来释放内存。 sync（同步）：处理与服务器的同步。 wake_lock： gps（全球定位系统） running（运行） wake_reason（唤醒原因） qcom, smd-modem：高通共享内存驱动，与调制解调器内存交互。 qcom, smd-rpm：高通共享内存驱动-电源管理器。 qcom，mpm：高通MSM电源休眠管理；关闭时钟，将设备置为休眠状态。 qcom, spmi高通系统电源管理接口；让设备从工作状态回到休眠状态。 wake_lock_in（唤醒锁） mobile_radio（手机无线网络）：蜂窝无线网络的连接时间（指连接到网络，不一定传输数据），手机切换网络时会有空挡。 user（使用者）：可能会有多个使用者的情况。 userfg（前台使用者）：测试时，处于前台的使用者。 3.3 JobScheduler JobScheduler可以替代WakeLock和Alarm运行App的任务。可以将它看作“互相协作的WakeLock/Alarm”API。如果5个App每30分钟唤醒设备一次，则它们的唤醒几乎不可能同步，最终设备每小时会被唤醒10次。但由于JobScheduler是在系统层级，系统可以更有效地执行所有的调度工作。每小时唤醒设备的次数也会减少。 第四章 屏幕和UI性能 4.1 UI性能基准 研究显示，0~100毫秒的延迟会让用户感知到瞬时的卡顿；100~300毫秒的延迟会让用户感觉迟缓；300~1000毫秒的延迟让用户感觉“手机卡死了”；1000毫秒以上的延迟会让用户想去干别的事情。 卡顿 大部分Android设备一秒刷新屏幕60次（也有例外，比如早期的Android设备的刷新频率是50fps，甚至更低）。由于屏幕每16毫秒刷新一次（1s/60fps=16ms/f），所以保证每帧的渲染时间少于16毫秒是非常重要的。如果有一帧跳过了，用户就会感知到动画的跳跃，这样的体验是非常不好的。 4.2 Android上的UI和渲染性能改进 在使用Gingerbread或更早的Android系统版本的设备上，屏幕绘制是完全在软件上完成的（没有GPU的需求）。然而，随着Android设备的屏幕越来越大，像素精度越来越高，为了能及时渲染屏幕，对软件的要求也越来越高。 Android的Honeycomb版本新增了平板电脑版，进一步扩大了屏幕的尺寸。考虑到这一点，这个版本增加了GPU芯片，App可以选择完全使用GPU硬件加速来运行渲染的程序。 对于运行在Ice Cream Sandwich或者更高版本系统上的App，GPU硬件加速是默认打开的，App会将大部分渲染工作交给特定的硬件，这显著地提高了渲染的速度。 Jelly Bean 4.1和4.2版本上，为了让App运行起来更加流畅，“黄油计划”为避免卡顿和抖动做了进一步的改进。通过改善VSYNC的时序（更好地调度帧的创建），增加额外的帧缓冲，Jelly Bean设备改善了卡顿丢帧的情况。Android团队在做这些改进的同时，也提供了一系列的工具来测量屏幕绘制、VSYNC缓冲和卡顿的情况，并对开发者开放了这些工具。 4.3 工具 要通过减少布局的层级来加快屏幕的绘制，尽可能地保持视图层级的扁平化并删除所有不必要渲染的视图。 Hierarchy Viewer Hierarchy Viewer（层次结构查看器）能够很便捷地以可视化方式查看各种视图嵌套关系，可用于研究XML视图结构。 Systrace 记录整个Android系统的数据。Systrace Screen Painting可以用来观察屏幕绘制的步骤。 第五章 内存性能 5.1 内存 共有内存：所有的App都会利用这些公共的框架类、资源以及本地类库。为了节省内存，Android使用共享内存来保存这些资源。当分配内存给App时，这些共享内存将被平均分配给所有正在运行的进程。 私有内存：私有内存是指只被你的App使用，而其他App不能使用的内存。因为只有你的进程可以使用这些数据，所以这些私有内存将会完全地分配给你的这个进程。 Zygote：在Android中，Zygote是一个包含所有框架类、公共资源以及本地库（预装在Zygote内部）的进程。当App启动时，在加载任何你编写的代码之前，它会分支（fork）出一个Zygote进程（App在系统中存活需要的一切由此开始）。这样App初始化就比从零开始快多了。 脏内存：脏内存是指仅存在于RAM中的内存，如果数据从RAM中清除掉，App需要重新运行才能将这些数据取回。 干净内存：而干净内存是指这些存储在RAM中的单元同样也会存储在磁盘上，如果这些数据被清理掉了，只需从设备中重新加载就可以了。 ART：在运行ART的设备上，程序代码已经在安装的时候编译过了，并且在磁盘上也做好准备了，所以当前内存中的程序代码是干净的。 5.1.1 内存清理 一般来说，一旦某个对象在App中没有一个活动的引用，就可以作为垃圾被回收了。垃圾回收器会先从根部的对象开始（它知道这些对象是活动的并且正被进程所使用），并且沿着每个引用去查找它们的关联。 5.1.1.1 垃圾回收在操作系统上的改变 设备内存很小，所以App的堆往往较小。垃圾回收器会遍历整个堆来寻找垃圾，会使所有的CPU进程和线程停止。对于使用内存少的App，垃圾回收非常迅速：可能是2~5毫秒。然而，随着设备变得越来越强大（读取更多内存），并且App也变得越来越大，垃圾回收花费的时间也越来越长。这些中断开始阻碍UI。 Gingerbread 使用了一个并发的垃圾回收器来做局部的回收工作，尽管不能清理所有未被引用的对象，但速度更快。并发垃圾回收器会和APP一起运行，而不是阻止APP运行。 垃圾回收器只做简单的“标记清理”，从一整条的内存中一块块地移除未被引用的对象，就会导致内存的碎片化。当设备显示有20MB的自由内存时，最大块的自由内存事实上可能只有1MB，如果用户尝试创建一个4MB的图片，将会遇到内存溢出问题。 Lollipop 在这个版本中，Android运行时由Dalvik转变成ART，垃圾回收的效率进一步提高。 在ART中有许多新的垃圾回收算法，其中一个：当一个App不在前台时，它将是一个半空间垃圾回收器，没有被引用的对象被移除之后，被用过的控件将被复制到内存的一块自由空间内，这样内存将会没有碎片。 15年AOSP有一个压缩垃圾回收器项目，可以实现对象在内存中移动位置从而消除碎片。 5.1.1.2 垃圾回收的执行时机 在App被分配了新对象（这增加了App所需要的内存空间）时； 新视图被创建，而旧视图无效（释放了内存中的引用）时； App发生内存泄露，并且在内存中保存了无用的引用（阻塞了垃圾回收，同时导致了其他的内存问题）时。 5.1.2 确定APP使用的内存大小 返回App可以使用的堆的最大值： ActivityManager.getMemoryClass() 可以获得更多内存。但是大的内存堆将会降低App的速度（因为此架构不得不通过查找更多的数据捕获无用的对象）： getLargeMemoryClass() 在log中输出信息： adb shell dumpsys meminfo app使用的全部内存包括私有内存和一定比例的共享内存。 procstats 设置→开发者选项→进程统计中，可以看到一个可视的设备内存使用量的界面（默认统计时间是最近的3小时，但是可以改为6、12或者24小时）。 5.1.3 Android内存警告 如果App正在运行，并存在内存问题，onTrimMemory会发出以下警告： TRIM_MEMORY_RUNNING_MODERATE 首先发出TRIM_MEMORY_RUNNING_MODERATE警告。 TRIM_MEMORY_RUNNING_LOW 如果继续执行，将会发出TRIM_MEMORY_RUNNING_LOW警告，就像是黄灯警示。这时系统会开始释放资源来提高系统性能。 TRIM_MEMORY_RUNNING_CRITICAL 如果仍然继续执行并且没有释放资源，将会发出红灯警告：TRIM_MEMORY_RUNNING_CRITICAL。此时，系统会结束后台进程以获取更多的内存。同时，这将降低App的性能。 TRIM_MEMORY_UI_HIDDEN 当回调TRIM_MEMORY_UI_HIDDEN时，App刚从前台转为后台，这是释放大量UI资源的大好时机。此时App在缓存的App列表中。如果有问题，此App的进程将会被结束。作为一个后台程序，尽可能多地释放资源，这样的恢复会比纯粹的重启更加快速。其中有3个级别： TRIM_MEMORY_BACKGROUND App处于列表中，但是是接近尾部的位置。 TRIM_MEMORY_MODERATE App处于列表的中部。 TRIM_MEMORY_COMPLETE 这是“下一个被结束的就是此App”的警告。 5.3 追踪内存泄露的工具 5.3.1 Heap Dump 5.3.2 Allocation Tracker 5.3.3 更加深层次的堆解析：MAT和LeakCanary hprof是已保存的堆转储文件。转换工具hprof-conv存储于AndroidSDK 工具目录下。 MAT是Eclipse的内存分析工具，可以独立下载使用。 第六章 CPU与CPU性能 6.1 检测CPU占用率 查看设备的CPU占用率 adb shell top -n 1 -m 10 -d 1 运行1次命令（-n 1），可以获取1秒内（-d 1）10个CPU占用率最高的App（-m 10） 报告如下： User 58%, System 14%, IOW 0%, IRQ 0% User 157 + Nice 6 + Sys 41 + Idle 75 + IOW 1 + IRQ 0 + SIRQ 0 = 280 PID PR CPU% S #THR VSS RSS PCY UID Name 15252 1 32% S 16 1581536K 93324K fg u0_a109 com.example.isitagoat 1952 0 20% S 97 1708552 136668K fg system system_server 15987 2 2% R 1 4464K 1108K shell top 2413 2 2% S 32 1650148K 76044K fg u0_a11 com.google.process.gapps 3010 1 2% S 41 1810248K 179400K fg u0_a28 com.google.android.googlequicksearchbox 3384 1 2% S 47 1621432K 83928K fg u0_a11 com.google.process.location 2586 1 2% S 26 1566872K 93088K fg u0_a91 com.elvison.batterywidget 2125 0 1% S 32 1698300K 166068K fg u0_a24 com.android.systemui 267 1 1% R 15 227172K 17060K fg system /system/bin/surfaceflinger 6256 1 0% S 49 1603916K 83816K fg u0_a28 com.google.android.googlequicksearchbox 第一行：用户占用了58%的CPU，内核空间占用了14% 第二行：调度器在状态间切换花费的时间（几十毫秒）。最大数值可能是CPU数的100倍。活跃的进程一共有280个，由于测试运行在Nexus 6（四核CPU）上，最大值是400。 表格：“Is it a goat?”App占用了32%的CPU，系统占用了20%，top命令占用了2%，后台和Google App也占用了一部分。 查看更详细的CPU信息 dumpsys cpuinfo 看到log Load: 12.28 / 11.64 / 11.56 CPU usage from 11368ms to 4528ms ago with 99% awake: 0.3% 1531/mediaserver: 0% user + 0.3% kernel / faults: 1093 minor 1 major 130% 15754/com.coffeestainstudios.goatsimulator: 111% user + 19% kernel / faults: 130 minor 10% 306/mdss_fb0: 0% user + 10% kernel 9.8% 267/surfaceflinger: 4.5% user + 5.2% kernel 4.5% 1952/system_server: 1.4% user + 3% kernel / faults: 65 minor 0.8% 19261/kworker/0:1: 0% user + 0.8% kernel 0.7% 2982/com.android.phone: 0.2% user + 0.4% kernel / faults: 181 minor 0.5% 158/cfinteractive: 0% user + 0.5% kernel 0.5% 18754/kworker/u8:4: 0% user + 0.5% kernel 0.4% 205/boost_sync/0: 0% user + 0.4% kernel 0.4% 211/ueventd: 0.2% user + 0.1% kernel 0.4% 2586/com.elvison.batterywidget: 0.2% user + 0.1% kernel / faults: 121 minor 第一行：CPU在过去的1、5、15分钟的平均负载 后面的：近7秒内所有App的CPU占用率（由于空间原因被截断了）。你可以看到每个App占用CPU的百分比（如果不止运行在一个核心上，它可以超过100%），以及用户态和内核态的比例。 6.2 使用Systrace分析CPU 6.3 Traceview（遗留的监视器DDMS工具） 6.4 Traceview（Android Studio） 6.5 其他优化工具 高通提供了一款免费App——Trepn。通过这款软件，你可以查看内存、CPU、电量、网络和其他特性。 第七章 网络性能 7.1 Wi-Fi与蜂窝无线电 7.1.1 Wi-Fi 高吞吐量、低延迟、没有数据收费、建立连接和关闭连接时会有延迟。 7.1.2 蜂窝 当手机处于数据连接的低覆盖区域，必须开启天线功率才能维持连接。 活跃的蜂窝无线信号（处于125毫安）比Wi-Fi信号（处于240毫安）耗电量低，但是鉴于蜂窝连接在网络中的实现方式，蜂窝连接的功耗通常会更高一些。 7.1.3 RRC状态机 为了提高蜂窝网络的服务质量，所有运营商都采用了一种无线资源控制（Radio Resource Control，RRC）的状态机来控制数据连接的建立与中断。 当手机启动数据连接后，在创建TCP连接之前，会有几种初始无线信号被发送到信号塔。这些信号会使无线连接的创建时间增加500~1000毫秒。 延迟是移动连接质量的关键之一，状态机可以在一定程度上抵消这种延迟。 每一种移动网络都有一个RRC状态机，用于确保在最后一个数据包发出之后无线电信号仍然开启，以补偿建立连接时产生的延迟并平衡电量消耗。（看了好久，终于看懂了，意思是手机中的网络连接因为建立连接时的延迟会和信号塔发送的数据包存在一定的错位，补偿延迟的意思就是保证手机接收到最后一个数据包时信号塔才会关闭连接。平衡电量消耗就看不懂了。） 4G（LTE）状态机 如果没有上面提到的延迟，如果接下来仍有数据快速地发送过来，又需要经历建立连接时产生地延迟。 采用状态机时，当最后的高功率延续时间段没有数据包时，无线连接将会关闭以节省电量。 一般情况下，LTE无线连接比3G无线连接耗费更多的电量。 但如果正在传输的文件很大，LTE的下载速度可能要更快，结束无线连接的时间也会相应缩短，因此使用的电量更少。 但是，绝大多数的移动数据传输并不是大型文件，而是由数百个小型文件构成，因此使用的数据块也相对较小。这些小小的文件无法充分利用LTE的带宽能力（因为它们太小了），因此通过LTE下载内容所耗费的电量比使用3G网络要稍多一些。 无线电连接和数据连接 无线电连接指的是Wi-Fi，数据连接指的是蜂窝网络。 蜂窝网络的连接数量有限，一段时间后，网络会自动清理孤立的连接。 蜂窝网络只有在需要进行数据传输时才会建立连接。 而Wi-Fi的连接一直存在。 手机通话时使用数据 手机通话时数据网络会降到3G，除非开启了VOLTE 7.2 测试工具 7.2.1 Wireshark 7.2.2 Fiddler 7.2.3 MITMProxy 7.2.4 AT&T ARO 7.2.5 混合型App和WebPageTest.org 7.3 Android网络优化 14条标志性性能优化原则： 减少HTTPS请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置Etags 使AJAX可缓存 7.3.1 文件优化 压缩文本文件 常用的压缩算法 --> Gzip --> 增设排除小文件的功能，把不足859字节的文件放到一个不用压缩就能发送的数据包里 更进一步的压缩算法，提高5%的压缩率，但是压缩执行时间多出100倍，注意只用它处理已经预压缩过的文件 --> Zopfli 7.3.2 精简文本文件 （Souders：精简JavaScript） 精简过程就是去掉文本文件中所有只具有方便阅读作用的格式（比如空格、制表符和注释），进而使文件变小。 根据页面大小和复杂度，精简可以将文件缩小20%~50%。很多构建工具（如grunt）自带精简库，在你做改动的时候就可以自动精简文件（帮你节省了很多工作）。 精简虽然可以把文件缩小10%~15%，但是精简过和未精简过的文件进行Gzip压缩后，所节省的文件大小差异只有1%~2%（因为空格的压缩效果好）。 可是，即便只能节省1%~2%的网络传输量，你也应该养成精简的习惯，因为这样能为用户节约设备存储空间。另外，文件越小，读入内存的速度就越快（而且导致内存有限的设备崩溃的可能性越小）。 7.3.3 图片 1.尺寸超大化 为图片创造图片bucket，App向服务器提供屏幕尺寸以确保得到尺寸正确的图片。 如果缩略图和原图在APP上展示效果一致，可以考虑下载缩略图而不是原图。 2.元数据 当用数码相机拍摄照片时，文件里很可能有与相片相关的元数据（设备名称、设备设置、拍摄地点）。图片编辑软件也会给图片添加一些元数据。如果不需要这些元数据的话可以考虑删除。 3.压缩 WebP格式图片通常比类似的JPEG格式图片小20%。 7.3.4 文件缓存 1.应用内缓存 Android缓存功能默认是关闭的，所以你需要将它打开。对于Android 4.0及更新版本，在onCreate中调用以下代码就可以启用HTTP响应缓存： private void enableHttpResponseCache() { try { long httpCacheSize = 10 * 1024 * 1024; // 10 MiB File httpCacheDir = new File(getCacheDir(), \"http\"); Class.forName(\"android.net.http.HttpResponseCache\") .getMethod(\"install\", File.class, long.class) .invoke(null, httpCacheDir, httpCacheSize); } catch (Exception httpResponseCacheNotAvailable) { Log.d(TAG, \"HTTP response cache is unavailable.\"); } } 2.服务器端缓存 服务器向设备传输的报头设定了设备里存储的每个文件的缓存时间。缓存定时器的长度实际取决于缓存内容及其改动的频率。 3.Cache Control（添加Expires报头） 缓存最常用的报头是Cache-Control报头，它有几个可以指定的常用值。 Private/Public 网络中CDN缓存使用的代表性指令。它可以向CDN表明文件是公共的（任何人都可以使用）还是用户私有的。 no-store如果文件 使用该指令，那么该文件无法缓存，必须在每次使用时下载。 no-cache no-cache报头的名称可能令人误解。带有no-cache报头的文件实际上是可以缓存的，但是再次使用前必须重新验证。 max age=X max-age表示文件可以缓存的最大时间（单位：秒）。常用值为0（与no-cache相同）、60、300、600、3600（1小时）、86 400（1天）、3 153 600（1年）。 4.ETag ETag是一种响应报头，包含由随机字符组成的唯一字符串。每次从缓存中使用文件时，ETag必须先在服务器端验证。如果本地字符串与服务器端一致，服务器发回“304 not modified”，那么使用本地文件。如果ETag不一致，则下载新文件并保存在缓存内。 对于经常过期的文件，ETag是验证本地缓存文件是否依旧与服务器同步的好方法。但对于很少改动的文件，ETag则是昂贵（从性能方面来看）的缓存机制。这是因为尽管并未下载文件（这样节省了带宽），但是依旧建立了连接，连接时间延长了文件处理过程。 5.Expires 给出文件未来过期和应当重新验证的具体日期。这是网络上最早使用的缓存报头，一些老式的浏览器可能还在使用它。 第一次启动APP 第一次启动几乎决定了用户满意度，关乎成败。如果App第一次启动花费了很长时间进行配置（下载图片和文件），那么用户可能就不会再用你的App了。把图片和文件放入App的资源文件，虽然需要下载的App会变大，但是可以加快第一次启动的速度。此外，如果你改动了标志、图标等，你需要做的是发布一个App更新。 HTTP缓存规范规定，如果文件不含内容，那么会被缓存24小时。如果你不想缓存文件，必须明确说明，以避免出现按照规范进行缓存的情况！ 7.3.5 分组连接 利用JobScheduler API 进行定期连接，减少APP进行网络连接的数量， 7.3.6 检测应用的无线电使用情况 检查用户连接的是wifi还是蜂窝网络： public static String getNetworkClass(Context context) { ConnectivityManager cm = (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo info = cm.getActiveNetworkInfo(); if(info==null || !info.isConnected()) return \"-\"; //未连接 if(info.getType() == ConnectivityManager.TYPE_WIFI) return \"wifi\"; if(info.getType() == ConnectivityManager.TYPE_MOBILE) { return \"cellular\"; } return \"unknown\"; } 确认蜂窝网络连接是否存在，使用TelephonyManager（Tel）数据行为API确定无线电是否打开。 if (Tel.getDataActivity() >0){ if (Tel.getDataActivity() 在Android 5.0中，ConncetivityManager中加入了新API，现在可以利用ConnectivityManager.OnNetworkActiveListener将这个仅适用蜂窝网络的方法推广应用到所有无线连接，从而找出无线网络何时处于高功率状态（并准备传输数据）。可以使用ConnectivityManager.isDefaultNetworkActive()查看网络是否已经处于活动状态。使用已经建立的无线连接是共享资源和节省用户电量的好方法。 GCM Network Manager GCM Network Manager可以在Gingerbread（2.3）版本之后的所有Google Android设备上运行。 用这个API设置的任务可以只在Wi-Fi开启状态或设备连通电源的时候运行。你也可以设置任务使其在后台定期运行或自动退出。利用此API进行非紧急性更新与连接，可以为用户直接节省大量的设备电池用量。 7.3.7 适时关闭连接 当需要下载很多的数据包时，可能会只对服务器开启TCP连接，这样就可以减少一些连接设置延迟。对相对快速、连续发送的文件确实如此。但如果文件发送的间隔时间达到或超过了15秒，可能还是得开启无线电（其实连接设置所需时间极少）。 如果一段时间内没有产生数据流量而连接还在开启，设备和服务器都有个关闭连接的清理进程。这也不是件坏事（后续的章节会讲述原由）。但缺点就是关闭连接的一方会告诉对方：“喂，我现在要关闭连接了。”这可能会造成无线电连接的继续开启，继续在设备上运行10~15秒的RRC状态机，给用户造成额外的电量损耗。 图片下载完成后，服务器和设备就会立即关闭连接的代码： HttpURLConnection connectionCloseProperly = (HttpURLConnection)ulrn.openConnection(); //这禁用了“保持链接” connectionCloseProperly.setRequestProperty(\"connection\", \"close\"); connectionCloseProperly.setUseCaches(true); connectionCloseProperly.connect(); Object response = connectionCloseProperly.getContent(); InputStream isclose = connectionCloseProperly.getInputStream(); //...download and render bitmap image connectionCloseProperly.disconnect(); 7.3.8 定期执行重复的ping命令 完美风暴：重复连接和关闭连接 想象一下，当几个人在某区域移动，他们手机上的App每隔五秒和服务器交换一次实时数据以更新位置信息。再想象一下，收到最后一个数据包后（在服务器上保留IP地址），服务器上的连接仍然保持90秒。通常而言，如果每个用户每次会话只要占用一个连接，这就应该没什么问题了。但是如果你更改了代码中的配置，使每一次ping都与服务器建立一个新的TCP连接，而App在发布前没有测试到这个问题，最后会发生什么事？ 那么你就引发了一场完美的数据流量风暴！现在每个Android用户每5秒ping一次，将18个之多的IP地址连入服务器。连入的用户越来越多，可能就会发生IP冲突现象，从而导致用户无法连接！恭喜，你的App向服务器成功地完成了一次DDoS攻击。 因此，要特别注意服务器重复执行ping操作，并且应当在App发布前进行测试。 7.3.9 网络安全技术的应用（HTTP和HTTPS） 在用网络传输数据时，必须保证用户的个人数据安全。 用户可能会连接到任何类型的网络，包括服务场所不安全的Wi-Fi热点。如果你传输的数据通过HTTP发送，窥探者能毫不费力地获取该数据——因为你是用明文发送的！你应该通过HTTPS发送，使用密钥加密数据，然后再将密钥告知接收方。 7.4 全球移动网络覆盖范围 全球数据仅供参考 7.4.1 CDN服务器 CDN服务器（大体上来说）是用来在网络前沿或者接近最后一英里处存储数据的服务器。它依赖于数据存储的分布式系统，主系统不会因为请求次数太多而不堪重负。将这些CDN服务器放置在用户附近，数据就更靠近用户了，这样就减少了请求和传送文件的往返时间。 7.4.2 仿真慢速网络 1.Wi-Fi网络节流 如果你正在使用无线路由器进行测试，并且可以在路由器上安装OpenWRT （一个开源路由器），那么会有一个wshaper插件（http://wiki.openwrt.org/doc/recipes/guest-wlan），让你可以对上行和下行链路连接进行节制，这至少可以让你模拟较慢的网络速度（但不是延迟）。 2.模拟器 Android模拟器可以控制网络条件。打开模拟器后，你可以登录到模拟器以模拟不同的吞吐量和延迟： telnet localhost 5554 network speed edge //gprs, umts hsdpa和全面的附加选项 network delay edge 3.自制法拉第笼 法拉第笼是由金属丝构成的笼子，它将内部空间同外部的电磁辐射完全隔离开来。制作局部法拉第笼能够减少到达手机的信号量。有报道称，一些开发人员成功使用旧的（不插电！）微波炉屏蔽掉了部分无线电。由于实验的不确定性，这些测试的结果很难重现，但这也许已足以用于定性测试了。 4.网络弱化器 AT&T发布了一款名为AT&T网络弱化器（http://developer.att.com/attenuator）的工具，如图7-16所示。这款网络弱化器在Samsung S3 ICS内核上运行（需要root和一个由AT&T提供的自制ROM闪光）。安装后，这个App可以像一个刻度盘一样减慢移动网络、降低吞吐量（很抱歉，如果你连接的是3G网络，它并不能使你的连接变得和4G网络一样快）。当滑动滑块将网速从UMTS变为EDGE时，上行链路、下行链路和往返时间定时器都会相应地作出调整，让你在较慢速的网络条件下对App进行一些简单的测试。你也可以从左到右滑动滑块以调整网络拥塞程度，增加每个连接的往返时间。 7.4.3 构建网络感知APP 感知网络，并且根据所测得的网络条件，调整用户的体验。 要为连接快速、中速和慢速网络的设备提供不一样的移动体验，只需要简单地去除内嵌视频或者减少图像的数量（或者至少改变图像的大小）。 确定移动网络速度的代码： TelephonyManager teleMan = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE); int networkType = teleMan.getNetworkType(); switch (networkType) { case 1: netType = \"GPRS\"; networkSpeed = \"slow\"; break; case 2: netType = \"EDGE\"; networkSpeed = \"slow\"; break; case 3: netType = \"UMTS\"; networkSpeed = \"medium\"; break; // 我们会略过一些网络类型，但你应该明白我的意思了 // 你可以在GitHub中查看完整代码 case 13: netType = \"LTE\"; networkSpeed = \"fast\"; break; } 手机向服务器发起下载图片的请求后获得200回复的时间 与 图片下载完成的时间 的差值可以用作估算网络延迟 确定实时的往返时间和吞吐量的代码： private Bitmap downloadBitmap(String url) { //下载开始时间 Long start = System.currentTimeMillis(); final DefaultHttpClient client = new DefaultHttpClient(); final HttpGet getRequest = new HttpGet(url); try { HttpResponse response = client.execute(getRequest); //检查成功返回码200 final int statusCode = response.getStatusLine().getStatusCode(); //收到200成功码回复的时间 Long gotresponse = System.currentTimeMillis(); } final HttpEntity entity = response.getEntity(); //获得文件的ContentLength contentlength = entity.getContentLength(); if (entity != null) { InputStream inputStream = null; try { inputStream = entity.getContent(); final Bitmap bitmap = BitmapFactory.decodeStream(inputStream); Long gotimage = System.currentTimeMillis(); //图片下载完成的时间 responsetime = gotresponse - start; //200回复完成的时间 imagetime = gotimage - start; //下载时间 throughput = ((double)contentlength/1024)/((double)imagetime/1000);//KB/s return bitmap; } } } 7.4.4 计算延迟 如果处于高延迟环境中，考虑预加载。 7.4.5 最后一英里的延迟 延迟通常在数据传输的最后一英里发生，在移动网络中尤其如此。这些技巧可以帮助你应对延迟，缓解问题，但不能从根本上解决问题。正如在7.4.2节中描述的那样，Facebook发现，在印度尼西亚的慢网连接中，84％的流量来自于南美和欧洲的CDN服务器。 7.4.6 其他无线电 Wi-Fi和蜂窝无线网都是最常用的传输数据的网络，也是最容易优化的。但是其他的无线电网络也会导致设备的能耗，因此它们的行为也应该被关注、讨论。 7.4.7 GPS Android提供了模糊定位，使用附近蜂窝基站和Wi-Fi网点的信息即可生成粗略的位置信息，并不需要开启GPS。然而，很多App需要更精准的定位，它们会打开GPS设备，从GPS卫星接收信号。定位需要从手机到卫星之间的一条信号线。为了优化定位设备的使用性能，可能必须调整GPS打开的时间（保持GPS接收器打开多久），以及使用频率。打开的时间越长，使用的频率越高，你得到的位置信息就越精准。 7.4.8 蓝牙 目前，所有的Android旧设备都必须通过蓝牙才能连接到其他设备。如果你对蓝牙的数据传输感兴趣的话，可以在Wireshark的非集群中收集它的日志信息。对于使用KitKat和更新版本系统的设备，你可以在开发者选项设置中打开“Bluetooth HCI snoop log”。当你选中了该选项时，Android设备将会收集所有通过蓝牙接口发送的数据包的日志信息，信息会被存放在/sdcard/btsnoop_hci.log中。在Wireshark中打开这个日志文件，你可以看到被传输数据包的信息。大部分数据是加密的，但是你可以观察到两个设备之间的通信模式（见图7-17）。 第八章 真实用户检测 真实用户检测即收集App的运行时数据，统计结果，生成报告，从这些数据中寻找可能出现的问题。 常用的RUM工具（境外）： Crashlytics、Crittercism、Google Analytics和New Relic RUM No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-4.框架层-运行时/Android后台任务.html":{"url":"04_Android/框架层/4-4.框架层-运行时/Android后台任务.html","title":"Android后台任务","keywords":"","body":"指导原则：一般来说，运行时间超过几毫秒的所有任务都应委派给台线程。长时间运行的常见任务包括解码位图、访问存储空间、处理机器学习 (ML) 模型、执行网络请求等。 后台任务的类别： 即时任务：是否需要在用户与应用进行互动时完成？ 精确任务：是否需要在精确的时间点运行？ 延期任务：以上两者都不是，那么定义为延期任务 解决方案： 即时任务 Kotlin 协程。许多 Android KTX 库都包含适用于常见应用组件（如 ViewModel）和常见应用生命周期的现成可用的协程作用域。 如果您是 Java 编程语言用户，请参阅 Android 上的线程处理。 对于应立即执行并需要继续处理的任务，即使用户将应用放在后台运行或重启设备，我们也建议使用 WorkManager 并利用其对长时间运行的任务的支持。 在特定情况下（例如使用媒体播放或主动导航功能时），您可能希望直接使用前台服务。 延期任务：如果您希望某些可延期异步任务即使在应用退出或设备重启后仍能正常运行，使用 WorkManager 可以轻松地调度这些任务。 精确任务：需要在精确时间点执行的任务可以使用 AlarmManager。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"04_Android/框架层/4-4.框架层-运行时/ANR问题.html":{"url":"04_Android/框架层/4-4.框架层-运行时/ANR问题.html","title":"Anr问题","keywords":"","body":"触发ANR的条件 在 5 秒内对输入事件（例如按键或屏幕轻触事件）没有响应。 BroadcastReceiver 在 10 秒内尚未执行完毕。 避免ANR的策略 1.使用AsyncTask 只需扩展 AsyncTask 并实现 doInBackground() 方法即可执行相应操作。如需向用户发布进度变化，您可以调用 publishProgress()，它会调用 onProgressUpdate() 回调方法。通过 onProgressUpdate()（在界面线程中运行）的实现，您可以向用户发送通知。 2.使用Thread或HandlerThread类 果是这样，您应该调用 Process.setThreadPriority() 并传递 THREAD_PRIORITY_BACKGROUND，从而将线程优先级设为“后台”优先。如果您不通过这种方式将线程设置为较低的优先级，则此线程仍可能会让应用变慢，因为默认情况下，此线程会按照与界面线程相同的优先级操作。 如果您实现了 Thread 或 HandlerThread，请确保在等待工作线程完成操作期间，界面线程不会阻塞；请勿调用 Thread.wait() 或 Thread.sleep()。非但不应在等待工作线程完成操作期间阻塞，主线程在完成操作时还应提供 Handler 以供其他线程向回发送。以这种方式设计应用，即可让应用的界面线程对输入保持响应，从而避免因 5 秒的输入事件超时而导致系统显示 ANR 对话框。 3.如果 BroadcastReceiver 接收到广播后要执行耗时操作，应该启动IntentService 对 BroadcastReceiver 执行时间的特定约束强调了广播接收器的功能：在后台执行少量离散工作，例如保存设置或注册 Notification。因此，与在界面线程中调用的其他方法一样，应用应避免在广播接收器中执行可能会长时间运行的操作或计算。但如果需要执行可能需要长时间运行的操作以响应 intent 广播，则应用应启动 IntentService，而不是通过工作线程执行密集型操作。 加强响应能力 通常，100 到 200 毫秒是一个阈值，一旦超出此阈值，用户便能够感受到应用速度缓慢。因此，除了采取措施以避免显示 ANR 之外，还有一些提示可以让用户感觉您的应用响应迅速： 如果应用在后台执行操作以响应用户输入，则显示正在进行该操作（例如在界面中使用 ProgressBar）。 特别是游戏，在工作线程中计算走法。 如果应用具有耗时较长的初始设置阶段，考虑显示启动画面或尽快呈现主视图，表明正在加载，并异步填充信息。在任何一种情况下，您都应以某种方式表明操作正在进行，以免用户认为应用已卡住。 使用 Systrace 和 Traceview 等性能工具确定应用响应能力方面的瓶颈。 什么是ANR，如何避免 ANR是指应用程序未响应，安卓系统对于一些事件需要在一定的时间范围内完成，如果超过预定时间仍未能得到有效响应或者响应时间过长，都会造成ANR。 出现的原因有三种： （1）KeyDispatchTimeout（5 seconds）主要类型按键或触摸事件在特定时间内无响应 （2）BroadcastTimeout（10 seconds）BoradcastReceiver在特定的时间内无法处理 （3）ServiceTimeout（20 seconds）小概率类型Service在特定的时间内无法处理完成 3：避免ANR最核心的一点就是在主线程减少耗时操作。通常需要从那个以下几个方案下手： （1）使用子线程处理耗时IO操作 （2）降低子线程优先级，使用Thread或者HandlerThread时，调用Process.setThreadPriority（Process.THREAD_PRIORITY_BACKGROUND）设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同 （3）使用Handler处理子线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程 （4）Activity的onCreate和onResume回调中尽量避免耗时的代码 （5）BroadcastReceiver中onReceiver代码也要尽量减少耗时操作，建议使用intentService处理。intentService是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"05_Linux/fork.html":{"url":"05_Linux/fork.html","title":"Fork","keywords":"","body":"fork() 是一个 Unix 系统调用，用于创建一个新的进程。它的原理涉及到操作系统的内存管理和进程控制机制： 复制父进程：当调用 fork() 时，操作系统会创建一个新的进程，称为子进程。子进程的内存空间会完全复制父进程的内存空间，包括代码段、数据段、堆和栈。这意味着子进程会得到一个父进程的副本，但是它们各自有独立的内存空间，互不干扰。 共享文件描述符：父进程和子进程之间共享打开的文件描述符。这意味着如果一个进程在 fork() 之前打开了文件，那么在 fork() 之后，子进程也会继承这些文件描述符，并且它们会指向相同的文件表项。但是，父子进程之间的文件描述符是独立的，关闭一个进程的文件描述符不会影响另一个进程。 返回值：在父进程中，fork() 返回子进程的进程 ID（PID），而在子进程中，fork() 返回 0。这样可以通过返回值来区分父进程和子进程。 进程状态：子进程是一个全新的进程，与父进程并行运行。子进程的状态会被设置为就绪状态，然后由调度器决定何时运行。 总的来说，fork() 的原理是通过复制父进程的内存空间来创建一个新的进程，使得父子进程可以并行运行，并且共享一些资源，例如文件描述符。这种机制为 Unix 系统提供了一种高效的多任务处理方式。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"05_Linux/Linux - Others -用户与用户组管理（命令&原理）.html":{"url":"05_Linux/Linux - Others -用户与用户组管理（命令&原理）.html","title":"Linux - others -用户与用户组管理（命令&原理）","keywords":"","body":"命令 用户管理 useradd 添加用户 选项 说明 -d 指定用户登入时的目录（主目录），如果此目录不存在，则同时使用-m选项，可以创建此目录 -c 指定账户的备注文字 -e 指定账号的有效期限 -f 缓冲天数．密码过期时在指定天数后关闭该账号 -g 指定用户所属组 -G 指定用户所属的附加用户组 -m 自动建立用户的登入目录 -r 创建系统账号 -s 指定用户的登陆shell -u 指定用户的用户ID。若添加-o选项、则ID可与其它用户重复 1-499为系统用户IP，用户IP应取500-60000之间的数值 可通过自看/etc/passwd文件，查看已存在的用户 创建账号的用户需有创建账号的权限 # 新建一个用户gem，该用户的登录Shell是/bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组 # 这里可能新建组group或adm useradd -s /bin/sh -g group -G adm,root gem 增加用户账号就是在/etc/passwd用户中为新用户增加一条记录，同时更新其它系统文件如/etc/shadow/、/etc/group等 Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理 passwd 设置用户的认证信息 包括用户密码，密码有效期等 用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令 选项 说明 -l 锁定密码，锁定后密码失效，无法登陆（新用户默认锁定） -d 删除密码．仅系统管理员可使用（指定空口令，不会锁定账号） -S 列出密码相关信息，仅系统管理员可使用 -f 强迫用户下次登录时修改口令 -u 口令解锁 root用户可随意更改自己和其它用户的密码，不需要知道原口令，即便出现警告，也可成功保存 普通用户设置新口令需要知道原口令 修改当前登录账户的密码时，可缺省用户名 用户密码保存在/etc/shadow文件中 userdel 删除指定账户和账户相关的文件和信息 选项 说明 -f 强制删除用户，即便该用户为当前用户 -r 删除用户的同时，删除与用户相关的所有文件 删除用户账号就是将/etc/passwd等系统文件中的该用户记录删除，必要时删除用户的主目录 # 此命令删除用户sam在系统文件中（主要是/etc/passwd、/etc/shadow、/etc/group等）的记录，同时删除用户的主目录 userdel -r sam usdermod 修改用户账号信息 选项 说明 -c 修改用户账号的备注信息 -d 修改用户的登入目录 -e 修改账号的有效期限 -f 修改缓冲天数，即修改密码过期后关闭账号的时间 -g 修改用户所属组 -l 修改用户账号名称 -L 锁定用户密码，使密码失效 -s 修改用户登陆后使用的shell -u 修改用户ID -U 解除密码锁定 举例： #此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer usermod -s /bin/ksh -d /home/z -g developer sam 用户组管理 若用户被创建时没有指定用户组，系统会为用户创建一个与用户名相同的组，并将与该账号同名的用户组同步到/etc/group文件中，这个组就是基本组，若在某个用户的目录中创建文件。文件的所属组，就是用户的基本组；另外可以为用户指定附加组，除基本组之外，用户所在的组都是附加组。为用户指定附加组，可以使用户拥有对应组的权限。 对用户组的添加、删除、修改，本质上就是对/etc/group文件的更新。 相关：Linux.md > 与用户账号有关的系统文件 groupadd 新增用户组 选项 说明 -g 指定新建用户组的组ID -r 创建系统用户组，组ID取值范围为1-499 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有的用户组的GID相同 添加一个新组，不指定组ID时，新组的组ID就是在当前已有的最大组标识号的基础上+1 groupdel 删除用户组 groupmod 修改用户组属性 选项 说明 -g 位用户组指定新的组标识号 -n 将用户组的名字改为新名字 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有的用户组的GID相同 newgrp 切換用户组 如果一个用户同时属于多个用户组，那么用户可以在用户组之前切换，以便拒用其他用户组的权限。 与用户账号有关的系统文件 所有关于用户与用户组管理的命令本质上都是对有关系统文件进行的修改。 有关的系统文件：/etc/passwd、/etc/shadow、/etc/group /etc/passwd 内容类似： 每一行记录对应着一个用户，每行记录又被冒号:分隔为7个字段，其格式和具体含义如下： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell \"用户名\"是代表用户账号的字符串。 通常长度不超过8个字符,并且由大小写字母和下或数字组成。登录名不能有冒号(:),因为冒号在这里是分隔符。 为了兼容起见。登录名中最好不要包含点字符(.),并且不使用连字符(-)和加号(+)打头。 “口令，一些系统中，存放着加密后的用户口令字。 虽个字段存放的只是用户口令的加密串，不是明文，但是由于\\etc\\passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux系统（如SVR4)都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符如\"x\"或者\"*\" “用户标识号\"是一个整数，系统内部用它来标识用户。 一般情况下它与用户名是一一对应的．如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等． 通常用户标识号的取值范围是0-65535。0是超级用户root的标识号，1-99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500 “组标识号'，字段记录的是用户所属的用户组。 它对应着/etc/group文件中的一条记录． “注释性描述”字段记录着用户的一些个人情况。 例如用户的真实姓名、电话、地址等。这个字段并没有什么实际的用途．在不同的Linux系统中。这个字段的格式并没有统一，在许多Linux系统中。这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出． “主目录”，也就是用户的起始工作目录。 它是用户在登录到系统之后所处的目录．在大多数系统中。各用户的主目录都被组织在同一个持定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell. Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的持点。常用的有sh(BourneShell),csh(CShell),ksh(KornShell)，tcsh(TENEX/TOPS20 type C Shell),bash(BourneAgainShell)等· 系统管理员可以根据系统情况和用户习惯为用户指定某个Shell.如果不指定Shell,那么系统使用sh为默认的登录Shell。即这个字段的值为/bin/sh。 用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解器）· 利用这一特点。我们可以限制用户只能运行指定的应用程序。在该应程序运行继束后，用户就自动退出了系统。有些Linux系统要求只有那些在系统中登记了的程序才能出现在这个字段中· /etc/shadow 内容类似： /etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据etc/passwd中的数据自动产生 它的文件格式与/etc/passwd类似，由若干个字段绢成，字段之间用:隔开。这些字段是： 登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志 “登录名是与/etc/passwd文件中的登录名相一致的用户账号 “囗令\"字段存放的是加密后的用户囗令字，长度为13个字符．如果为空，则对应户没有口令，登录时不需要囗令；如果含有不属于集合{./0-9A-Za-z}中的字符，则对应的用户不能登录 “最后一次修改时间“表示的是从某个时刻起，到用户最后一次修改口令时的天数．时间起点对不同的系统可能不一样．例如在SCO Linux中，这个时间起点是1970年1月1日． \"最小时间间隔\"指的是两次修改囗令之间所需的最小天数。 “最大时间间隔\"指的是囗令保持有效的最大天数。 \"警告时间\"字段表示地时从系统开始警告用户到用户密码正式失效之间的天数 \"不活动时间\"表示的时用户没有登录活动但账号仍能保持有效的最大天数 \"失效时间\"字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登陆了。 /etc/group 内容例子： 放置用户组的所有信息 将用户分组是Linux系统中对用户进行管理及控制访问仅限的一种手段。 每个用户都属于某个用户组；一个组中可以有多个用户。一个用户也可以属于不同的组。 当一个用户同时是多个组中的成员时。在/etc/passwd文件中记录的是用户所属的主组，也就是登录所属的默认组,而真他组称为附加组。 用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。 用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段．这些字段有： 组名：口令：组标识号：组内用户列表 \"组名\"是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。 \"口令\"字段存放的是用户组加密后的口令字。—般Linux系统的用户组都没有口令，即这个字段一般为空，或者是* \"组标识号\"与用户标识号类似，也是一个整数，被系统内部用来标识组 \"组内用户列表\"是属于这个组的所有用户的列表/b,不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是夫家族 伪用户 系统中有一类用户称为伪用户(pseudo users)。 这些用户在/etc/passwd文件中也占有一条记录。但是不能登录。因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求· 常见的伪用户如下所示： 伪用户 含义 bin 拥有可执行的用户命令文件 sys 拥有系统文件 adm 拥有帐户文件 uucp UUCP使用 lp lp或lpd子系统使用 nobody NPS使用 除了上面列出的伪用户外，还有许多标准的伪用户例如：audit,cron,mail,usenet等，它们也都各自为相关的进程和文件所需要。 由于/etc/passwd文件是所有用户都可读的，如果用户的密码太筒单或规律比较明显的i话，一台普通的计算机很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是etc/shadow文件。超级用户才拥有该文件读权限，这就保证了用户密码的安全性。 添加批量用户 添加和删除用户对每应Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个．上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加。必然要找一种简便的创建大量户的方法．Linnux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下 (1)先编辑一个文本用户文件。 每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号，一个范例文件user.txt内容如下： (2)以root身份执行命令/usr/sbin/newusers,从刚创建的用户文件user.txt中导入数据.创建用户： newusers 然后可以执行命令vipw或vi/etc/passwd检查/etc/passwd文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。 (3)执行命令/usr/sbin/pwunconv 将/etc/shadow产生的shadow密码解锁，然后回写道/etc/passwd中，并将/etc/shadow的shadow密码栏删掉，这是为了方便下一步的密码转换工作，即先取消shadow password功能 (4)编辑毎个用户的密码对照文件 范例文件passwd.txt内容如下： (5)以root身份执行命令/usr/sbin/chpasswd 创建用户密码，chpasswd会将经过/usr/bin/passwd命令编码过的密码写入/etc/passwd的密码栏 chpasswd (6)确定密码经编码写入/etc/passwd的密码栏后 执行命令/usr/sbin/pwconv将密码编码为shadow password，并将结果写入/etc/shadow pwconv 这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"05_Linux/Linux - Others.html":{"url":"05_Linux/Linux - Others.html","title":"Linux - others","keywords":"","body":"常用知识 Linux发行版本： Debian Ubuntu RedHat Fedora CentOS GUN/POSIX： GUN：GUN软件可以自由地“使用、复制、修改和发布” POSIX：可移植操作系统接口，提高UNIX环境下应用程序的可移植性；遵循POSIX标准的操作系统编写的程序，可在其它任何遵循POSIX标准的操作系统上运行 远程终端访问： 工具：XFTP FileZilla SecureCRT XShell SSH：用于网络传输的协议；SFTP：用于远程文件管理的协议。 系统启动过程 过程分为五个阶段： 内核的引导 xu当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动 操作系统接管硬件以后，首先读入/boot目录下的内核文件 运行init init进程是系统所有进程的起点，没有这个进程，系统中的任何进程都不会启动 init进程首先需要读取配置文件/etc/inittab 运行级别 许多程序需要开机启动，它们在Windows叫做“服务”，在Linux叫做守护进程。init进程的一大任务就是去运行这些开机启动的程序。但是不同的场合需要启动不同的程序，比如用作服务器时需要启动Apache，用作桌面就不需要。Linux允许为不同的场合，分配不同的开机启动程序，这就叫做“运行级别”，也就是说，启动时根据“运行级别”，确定要运行哪些程序。 Linux系统有七个运行级别： 0：系统停机状态，系统默认运行级别不能设置为0，否则不能正常启动 1：单用户工作状态，root权限，用于系统维护，禁止远程登录 2：多用户状态（没有NFS） 3：完全的多用户状态（有NFS），登录后进入控制台命令行模式 4：系统未使用，保留 5：X11控制台，登陆后进入图形GUI模式 6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 系统初始化 在init的配置文件中有这么一行：si::sysinit:/ect/rc.d/rc.sysinit它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：激活交换分区、检查磁盘，加载硬件模块以及其它一些需要优先执行的任务。 建立终端 rc执行完毕后，返回init，这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端： 从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。 同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。 用户登录系统 一般来说，用户的登陆方式有三种：命令行登录、ssh登录、图形界面登录 图形界面登录流程： 当用户看到mingetty的登录界面时，就可以输入用户名和密码来登录系统了。 Linux的账号验证程序时login，login会接受mingetty传来的用户名作为用户名参数。 然后login会对用户名进行分析，如果用户名不是root，且存在/etc/nologin文件，login将输出nologin文件的内容，然后退出。 这通常用来系统维护时防止非root用户登录，只有/etc/securetty中登记了的终端才允许root用户登录，如果不存在这个文件，则root用户可以在任何终端上登录 /etc/usertty文件用户对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。 图形界面与文字模式的切换方式： Linux预设提供了六个命令窗口终端机让我们来登录。 默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1, tty2，...tty6， 你可以按下Ctrl+Alt+F1~F6来切换它们。 如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl+Alt+Fl~F6来进入其中一个命令窗口界面。 当你进入命令窗口界面后再返回图形界面只要按下Ctrl+Alt+F7就回来了。 如果你用的vmware虚拟机，命令窗口切换的快捷键为Alt+Space+F1~F6如果你在图形界面下请按+Shift+Ctrl+Fl~F6切换至命令窗口。 Linux关机： 在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊特殊下，不得已才会关机。 正确的关机流程为：sync>shutdown>reboot>halt： sync将数据由内存同步到硬盘中。 shutdown关机指令： shutdown -h now 立马关机 shutdown -h 20:25 今天20:25关机 shutdown -h +10 10分钟后关机 shutdown -h 10 \"shown_msg\" 10分钟后关机，并且会显示信息到用户当前的屏幕中 shutdown -r now 系统立马重启 shutdown -r +10 系统十分钟后立马重启 reboot 重启，等同于 shutdown -r now halt 关闭系统，等同于 shutdown -h now 和 poweroff 不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中 用户态与内核态 用户态：完全在操作系统内核中进行，拥有对硬件的所有操作权限，任何异常都可能导致整台机器停机。 内核态：在应用程序中进行，没有对硬件的直接控制权限，也不能直接访问地址的内存，程序时通过调用系统接口来达到访问硬件和内存，在这种保护牧场下，即使程序发生崩溃也可以恢复。 用户态和内核态之间切换的开销： 保留用户态现场（上下文、寄存器、用户栈等） 复制用户态参数，用户栈切到内核栈，进入内核态 额外的检查（因为内核代码对用户不信任） 执行内核态代码 复制内核态代码执行结果，回到用户态 恢复用户态现场（上下文、寄存器、用户栈等） 从上图我们可以看出来通过系统调用将Linux整个体系分为用户态和内核态，为了使应用程序访问到内核的资源，如CPU、内存、I/O，内核必须提供一组通用的访问接口，这些接口就叫系统调用。 库函数就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现，它对系统调用进行封装，提供简单的基本接口给程序员。 Shell顾名思义，就是外壳的意思，就好像把内核包裹起来的外壳，它是一种特殊的应用程序，俗称命令行。Shell也是可编程的，它有标准的Shell 语法，符合其语法的文本叫Shell脚本，很多人都会用Shell脚本实现一些常用的功能，可以提高工作效率。 最后来说说，什么情况会导致用户态到内核态切换 系统调用：用户态进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如 fork（）就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现，如Linux 的 int 80h 中断，也可以称为软中断 异常：当 C P U 在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常 中断：当 C P U 在执行用户态的进程时，外围设备完成用户请求的操作后，会向 C P U 发出相应的中断信号，这时 C P U 会暂停执行下一条即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"05_Linux/Linux - 命令 - 其它.html":{"url":"05_Linux/Linux - 命令 - 其它.html","title":"Linux - 命令 - 其它","keywords":"","body":"命令格式 command -shortoption parameter command --longoption parameter 比如： $rm -r dir rm --recursive dir 注意：使用短选项时可以将多个选项合并 权限与用户/用户组管理 Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 权限管理 权限分类 权限 对应字符 文件 目录 读权限 r 可查看文件内容 可以列出目录中的内容 写权限 w 可修改文件内容 可以在目录中创建、删除文件 执行权限 x 可执行该文件 可以进入目录 第一个字符解析： 字符 含义 d 目录 - 文件 l 链接文档 b 装置文件里面的可供储存的接口设备（可随机存取装置） c 装置文件里面的串行端口设备，例如键盘、鼠标（一次性读取装置） 接下来的字符中，三个为一组，且均为rwx三个参数的组合，其中'r'代表可读；'w'代表可写；'x'代表可执行。三个权限的位置不会改变，如果没有权限，就会出现减号'-'而已。 权限所有者 含义 属主权限 该文件的所有者拥有该文件的权限 属组权限 该文件所有者的同组用户拥有该文件的权限 其他用户权限 其他用户.. 注意： '-rwxrwxrwx'为权限最开放的777 对root用户来说，一般情况下文件的权限对其不起作用 权限顺序：所属用户的权限、组群权限、其他用户的权限 chmod 更改文件的九个属性 两种设置方法：数字和符号 1.数字类型改变文件权限 各权限分数：r-4；w-2；x-1 举例：-rwxr-----分数为 owner=rwx=4+2+1=7 group=r--=4+0+0=4 others=---=0+0+0=0 为740 语法： chmod [-R] xyz chomd 740 dir 2.符号类型改变文件权限 chgrp 变更文件或目录的所有者 语法： chgrp [-R] 参数： -R 递归更改文件属组 chown 更改文件属主，也可以同时更改文件属组 语法： chown [-R] chown [-R] : 用户与用户组管理 见Linux-用户与用户组管理 用户切换 su 将用户切换为root su -usemame 需要注意。以上的“-”为一个选顶，类似于”-l“，选顶与用户名之间应有一个空格 使用su命令切換用户时。需要蝓入的是目标用户的密码 选项与用户名缺省的情况下，只切换用户，但不改变用户环境 由root用户切换到具它用户，可以不输入密码。 在命令行输入\"exit\"或“su -user\",可退出目标用户。 sudo sudo [选项] -u 用户[命令] 说明： sudo命令可以视为受限的su，它可以使部分\"用户使其它用户的身份执行命令。 在使用sudo命令之前，需要通过修改/etc/sudoers文件，为当前用户配置要使用的权限。 /etc/sudoers文件有一定的语法规范，为避免因修改后出现语法谄误，应使用visudo命令打开文件进行修改， 如下所示为/etc/sudoers文件中的一条配置信息，该信息设置了root用户可能任何情境下执行任何命令。 root ALL=(ALL) ALL 网络管理与通信 ifconfig 查看网卡 ifconfig -a eth0用于访问外部网络，默认情况下关闭 lo网卡用实现本机内部访问，IP地址为127.0.0.1（本机回送地址） netstat ping write 使当前用户向另一个用户发送信息 wall 使当前用户向所有用户发送信息 压缩解压 gzip/gunzip .gz 压缩后不保存源文件，若同时列出多个文件，则每个文件会被单独压缩 zip/unzip .zip 压缩后保存源文件 bzip2/bunzip2 .bz2 使用选项 -k时保留源文件 tar 打包多个文件或目录，通常与压缩命令一起使用 -c 产生.tar打包文件 -v 打包时显示详细信息 -f 指定压缩后的文件名 -z 打包，同时通过gzip指令压缩备份文件，压缩后格式为.tar.gz -x 从打包文件中还原文件 帮助命令 man 查看帮助手册 -a 在所有的man帮助手册中搜索 -p 指定内容时，使用分页程序 -M 指定man手册搜索的路径 info 也是查看帮助手册，编写方式不一样 whatis 查询命令的功能 whoami 打印当前有效的用户名称 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"05_Linux/Linux - 工具 - GCC编辑器.html":{"url":"05_Linux/Linux - 工具 - GCC编辑器.html","title":"Linux - 工具 - gcc编辑器","keywords":"","body":"GCC是由GUN开发的编程语言编译器，现可编译C、Java、OC等 编译过程：预处理-e；编译-s；汇编-o；链接 预处理 -e 删除代码中的#define，展开所有宏定义 处理条件编译指令，如#if、#ifdef、#undef等 将由#include包含的文件插入到预编译指令对应的位置，若文件中包含其它文件，同样进行替换 删除代码中的注释 添加行号和文件标识 保留#pragma编译器指令 编译 -s 在编译阶段，GCC会对经过预处理的文件进行语法、词义和语义分析，确定代码实际要做的工作，若检查无误，则生成相应的汇编代码文件 汇编 -o 汇编过程将编译后生成的汇编代码转换为机器可以执行的命令，即二进制指令，每一个汇编语句几乎都会对应一条机器指令 链接 链接过程是组装各个目标文件的过程，在这个过程中会解决符号依赖和库依赖关系，最终生成可执行文件 文件编译 单文件编译 $ gcc hello.c 多文件编译 $ gcc _main.c _add.c -o _main No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"05_Linux/Linux - 工具 - GDB调试工具.html":{"url":"05_Linux/Linux - 工具 - GDB调试工具.html","title":"Linux - 工具 - gdb调试工具","keywords":"","body":"GDB可以逐条执行程序、操控程序的运行，并且可以随时查看程序中所有的内部状态，如各变量的值、传给函数的参数、当前执行的语句位置等，藉此判断代码中的逻辑错误。 使用： 在代码中加入调试信息，并调试程序 $ gcc gdbtest.c -o app -g (gdb) gdb app 列出程序代码，并设置断点 list 行号 b 行号 b 22 if i=5 #在22行设定带条件的断点 info b #查看断点 disable Num #取消断点 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"05_Linux/Linux - 文件系统（原理&命令&编程）.html":{"url":"05_Linux/Linux - 文件系统（原理&命令&编程）.html","title":"Linux - 文件系统（原理&命令&编程）","keywords":"","body":"磁盘 磁盘上的盘片被细分为多个大小相同的扇区，扇区是磁盘空间的基本单位，一般来说，一个扇区的大小为512字节。 磁盘中的第一个扇区非常重要，其中存储了与磁盘正常使用相关的重要信息：主引导记录、磁盘分区表、魔数。 主引导记录（Master Boot Record）占用446字节，其中包含一段被称为引导加载流程（Boot Loader）的程序，计算机启动后，会到磁盘0扇面的0扇区去读取MBR中的内容，只有MBR中的程序正确无误，计算机才能正常开机。 磁盘分区表（Partition Table）占用64个字节，其中记录整块磁盘的分区状态，每个分区的信息需要16个字节，因此磁盘分区表若只记录分区信息，便最多只能存储4个分区的分区信息。 魔数（Magic Number）占用2个字节，用来标识MBR是否有效。 Linux系统中遵循“一切皆文件”的思想，Linux下的设备也会被视为文件，硬盘作为设备的一种，其对应的文件被存储于系统的/dev目录下。若磁盘为SATA类型，则磁盘路径名为/dev/sda，如图所示的四个分区（主分区）在/dev目录下对应的文件名如下所示： P1: /dev/sda1 P2: /dev/sda2 P3: /dev/sda3 P4: /dev/sda4 总共有4个分区显然是不够的，所以设计了扩展分区的概念，扩展分区和主分区一样，也是存放在64B的分区表中，也就是它会占一个主分区号，它的作用是用来扩展成多个其他分区的，扩展分区本身不可以直接使用，可以在扩展分区上建立逻辑分区，这时逻辑分区是可以设置很多个的，所以说其实扩展分区是一种用来解决分区表只能有4个分区限制的问题。 主分区数量至少1个，最多4个(如果存在扩展分区，则最多3个）。主分区可以直接使用，主分区本身不能继续分区，一个主分区就是一个逻辑磁盘。 扩展分区0个或1个，会占用一个主分区号，不能直接使用，必须在其上建立逻辑分区后才能用。 其实就是把1个主分区拿过来进行分区扩展了。 逻辑分区可以若干个，通过扩展分区建立，可以直接使用，扩展分区的容量是所有逻辑分区容量之和（如果扩展分区被完全使用的话）。 P1为主分区，P2为扩展分区，占用了一个主分区号。 L1-L4为逻辑分区。 系统目录结构 以下是对这些目录的解释： 目录 使用 / 根目录，只包含目录，不包含文件 /bin 存放可执行文件，bin是Binary的缩写，常用命令都以二进制文件的形式存放在该目录中 /boot 这里存放的是启动Linux时使用的一些核心文件，包适一些连接文件以及镜像文件、内核文件、引导程序文件等 /dev dev是device的缩写，该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。包括块设备文件（如磁盘对应文件）、字符设备文件（如键盘对应文件）等。 /etc 这个目录用来存放所有的系统管理所需要的配置文件和子目录 /home 用户的主目录，在Linux中。每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的， /lib 这个目录里存放着系统最基本的动态连接共享库。其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用这些共享库。该目录中的文件一般以.a、.dll、.so结尾（后缀不代表文件类型）。也会存放与内核模块相关的文件。 /lost+found 这个目录一般情况下是空的。当系统非法关机后。这里就存放了一些文件· /media linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux会把识别的设备挂载到这个目录下 /mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱内容了。 /opt 存放附加的应用程序软件包 /proc 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all /root 该目录为系统管理员，也称作超级权限者的用户主目录 /sbin s就是SuperUser的意思，这里存放的是系统管理员使用的系统管理程序 /selinux 这个目录是Redhat/CentOS所特有的目录，SeLinux是一个安全机制，类似于Windows的防火墙，但是这套机制比较复杂，目录就是存放SeLinux相关的文件的。 /srv 该目录存放一些服务启动之后需要提取的数据 /sys 这是Linux2.6内核的一个很大变化，该目录下安装了2.6内核中一个新出现的文件系统sysfs。sysfs文件系统集成了下面三种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统、针对伪终端的devpts文件系统。该文件系统是内核设备的一个直观反映当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建 /swap 存放虚拟内存交换所用文件 /tmp 这个目录是用来存放一些临时文件的，重启系统后该目录的文件不会被保存，每个用户都能创建该目录，但不能删除其它用户的/tmp目录 /usr 这是一个非常重要的目录，用户的很多应用程序和文件从放在这个目录下，类似于windows下的program files目录，占用空间最大的目录 /usr/bin 系统用户使用的应用程序 /usr/sbin 超级用户使用的比较高级的管理程序和系统守护程序 /usr/lib 库文件 /usr/src 内核源代码默认的放置目录 /usr/share/doc 文档 /var 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下，包括各种日志文件。 /run 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删除或清除。如果你的系统上有/var/run目录，应该让它指向run。 比较重要的目录，注意不要误删或随意修改内部文件： /etc 配置文件存放目录，修改可能导致系统不能启动 /bin、/sbin、/usr/bin、/usr/sbin 系统预设执行文件的存放目录 /var 各个程序的日志文件，mail的预设等 文件类型 Linux系统中的文件类型不以扩展名区分，拓展名只表示与程序的关联。 ls -l 命令打印的文件属性信息中的第一个字符，便代表文件的类型： d：directory，目录文件 l：link，符号链接文件 s：socket，嵌套字文件 b：block，块设备文件 c：character，字符设备文件 p：pile，管道文件 -：不属于以上任一种文件的普通文件 设备文件 Linux系统中将外部设备视为一个文件来管理，设备文件被保存在系统的/dev目录下。 将设备抽象为文件的好处是：应用程序可以使用与操作普通文件一样的方式，对设备文件执行打开、关闭、读写等操作。 比如查看属性信息时，无论是普通文件还是设备，都可以使用”ls -l\"命令。 使用\"ls -l /dev\"命令查看设备文件的详细信息 硬链接与软链接（符号链接） 链接文件分为两种：硬链接文件和软链接文件，这两种文件都能实现windows中快捷方式的功能，但它们的实现方式不同。 硬链接 硬链接是指通过索引节点来进行链接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都会给它分配一个编号，这个编号被称为索引节点编号号(Inode)，它是文件或者目录在一个文件系统中的唯一标识，文件的实际数据放置在数据区域（data block），它存储着文件重要参数信息，也就是元数据 （metadata），比如创建时间、修改时间、文件大小、属主、归属的用户组、读写权限、数据所在block号等，如下图所示。 在Linux系统中，多个文件名指向同一索引节点(Inode)是正常且允许的。一般这种链接就称为硬链接。硬链接的作用之一是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要的文件，以防止“误删”源数据(很多硬件，如netapp存储中的快照功能就应用了这个原理，增加一个快照就多了一个硬链接》。不过硬链接只能在同一文件系统中的文件之间进行链接，不能对目录进行创建。之所以文件建立了硬链接就会防止数据误删，是因为文件系统的原理是，只要文件的索引节点还有一个以上的链接（仅删除了该文件的指向），只删除其中一个链接并不影响索引节点本身和其他的链接（数据的实体并未删除），只有当最后一个链接被删除后，此时如果有新数据要存储到磁盘上，被删除的文件的数据块及目录的链接才会被释放，空间被新数据暂用覆盖。 软链接 软链接（也叫符号链接），类似于windows系统中的快捷方式，与硬链接不同，软链接就是一个普通文件，只是数据块内容有点特殊，文件用户数据块中存放的内容是另一文件的路径名的指向，通过这个方式可以快速定位到软连接所指向的源文件实体。软链接可对文件或目录创建。 软链接作用： 便于文件的管理，比如把一个复杂路径下的文件链接到一个简单路径下方便用户访问。 节省空间解决空间不足问题，某个文件文件系统空间已经用完了，但是现在必须在该文件系统下创建一个新的目录并存储大量的文件，那么可以把另一个剩余空间较多的文件系统中的目录链接到该文件系统中。 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接就变成了死链接。 区别 软链接： 软链接是存放另一个文件的路径的形式存在。 软链接可以 跨文件系统 ，硬链接不可以。 软链接可以对一个不存在的文件名进行链接，硬链接必须要有源文件。 软链接可以对目录进行链接。 硬链接： 硬链接，以文件副本的形式存在。但不占用实际空间。 不允许给目录创建硬链接。 硬链接只有在同一个文件系统中才能创建。 删除其中一个硬链接文件并不影响其他有相同 inode 号的文件。 不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。 文件描述符（File Descriptor) 文件描述符是一个非负整数，实质上是一个索引值，存储于由内核维护的该进程打开的文件描述符表中。 系统为每个进程维护了一个文件描述符表（open file description table)，用于存储进程打开文件的文件描述符，进程打开的普通文件其文件描述符从3开始。 存在于进程中的文件描述符是进程级别的，除此之外，内核也对所有打开的文件维护了一个文件描述符表，这是一个系统级的文件描述符表，该表又称打开文件表（open file table），表中的记录被称为打开文件句柄（open file handle） 一个打开文件句柄中与一个已打开的文件相关的信息如下： 当前文件的偏移量 打开文件时所用的状态标识 文件访问模式 与信号驱动相关的设置 对该文件inode对象的引用 文件类型和访问权限 指向该文件所持有的锁列表的指针 文件的各种属性信息 文件系统 inode与dentry Linux系统中将文件的属性与数据分开存储，文件中的数据存放的区域称为数据区，文件属性又被称为元数据，存放文件属性的区域称为元数据区，基于这种文件存储方式，Linux文件系统中定义了两个与文件相关的，至关重要的概念：索引节点和目录项： 索引结点（inode） 实质是一个结构体，主要功能是保存文件的属性信息（如所有者、所属区、权限、文件大小、时间戳等）。 Linux系统中每个文件都会被分配一个inode，当由文件创建时，系统会在inode表中获取一个空闲的inode分配给这个文件。inode存储在inode表中，inode表存储inode和incode的编号（inumber），inode表在文件系统创建之时便被创建，因此文件系统中可存储的文件数量也在文件系统创建时已确定。 目录项（dentry） Linux文件系统中的索引结点保存着文件的诸多属性信息，但并未保存文件的文件名。实际上，Linux系统中文件的文件名并不保存在文件中，而是保存在存放该文件的目录中。 Linux系统中定义了一个被称为目录项的结构体，该结构体主要存储文件的文件名与inode编号，系统通过读取目录项中的文件名和文件的inumber，来判断文件是否存在于这个目录中。dentry允许同一个inode对应不同的文件名，但不允许相同的文件名对应不同的inode。 ext2与ext3文件系统 ext2 磁盘分区的第一个部分为启动块（Boot Block），启动块占用一个块空间，用来存储磁盘的分区信息和启动信息。图中启动块后是多个块组，每个块组包含六部分：超级块（SuperBlock）、块组描述符（GDT）、块位图（Block Bitmap）、位图（Inode Bitmap）、位表（Inode Table）、数据块（Data Blocks） ext2文件系统的结构有以下几个优点： 可有效放置磁盘碎片的产生，减少磁盘传送次数，降低系统消耗 管理员可以根据给定分区的大小，预计分区中存放的文件数，从而确定分区中inode的数量，保证磁盘空间利用率 降低对存放一个单独块组中的文件并行访问时磁盘的平均寻道时间 支持快速符号链接 ext3 ext3是一个完全兼容ext2文件系统的日志文件系统，它在ext2的基础上，添加了一个被称为日志的块，专门记录写入或修订文件时的步骤 日志文件系统可以按照不同的方式进行工作。ext3中可通过对/etc/fstab文件中的data属性进行设置来修改文件系统的工作模式。日志文件系统的工作模式分为三种，其设置方式如下： data=journal data=ordered data=writeback 数据块寻址 Linux文件系统中文件的属性信息和数据分开存放，系统通过文件inode中的索引项Block来查找文件数据。Block索引项是一个数组，包括15个索引项，其中： Block[0]-Block[11] 直接索引项 Block[12] 间接索引项 Block[13] 二级间接索引项 Block[14] 三级间接索引项 虚拟文件系统 虚拟文件系统又称虚拟文件切换系统（Virtual Filesystem Switch），是操作系统中文件系统的虚拟层，其下才是具体的文件系统。虚拟文件系统的主要功能，是实现多种文件系统操作接口的统一，既能让上层的调用者使用同一套接口与底层的各种文件系统交互，又能对文件系统提供一个标准接口，使Linux系统能同时支持多种文件系统。虚拟文件系统与上层应用以及底层的各种文件系统之间的关系如上图。 挂载 挂载是指将一个目录作为入口，将磁盘分区中的数据放置在以该目录为根节点的目录关系树当中，这相当于为文件系统与磁盘进行了链接，制定了某个分区中文件系统访问的位置。 Linux系统中根目录是整个磁盘访问的基点，因此根目录必须要挂载到某个分区。 命令 磁盘操作 fdisk 用于磁盘分区 作用：查看当前系统中的磁盘，磁盘中的分区情况，也可用于磁盘分区 语法： fdisk [-l] 选项： -l 可以列出指定设备的分区表状态，若仅有fdisk -l时，则系统将会把整个系统内能够搜寻到的装置的分区均列出来。 例：列出所有分区信息 例：找出系统中的根目录所在磁盘，并查阅该硬盘内的相关信息 输入m后，就会看到底下这些命令介绍 离开fdisk时按下q，那么所有的动作都不会生效，相反的按下w就是动作生效的意思。 使用p可以列出目前这颗磁盘的分割表信息，这个信息的上半部在显示整体磁盘的状态。 fsck 检查和维护不一致的文件系统 若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。 语法： fsck [-t 文件系统] [-ACay] 装置名称 选项： 选项 说明 -t 给定档案系统的型式，若在/etc/fstab中已有定义或kernel本身已支援的则不需加上此参数 -s 依序一个一个地执行fsck指令来检查 -A 对/etc/fstab中所有列出来的分区(partition)做检查 -C 显示完整的检查进度 -d 打印出 e2fsck 的 debug 结果 -p 同时有 -A 条件时，同时有多个fsck的检查一起执行 -R 同时有 -A 条件时，省略/不检查 -V 详细显示模式 -a 如果检查有错则自动修复 -r 如果检查有错则由使用者回答是否修复 -y 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复 例：查看系统有多少文件系统支持的 fsck命令： 例：强制检测 /dev/hdc6 分区： 如果没有加上 -f 的选项，则由于这个文件系统不曾出现问题，检查的经过非常快速；若加上-f强制检查，才会一项一项的显示过程。 du 检查磁盘空间使用量 语法： df [-ahskm] 选项： 选项 说明 -a 列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已 -h 以人们较易阅读的容量格式显示 -s 列出总量而已，而不列出每个各别的目录占用容量 -S 不包括子目录下的总计，与-s有点差别 -b/-k/-m/-g 以b/kb/mb/Gb为单位，显示目标占用磁盘块的总和 -x 以最初处理时的文件系统为准，跳过不同文件系统上的文件 -D 显示指定符号链接的源文件大小 例：列出目前目录下的所有目录容量 例：将文件的容量也列出来 例：检查目录底下每个目录所占用的容量 通配符 * 代表每个目录 与df不一样的是，du这个命令会直接到文件系统去搜寻所有的文件数据 df 列出文件系统的整理磁盘使用量 语法： df [-ahikHTm] 选项： 选项 含义 -a 列出所有的文件系统，包含系统特有的/proc等文件系统 -k 以KBytes的容量显示各文件系统 -m 以MBytes的容量显示各文件系统 -h 以人们较易阅读的GBytes、MBytes、KBytes等格式自行显示 -H 以M=1000K取代M=1024K的进位方式 -T 显示文件系统类型，连同该partition的filesystem名称（例如ext3）也列出 -i 不用硬盘容量，而以inode的数量来显示 参数可以是文件，但打印的信息会是该文件所在文件系统磁盘的使用情况。 例：将系统内所有的文件系统列出来（默认1Kbytes） 例：将容量结果以易读的容量格式显示出来 例：将系统内的所有特殊文件格式及名称都列出来 mkfs 磁盘格式化 语法： mkfs [-t 文件系统格式] 选项：-t：可以接文件系统格式，例如ext3、ext2、vfat等（系统有支持才会生效） 例：查看mkfs支持的文件格式 按下两个tab 例：将分区/dev/hdc6 格式化为 ext3 文件系统 mkf2es 可为磁盘分区创建ext2、ext3文件系统 Mkfs命令也可以为磁盘分区创建系统，其常用选项为-t，参数一般为文件系统类型 mount 磁盘挂载 将某个分区挂载到目录 语法： mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 -t 指定待挂载设备的文件系统类型，常见的类型如下： 光盘/光盘镜像：iso9660 DOS fat16文件系统：msdos Windows 9x fat32文件系统：ntfs Mount Windows 文件网络共享：smbfs UNIX(LINUX)文件网络共享：nfs -o 描述设备的挂载方式，常用的挂载方式如下： loop：将一个文件视为硬盘分区挂载的系统 ro：read-only，采用只读的方式挂载设备 rw：采用读写的方式挂载设备 iocharset：指定访问文件系统所用的字符集 remount：重新挂载 例：用默认的方式，将刚刚创建的 /dev/hdc6 挂载到 /mnt/hdc6 上面 unmount 磁盘卸除 当需要挂载的分区知识一个移动存储设备（如移动硬盘）时，要进行的工作是在该设备与主机之间进行文件传输，那么在文件传输完成后，需要卸下该分区。 语法： umount [-fn] 选项： -f：强制卸除！可用在类似网络文件系统（NFS）无法读取到的情况下； -n：不升级 /etc/mtab 情况下卸除 unmount指定设备名或挂载点来接卸载分区，如挂载点目录为/mnt，使用的命令如下： unmount /mnt 以设备为参数时，可能会因为设备正忙或无法响应导致挂载失败，也可以为命令添加选项-l，该选项代表“lazy mount\"，使用该选项时，系统会立刻从文件层次结构中卸载指定的设备，但在空闲时才清除文件系统中的所有引用。 链接文件 ln 第一个参数为被链接的文件，即源文件路径名，第二个参数为链接文件的路径名，指定链接文件的存储位置。 当ln命令的选项缺省时，系统会创建一个硬链接文件。 若搭配-s选项，则会创建一个软链接文件。 -i 交互模式，文件存在则提示用户是否覆盖。 -s 软链接(符号链接)。 -d 允许超级用户制作目录的硬链接。 -b 删除，覆盖以前建立的链接 注意： 创建硬链接文件时。源路径中的对象不能是一个目录， 路径操作 Linux的目录结构为树状结构，最顶级的目录为根目录/。 其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。 绝对路径：由根目录/写起，例如 /usr/share/doc 相对路径：不是由/写起，例如由/usr/share/doc到/usr/share/man底下时，可以写成../man cd 切换路径 切换到相对路径 cd ./xxx 切换到绝对路径 cd /xxx 切换到当前用户的家目录 cd ~ 去到上一级目录 cd .. mv 重命名文件和文件夹 mv a b mv /a /b/c pwd 查看当前路径 -P 显示确实的路径，而非使用连结路径 mkdir 创建路径 -m 配置文件的权限，不需要管默认权限 -p 帮助直接将所需要的目录（包含上一级目录）递归创建 rmdir 删除目录 只能删除空的目录，rm可以删除非空目录 -p 连同上一级（空的）目录也一起删除 文件操作 ls 查看文件 -a 查看包括隐藏文件在内的所有文件 -l 以详细信息列出文件，包括文件的属性与权限等，可指定文件名 -d 仅列出目录本身，而不是列出目录内的文件数据 cat 由第一行开始显示文件内容 语法： cat [-AbEnTv] 选项与参数： -A 相当于-vET的整合选项，可列出一些特殊字符而不是空白而已 -b 列出行号，仅针对非空白行做行号显示，空白行不标行号 -E 将结尾的断行字节$显示出来 -n 列印出行号，连同空白行也会有行号，与-b选项不同 -T 将[tab]按键以^l显示出来 -v 列出一些看不出来的特殊字符 tac 从最后一行开始显示 nl 显示的时候顺便输出行号 语法： nl [-bnw] 文件 选项与参数： -b 指定行号的指定方式，主要有两种： -b a 表示不论是否为空行，也同样列出行号 -b t 如果有空行，空的那一行不要列出行号（默认） -n 列出行号表示的方法，主要有三种 -n ln 行号在荧幕的最左方显示 -n rn 行号在自己栏位的最右方显示，且不加0 -n rz 行号在自己栏位的最右方显示，且加0 -w 行号栏位的占用位数 more 分页显示文件内容 运行时可以输入的命令有： f或Space 显示下一页 Enter 显示下一行 /字串 表示在这个显示的内容当中，向下搜寻’字串‘这个关键字 :f 立刻显示出档名以及目前显示的行数 q/Q 退出 b或[ctrl]-b 代表往回翻页，此动作只对文件有用，对管线无用 less 与more相似，可以往前翻页 运行时可以输入的命令有： Space 显示下一页 [pagedown] 向下翻动一页 [pageup] 向上翻动一页 /字串 向下搜寻’字串‘这个关键字 ?字串 向上搜寻’字串‘这个关键字 n 重复前一个搜寻 N 反向的重复前一个搜寻 q/Q 退出 head 查看文件的前n行 语法： head [-n number] 文件 选项参数 -n 后面接数字，表示几行的意思 tail 查看文件的后n行 语法： head [-n number] 文件 选项参数 -n 后面接数字，表示几行的意思 -f 表示池逊检测后面所接的档名，按下Ctrl+C才会结束对tail的检测 touch 创建新文件 文件路径操作 cp 复制文件/目录 语法： cp [-adfilprsu] cp [options] source1 source2 source3 ... directory 选项与参数： -a 相当于-pdr -d 若来源档为连结档的属性，则复制连结档属性而非文件本身 -f 强制，若目标文件已经存在且无法开始，则移除后再尝试一次 -i 若目标档已经存在时，在覆盖时会先询问动作的进行 -l 进行硬式连结的连结档创建，而非复制文件本身 -p 连同文件的属性一起复制过去，而非使用默认属性（备份常用） -r 递归复制目录下的文件和子目录 -s 复制成为符号连结档，亦即”捷径“文件 -u 若destination比source旧才升级destintaion mv 移动文件或目录 语法： cp [-adfilprsu] cp [options] source1 source2 source3 ... directory 选项与参数： -f 忽略不存在的文件，不会出现警告信息 -r 递归删除目录中所有子文件和子目录，很危险 -i 在删除文件或目录时对要删除的内容逐一进行确认 rm 删除目录中的文件或目录 -f 忽略不存在的文件，不会出现警告信息 -r 递归删除目录中所有子文件和子目录，很危险 -i 在删除文件或目录时对要删除的内容逐一进行确认 文件搜索 which 查看命令所在路径 find 接触搜索关键字查找文件或目录 find 搜索路径 [选项] 搜索关键字 -name 根据文件名查找 -size 根据文件大小查找 -user 根据文件所有者查找 locate 借助搜索关键字查找文件或目录 locate [选项] 搜索关键字 locate速度远胜find find搜索整个目录，locate搜索数据库 /var/lib/locatedb 即使文件存在，数据库中没有记录，locate便搜索不到 grep 在文件中搜索与字符串匹配的行并输出 编程 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"05_Linux/Linux - 服务器（原理&编程）.html":{"url":"05_Linux/Linux - 服务器（原理&编程）.html","title":"Linux - 服务器（原理&编程）","keywords":"","body":"Socket 原理 计算机网络架构 socket编程原理： 当使用socket进行通讯时，进程会先生成一个socket文件，之后再通过socket文件进行数据传递 编程 服务器专用接口 bind() 使服务器端的一个socket文件与网络中的一个进程进行绑定，因为文件描述符可标识socket文件，“主机名+端口号“可标识网络中的唯一进程，因此bind()函数实际上是将报务器端的socket文件与网络中的进程地址进程绑定。 listen() listen()函数仍用于服务器端，从字面上看，其功能为使已绑定的socket监听对应客户端进程状态，但实际上，该函数用于设置服务器同时可建立的连接的数量。 accept() accept()函数在listen()函数之后使用，其功能为阻塞等待客户端的连接请求。 当传输层使用TCP协议时，服务器与客户在创建连接前，会先经过“三次握手”机制测试连接，“三次握手”完成后，服务器调用accept()函数处理连接请求，此时若还没有客户端的请求到达。便阻塞等待调用accept()函数的进程，直到接 收到客户端发来的请求，且服务器中已创建的连接数末达到backlog，accept()函数才会返回，并传出客户端的地址。 recv() 该函数用于从已连接的套接字中接收信息 客户端专用接口 connect() 向服务器发起连接请求 send() 向处于连接状态的套接字中发送数据 服务器和客户端共用 socket() socket()函数用于创建套接字，也可以说socket()函数用于打开网络通讯端口。该函数类似于文件操作中的open()函数，若调用成功，也返回一个文件描述符，之后应用裎序可以采用socket通信中的读写函数在网络中收发数据；若调 用失败会返回-1，并设置errno。 close() 用于释放系统分配给套接字的资源 socket网络编程实例 socket本地通信： socket原本是为网络通讯设计的，但后来在socket框架的基础上发展出了一种IPC（进程通信）机制，即UNIX Domain Socket,专门用来实现使用socket实现的本地进程通信。 本地通信的流程与使用的接囗与基于TCP协议的网络通信模型相同，其大致流程如下： 调用socket函数通信双方进程创建各自的socket文件； 定义并初始化服务器端进程的地址，并使用bind()函数将其与服务器端进程绑定； 调用listen()函数监听客户端进程请求， 客户端调用connect()函数，根据已明确的客户端进程地址，向服务器发送请求； 服务器端调用accept()函数，处理客户端进程的请求，若客户端与服务器端进程成功建立连接，则双方进程可开始通信。 通信双方以数据流的形式通过已创建的连接互相发送和接收数据，进行通信； 待通信结束后。通信双方各自调用close()函数关闭连接 与socket网络通信不同的是，在本地通信中用到的套接字的结构体类型为socket_sockaddr_un 高并发服务器 多进程并发服务器 在多进程并发服务器中，若有用户请求到达，服务器将会调用fork()函数，创建一个子讲程，之后父进程将继续调用accept(),而子进程则去处理用户请求。 说明： 多进程并发服务器效率高目更加稳定。服务器中的进程不会受其它讲程状态的影响： 多进程并发服务器中进程数量受可打开文件描述符的限制： 多进程并发服务器中进程数量受内存容量限制。 多线程并发服务器 考虑到每个进程可打开的文件描述符数量有眼，且进程占用资源较多，系统中进程的数量又受到内存大小的限制，为在保证服务器效率的前提下，降低服务器的消耗，可利用多线程机制搭建并发服务器。 与多进程服务器相比： 线程占用的空间资源大大减少，因此内存堆服务器的限制也被降低； 多线程并发服务器稳定性较差· 因此在搭建服务器时。应从需求出发，选择更为合适的服务器。 线程池 当服务器程序启动后，预先在其中创建定数量的线程，并将这些线程依次加入队列中。 在没有客户端的请求抵达时，线程队列中的线程都处于阻塞状态，此时这些线程只占用一些内存，但不占cpu。 若随后有用户请求到达，由线程池从线程队列中选出一个空闲线程，并将用户请求传给选出的线程，由该线程完成用户请求。 用户请求处理完毕，该线程并不退出，而是再次被加入线程队列，等待下一次任务。 此外，若线程队列中处于阻塞状态的线程较多，为节约资源，线程池会自动销毁一部分线程。 若线程队列中所有线程都有任务执行，线程池会自动创建一定数量的新线程，以提高服务器效率。 I/O多路转接服务器 为进一步提升服务器效率，人们提出了一种被称为I/O多路转接的模型。其中、\"多路\"指代连接到服务器的多个客户端程序。而\"转接\"则是指在服务器主线与各分支之间设置一个\"岗位\"，由该岗位实现监控多路连接中数据状态的功能，若某路连接中数据就绪，就通知服务器，使主程序对该路请求作出处理。 与多进程和多线程并发服务器相比，I/O多路转接服务器实现了I/O多路复用，系统不必创建多进程或多线捏，也不必维护多个进程或线程，因此大大降低了系统开开销。 Linux系统中提供了select()、poll()和epoll()函数来实现I/O多路转接，下面将对这几种机制进行详细讲解与演示。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"05_Linux/Linux - 管道操作.html":{"url":"05_Linux/Linux - 管道操作.html","title":"Linux - 管道操作","keywords":"","body":"Linux 下将不同的命令 | 一起输出的效果 在 Linux 命令行中，使用管道符号 | 将多个命令连接起来，可以将前一个命令的输出作为后一个命令的输入，实现多个命令的串联执行。这种方式被称为管道操作，是 Linux 命令行强大的一个重要特性。 管道操作的作用 数据传递: 将一个命令的输出作为另一个命令的输入，实现数据流的传递。 数据过滤: 通过管道将数据传递给不同的命令进行过滤、筛选、排序等操作。 数据转换: 将一种数据格式转换为另一种数据格式。 组合命令: 将多个简单的命令组合成一个复杂的命令，实现更强大的功能。 示例 Bash # 例1：统计文本文件中的行数 cat file.txt | wc -l # 解释： # cat file.txt：读取文件 file.txt 的内容 # |：将 cat 命令的输出作为 wc -l 命令的输入 # wc -l：统计输入的行的数量 # 例2：查找包含 \"error\" 字符串的行并显示行号 grep \"error\" file.txt | cat -n # 解释： # grep \"error\" file.txt：查找文件中包含 \"error\" 的行 # |：将 grep 命令的输出作为 cat -n 命令的输入 # cat -n：显示行号 # 例3：将大写字母转换为小写字母并排序 cat file.txt | tr 'A-Z' 'a-z' | sort # 解释： # tr 'A-Z' 'a-z'：将大写字母转换为小写字母 # sort：对输入的数据进行排序 Use code with caution. 常用结合的命令 grep: 查找文本 sed: 流编辑器 awk: 文本处理 sort: 排序 uniq: 去重 cut: 分割 paste: 合并 xargs: 构造命令行参数 注意事项 命令执行顺序: 管道中的命令从左向右依次执行。 缓冲区: 管道之间存在缓冲区，可以容纳一定量的数据。 错误处理: 如果某个命令执行失败，整个管道通常会中断。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"05_Linux/Linux - 进程管理（原理&命令&编程）.html":{"url":"05_Linux/Linux - 进程管理（原理&命令&编程）.html","title":"Linux - 进程管理（原理&命令&编程）","keywords":"","body":"进程通信 IPC Linux系统中进程通信的机制继承自Unix，后经贝尔实验室与BSD对进程间通讯手段的改进与扩充，以及POSIX标准对Unix标准的统一，发展出如今Linux系统中使用的进程通信(IPC)机制，即包含管道通信、信号量、消息队列、共享内存以及socket通信等的诸多通信机制。 管道 管道是一种最基本的进程通信机制，其实质是由内核管理的一个缓冲区，可以形象地认为管道的两端连接着两个要进行通信的进程。其中一个进程进行信息输出，将数据写入管道；另一个进程进行信息输入，从管道中读取信息。 管道的逻辑结构如图所示： 管道分为匿名管道(pipe)和命名管道(named pipe)。 在进程中创建的管道是匿名管道，进程退出后管道会被销毁，匿名管道只能用于有亲缘关系的进程间通信。 命名管道被具象化为一个文件，在进程中可使用操作文件的方式向内存中写入或从内存中读出数据，命名管道与进程的联系较弱。相当于一个读写内存的接口，进程退出后，命名管道依然存在。 匿名管道 pipe() 匿名管道利用fork机制建立联系，刚创建出的管道，读写两端都连接在同一个进程上，当进程中调用fork()创建子进程后，父子进程共享文件描述符，因此子进埕拥有与父进程相同的管道。pipe()创建管后读端对应的文件描述符为fd[0]，写端对应的文件描述符为fd[1]。 管道采用半双工通信方式。只能进行单向数据传递，为严谨起见，应使用close()函数关闭除通信端口之外的端口。 管道只能进行半双工通信。若要实现同时双向通信，需要为通信的进程创建两个管道 有指向管道读端的文件描述符打开时，向管道中与入数据才有意义。 若所有指向管道与端的文件描述符都被关闭后仍有进程从管道的读端读取数据，那么管道中剩余的数据都被读取后，再次read会返回0。 若有指向管道写端的文件描述符未关闭，而管道写端的进程也没有向管道中写入数据，那么当进程从管道中读取数据，且管道中剩余的数据都被读取时，再次read会阻塞，直到与端向管道写入数据，阻塞才会解除。 若有指向管道读端的文件描述符没关闭，但读端进程没有从管道中读取数庭，写端进程持续向管道中写入数据，那么管道缓存区写满时冉次write会阻塞，直到读端将数据读出，阻塞才会解除。 管道中的数据以字节流的形式传输，这要求管道两端的进程事先约定好数据的格式。 popen()/pclose() FILE*popen(const char *command，const char *type); int pclose(FILE *stream）； popen()函数的功能是：调用pipe()函数创建管道，调用fork()函数创建子进程，之后在子进程中通过execve()函数调用shell命令执行相应功能。若整个流程都成功执行，则返回一个I/O文件指针；若pipe()或fork()函数调用失败，或因无法分配内存等原因造成popen()函数调用失败，该函数将会返回NULL。 pclose()函数的功能是关闭由popen()打开的I/O流，并通过调用wait()函数等待子进程命令执行结束，返回shell的终止状态，防止产生僵尸进程。与文件操作函数fopen()类似，popen()调用之后务必要使用pclose()函数关闭打开的文件I/O指针，若pclose()函数调用失攸，则返回-1。 命名管道 命名管道又名FIFO(first in first out)，它与匿名管道的不同之处在于：命名管道与系统中的一个路径名关朕，以文件的形式存在于文件系统中。如此，系统中的不同进程可以通过FIFO的路径名访问FIFO文件，实现彼此间的通信。 mkfifo() mkfifo命令的参数一般为文件名，其常用参数为 -m，用于指定所创建文件的权限。 在程序中创建FIFO文件的函数与mkfifo同名，mkfifo()的头文件为sys/type.h与sys/stat.h，其函数声明如下： int mkfifo(const char *pathname，mode_t_mode); 消息队列 消息队列的实质是一个存放消息的表，该链表由内核维护；消息队列中的每个消息可以视为一条记录，消息包括一个长整型的类型字段和需要传递的数据。消息队列由消息队列标识符(queue ID）标识，对消息队列有读权限的进程可以从队列中读取消息，对消息队列有写权限的进程可以照规则，向其中添加消息。 特点： 与管道相比。消息队列的通信方式更为灵活 提供有格式的字节流，无需通信双方额外约定数传输格式 将消息设定为不同类型，并分配了不同的优先级 新添加的消息总是在队尾，但接收消息的进程可以读取队列中间的数据 降低了读与进程间的耦合强度 与FIFO类似，消息队列可以实现无亲缘关系进程间的通信，且独立于通信双方的进程之外，若没有删除内核中的消息队列，即便所有使用消息队列的进程都已终止，消息队列仍存在于内核中，直到内核重新启动、管理命令被执行或调用系统接囗删除消息队列时，消息队列才会真正被销毁。 注意： 系统中的最大消息队列数与系统中最大消息数都有一定限制，分别由宏MSGMNI和F宏MSGTOL定义 消息队列的每个消息中所含数据块的长度以及队列中所含数据块的总长度也有限制，分别由宏MSGMAX和宏MSGMNB定义。 使用消息队列实现进程间通信的步骤如下： 创建消息队列 msgget() 发送消息到消息队列 msgnd() 从消息队列中读取数据 msgrcv() 删除消息队列 msgctl() 键值与标识符: 对多个进程来说。要通过消息队列机制实现进程间通信，必须能与相同消息队列进行关朕，键值(key)就是实现进程与消息队列关联的关腱。当在进程中调用msgget()函数创建消息队列时，传入的key值会被保存到内核中，与msgget()函数创建的消息队列一一对应：若进程中调用msgget()函数获取已存在的消息队列，只需向msgget()函数中传入键值。就能获取到内核中与键值对应的消息队列。也就是说，键值是消息队列在内存级别的唯一标识。 对单个进程来说，可能需要实现与多个进程间的通信，因此会与多个消息队列关朕，当多次调用msgget()函数与多个消息队列进行关联时，每个msgget()函数都会返回一个非负整数，这个非负整数就是进程对消息队列的标识。标识符是消息队列在进程级别的唯一标识。 信号量 Linux系统采用多道裎序设计技木，允许多个进程同时在内核中运行，但同一个系统中的多个进程之间，可能因为进程合作或资源共享，产生制约关系。 制约关系分为直接制约关系和间接制约关系： 需要进程间协调合作导致的制约关系。称为直接相互制约关系。 因资源共享导致的制约关系。称为间接相互制约关系． 直接相互制约的进程间有同步关系，间接相互制约的进程间有互斥关系，同步与互斥存在的根源是系统中存在临界资源(Critical Resource) 计算机中的硬件资源（如内存、打印机、磁盘）以及软件资源（如共享代码段．变量等）都是临界资源，为了避免多进程的并发执行造成的不一致性，临界资源在同时刻只允许有限个进程对其进行访问或修改。 计算机中的多个讲程必须互斥地访问系统中的临界资源，用于访问临界资源的代码称为临界区(Critical Section），临界区也属于临界资源，若能保证进程间互斥地进入自己的临界区，就能实现进程对临界资源的互斥访问。 信号量(Semaphore)是专门用于解决进程同步与互斥问题的一种通信机制，它与信号无关，也不同于管道、FIFO以及消息队列。一般不用来传输数据，信号量包括一个被称为信号量的表示资源数量的非负整型变量、修改信号量的原子操作P和V，以及该信号量下等待资源的进程队列。 在Linux系统中，不同的进程通过获取同一个信号量键值进行通信，实现进程间对资源的互斥访问。使用信号量进行通信时，通常需要以下步骤： 创建信号量/信号量集，或获取系统中已有的信号量/信号量集；semget() 初始化信号量。早期信号量通常被初始为1,但有些进程一次需要多个同类的临界资源，或多个不同类且不唯一的临界资源，因此可能需要初始化的不是信号量，而是一个信号量集；semctl() 信号量的P、V操作，根据进程请求，修改信号量的数量。执行P操作会使信号量 -1，执行V操作会使信号量 +1；semop() 从系统中删除不需要的信号量；semctl() 共享内存 共亨内存允许两个或多个进程访问给定的同一块存储区域。已知当一个进程被启动时，系统会为其创建一个0-4G的虚拟内存空间，根据虚拟地址与物理地址之间的映射关系，进程可以通过操作虚拟地址，实现对物理页面的操作。 一般情况下。每个进程的虚拟地址会与不同的物理地址进行映射．但是当使用共亨内存进行通信时，系统会将同一段物理内存映射给不同的进程。两个进程的虚拟地址空间与共享内存之间的映射关系如图： 创建一块新的共享内存，或打开一块已经存在的共享内存；shmget() 进行地址映射，将共享内存映射到进程虚拟地址空间中；shmat() 解除物理内存与进程虚拟地址空间的映射关系；shmdt() 对已存在的共享内存进行操作；shmctl() 进程 标识符 进程标识符，简称pid，是进程的唯一标识 父进程标识符，简称ppid，标识该进程的父进程，即创建进程的进程所对应的pid 用户标识符，简称uid，标识创建该进程的用户。此外euid标识有效用户的标识符 组标识符：简称gid，标识创建进程用户的所属组，Euid对应的组标识符即为egid 进程状态 通常进程的状态被划分为五种：初始态、就绪态、运行态、睡眠态和中止态。初始态一般不进行讨论，因为当初始化完成后，进程会立刻转化为就绪态。 就绪态：处于就绪态（Ready）的进程，所需的其它资源已分配到位，此时只等待cpu，当可以使用cpu时，进程会立刻变为运行态。 运行态：进程处于运行态（Execting）时会占用cpu，处于此状态的进程的数目必定小于等于处理器的数目，即每个cpu上至多只能运行一个进程 睡眠态：处于睡眠态（Sleeping）的进程会因某种原因暂时不能占有cpu。睡眠态分为不可中断的睡眠和可中断的睡眠。 终止态：处于终止态的进程已运行完毕，此时进程不会被调度，也不会再占用CPU。 PCB 每个进程的PCB中都有一个指向页表的指针、进程、页表与内存之间的映射关系如图所示 进程组由用户启动的进程创建，用户启动的进程是进程组中的领导进程（process group leader），进程组中领导进程的pid亦是识别进程组的进程组id，即pgid。 进程组与会话 会话（session）是进程组的集合，会话中的每个进程组称为一个工作（job） 会话由其中的进程创建，创建会话的进程称为会话的领导进程（session leader），会话领导进程的pid也是标识会话的会话id，即sid 一个会话中一般有一个进程组工作在前台，使用终端，其余进程组工作在后台（在终端执行命令时，在命令之后添加“&”则将命令启动的进程放在后台执行）。会话的意义在于可在同一个终端执行多个进程组。 进程控制 fork() exec函数族 exit()/_exit() exit()和_exit()都是用来终止进程的，但它们所做的操作有些许差别：当程序执行到 _exit()函数时，系统会无条件地停止剩下操作，终止进程，并清除进程所用内存空间以及进程在内核中的各种数据结构；exit()函数对_exit()进行了包装，在执行退出前还有若干道工序，最重要的就是它会在调用_exit()之前先检查文件的打开情况，将缓冲区中的内容写回文件。相对而言，exit()函数相比_exit()函数更为安全。 孤儿进程：父进程在进程退出前退出，子进程变为孤儿进程。 僵尸进程：当进程调用了exit()函数后，该进程并不是马上消失，而是留下一个称为僵尸进程（Zombie）的数据结构。僵尸进程是Linux系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码，也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息，供父进程收集。 进程同步 wait() 处于僵尸态的进程不能再次被运行．但是却会占用一定的内存空间，并占据进程编号，当系统中僵尸进程较多时，将会消耗系统的大部分内存，新的进程可能因内存不足或无法获取pid而无法创建，因此应尽量免僵尸进程的产生。 在父进程中通过wait()和waitpid()函数可以有效防止僵尸进程的产生，对于内存中已经存在的僵尸进程，则可通过杀死其父进程的方法解决。 当僵尸进程的父进程被终止后，僵尸进程将作为孤儿进程被init进程接收，init进程会不断调用wait()函数获取子进程状态。对已处于僵尸态的进程进行处理。 孤儿程水远不会成为僵尸进程。 进程管理命令 ps Process Status 缩写，在命令行输入ps后回车就能查看当前系统中正在运行的进程 选项 说明 a 显示当前终端机下的所有进程，包括其它用户启动的进程 u 以用户的形式，显示系统中的进程 x 忽视终端机，显示所有进程 e 显示每个进程使用的环境变量 r 只列出当前终端机中正在执行的进程 top ps命令执行后，会显示执行命令那一刻系统中进程的相关信息，若想信息动态地显示，可以使用top命令。 top默认的更新间隔为3s。 pstree 以树状图形式显示系统中的进程，可以直接观察到进程之间的派生关系 pgrep 根据进程名从进程队列中查找进程，查找成功后默认显示进程的pid nice 设置Linux系统中进程的nice值 bg 将进程放入后台运行，使前台可以执行其它任务 fg 将后台的进程调往前台 jobs 查看Linux系统中的作业列表及作业状态，进程中的作业也有编号，编号从1开始。Linux系统中作业从用户角度进行编号，进程从系统管理员的角度进行编号。 当选项和参数缺省时，默认显示作业编号、作业状态和启动作业的命令。 kill 终止正在运行的进程，工作原理是发送某个信号到指定进程，以终止该进程。 线程 线程概述 与进程不同。线程(Thread)是系统调度分派的最小单位，与进程相比，线程没有独立的地址空间。多个线程共享一段地址空间。因此线程消耗更少的内存资源，线程间的通信也更为方便，有时线程也被称为轻量级进程(Light Weight Process，LWP) Linux系统中的线程借助进程机制实现，线程与进程联系密切： 进程可以蜕变成线程，当在一个进程中创建一个线程时，原有的进程就会变成线程，两个线裎共用一段地址空间， 线程又被称为轻量级讲程。线程的TCB(Thread Control Block，线程控制块）与进程的PCB相同，因此也可以将TCB视为PCB； 对内核而言，线程与进程没有区别，cpu会为个线程与进程分配时间片，并通过PCB来调度不同的线程和进程。 进程与线程 进程组成：线程集+资源集（地址空间、打开的文件描述符、用户信息等） 线程组成：程序、数据、TCB以及少量必不可少的用于保证线程独立运行的资源、程序计数器、栈空间、寄存器 优点：同一个进程地址空间的多个线程共享虚拟地址空间，进而共享相同的页目录、页表和物理页面，因此线程间的许多数据是共享的，线程不必通过类似进程通信使用的管道、信号量等机制，便能进行通信 缺点：因为多个线程共享一段地址空间，当多个线程同时需要对其中的数据进行访问时，可能会因竞争导致读写错误，因此，正如控制多个进程对共享资的访问一样，系统同样也应实现对线程间的共享数据的同步。 线程操作 pthread_create() 进程拥有独立的地址空间，当使用fork()函数创建出新进程后，若其中一个讲程要对fork()之前的数据进行修改，进程中会依据“写时复制”原则，,先复制一分该数据到子进程的地址空间，再修改数据，因此即便是全局变量。在进程间也是平共享的。 但由于线程间共享地址空间，因此在一个线程中对全局区的数据进行修改，其它线程中访问到的也是修改后的数据。 pthread_exit() return和exit()也有退出功能，但retum用于退出函数，exit()用于退出进程。 pthread_cancel() 线程机制中厍用于终止线程的函数为pthread_cancel，该函数对应线程机制中的kill()函数，pthread_cancel()函数可向指定线程发送信号CANCEL，使一个线程强行杀死另外一个线程。 pthread_join() 在进程中，父进程退出，子进程仍可继续执行；但在线程中，作为程序入口的主线程退出，属于同一进程中的所有线程都会退出。 为避免主线程提前退出对其它线程造成影响，可以使用pthread_join()函数将主线程挂起。 pthread_detach() 在线程终止后，其它线程调甲pthread_join()数获取该线程的终止状态前，该线程会一直保持终止状态，这种状态类似讲程中的僵尸态。为避兔处于终止状态的线程占用内存，线程机制中提供了pthread_detach()函数，可在线程被创建后设置线程分离，被分离的线程在执行结束后将会自动释放，不再等待其它线程回收 线程属性 线程同步 互斥锁 使用互斥锁实现线程同步时，系统会为共享资源添加一个称为互斥锁的标记，防止多个线程在同一时刻访问相同的共用资源。 条件变量 使用互斥锁实现线程同步时，系统会为共享资源添加一个称为互斥锁的标记，防止多个线程在同一时刻访问相同的共用资源。 信号量 使用信号量实现线程同步时，线程在访问共享资源时会根据操作类型执行P/V操作：若有线程申请访问共享资源，系统会执行P操作使共享资源计数减一；若有线程释放共亨资源，系统会执行V操作共享资源计数加一。 上下文切换 什么是上下文切换？ 我们知道 Linux 是一个多任务操作系统，它能支持远大于 CPU 数量的任务同时运行。但实际上同一时刻只会有 CPU 数量的进程在运行，等 CPU 时间片到了之后，进程调度器就会把 CPU 资源分配给其他进程。 在这个过程中就会涉及到进程之间的切换，这时候就需要将当前进程的上下文信息保存下来，随后加载被调度进程的上下文信息，这就是上下文切换。 这里所说的上下文信息，既包括虚拟内存、栈、全局变量等用户态的资源，也包括内核堆栈、寄存器等内核态的资源。不同类型的上下文切换，会涉及到不同类型资源的切换，例如：同一进程不同线程的切换，只需要切换内核态的资源，而不需要切换用户态的资源。 上下文切换类型 上下文还分为了三种类型，分别是： 进程上下文切换 线程上下文切换 中断上下文切换 进程上下文切换 进程上下文切换指的是不同进程之间发生切换。一般来说，进程被调度有如下几个时机： 某个进程时间片耗尽，会被系统挂起，切换到其他等待 CPU 的进程。 进程所需系统资源不足，需要等到资源满足时才可运行，此时会被挂起，其他进程会被调度。 进程通过 sleep 方法主动挂起，其他进程就有机会被调度。 有更高优先级的进程，当前进程会被挂起，高优先级进程会被调度。 硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。 当发生如上几种情况的时候，就会发生进程调度，进而发生进程上下文切换。 线程上下文切换 我们都知道进程是资源分配的基本单位，线程是调度的基本单位，进程只是给线程提供了虚拟内存等资源。而线程上下文切换，就可以分为两种情况： 进程调度前后的两个线程，属于同一进程。此时因为资源共享，所以在切换的时候虚拟内存等这些资源就不需要变化，只需要切换线程的私有数据、寄存器等不共享的数据。 进程调度前后的两个线程，不属于同一进程。这时候因为资源部共享，所以切换过程和进程上下文切换是一样的。 所以你会发现同进程内的线程切换，要比多进程间的切换消耗更少的资源，这其实就是多线程比起多进程的一个优势。 中断上下文切换 中断上下文切换指的是为了响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将当前的状态保存下来。这样在中断结束后，进程仍然可以从原来的状态恢复运行。 中断上下文切换，并不需要保存和恢复进程的虚拟内存等用户态资源，只需要处理 CPU 寄存器、内核堆栈等内核态的资源即可。 分析工具 查看系统的上下文切换情况，有三个工具可以使用，分别是：vmstat 命令、pidstat 命令、/proc/interrupts 文件。 vmstat 命令 vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。该命令的语法格式为： vmstat 其中常用的选项有： -a：显示活动内页； -f：显示启动后创建的进程总数； -m：显示 slab 信息； -n：头信息仅显示一次； -s：以表格方式显示事件计数器和内存状态； -d：报告磁盘状态； -p：显示指定的硬盘分区状态； -S：输出信息的单位。 我们执行 vmstat 5 命令后，会每隔 5 秒输出一次结果，如下所示。 procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 6893400 2352 563768 0 0 2 425 153 32 1 3 96 0 0 其中与上下文相关的 4 列内容如下： cs（context switch）是每秒上下文切换的次数。 in（interrupt）则是每秒中断的次数。 r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。 b（Blocked）则是处于不可中断睡眠状态的进程数。 可以看到上面输出中上下文切换次数 cs 是 32 次，而系统中断次数 in 是 153 次，而就绪队列长度 r 和不可中断状态进程数 b 都是 0。 pidstat 命令 vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用我们前面提到过的 pidstat 了。给它加上 -w 选项，你就可以查看每个进程上下文切换的情况了。 例如执行如下命令，我们可以得到每个进程的上下文切换情况了。 // 每隔 5 秒输出一次结果 // -w 表示显示每个进程的上下文切换情况 [root@iZwz92ezhi90syoqbgjgn1Z ~]# pidstat -w 5 Linux 4.18.0-348.7.1.el8_5.x86_64 (iZwz92ezhi90syoqbgjgn1Z) 23/08/22 _x86_64_ (4 CPU) 15:04:39 UID PID cswch/s nvcswch/s Command 15:04:44 0 1 0.20 0.00 systemd 15:04:44 0 11 27.94 0.00 rcu_sched 15:04:44 0 497 19.56 0.00 xfsaild/vda3 15:04:44 0 603 0.20 0.00 systemd-journal 15:04:44 0 829 0.40 0.00 sssd_be 15:04:44 0 831 1.60 0.00 sssd_nss 15:04:44 0 3931 0.40 0.00 kworker/2:0-mm_percpu_wq 15:04:44 0 3998 0.40 0.00 kworker/1:0-mm_percpu_wq 15:04:44 0 4005 0.20 0.00 kworker/u8:0-flush-253:0 15:04:44 0 4021 0.80 0.00 kworker/3:2-mm_percpu_wq 15:04:44 0 4037 5.99 0.00 kworker/0:0-events 上述结果中的 cswch 与 nvcswch 是重点关注的对象。cswch 表示每秒自愿上下文切换（voluntary context switches）的次数，nvcswch 表示每秒非自愿上下文切换（non voluntary context switches）的次数。 所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。 而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。 /proc/interrupts 文件 我们可以通过 vmstat 获取中断的次数，但是我们却无法获取中断类型。实际上我们可以通过 /proc/interrupts 文件获取中断的详细信息。/proc 实际上是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。/proc/interrupts 就是这种通信机制的一部分，提供了一个只读的中断使用情况。 我们可以通过如下命令，动态观察中断的变化情况： # -d 参数表示高亮显示变化的区域 $ watch -d cat /proc/interrupts CPU0 CPU1 ... RES: 4385721 4430589 3732298 4259089 Rescheduling interrupts ... 通过这种方式，我们就可以知道具体是哪种中断类型出现异常，从而定位到具体的资源。 如何排查异常？ 今天我们深入了解了一下上下文切换这个指标，但每秒上下文切换多少次才算正常呢？ 这个数值取决于系统本身的 CPU 性能。如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。 具体遇到问题的时候，需要根据变化的上下文切换类型，再做具体的分析。例如： 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题。 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈。 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。 协程 可以在线程上通过分时复用的方式运行，但对操作系统来说，只有线程是可见的。 协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。也就是说，协程只有和异步IO结合起来，才能发挥最大的威力。 如何处理在协程中调用阻塞IO的操作呢？一般有2种处理方式： 在调用阻塞IO操作的时候，重新启动一个线程去执行这个操作，等执行完成后，协程再去读取结果。这其实和多线程没有太大区别。 对系统的IO进行封装，改成异步调用的方式，这需要大量的工作，最好寄希望于编程语言原生支持。 协程对计算密集型的任务也没有太大的好处，计算密集型的任务本身不需要大量的线程切换，因此协程的作用也十分有限，反而还增加了协程切换的开销。 总结： 在有大量IO操作业务的情况下，我们采用协程替换线程，可以到达很好的效果，一是降低了系统内存，二是减少了系统切换开销，因此系统的性能也会提升。 在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"05_Linux/REFERS.html":{"url":"05_Linux/REFERS.html","title":"Refers","keywords":"","body":" Linux - Others - Shell编程实例 Linux - Others - Shell（命令&编程） Linux - 命令 - yum Linux - 文件系统 - 文件IO编程实例 Linux - 服务器 - Socket编程实例 Linux - 进程管理 - 管道编程实例 Linux - 进程管理 - 线程编程实例 Linux - 进程管理 - 进程编程实例 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"05_Linux/Vi编辑器.html":{"url":"05_Linux/Vi编辑器.html","title":"Vi编辑器","keywords":"","body":"模式切换 插入模式 底行模式 :set nu 设置行号 :set nonu 取消行号 :n 使光标移动到第n行 :/xx 在文件中查找xx，若查找结果不为空，可以用n查找下一个，用N查找上一个 :q 退出vi编辑器 :w 保存编辑后的内容 :wq 保存并退出vi编辑器 :q! 强行退出vi编辑器，不保存对文件的修改 :w! 对于没有修改权限的用户强行保存对文件的修改，并且修改后的文件的所有者和所属组都有相应的变化 :wq! 强行保存文件并退出vi编辑器 命令模式 设置vi编辑器 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"06_数据库/MySQL.html":{"url":"06_数据库/MySQL.html","title":"Mysql","keywords":"","body":"一、基础概念 DB（database） DBMS（database management system）DB是通过DBMS创建和操作的容器 常见的DBMS：MySQL Oracle（贵） DB2（处理海量的数据） SqlServer（微软公司，只能安装在Windows操作系统下） 二、DQL语句 基础查询 语法: select from ； 类似于:System.out,printIn(打印东西)； 特点： 查询列表可以是：表中的字段、常量值、表达式、函数 查询的结果是一个虚拟的表格 用例： #查询表中的单个字段 select last_name from employees; #查询表中的多个字段 select last_name,salary,email from employees; #查询表中的所有字段 select * from employees; #查询常量值 select 100; select 'john'; #查询表达式 select 100%98; #查询函数 select version(); #起别名 /* 用处： 1.便于理解； 2.如果要查询的字段有重名的情况，使用别名可以区分开来。 */ select 100%98 as 别名 select last_name as 姓, first_name as 名 from employees; select last_name 姓, first_name 名 from employees; #eg.查询salary,显示结果为out put select salary as out put from employees;#out被识别为关键字，出现错误 select salary as \"out put\" from employees; #去重 #eg.查询员工表中涉及到的所有部分编号 select department_id from employees;//会有重复信息 select distinct department_id from employees; #+号的作用 /*用法： 只能作为运算符使用。 如果有字符型，尝试转换成数值型，再进行运算（“1”->1）;如果转换失败，则转换成0，再进行运行。 只要其中一方为null，结果肯定为null */ #eg.查询员工名和员工的姓，连接成一个字段，并显示为 姓名 select concat(last_name,first_name) as 姓名 from employees; #eg.查询出表employees的全部列，各个列之间用逗号连接，列头显示成out_put select concat('first_name', ',' , 'last_name', ',' ,'job_id', ',',IFNULL(commission_pct,0)) as out_put from employees; 条件查询 语法： select 查询列表 from 表名 where 筛选条件; 分类： 按条件表达式筛选 条件运算符 > >= 按逻辑表达式筛选 逻辑运算符 && || ! and or not 模糊查询 like between and in is null 用例： 1.按条件表达式筛选 #eg. 查询工资>12000的员工信息 SELECT * FROM employees WHERE salary>12000; #eg. 查询部门编号不等于90号的员工名和部门编号 SELECT last_name, department_id FROM employees WHERE department_id!=90;//不标准，最好是department_id<>90; 2.按逻辑表达式筛选 #eg.查询工资z在10000到20000之间的员工名，工资和奖金 SELECT last_name, salary, commission_pct FROM employees WHERE salary>=10000 AND salary110 OR salary>15000; 3.模糊查询 3.1 like 特点： - 一般和通配符搭配使用 %任意多个字符，包含0个字符 _任意单个字符 #eg. 查询员工名共包含字符a的员工信息 SELECT * FROM employees WHERE last_name LIKE '%a%';//默认大小写a是一回事 #eg.查询员工名中第三个字符为e，第五个字符为a的员工名和工资 SELECT last_name FROM employees WHERE last_name LIKE '___e_a%'; #eg. 查询员工名中第二个字符为下划线的员工名 SELECT last_name FROM employees WHERE last_name LIKE '_\\_%'; SELECT last_name FROM employees WHERE last_name LIKE '_$_%' ESCAPE '$'; 3.2 between and 注意： 使用 between and 可以提高语句的简洁度 包含临界值 两个临界值不要调换顺序 #eg. 查询员工编号在100到120之间的员工信息 SELECT * FROM employees WHERE employee_id BETWEEN 100 AND 120; 3.3 in关键字 含义：判断某字符的值是否属于in列表中的某一项 特点： 使用in提高语句简洁度 in列表的值必须是同样的类型，或者可以兼容的类型，即可以隐式转换 #eg. 查询员工的公众编号是 IT_PROG、AD_VP、AD_PRES中的一个的员工名和工种编号 SELECT last_name, job_id FROM employees WHERE job_id IN ('IT_PROG','AD_VP','AD_PRES'); 3.4 is null 关键字 = 或 <> 不能用于判断null值 is null 或 is not null 可以判断null值 #eg. 查询没有奖金的员工名和奖金率 SELECT last_name, commission_pct FROM employees WHERE commission_pct IS NULL; 4.安全等于 特点：可读性差 #eg. 查询没有奖金的员工名和奖金率 SELECT last_name, commission_pct FROM employees WHERE commission_pct NULL; #eg. 查询工资为12000的员工信息 SELECT * FROM employees WHERE salary 12000; Tips： IS NULL：仅仅可以判断NULL值，可读性较高，建议使用 : 既可以判断NULL，又可以判断普通的数值， 可读性较低 排序查询 语法： SELECT 查询列表 FROM 表 (WHERE 筛选条件） ORDER BY 排序列表 特点： ASC 代表升序，DESC代表降序，不写默认升序 ORDER BY 子句中可以支持单个字段、多个字段、表达式、函数、别名 ORDER BY 子句一般是放在查询语句的最后面，LIMIT子句除外 #eg.查询员工信息，要求工资从高到低排序 SELECT * FROM employees ORDER BY salary DESC;(降序排序) SELECT * FROM employees ORDER BY salary ASC;(升序排序) SELECT * FROM employees ORDER BY salary ;(默认为升序排序) #eg.查询部门编号>=90的员工信息，要求按入职时间排序 SELECT * FROM employees WHERE department_id >= 90 ORDER BY hiredate ASC; #eg.按年薪的高低显示员工信息和年薪【按别名排序】 SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 FROM employees ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC; #eg.按姓名的长度显示员工的姓名和工资【按函数排序】 SELECT LENGTH(last_name) 字节长度，last_name,salary FROM employees ORDER BY LENGTH(last_name) DESC; #eg.查询员工信息，要求先按工资排序，再按员工编号排序【按多个字段排序】 SELECT * FROM employees ORDER BY salary ASC，employee_id DESC; 常见函数 语法： SELECT 函数名(实参列表) (from 表) 分类： 单行函数：做处理使用 如 concat、length、ifnull等 又分为 字符函数、数学函数、日期函数、其他函数、流程控制函数 分组函数：做统计使用、又称为统计函数、聚合函数、组函数 1.单行函数 1.1 字符函数 1.1.1 length select length(‘john’); #4 select length('张三丰hahaha'); #15 uft8 一个中文字占3个字节，一个英文字占1个字节 1.1.2 concat 链接字符串 select concat(first_name,'_',last_name) from employees; 1.1.3 upper lower upper：英文字母变大写；lower：英文字母变小写。 #eg. 姓变大写，名变小写，然后拼接 select concat(upper(last_name),lower(first_name)) 姓名 from employees; 1.1.4 substr substring 注意：索引从1开始 select substr('李莫愁爱上了陆展元',7) out_put; #李莫愁爱上了 select substr('李莫愁爱上了陆展元',1,3) out_put; #李莫愁 #eg.姓名中首字符大写，其他字符小写然后用_拼接，显示出来 select concat(upper(substr(last_name,1,1)),'_',lower(substr(last_name,2))) out_put from employees; 1.1.5 instr 返回子串第一次出现的索引，如果找不到返回0 select instr('杨不悔爱上了殷六侠','殷六侠') as out_put; #7 1.1.6 trim 去掉前后的空格 select length(trim(' 张翠山 ')) as out_put; #9 select length(trim('a' from 'aaaaaa张aa翠山aaaaa')) as out_put;#张aa翠山 11 1.1.7 rpad lpad rpad：用指定的字符实现右填充指定长度；lpad：用指定的字符实现左填充指定长度 select rpad('殷素素',10,'*') as out_put;#殷素素******* select lpad('殷素素',10,'*') as out_put;#*******殷素素 1.1.9 replace 替换 select replace('张无忌爱上了周芷若','周芷若','赵敏') as out_put; 1.2 数学函数 1.2.1 round 四舍五入 select round(1.65);#2 select round(-1.65);#-2 select round(-1.45);#-1 select round(1.567,2);#1.57 1.2.2 ceil 向上取整（更大的数） select ceil(1.002);#2 select ceil(1.00);#1 1.2.3 floor 向下取整（更小的数 select ceil(1.002);#1 select ceil(0.99);#0 select ceil(9.99);#9 select ceil(-9.99);#-10 1.2.4 truncate 截断 select truncate(1.65,1);#1.6 1.2.5 mod 取余 select mod(10,3); #1 select 10%3;#1 select mod(-10,-3);#-1 被除数为正，结果为正，被除数为负，结果为负 select mod(-10,3);#-1 select mod(10,-3);#1 select mod(10,3);#1 1.3 日期函数 1.3.1 now 返回当前系统日期+时间 select now(); 1.3.2 curdate 返回当前系统日期，不包含时间 select curdate(); 1.3.3 curtime 返回当前系统时间，不包含日期 select curtime(); 1.3.4 year month monthname... 可以获取指定的部分、年、月、日、小时、分钟、秒 select year(now()) 年; select year(now('1998-1-1')) 年; select year(hiredate) 年 from employees; select month(now()) 月; #8 select monthname(now()) 月; #August 1.3.5 str_to_date 将日期格式的字符转换成指定格式的日期 select str_to_date('1998-3-2','%Y-%c-%d') as out_put; #1990-03-02 #eg.查询入职日期为1992-4-3的员工信息 select * from employees where hiredate = str_to_date('1992-4-3','%c-%d %Y'); 1.3.6 date_format 将日期转换成字符 select date_format('2018/6/6','%Y年%m月%d日') #2018年06月06日 #eg.查询有奖金的员工名和入职日期(**月/**日 **年) select last_name,date_format(hiredate,'%m月/%d日 %y年') 入职日期 from employees where commission_pct is not null; 1.4 其他函数 select version();#查看版本 select database();#查看当前数据库 select user();#查看当前用户 1.5 流程控制函数 1.5.1 if函数 select if(10>5,'大','小'); #大 select last_name,commission_pct,if(commision_pct is null,'没奖金，哈哈','有奖金，嘻嘻') 备注 from employees; 1.5.2 case函数 (1) switch case 的效果 语法： case 要判断的字段或表达式 when 常量1 then 要显示的值或语句 when 常量2 then 要显示的值2或语句2 ··· else 要显示的值n或语句n end 用例： #eg.查询员工的工资，要求部门号为30，显示的工资为1.1倍；部门号为40，显示的工资为1.2倍；部门号为50，显示的工资为1.3倍；其他部分，显示的工资为原工资。 select salary 原始工资,department_id, case department_id when 30 then salary*1.1 when 40 then salary*1.2 when 50 then salary*1.3 else salary end as 新工资 from employees; (2)类似于多重if 语法： case when 条件1 then 要显示的值或语句 when 条件2 then 要显示的值2或语句2 ··· else 要显示的值n或语句n end 用例： #eg.查询员工的工资的情况，如果工资>20000,显示A级别；如果工资>15000,显示B级别；如果工作>10000,显示C级别；否则，显示D级别。 select salary, case when salary>20000 then 'A' when salary>15000 then 'B' when salary>10000 then 'C' else 'D' end as 工资级别 from employees; 2. 分组函数 sum 求和 avg 平均值 max 最大值 min 最小值 count 计算个数 1.简单使用 select sum(salary) from employees; select round(avg(salary),2) from employees; select min(salary),max(salary) from employees; 2.参数支持哪些类型 sum,avg字符型，但没有意义 select max(last_name),min(last_name) from employees;#支持，也有意义 select max(hiredate),min(hiredate) from employees;#支持，也有意义 count 都支持，也有意义，会忽略null值 3.是否忽略null值 会忽略null值:sum、avg、max、min、count select avg(commisssion_pct),sum(commisssion_pct)/35,sum(commisssion_pct)/127 from employees; 4.和distinct搭配(去重) select sum(distinct salary) from employees; 5.count函数介绍 select count(*) from employees; #统计行数，效率一般更高 select count(1) from employees; #统计行数 写1 写2都行 写啥都一样，除了null 6.和分组函数一同查询的字段有限制，要求是group by 之后的字段 select avg(salary),employee_id from employees;#没有任何意义 分组查询 语法： select 分组函数、列（要求出现在group by的后面） from 表 【where 筛选条件】 group by 分组的列表 【order by 子句】 注意：查询列表必须特殊，要求是分组函数和group by后出现的字段 特点： 分组查询中的筛选条件分为 数据源 位置 分组前筛选 原始表 where 分组后筛选 分组后的结果集 having tips:分组函数做条件肯定是在having语句之中；能用分组前筛选的，优先考虑使用分组前筛选 group by子句支持单个字段分组、多个字段分组（没有顺序要求）、表达式分组、函数分组 也可以添加排序（排序放在整个分组查询的最后） 1.简单分组查询 #eg.查询每个部门的平均工资 select avg(salary) from employees; #eg.查询每个工种的最高工资 select max(salary),job_id from employees group by job_id; #eg.查询每个位置上的部门个数 select count(*),location_id from departments group by location_id; 2.添加筛选条件 #eg.查询邮箱中包含a字符的每个部门的平均工资 select avg(salary),department_id from employees where email like '%a%' group by department_id #eg.查询有奖金的每个部门的每个领导手下员工的最高工资 select max(salary),manager_id, from employees where commission_pct is not null group by manager_id; 3.添加复杂筛选条件 #eg.查询哪个部门的员工个数>2 #tips:1.查询每个部门的员工个数；2.根据1的结果进行筛选，查询哪个部门的员工个数>2 select count(*),department_id from employees group by department_id having count(*)>2; #eg.查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资 select job_id,max(salary) from employees where commission_pct is not null group by job_id having max(salary)>12000; #eg.查询领导编号>102的每个领导手下的最低工资>5000的领导编号是哪个，以及其最低工资 select min(salary),manager_id from employees where manager_id>192 group by manager_id having min(salary)>5000 4.按表达式或函数分组 #eg.按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数>5的有哪些 select count(*),length(last_name) from employees group by length(last_name) having count(*)>5; 5.按多个字段分组 #eg.查询每个部门每个工种的员工的平均工资 select avg(salary),department_id,job_id from employees group by job_id,department_id; 6.添加排序 #eg.查询每个部门每个工种的员工的平均工资，并且按平均工资的高低显示 select avg(salary),department_id,job_id from employees where department_id is not null group by job_id,department_id order by avg(salary) desc; 连接查询 按年代分类： sql92标准：仅仅支持内连接 sql99标准：【推荐】支持内连接+外连接+交叉连接 按功能分类： 内连接：等值连接、非等值连接、自连接 外连接：左外连接、右外连接、全外连接 交叉连接： 1. sql92标准 1.1 等值连接 多表等值连接的结果为多表的交集部分 n表连接，至少需要n-1个连接条件 多表的顺序没有要求 一般需要为表起别名 可以搭配前面介绍的所有子句使用，比如排序、分组、筛选 #eg.查询女神名和对应的男神名 select name,boyname from bos,beauty where beauty.boyfriend_id=boys.id; #eg.查询员工名和对应的部门名 select last_name,department_name from employees,departments where employees.department_id=departments.department_id; 可以为表起别名（如果为表起了别名，则查询的字段不能使用原来的表名去限定） #eg.查询员工名、工种号、工种名 select last_name,e.job_id,title from employees as e,jobs where e.job_id=jobs.job_id 表名顺序可以替换 可以加筛选 #eg.查询有奖金的员工名、部门名 select last_name,department_name from employees e,departments d where e.department_id=d.department_id and e.commission_pct is not null #eg.查询城市名中第二个字符为o的部门名和城市名 select department_name,city from departments d,location l where d.location_id = l.location_id and city like '_o%'; 可以加分组 #eg.查询每个城市的部门个数 select count(*) 个数,city from departments d,locations l where d.location_id=l.location_id group by city; #eg.查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资 select department_name,manager_id,min(salary) from departments d,employees e where d.department_id=e.department_id and commission_pct is not null group by department_name,d.manager_id 可以加排序 #eg.查询每个工种的工种名和员工个数，并且按员工个数降序 select job_title,count(*) from employees e,jobs j where e.job_id=j.job_id group by job_title order by count(*) desc; 可以实现三表连接 #eg.查询员工名、部门名、所在的城市 select last_name,department_name,city from employees e,departments d,location l where e.department_id=d.department_id and d.location_id=l.location_id; 1.2 非等值连接 #eg.查询员工的工资和工资级别 select salary,grade_level from employees e,job_grades g where salary between g.lowest_sal and g.highest_sal; 1.3 自连接 #eg.查询员工名和上级的名称 select employees_id,last_name,employee_id,last_name from employees e,employees m where e.manager_id=m.employee_id; 2. sql99语法 语法： select 查询列表 from 表1 别名 【连接类型】 join 表2 别名 on 连接条件 【where 筛选条件】 【group by 分组】 【order by 排序列表】 类型： 内连接：inner 外连接 左外：left【outer】 右外：right【outer】 全外：full【outer】 交叉连接：cross 2.1 内连接 语法： select 查询列表 from 表1，别名 inner join 表2，别名 on 连接条件 特点： 添加排序、分组、筛选 inner可以省略 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读 inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集 2.1.1 等值连接 #eg.查询员工名、部门名 select last_name,department_name from employee e inner join departments d on e.department_id=d.department_id; #eg.查询名字中包含e的员工名和工种名（添加筛选） select last_name,job_title from employee e inner join jobs j on e.job_id=j.job_id where e.last_name like \"%e%\"; #eg.查询部门个数>3的城市名和部门个数（添加分组+筛选） select city,count(*) 部门个数 from departments d inner join locations l on d.location_id=l.location_id group by city having count(*)>3; #eg.查询哪个部门的部门员工个数>3的部门名和员工个数，并按个数排序 select count(*),department_name from employees e inner join departments d on e.department_id=d.department_id group by department_name having count(*)>3 order by count(*); #eg.查询员工名，部门名，工种名，并按部门名降序 select last_name,department_name,job_title from employees e inner join departments d on e.department_id = d.department_id inner join jobs j on e.job_id = j.job_id order by department_name desc; 2.1.2 非等值连接 #eg.查询员工的工资级别 select salary,grade_level from employees e join job_grades g on e.salary between g.lowest_sal and g.highest_sal #eg.查询工资级别的个数>20的个数，并且按工资级别降序 select count(*),grade_level from employees e join job_grades g on e.salary between g.lowest_sal and g.highest_sal group by grade_level having count(*)>20 order by grade_level desc; 2.1.3 自连接 #eg.查询员工的名字、上级的名字 select e.last_name,m.last_name from employees e join employees m on e.manager_id = m.employee_id; #eg.查询姓名中包含字符K的员工的名字、上级的名字 select e.last_name,m.last_name from employees e join employees m on e.manager_id = m.employee_id; where e.last_name like '%k%'; 2.2 外连接 应用场景：用于查询一个表中有，另一个表没有的记录 特点： 外连接的查询结果为主表中的所有记录 如果从表中有和它匹配的，则显示匹配的值 如果从表中没有和它匹配的，则显示null 外连接查询结果=内连接结果+主表中有而从表没有的记录 左外连接，left join 左边的是主表（from后是主表） 右外连接，right join 右边的是主表（join后是主表） 左外和右外交换两个表的顺序，可以实现同样的效果 全外连接=内连接的结果+表1中有但表2没有的+表2中有单表1没有的 #eg.查询男朋友不在男神表的女神名 #右外连接 select b.name,bo.* from beauty b left outer join boys bo on b.boyfriend_id = bo.id where bo.id is null; #左外连接 select b.name,bo.* from boys bo right outer join beauty b on b.boyfriend_id = bo.id where bo.id is null; #eg.查询哪个部门没有员工 #左外连接 select d.*,e.employee_id from departments d left outer join employees e on d.department_id = e.department_id where e.employee_id is null #右外连接 select d.*,e.employee_id from employees e right outer join departments d on d.department_id = e.department_id where e.employee_id is null; #全外连接 select b.*,bo.* from beauty b full outer join boys bo on b.boyfriend_id = bo.id; #交叉连接（笛卡尔乘积） select b.*,bo.* from beauty b cross join boys bo; 2.3 子查询 含义：出现在其他语句中的select语句，称为子查询或内查询；内部嵌套其他select语句的查询，称为外查询或主查询 分类： 按子查询出现的位置： select 后面：仅仅支持标量子查询 from 后面：支持表子查询 where或having后面：标量子查询（单行）、列子查询（多行）、行子查询 exists后面（相关子查询） 按结果集的行列数不同： 标量子查询（结果集只有一行一列） 列子查询（结果集只有一列多行） 行子查询（结果集有一行多列） 表子查询（结果集一般为多行多列） 2.3.1 where或having后面 特点： 子查询放在小括号内 子查询一般放在条件的右侧 2.3.1.1 标量子查询 标量子查询，一般搭配着单行操作符使用 > = #eg.谁的工资比Abel高？ select * from employees where salary > ( select salary from employees where last_name = 'Abel' ); #eg.返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id和工资 select last_name,job_id,salary from employees where job_id = ( select job_id from employees where employee_id = 141 ) and salary > ( select salary from employees where employee_id = 143 ); #eg.返回公司工资最少的员工的last_name,job_id和salary select last_name,job_id,salary from employees where salary = ( select min(salary) from employees ); #eg.查询最低工资大于50号部门最低工资的部门id和其最低工资 select min(salary),department_id from employees group by department_id having min(salary) > ( select min(salary) from employees where department_id = 50 ) #非法使用标量子查询 select min(salary),department_id from employees group by department_id having min(salary) > ( select salary #得到的就不是一个值了 from employees where department_id = 50 ) 2.3.1.2 列子查询（多行子查询） 列子查询，一般搭配着多行操作符使用 操作符 含义 IN / NOT IN 等于列表中的任意一个 ANY / SOME 和子查询返回的某一个值比较 ALL 和子查询返回的所有值比较 #eg.返回location_id是1400或1700的部门中所有员工姓名 select last_name from employees where department_id in( select distinct department_id from departments where location_id in (1400,1700) ); #eg.返回其他部门中比job_id为‘IT_PROG’部门任一工资低('IT_PROG'; #eg.返回其它部门中比job_id为'IT_PROG'部门所有工资都低的员工的员工号、姓名、job_id以及salary select employee_id,last_name,job_id,salary from employees where salary 'IT_PROG'; 2.3.1.3 行子查询（结果集一行多列或多行多列） #eg.查询员工编号最小并且工资最高的员工信息 select * from employees where employee_id = ( select min(employee_id) from employees ) and salary = ( select max(salary) from employees ); select * from employees where(employee_id,salary)=( select min(employee_id),max(salary) from employees ); 2.3.2 select后面 只支持标量子查询 2.3.2.1 标量子查询 #eg.查询每个部门的员工个数 select d.*,( select count(*) from employees e where e.department_id=d.department_id ) 个数 from departments d; #eg.查询员工号=102的部门名 select ( select department_name from departments d inner join employees e on d.department_id=e.department_id where e.employee_id=102 ) 部门名; 2.3.3 from后面的子查询 2.3.3.1 表子查询 #eg.查询每个部门的平均工资的工资等级 select ag_dep.*,g.grade_level from ( select avg(salary) ag,department_id from employees group by department_id ) ag_dep inner join job_grades g on ag_dep.ag between lowest_sal and highest_sal; 2.3.4 exists后面 2.3.4.1 相关子查询 语法： exists（完整的查询语句） 结果： 1或0 #eg.查询有员工名的部门名 select department_name from departments where exists ( select * from employees e where d.department_id = e.department_id ); select department_name from departments d where d.department_id in ( select department_id from employees ); #eg.查询没有女朋友的男神信息 select bo.* from boys bo where bo.id not in ( select boyfriend_id from beauty ); select bo.* from boys bo where not exists( select boyfriend_id from beauty b where bo.id=b.boyfriend_id ); 分页查询 应用场景：当要显示的数据、一页显示不全、需要分页提交sql请求 语法： select 查询列表 from 表 【join type join 表2 on 连接条件 where 筛选条件 group by 分组字段 having 分组后的筛选 order by 排序的字段】 limit 【offset,】size; offset 要显示条目的起始索引（从0开始） size要显示的条目个数 特点： limit语句放在查询语句的最后 公式：要显示的页数 page，每页的条目数 size #eg.查询前五条员工信息 select * from employees limit 0,4; select * from employees limit 5; #eg.查询第11条-第25条 select * from employees limit 10,15; #eg.有奖金的员工信息，并且工资较高的前10名显示出来 select * from employees where commission_pct is not null order by salary desc limit 10; 联合查询 union：将多条查询语句的结果合并成一个结果 应用场景：要查询的结果来自多个表，且多个表没有直接的连接关系，但查询的信息一致时 特点：两个表的列数必须一样；多条查询语句的每一列的类型和顺序最好一致；使用union时会自动去重，使用union all 会包含重复项 #eg.查询部门编号>90或邮箱包含a的员工信息 select * from employees where email like '%a%' or department_id > 90; select * from employees where email like '%a%' union select * from employees where department_id > 90; #eg.查询中国用户中男性的信息>以及外国用户中男性的信息 select id,cname,csex from t_ca where csex='男' union select t_id,tName,tGender from t_ua where tGender='male' 三、DML语言 数据操作语言 1.插入语句 语法： insert into 表名(列名...) values(值1,...) #法一：支持插入多行，支持子查询 insert into beauty(id,name,sex,borndate,phone,photo,boyfriend_id) values(13,'唐艺昕','女','1990-4-23','18988888888',null,2); #法二：不支持插入多行，不支持子查询 insert into beauty(id,name,sex,phone) values(14,'金星','女','13988888888'); 特点： 插入的项目和列项目必须同类型或可兼容 可以为NULL的列如何插入值： 列的顺序可以调换 列数和值的个数必须一致（就算插入的数据为null，也不可以省略） 省略列名，默认所有列，而且列的顺序和表中列的顺序一致 2.修改语句 语法： update 表名 set 列 = 新值，列 = 新值，... where 筛选条件 #sql92 update 表1 别名，表2别名 set 列 = 值，列 = 值 where 连接条件 and 筛选条件 #sql99 update 表1 别名 inner | left | right join 表2 别名 on 连接条件 set 列 = 值，列 = 值 where 筛选条件 3.删除语句 delete 语法： #1.单表的删除 delete from 表名 where 筛选条件 #2.多表的删除 #sql92 delete 别名 from 表1 别名，表2，别名 where 连接条件 and 筛选条件 #sql99 delete 表1的别名，表2的别名 from 表1 别名 inner | left | right join 表2 别名 on连接条件 where 筛选条件 用例： #eg.删除张无忌的女朋友的信息 delete b from beauty b inner join boys bo on b.boyfriend_id = bo.id where bo.boyName='张无忌'; truncate 不允许加where，也叫做清空数据 语法： truncate table 表名 特点： delete可以加where条件，truncate不能加 truncate删除效率高一点 加入要删除的表中有自增长列，用delete删除后，再插入数据，自增长列的值从断点开始；而truncate删除后，再插入数据，自增长列的值从1开始 truncate删除没有返回值，delete删除有返回值 truncate删除不能回滚，而delete删除可以回滚 四、DDL语言 1.库的管理 创建 create database 库名; 修改 rename database to alter database character set gbk 删除 drop database #通用的写法： DROP DATABASE IF EXISTS ; 2.表的管理 创建 create table <> 表名( 列名 列的类型【(长度) 约束】, 列名 列的类型【(长度) 约束】, 列名 列的类型【(长度) 约束】, ); 修改 #1.修改列名 ALTER TABLE CHANGE COLUMN ; #2.修改列的类型或约束 ALTER TABLE MODIFY COLUMN ; #3.添加新列 ALTER TABLE ADD COLUMN ; #4.删除列 ALTER TABLE DROP COLUMN #5.修改表名 ALTER TABLE RENAME TO ; 删除 DROP TABLE ; 表的复制 #1.仅仅复制表的结构 CREATE TABLE LIKE ; #2.复制表的结构+数据 CREATE TABLE SELECT * FROM ; #3.只复制部分数据 CREATE TABLE SELECT ,,... FROM WHERE ; #4.仅仅复制某些字段 CREATE TABLE SELECT ,,... FROM WHERE 0; 3.数据类型 3.1数值型 3.1.1整型 整数类型 字节 范围 TinyInt 1 有符号：-128~127无符号：0~255 SmallInt 2 有符号：-32768~32767无符号：0~65535 MediumInt 3 有符号：-8388608~8388607无符号：0~1677215 Int、Integer 4 有符号：-2147483648~2147483647无符号：0~4294967295 BigInt 8 有符号：-9223372036854775808~9223372036854775807无符号：0~9223372036854775807*2+1 特点： 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，添加unsigned关键字 如果插入的数值超出了范围，会报错 如果不设置长度，会有默认的长度 长度代表了显示的最大宽度，如果不够会用0在左边填充 3.1.2小数 浮点数 浮点数类型 字节 范围 float 4 double 8 定点数 定点数类型 字节 范围 DEC(M,D)DECIMAL(M,D) M+2 最大取值范围与double相同，给定decimal的有效取值范围由M和D决定 特点： M：整数部位+小数部位；D：小数部位；如果超过范围，则插入临界值 M和D都可以省略，如果是decimal，则M默认为10，D默认为0；如果是float和double，则会根据插入的数值的精度来决定精度 定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用 原则： 所选择的类型越简单越好，保存的数值的类型越小越好 3.2字符型 较短的文本：char、varchar 字符串类型 最多字符数 描述及存储需求 char(M) M M为0-255之间的整数 varchar(M) M M为0-65535之间的证书 特点：char固定长度，varchar可变长度；char比较耗空间，varchar比较节省，char效率高，varchar效率低。 应用场景：性别 char(1)， 较长的文本：text、blob（较长的二进制数据） 其他： enum 不区分大小写 又称为枚举类型，要求插入的值必须属于列表中指定的值之一 如果列表成员为1-255，则需要1个字节存储 如果列表成员为255-65535，则需要2个字节存储 最多需要65535个成员 set 不区分大小写 和enum类型类似，里面可以保存0-64个成员。和enum类型最大的区别是：set类型一次可以选取多个成员，而enum只能选一个，根据成员个数不同，存储所占的字节也不同。 binary和varbinary用于保存较短的二进制 3.3日期型 4.常见约束 含义：一种限制，用于限制表中的数据，为了保证表的数据的准确和可靠性 分类：六大约束 NOT NULL：非空，用于保证该字段的值不能为空，比如姓名、学号等 DEFAULT：默认，用于保证该字段有默认值，比如性别 PRIMARY KEY：主键，用于保证该字段的值具有唯一性，并且非空，一个表只能有一个，允许但不推荐，比如学号、员工编号等 UNIQUE：唯一，用于保证该字段的值具有唯一性，可以为空，一个表可以有多个，允许但不推荐比如座位号 CHECK：检查约束【mysql中不支持】，比如年龄、性别 FOREIGN KEY：外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值。在从表添加外键约束，用于引用主表中某列的值。比如学生表的专业编号，员工表的部门编号，员工表的工种编号。 特点：1.要求在从表设置外键关系；2.从表的外键列的类型和主表的关联列的类型一致或兼容； 添加约束的时机；3.主表的关联列必须是一个key（一般是主键或唯一）；4.插入数据是，先插入主表，再插入从表；删除数据是，先删除从表，再删除主表 4.1.创建表时 必须在数据添加之前添加约束 约束的添加分类： 列级约束：六大约束语法上都支持，但外键约束没有效果 create table stuinfo ( id int primary key, stuName varchar(20) not null, gener char(1) check(gender='男' or gender='女'), seat int unique, age int default 18, majorId int foreign key references major(id) ); 表级约束：除了非空、默认、其他都支持 语法 【constraint 约束名】 约束类型（字段名） create table stuinfo ( id int , stuName varchar(20) , gener char(1) , seat int , age int , majorId int , constraint pk primary key(id), constraint uq unique(seat), constraint ck check(gender = '男' or gender = '女'), constraint fk_stuinfo_major foreign key(majorid) references major(id) ); 通用的写法 create table if exists stuinfo( if int primary key, stuname varchar(20) not null, sex char(1), age int default 18, seat int unique, majorid int, constraint fk_stuinfo_major foreign key(majorid) references major(id) ) 4.2修改表时 #1.添加非空约束 alter table stuinfo modify column stuname varchar(20) not null; #2.添加默认约束 alter table stuinfo modify column age int deafult 18 #3.添加主键 alter table stuinfo modify column id int primary key; alter table stuinfo add primary key(id); #4.添加唯一 alter table stuinfo modift column seat int unique; alter table stuinfo add unique(seat); #5.添加外键 alter table stuinfo add constraint foreign key(majorid) references major(id); 4.3修改表时删除约束 #1.删除非空约束 alter table stuinfo modify column stuname varchar(20) null; #2.删除默认约束 alter table stuinfo modify column age int; #3.删除主键 alter table stuinfo drop index ; show index from ; #4.删除唯一 alter table stuinfo drop index ; #5.删除外键 alter table stuinfo drop foreign key; 标识列 又称为自增长列 含义：可以不用手动的插入值，系统提供默认的序列值 特点：1.标识列必须和主键搭配吗？不一定，但要求是一个key；2.一个表可以有几个标识列？至多一个！；3.标识列的类型只能是数值型；4.标识列可以通过set auto_increment_increment=3设置 #1.创建表时设置标识列 create table tab_identity ( id int primary key auto_increment, name varchar(20) ); insert into tab_identity values(1,'john'); #2.修改表时设置标识列 alter table tab_identity modify column id int primary key auto_incremnet; #3.修改表时删除标识列 alter table tab_identity modift column id int; 五、TCL语言 transaction control language 事务控制语言 事务：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。 案例：转账 存储引擎： 在mysql中的数据用各种不同的计数存储在文件（或内存）中 通过show engines来查看mysql支持的存储引擎 在mysql中用的最多的存储引擎有：innodb，myisam，memory等。其中innodb支持事务，而myisam，memory等不支持事务。 事务的ACID属性 原子性：Atomicity：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生 一致性：Consistency：事务必须使数据库从一个一致性状态到另一个一致性的状态。 隔离性：Isolation：事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性：Durability：持久性是指一个事务一旦被提交，它对数据库中的数据的改变就是永久性的，接下来的其他操作和数据库故障都不应该对其有任何影响。 事务的创建： 隐式事务：事务没有明显的开启和结束的标记。 比如：insert、update、delete 显示事务：事务具有明显的开启和结束的标记。 前提：比如先把自动提交功能关闭 set autocomit=0; 开启事务的语句： #步骤1：开启事务 set autocommit=0; start transaction;可选的 #步骤2：编写事务中的sql语句(select insert update delete) 语句1； 语句2； …… #步骤3：结束事务 commit；提交事务 rollback；回滚事务 savepoint;保存点，只搭配rollback使用 当多个事务同时访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发的问题 脏读：对于两个事务T1，T2，T1读取了已经被T2更新但还没有被提交的字段之后，若T2回滚，T1读取的内容就是临时且无效的。 不可重复读：对于两个事务T1，T2，T1读取了一个字段，然后T2更新了该字段之后，T1再次读取他一字段，值就不同了。 幻读：对于两个事务T1，T2，T1从一个表中读取了一个字段，然后T2在该表中插入了一些新行。之后，如果T1再次读取同一个表，就会多出几行。 数据库提供的4种事务隔离级别 Oracle支持的2种事务隔离级别：read commited，serializable。Oracle默认的事务隔离级别为：read commited。 mysql支持4种事务隔离级别。Mysql默认的事务隔离级别为：repeatable read。 六、视图 含义：虚拟表，和普通表一样使用 特点：动态生成，只保存了sql逻辑，不保存查询结果 语法： #1.创建 CREATE VIEW AS SELECT…… #2.使用（当正常的表一样使用） SELECT . FROM #3.修改 ALTER VIEW AS SELECT…… #4.删除 DROP VIEW ,,…… #5.查看 DESC ; No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"06_数据库/SQLite基础.html":{"url":"06_数据库/SQLite基础.html","title":"Sqlite基础","keywords":"","body":"SQLite基础 基础 不区分大小写 数据类型 null 值是一个null值 integer 值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中 real 浮点值，存储为 8 字节的 IEEE 浮点数字 text 文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储 blob blob数据，完全根据它的输入存储 创建数据库 SQLiteOpenHelper第一次调用getReadableDatabase()时如果数据库不存在就会创建 创建表 CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); 删除表 drop table语句删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范 DROP TABLE COMPANY; insert 向数据库的某个表中添加新的数据行 #指定列 INSERT INTO TABLE_NAME [(column1, column2, column3,...columnN)] VALUES (value1, value2, value3,...valueN); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (2, 'Allen', 25, 'Texas', 15000.00 ); #全部 INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN); select 获取数据，以结果表的形式返回数据 #指定列 SELECT column1, column2, columnN FROM table_name; # 全部 SELECT * FROM table_name; SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name = 'COMPANY'; 运算符 SELECT * FROM COMPANY WHERE SALARY > 50000; SELECT * FROM COMPANY WHERE SALARY != 20000; 逻辑运算符： and 允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在 between 用于在给定最小值和最大值范围内的一系列值中搜索值 exists 用于在满足一定条件的指定表中搜索行的存在 in 用于把某个值与一系列指定列表的值进行比较 not in IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较 like 把某个值与使用通配符运算符的相似值进行比较 glob 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的 not 是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。它是否定运算符。 or 用于结合一个 SQL 语句的 WHERE 子句中的多个条件 is null 用于把某个值与 NULL 值进行比较 is 与 = 相似 is not 与 != 相似 || 连接两个不同的字符串，得到一个新的字符串 UNIQUE 搜索指定表中的每一行，确保唯一性（无重复） SELECT * FROM COMPANY WHERE AGE >= 25 OR SALARY >= 65000; 表达式 SELECT COUNT(*) AS \"RECORDS\" FROM COMPANY; where 指定从一个表或多个表中获取数据的条件 and/or update UPDATE COMPANY SET ADDRESS = 'Texas' WHERE ID = 6; # 更新所有行的ADDRESS和SALARY UPDATE COMPANY SET ADDRESS = 'Texas', SALARY = 20000.00; delete #基本语法 DELETE FROM table_name WHERE [condition]; DELETE FROM COMPANY WHERE ID = 7; #删除所有 DELETE FROM COMPANY; like %：0个、1个或多个数字或字符 _: 代表单一的数字或字符 SELECT column_list FROM table_name WHERE column LIKE 'XXXX%' or SELECT column_list FROM table_name WHERE column LIKE '%XXXX%' or SELECT column_list FROM table_name WHERE column LIKE 'XXXX_' or SELECT column_list FROM table_name WHERE column LIKE '_XXXX' or SELECT column_list FROM table_name WHERE column LIKE '_XXXX_' #COMPANY 表中 AGE 以 2 开头的所有记录 SELECT * FROM COMPANY WHERE AGE LIKE '2%'; #COMPANY 表中 ADDRESS 文本里包含一个连字符（-）的所有记录 SELECT * FROM COMPANY WHERE ADDRESS LIKE '%-%'; glob 与like类似，但大小写敏感 *: 0个、1个或多个数字或字符 ?: 代表一个单一的数字或字符 SELECT * FROM COMPANY WHERE AGE GLOB '2*'; limit 限制由select语句返回的数据数量 SELECT column1, column2, columnN FROM table_name LIMIT [no of rows] SELECT column1, column2, columnN FROM table_name LIMIT [no of rows] OFFSET [row num] SELECT * FROM COMPANY LIMIT 6; #从第三位开始提取 3 个记录 SELECT * FROM COMPANY LIMIT 3 OFFSET 2; order by 基于一个或多个列按升序或降序顺序排列数据 SELECT column-list FROM table_name [WHERE condition] [ORDER BY column1, column2, .. columnN] [ASC | DESC]; SELECT * FROM COMPANY ORDER BY SALARY ASC; SELECT * FROM COMPANY ORDER BY NAME, SALARY ASC; group by 对相同的数据进行分组 #语法 SELECT column-list FROM table_name WHERE [ conditions ] GROUP BY column1, column2....columnN ORDER BY column1, column2....columnN SELECT NAME, SUM(SALARY) FROM COMPANY GROUP BY NAME; having 指定条件来过滤将出现在最终结果中的分组结果 #下面是 HAVING 子句在 SELECT 查询中的位置： SELECT FROM WHERE GROUP BY HAVING ORDER BY #语法 SELECT column1, column2 FROM table1, table2 WHERE [ conditions ] GROUP BY column1, column2 HAVING [ conditions ] ORDER BY column1, column2 # 名称计数小于 2 的所有记录 SELECT * FROM COMPANY GROUP BY name HAVING count(name) distinct 与select语句一起使用，消除所有重复的记录，并只获取唯一一次记录 # 语法 SELECT DISTINCT column1, column2,.....columnN FROM table_name WHERE [condition] # 案例 SELECT DISTINCT name FROM COMPANY; 高级 约束 约束是在表的数据列上强制执行的规则，比如不能为null。常见约束： not null: 确保某列不能有null值 default： 没有指定值时，提供默认值 unique：确保某列中所有值是不同的 primary key：唯一标识数据库表中的各行/记录 check：确保某列中所有值满足一定条件 CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL UNIQUE, ADDRESS CHAR(50), SALARY REAL DEFAULT 50000.00 check(SALARY>0) ); alter table 可以重命名表，或向现有表中添加一个新的列。但不能 重命名列、删除一列、添加约束、删除约束。 Join 结合2个或多个数据库中表的记录。 交叉连接 cross join: 把第一个表中的每一行与第二个表中的每一行进行匹配。如果2个输入表分别有x行和y行，则结果有x*y行。这可能会产生一个非常大的表，使用需谨慎。 SELECT EMP_ID, NAME, DEPT FROM COMPANY CROSS JOIN DEPARTMENT; 内连接 inner join: 满足条件的记录才会出现在结果集中。 SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID; 左外连接 left outer join: 左表全部出现在结果集中，若右表无对应记录，则相应字段为null SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMEN ON COMPANY.ID = DEPARTMENT.EMP_ID; Union union用于合并2个或多个select语句的结果，不返回任何重复的行。使用union时，每个select返回的列数必须是相同的，相同的列表达式，相同的数据类型，并确保它们相同的顺序。 SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID UNION SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID; union all用于结合2个select语句的结果，包括重复行。 SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID UNION ALL SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID; null值 表示一个缺失值的项。 别名 可以暂时把表或列重命名为另一个名字，这就是别名。 #表 别名的基本语法如下： SELECT column1, column2.... FROM table_name AS alias_name WHERE [condition]; #示例 SELECT C.ID, C.NAME, C.AGE, D.DEPT FROM COMPANY AS C, DEPARTMENT AS D WHERE C.ID = D.EMP_ID; #列 别名的基本语法如下： SELECT column_name AS alias_name FROM table_name WHERE [condition]; # 示例 SELECT C.ID AS COMPANY_ID, C.NAME AS COMPANY_NAME, C.AGE, D.DEPT FROM COMPANY AS C, DEPARTMENT AS D WHERE C.ID = D.EMP_ID; 触发器 触发器是数据库的回调函数，指定的数据库事件发生时自动执行。 #语法 CREATE TRIGGER trigger_name [BEFORE|AFTER] event_name ON table_name BEGIN -- 触发器逻辑.... END; # demo 在 COMPANY 表中插入记录，这将导致在 AUDIT 表中创建一个审计日志记录。 CREATE TRIGGER audit_log AFTER INSERT ON COMPANY BEGIN INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, datetime('now')); END; # 列出触发器 SELECT name FROM sqlite_master WHERE type = 'trigger'; # 删除触发器 DROP TRIGGER trigger_name; 索引 索引是一种特殊的查找表，数据库搜索引擎用来加快数据检索。索引是指向表中数据的指针。 索引会加快select查询和where子句，但它会减慢使用update和insert语句时的数据输入。 索引可以创建和删除，不会影响数据。 使用create index语句创建索引，运行命名索引，可以指定表及要索引的一列或多列，并指示索引是升序排列还是降序排列。 #语法 CREATE INDEX index_name ON table_name; # demo 在 COMPANY 表的 salary 列上创建一个索引 CREATE INDEX salary_index ON COMPANY (salary); #删除索引 DROP INDEX salary_index; 以下情况避免使用索引： 较小的表上 频繁的大批量更新或插入操作的表上 列中含有大量的null值 频繁操作的列上 indexed by 执行sql语句时强制使用某个索引，虽然这个命令看起来非常有用，但现在不推荐，因为数据库的 SQL 分析引擎已经足够智能，它会自己判定用不用索引和使用哪个索引。 #语法 SELECT|DELETE|UPDATE column1, column2... INDEXED BY (index_name) table_name WHERE (CONDITION); #demo SELECT * FROM COMPANY INDEXED BY salary_index WHERE salary > 5000; alter 命令 SQLite中的alter只支持下面2种： 重命名表 添加额外的列 不支持现有列的重命名，删除和修改。 #重命名表 语法 ALTER TABLE [database_name.]table_name RENAME TO new_table_name; #demo ALTER TABLE tbl_employee RENAME TO tbl_employee_old; #添加一列 语法 ALTER TABLE [database_name.]table_name ADD COLUMN column_def...; #demo ALTER TABLE tbl_employee_old ADD COLUMN SEX char(1); 清空表中的数据 truncate table用于清空表中的数据，然后将自增值重新设置为1。但SQLite中并没有truncate table。可以使用delete删除全部数据，想要恢复自增值为1，就需要先drop table删除整个表，然后再重新创建一遍。 #删除全部数据 DELETE FROM table_name; #删表 DROP TABLE table_name; 视图 视图就是一条select语句执行后返回的结果集。原表中数据变了，这里的结果集也会变。视图是虚表。 作用： 方便操作，减少复杂的sql语句，增强可读性 更加安全，限制数据访问，用户只能看到有限的数据 汇总各种表中的数据，用于生成报告 视图是只读的，无法在视图上更新数据。可以在视图上创建触发器，当在表中执行delete、insert、update更新数据时可以出发视图更新操作。 # 下面是一个从 COMPANY 表创建视图的实例。视图只从 COMPANY 表中选取几列 CREATE VIEW COMPANY_VIEW AS SELECT ID, NAME, AGE FROM COMPANY; # 删除视图 DROP VIEW view_name; 事务 事务是指在某个块中执行的一系列操作，要么全部执行，要么全部不执行。可以用来维护数据库的完整性，保证成批的sql语句要么全部执行，要么全部不执行。事务必须满足4个条件（ACID）。 原子性（Atomicity）：一组事务，要么成功，要么失败回滚当作什么事都没发生 稳定性（Consistency）：有非法数据（外键约束之类），事务撤回 隔离性（Isolation）：事务独立运行。 可靠性（Durability）：软、硬件崩溃后，SQLite数据表会利用日志文件重构修改 默认情况下，SQLite事务是自动提交的，即执行sql语句后立马就会执行Commit操作。 BEGIN TRANSACTION 开始事务处理 COMMIT 或者 END TRANSACTION 保存更改 ROLLBACK 回滚所做的更改 BEGIN; DELETE FROM COMPANY WHERE AGE = 25; END TRANSACTION; 子查询 子查询（内部查询或嵌套查询）：where子句中嵌入另一个sql查询语句。 # 先查询出 salary 大于 50000 的职工的 id 作为条件，筛选出这些人的所有信息 SELECT * FROM tbl_employee WHERE id IN ( SELECT id FROM tbl_employee WHERE salary > 50000 ); # 上面语句 仅作举例 其实可以更简单的查询 SELECT * FROM tbl_employee WHERE id > 50000; # 筛选出 tbl_employee 中的年龄在 tbl_age 中大于 27 岁的那些记录 SELECT * FROM tbl_employee WHERE age IN (SELECT age FROM tbl_age WHERE age > 27 ); # 用于旧表 tbl_employee 中的数据导入到新表 tbl_employee_new 当中 INSERT INTO tbl_employee_new SELECT * FROM tbl_employee; insert into company_bkp select * from company where id in (select id from company where salary > 4000); UPDATE tbl_employee SET salary = salary * 1.2 WHERE age IN (SELECT age FROM tbl_age WHERE age > 27 ); DELETE FROM tbl_employee WHERE age IN (SELECT age FROM tbl_age WHERE age > 27 ); autoincrement 设置字段值自动递增，只能用于整型（integer），默认从1开始。 CREATE TABLE tbl_employee ( id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, name CHAR(64) NOT NULL, age INTEGER NOT NULL, city CHAR(64), salary REAL ); SQLite 注入 用户输入的数据直接插入表中，可能有安全问题，可能会被sql注入，然后引发数据丢失之类的问题。 防止sql注入： 必须校验用户的输入，可以通过正则表达式、限制长度、单引号和双“-”进行转换等 不要使用动态拼装sql，可以使用sql预处理语句 机密信息加密之后再存放，或者hash掉密码和敏感的信息 尽量不使用管理员权限的数据库连接，使用那种权限有限的数据库连接 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装 sql注入的检测方法一般采用辅助软件或网站平台来检测 常用函数 函数 描述 count() 计算一个数据库表中的行数 max() 选择某列的最大值 min() 选择某列的最小值 avg() 计算某列的平均值 sum() 为一个数值列求和 random() 返回一个介于 -9223372036854775808 和 +9223372036854775807 之间的伪随机整数 abs() 返回数值参数的绝对值 upper() 把字符串转换为大写字母 lower() 把字符串转换为小写字母 length() 返回字符串的长度 sqlite_version() 返回sqlite库的版本 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"06_数据库/SQL注入.html":{"url":"06_数据库/SQL注入.html","title":"Sql注入","keywords":"","body":"SQL注入（SQL Injection）是一种代码注入攻击技术，攻击者通过在应用程序的输入字段中插入或“注入”恶意的SQL代码，从而改变预期的SQL查询。这样，攻击者可以绕过应用程序的安全检查，执行未经授权的操作，比如读取、修改、删除数据库中的数据，甚至获取系统权限。 SQL注入的工作原理 当应用程序直接将用户输入的数据嵌入到SQL查询中，而不进行适当的校验和处理时，就会导致SQL注入。例如，假设有一个登录系统，用户输入用户名和密码，这些输入被直接拼接到SQL查询中： SELECT * FROM users WHERE username = 'user_input' AND password = 'user_password'; 如果攻击者在用户名字段中输入' OR '1'='1，密码字段中输入' OR '1'='1，则查询将变为： SELECT * FROM users WHERE username = '' OR '1'='1' AND password = '' OR '1'='1'; 由于'1'='1'始终为真，SQL查询将返回所有用户，攻击者因此能够绕过身份验证。 SQL注入的危害 数据泄露：攻击者可以读取数据库中的敏感信息。 数据篡改：攻击者可以修改或删除数据库中的数据。 权限提升：攻击者可能通过SQL注入获取更高的权限，控制整个系统。 持久后门：攻击者可以在数据库中插入恶意代码，建立持久的后门。 防御SQL注入的方法 使用参数化查询（Prepared Statements）：避免直接拼接SQL查询字符串，使用占位符和绑定变量来传递用户输入。 String sql = \"SELECT * FROM users WHERE username = ? AND password = ?\"; PreparedStatement statement = connection.prepareStatement(sql); statement.setString(1, username); statement.setString(2, password); ResultSet resultSet = statement.executeQuery(); 使用存储过程：将SQL逻辑放在数据库中，通过调用存储过程来执行查询。 输入验证：严格验证和过滤用户输入，拒绝或转义包含特殊字符的输入。 最小权限原则：限制应用程序对数据库的权限，仅授予执行所需操作的最低权限。 安全框架：使用安全框架和ORM（对象关系映射）工具，它们内置了防SQL注入的机制。 通过以上方法，可以有效防止SQL注入攻击，保护应用程序和数据的安全。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/":{"url":"07_项目管理/","title":"Cicd","keywords":"","body":"07_项目管理 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/CICD/CICD.html":{"url":"07_项目管理/CICD/CICD.html","title":"Cicd","keywords":"","body":"一、CI/CD 的概述 CI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。 CI/CD 的核心概念是持续集成、持续交付和持续部署。它是作为一个面向开发和运营团队的解决方案，主要针对在集成新代码时所引发的问题（也称为：“集成地狱”）。 CI/CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。 这些关联的事务通常被统称为 CI/CD 管道，由开发和运维团队以敏捷方式协同支持。 二、CI 持续集成（Continuous Integration） 持续集成（CI）是构建软件和完成初始测试的过程。持续部署（CD）是将代码与基础设施相结合的过程，确保完成所有测试并遵循策略，然后将代码部署到预期环境中。当然，许多公司也有自己特有流程，但主要步骤如下。 1.CI：代码提交阶段 参与者：开发工程师，数据库管理员（DBA），基础架构团队 技术：GitHub，GitLab，SVM，BitBucket 流程：代码提交阶段也称为版本控制。提交是将开发人员编写的最新代码变更发送到代码存储库的操作。开发人员编写的代码的每个版本都被无限期地存储。在与合作者讨论和审查变更之后，开发人员将编写代码，并在软件需求、特性增强、bug修复或变更请求完成后提交。管理编辑和提交变更的存储库称为源代码管理工具（配置管理工具）。在开发人员提交代码（代码推送请求）后，代码更改被合并到主线代码分支中，这些主线代码分支存储在GitHub这样的中央存储库中。 2.CI：静态代码检查阶段 参与者：开发工程师，数据库管理员（DBA），基础架构团队 技术：GitHub，GitLab，SVM，BitBucket 流程：开发人员编写代码并将其推送到存储库后，系统将自动触发以启动下一个代码分析过程。开发过程中存在这种情况：提交的代码可以构建成功，但在部署期间构建失败。无论从机器还是人力资源的利用率而言，这都是一个缓慢而昂贵的过程。因此必须检查代码中的静态策略。SAST（静态应用程序安全性测试）：SAST是一种白盒测试方法，可以使用SonarQube，Veracode，Appscan等SAST工具从内部检查代码，以发现软件缺陷，漏洞和弱点（例如SQL注入等）。这是一个快速检查过程，其中检查代码是否存在语法错误。尽管此阶段缺少检查运行时错误的功能，但该功能将在以后的阶段中执行。 将额外的策略检查加入自动化流水线中可以显著减少流程中稍后发现的错误数量。 3.CI：构建 参与者：开发工程师 技术：Jenkins，Bamboo CI，Circle CI，Travis CI，Maven，Azure DevOps 流程：持续集成过程的目标是提交的代码持续构建为二进制文件或构建产物。通过持续集成来检查添加的新模块是否与现有模块兼容，不仅有助于更快地发现bug，还有助于减少验证新代码更改的时间。构建工具可以根据几乎所有编程语言的源代码创建可执行文件或包（.exe，.dll，.jar等）。在构建过程中，还可以生成SQL脚本，配合基础设施配置文件一起进行测试。简而言之，构建阶段就是编译应用程序的阶段。Artifactory存储、构建验证测试和单元测试也可以作为构建过程的一部分。 构建验证测试（BVT）/冒烟测试/单元测试： 创建构建后立即执行冒烟测试。BVT将检查所有模块是否正确集成，以及程序的关键功能是否正常运行。这样做的目的是拒绝严重损坏的应用程序，以使QA团队不会在安装和测试软件应用程序步骤浪费时间。 在完成这些检查后，将向流水线中执行UT（单元测试），以进一步减少生产中的故障。单元测试可验证开发人员编写的单个单元或组件是否按预期执行。 构建产物存储： 一旦构建就绪，程序包就会存储在称为Artifactory或Repository工具的中央数据库。随着每天构建量的增加，跟踪所有构建产物也会变得愈加困难。因此，一旦生成并验证了构建产物，就将其发送到存储库进行存储管理。诸如Jfrog Artifactory之类的存储库工具可用于存储诸如.rar，.war，.exe，Msi等之类的二进制文件。测试人员可以从此处手动进行选择，并在测试环境中部署构建产物以进行测试。 4.CI：测试阶段 参与者：测试人员、QA 技术：Selenium，Appium，Jmeter，SOAP UI，Tarantula 过程：发布构建过程后的一系列自动测试将验证代码的准确性。此阶段可帮助避免生产中的错误。根据构建的大小，此检查可能持续数秒至数小时。对于由多个团队提交和构建代码的大型组织，这些检查在并行环境中运行，以节省宝贵的时间并尽早将错误通知开发人员。 测试人员（或称为QA工程师）基于用户描述的测试用例和场景设置自动化测试用例。他们执行回归分析、压力测试来检查与预期输出的偏差。测试中涉及的活动有完整性测试、集成测试、压力测试。这是一个高层次测试方法。在这个阶段，可以发现开发人员忽视的某些代码问题。 集成测试： 集成测试是使用Cucumber、Selenium等工具执行的，在这些工具中，单个应用程序模块被组合起来并作为一组进行测试，同时评估其是否符合指定的功能需求。在集成测试之后，需要有人批准该组中的更新集应该移到下一个阶段，这通常是性能测试。这个验证过程可能很麻烦，但它是整个过程的一个重要部分。验证这个过程业界有很多优秀的方案。 性能和压力测试： Selenium、JMeter等自动化测试工具也可执行性能和压力测试，以检查应用程序在面对高负载时是否稳定和性能良好。该测试流程通常不会在每个更新提交上运行，因为完整的压力测试是长期运行的。当发布主要的新功能时，将对多个更新进行分组，并完成完整的性能测试。在单个更新被转移到下一阶段的情况下，流水线可能将金丝雀测试加入作为可选。 三、CD 持续交付（Continuous Delivery） 参与者：站点可靠性工程师（SRE）、运营和维护团队。 技术：JIRA、ServiceNow、Slack、电子邮件、Hipchat。 过程：DevOps团队的目标是更快地持续发布，然后不断减少错误和性能问题。这是通过不时地通过发送电子邮件向开发人员、项目经理提供有关新版本的质量和性能的反馈。通常情况下，反馈系统是整个软件交付过程的一部分。因此，交付中的任何更改都会频繁地录入系统，以便交付团队可以对它采取行动。 四、CD 持续部署（Continuous Deployment） 参与者：基础架构工程师，SRE，运维工程师 技术：Spinnaker，Argo CD，Tekton CD 过程：在测试阶段完成之后，可以部署到服务器的标准代码准备就绪。在部署到生产中之前，它们将被部署到产品团队内部使用的测试环境或beta环境。在将构建移至这些环境之前，构建必须经过Bake和Deploy的子阶段。这两个阶段都是Spinnaker所支持存在的。 1.CD：Bake Baking是指在生产时使用当前配置从源代码创建不可变的镜像实例。这些配置可能是数据库更改和其他基础结构更新之类的事情。Spinnaker可以触发Jenkins执行此任务，并且某些组织更喜欢使用Packer。 2.CD：部署 Spinnaker自动将已bake的镜像发送到部署阶段。这是将服务器组设置为部署到集群的位置。与上述测试过程类似，在部署阶段将执行功能相同的过程。首先将部署移至测试阶段，然后最终移至生产环境，以进行批准和检查。这个处理过程可以由Spinnaker等工具支持。 3.CD：验证 这也是团队优化整个CI/CD流程的关键位置。因为现在已经进行了如此多的测试，所以失败很少见。但是，此时必须尽快解决所有故障，以最大程度地减少对最终客户的影响。团队也应该考虑使流程的这一部分自动化。 使用蓝绿部署、金丝雀分析、滚动更新等策略部署到产品。在部署阶段，将监视正在运行的应用程序以验证当前部署是否正确或是否需要回滚。 4.CD：监控 参与者：站点可靠性工程师（SRE）、运营团队 技术：Zabbix、Nagios、Prometheus、Elastic Search、Splunk、Appdynamics、Tivoli 过程：为了使软件发行版具有故障安全性和健壮性，在生产环境中跟踪发行版的运行状况至关重要。应用程序监视工具将跟踪性能指标，例如CPU利用率和发行版延迟。日志分析器将扫描由底层中间件和操作系统产生的大量日志，以识别行为并跟踪问题的根源。如果生产中出现任何问题，将通知利益相关者以确保生产环境的安全性和可靠性。此外，监视阶段可帮助组织收集有关其新软件更改如何为收入贡献的情报，帮助基础设施团队跟踪系统行为趋势并进行容量规划。 五、CI 和 CD 有什么区别？ CI/CD 中的“CI”始终指持续集成，它属于开发人员的自动化流程。 成功的 CI 意味着应用代码的新更改会定期构建、测试并合并到共享存储库中。 该解决方案可以解决在一次开发中有太多应用分支，从而导致相互冲突的问题。 CI/CD 中的“CD”指的是持续交付和/或持续部署，这些相关概念有时会交叉使用。两者都事关管道后续阶段的自动化，但它们有时也会单独使用，用于说明自动化程度。 持续交付（第一种CD）通常是指开发人员对应用的更改会自动进行错误测试并上传到存储库（如 GitHub 或容器注册表），然后由运维团队将其部署到实时生产环境中。 这旨在解决开发和运维团队之间可见性及沟通较差的问题。 因此，持续交付的目的就是确保尽可能减少部署新代码时所需的工作量。 持续部署（另一种“CD”）指的是自动将开发人员的更改从存储库发布到生产环境，以供客户使用。 它主要为了解决因手动流程降低应用交付速度，从而使运维团队超负荷的问题。持续部署以持续交付的优势为根基，实现了管道后续阶段的自动化。 所以，用一张图总结一下就是： CI/CD 既可能仅指持续集成和持续交付构成的关联环节，也可以指持续集成、持续交付和持续部署这三项构成的关联环节。 更为复杂的是，有时“持续交付”也包含了持续部署流程。 归根结底，我们没必要纠结于这些语义，您只需记得 CI/CD 其实就是一个流程（通常形象地表述为管道），用于实现应用开发中的高度持续自动化和持续监控。 许多企业最开始先添加 CI，然后逐步实现交付和部署的自动化（例如作为云原生应用的一部分）。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Coding/REFERS.html":{"url":"07_项目管理/Coding/REFERS.html","title":"Refers","keywords":"","body":" Addison Wesley - Refactoring-Improving the Design of Existing Code 设计模式-可复用面向对象软件的基础 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Coding/SOLID原则.html":{"url":"07_项目管理/Coding/SOLID原则.html","title":"Solid原则","keywords":"","body":"在程序设计领域， SOLID（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）是由罗伯特·C·马丁在21世纪早期引入，指代了面向对象编程和面向对象设计的五个基本原则。当这些原则被一起应用时，它们使得一个程序员开发一个容易进行软件维护和扩展的系统变得更加可能。 1 单一职责原则（SRP） 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中，即又定义有且仅有一个原因使类变更。（甲类负责两个不同的职责：职责A，职责B。当由于职责A需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责B功能发生故障。也就是说职责A和B被耦合在了一起”）。 2 开放封闭原则（OCP) 实体应该对扩展是开放的，对修改是封闭的。即可扩展(extension)，不可修改(modification)。 eg: 原代码，不同用户类型进行不同服务，但是后续每新增不同的用户类型，只能在下面继续加判断代码。 图片丢失 修改后代码，用户实现统一的接口，后续新增用户类型，只需要新增对应实现类。 3 里氏替换原则（LSP） 一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序的错误。 经典的例子: 正方形不是长方形的子类。原因是正方形多了一个属性“长 == 宽”。这时，对正方形类设置不同的长和宽，计算面积的结果是最后设置那项的平方，而不是长*宽，从而发生了与长方形不一致的行为。如果程序依赖了长方形的面积计算方式，并使用正方形替换了长方形，实际表现与预期不符。 4 接口隔离原则（ISP） 接口隔离原则表明客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中的方法分组，然后用多个接口替代它，每个接口服务于一个子模块。简单地说，就是使用多个专门的接口比使用单个接口要好很多。 ISP的主要观点如下： 1）一个类对另外一个类的依赖性应当是建立在最小的接口上的。 ISP可以达到不强迫客户（接口的使用方法）依赖于他们不用的方法，接口的实现类应该只呈现为单一职责的角色（遵循SRP原则） ISP还可以降低客户之间的相互影响---当某个客户要求提供新的职责（需要变化）而迫使接口发生改变时，影响到其他客户程序的可能性最小。 2）客户端程序不应该依赖它不需要的接口方法（功能）。 客户端程序就应该依赖于它不需要的接口方法（功能），那依赖于什么？依赖它所需要的接口。客户端需要什么接口就是提供什么接口，把不需要的接口剔除，这就要求对接口进行细化，保证其纯洁性。 5 依赖倒置原则（DIP） 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对抽象（接口）编程，而不是针对实现细节编程。 开闭原则（OCP）是面向对象设计原则的基础也是整个设计的一个终极目标，而依赖倒置原则（DIP )则是实现OCP原则的一个基础，换句话说开闭原则（OCP）是你盖一栋大楼的设计蓝图，那么依赖倒置原则就是盖这栋大楼的一个钢构框架。 来看一个例子假设我们在开发一个软件产品需要一个日志系统，要将系统产生的一些重要事情记录在记事本上。通常我们的实现如下： 但是随着时间的推移，产品做的好买了很多客户，产品变得越来越大，使用Logger 类的地方成千上万处，可怕的事情终于发生了： A 客户提出来我想把日志存在数据库中便于做统计分析。 B 客户说我想把日志打印在一个控制台上便于我时时监测系统运行情况。 C 客户说我要把日志存到Windows Azure Storage上。 怎么办呢？ 回过头来看看我们的这个日志系统的设计才恍然大悟：没有遵守面向对象设计原则的依赖倒置原则和开闭原则了。知道就好，找到法门了， 我们将日志这一块的设计重构一下让其符合OCP和DIP应该就可以了。 那么我们就要首先抽象写日志的接口ILog， 让实际调用的地方调用高层抽象（ILog），具体的实现类TextLogger，ConsoleLogger，DatabaseLogger，AzureStorageLogger都继承自ILog接口，然后我们在利用反射加配置，不同的用户配置不同的具体实现类，这样问题就迎任而解了。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Coding/【CleanCode】阅读笔记.html":{"url":"07_项目管理/Coding/【CleanCode】阅读笔记.html","title":"【cleancode】阅读笔记","keywords":"","body":"阅读笔记的阅读笔记，有机会读下全文 整洁代码 尽量让代码易读 有意义的命令 尽量避免使用与本意相悖的词，比如isNot\\dontHave 不同东西意义不一样时，一定要在命名上区分，如变量，不要简单的cat1，cat2这样区分 只要短名称足够清楚，就要比长名称好 函数 要确保函数只做一件事，函数中的语句都要在同一抽象层级上 自顶向下读代码：向下规则，让代码拥有自顶向下的阅读顺序，让每个函数后面都跟着下一抽象层级的函数，这样一来，在看函数列表时，就能循抽象层级向下阅读了，我把这叫做向下规则 最理想的参数数量是零，有足够的理由才能用三个以上参数 对于转换，使用输出参数而非返回值令人迷惑，如果函数要对输入参数进行转换操作，转换结果就该体现为返回值 如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了 对于一元函数，函数和参数应当形成一种非常良好的动词/名词对形式 函数要么做什么事，要么回答什么事，但二者不可得兼 try/catch代码块把错误处理与正常流程混为一谈，最好把try和catch代码块的主体部分抽离出来，另外形成函数 错误处理就是一件事，处理错误的函数不该做其他事 函数中的每个代码块都应该只有一个入口和一个出口 尽量少使用break，continue，不能用goto 注释 若编程语言足够有表达力，就不需要注释 程序员应当负责将注释保持在可维护、有关联、精确的高度，更应该把力气用在写清楚代码上，直接保证无须编写注释 不准确的注释要比没注释坏得多 对象和数据结构 过程式代码难以添加新的数据结构，因为这要修改所有相关函数；面向对象代码难以添加新函数，因为要修改所有相关类 模块不应了解它所操作对象的内部情形，意味着对象不应通过存取器曝露其内部结构，因为这样更像是曝露而非隐藏其内部结构 类 类应该从一级变量列表开始，如果有公共静态变量，应该先出现，然后是私有静态变量，以及实体变量，很少会有公共变量 公共函数应该跟在变量列表之后 内聚性强，方法操作的变量越多，就越黏聚到类上，如果一个类的每个变量都被每个方法所使用，则该类具有最大的内聚性 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Coding/【Refractoring - Improving the existing code】阅读笔记.html":{"url":"07_项目管理/Coding/【Refractoring - Improving the existing code】阅读笔记.html","title":"【refractoring - improving the existing code】阅读笔记","keywords":"","body":"什么是重构（refactoring） 名词：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 动词：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。 重构的目的是使软件更容易被理解和修改。你可以在软件内部做很多修改，但必须对软件可观察的外部行为只造成很小变化，或甚至不造成变化。 为什么重构 重构改进软件设计 如果没有重构，程序的设计会逐渐腐败变质。重构很像是在整理代码，其改进设计的一个重要方向就是消除重复代码。 重构使软件更容易理解 除了计算机，我们编写的代码，更多的是给将来的程序员，甚至是我们自己看的。在重构上花一点时间，可以让代码更好地表达自己的意图。重构还可以帮助我们理解不熟悉的代码。 重构帮助找到 bug 对代码进行重构，可以加深对代码和程序结构的理解，有助于找到 bug。 重构提高编程速度 重构可以帮助改进软件设计，而良好的设计是快速开发的根本。 何时重构 重构本来就不是一件应该特别拨出时间做的事情，重构应该随时随地进行。你不应该为重构而重构，你之所以重构，是因为你想做别的什么事，而重构可以帮助你把那些事做好。 事不过三 第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。 添加新功能时重构 一个动机是重构可以帮助理解需要修改的代码；另一个动机是代码当前的设计无法帮助我轻松添加所需要的功能。 修复错误时重构 收到 bug 报告，就是需要重构的信号，因为代码没有清晰到可以一眼看出 bug 所在。 代码评审（code review）时重构 代码评审对于编写清晰代码很重要，也会让更多人有机会提出更多的建议。 对于今天的工作，我了解得很充分；对于明天的工作，我了解得不够充分。但如果我纯粹只是为今天工作，明天我将完全无法工作。 代码的坏味道 重复代码（Duplicated Code） 如果你在一个以上的地点看到相同的程序结构，那么可以肯定：设法将它们合而为一，程序会变得更好。 过长函数（Long Method） 我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。我们可以对一组甚至短短一行代码做这件事。哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途，我们也该毫不犹豫地那么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。 如何确定该提炼哪一段代码呢? 一个很好的技巧是：寻找注释。它们通常能指出代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数去。 过大的类（Long Class） 如果想利用单个类做太多事情，其内往往就会出现太多实例变量。一旦如此，重复代码也就接踵而至了。 过长参数列（Long Parameter List） 太多参数会造成前后不一致、不易使用，而且一旦你需要更多数据，就不得不修改它。如果将对象传递给函数，大多数修改都将没有必要，因为你很可能只需（在函数内）增加一两条请求，就能得到更多数据。 发散式变化（divergent change） 某个类经常因为不同的原因在不同的方向上发生变化。 霰弹式修改（shortgun surgery） 如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改。 依恋情结（feature envy） 函数对某个类的兴趣高过对自己所处类的兴趣，这种孺慕之情最通常的焦点便是数据。无数次经验里，我们看到某个函数为了计算某个值，从另一个对象那儿调用几乎半打的取值函数。 数据泥团（Data Clumps） 两个类中相同的字段，许多函数签名中相同的参数，这些总是绑在一起出现的数据应该有自己的对象。 基本类型偏执（primitive obsession） 在小任务上运用小对象，比如：结合数值和币种的 money 类、由一个起始值和一个结束值组成的 range 类、电话号码或邮政编码（ZIP）等的特殊字符串。 switch语句 大多数时候，一看到 switch 语句，你就应该考虑以多态来替换它。 冗赘类（Lazy Class） 对于没有必要存在的类，让它消失。 夸夸其谈未来型（speculative generality） 为了未来的可能性处理一些非必要的情况，往往造成系统难以理解和维护。 中间人（Middle Man） 如果某个类接口有一半的函数都委托给其它类，就属于过度委托。 不适当的亲密（Inappropriate Intimacy） 两个类关系过于亲密，花费太多时间去探究彼此的 private 成分，此时建议要么拆算，要么将共同点提取到一个新类。 过多的注释（Comments） 一段代码有长长的注释，这些注释之所以存在往往是因为代码很糟糕。当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。 主要的重构列表 重新组织函数 提炼函数（Extract Method） 如果有一个过长的函数，或者一段需要注释才能理解的代码，将其中一段代码提取到一个独立函数中，并让函数名称解释该函数的用途。 简短而命名良好的函数更容易被复用，而且高层函数读起来就像一系列注释。 内联函数（Inline Method） 如果一个函数的名称和函数体一样清晰易懂，则去掉函数调用，在调用点直接使用函数体。 另一种场景是，有一群组织不合理的函数，可以先将它们内联到一个大函数中，然后再提炼出组织合理的小函数。 内联临时变量（Inline Tmep） 如果一个临时变量，只被一个简单表达式赋值一次，而它妨碍了其他重构手法。将所有对该变量的引用替换为对应的赋值表达式。 以查询取代临时变量（Replace Temp With Query） 如果一个临时变量保存了一个表达式的运算结果，将这个表达式提取到一个函数中，将对这个临时变量的所有引用替换为对新函数的调用。该新函数也可以被其它函数调用，即提高了复用性。 引入解释型变量（Introduce Explaining Variable） 如果有一个复杂的表达式，将该复杂表达式（或一部分）赋值给一个临时变量，用变量的名称来解释表达式的意图。（用提炼函数（Extract Method）方法也可以，看哪种更合适） 分解临时变量（Split Temporary Variable） 如果一个临时变量被多次赋值，但它既不是循环变量，也不是用于收集计算结果，说明它承担了多个责任，有多个含义，则应该在每次赋值的时候使用单独的临时变量，用良好的命名表达意图。 移除对参数的赋值（Remove Assignments to Parameters） 如果需要在函数内对参数赋值，请使用一个临时变量取代参数。 Replace Method with Method Object（以函数对象取代函数） 你有一个大型函数，其中对局部变量的使用使你无法采用 提取函数（Extract Method）。 将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。 替换算法（Substitute Algorithm） 用一个更好的算法直接替换原有的算法。 在对象间搬移特性 搬移函数（Move Method） 如果一个函数与另一个类的交流比所在类更多，应该考虑将该函数搬移到另一个类。如果一个类有太多行为，或一个类与另一个类有太多合作而形成高度耦合，就应该考虑是否可以通过搬移函数进行重构。 搬移字段（Move Field） 如果一个类中的字段，被另一个类更多地用到，应该考虑将该字段搬移到另一个类中。 提炼类（Extract Class） 如果某个类做了两个或多个事情，应该将相应的数据和函数提炼到新的类中。如果类很大，做的事情很多，很多数据和函数总是一起出现或一起变化，就可以考虑提炼新类了。 内联类（Inline Class） 如果某个类没有承担什么责任，不再有单独存在的理由，将这个类的所有特性内联到另一个类中，将原类移除。 隐藏委托关系（Hide Deleage） 通过封装，对外部客户隐藏内部的委托细节，避免内部的委托发生变化波及客户。 如果某个客户先通过服务对象的字段得到另一个对象，然后调用后者的函数，那么客户就必须知晓这一层委托关系。万一委托关系发生变化，客户也得相应变化。你可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来，从而去除这种依赖。这么一来，即便将来发生委托关系上的变化，变化也将被限制在服务对象中，不会波及客户。 移除中间人（Remove Middle Man） 如果服务类做了太多的简单委托，移除服务类，让客户直接调用委托类。 该重构手法与隐藏委托关系（Hide Deleage）刚好相反，所以很难说什么程度的隐藏和封装是合适的，这是随着系统的变化而变化的，根据具体的场景使用合适的方法即可。 引入外部函数（Introduce Foreign Method） 如果客户类需要的少数几个功能，服务类不能提供，而且不能修改服务类源码，则可以在客户类创建函数提供所需的功能。 引入本地扩展（Introduce Local Extension） 在引入外部函数（Introduce Foreign Method）的基础上，如果需要在客户类建立大量的外部函数，则应该考虑将这些函数组织到新的类中，该新类应该是源类的子类，即本地扩展。 重新组织数据 Self Encapsulate Field（自封装字段） 对于类的字段，可以直接访问，也可以通过取值函数/设值函数（get/set)去访问。在一个类中，可以直接访问，如果为了在子类中改变获取数据的方式（如延迟获取）等，则可以通过取值函数/设置函数访问。 Replace Data Value with Object（以对象取代数据值） 如果一个数据项，需要与其它的数据与行为放在一起才有意义，将数据项变成对象。 Replace Array with Object（以对象取代数组） 有一个数组，其中每个元素代表都是不同的东西，建议以对象代替数组，将数组中的每个元素作为对象的字段。 Duplicate Observed Data（复制“被监视数据”） 一个分层良好的系统，应该将处理用户界面和处理业务逻辑的代码分开。之所以这样做，原因有以下几点：(1)你可能需要使用不同的用户界面来表现相同的业务逻辑，如果同时承担两种责任，用户界面会变得过分复杂；(2)与 GUI 隔离之后，领域对象的维护和演化都会更容易，你甚至可以让不同的开发者负责不同部分的开发。 以字面常量取代魔法数（Replace Magic Number with Symbolic Constant） 如果有一个字面数值，带有特殊含义，将其替换为有意义的常量，通过命名表达其含义。 封装字段（Encapsulate Field） 如果有public的字段，将其改为private，并提供相应的访问函数。 Encapsulate Collection（封装集合） 如果一个函数返回一个集合，建议返回该集合的一个只读副本。而且，不要提供对集合的设值（set）函数，应该提供给集合添加/删除元素的函数。 以类取代类型码（Replace Type Code With Class） 如果类中有一个数值类型码，但并不影响类的行为，以一个新的类替换类型码。 以字段取代子类（Replace Subclass with Fields） 如果各个子类的唯一差别是返回常量值的函数上，建议在父类中添加表示该常量值的字段，并通过函数返回，然后移除所有的子类。 简化条件表达式 分解条件表达式（Decompose Conditional) 如果有一个复杂的条件表达式(if-else)，将每部分都提炼成单独的函数。 合并条件表达式（Consolidate Conditional Expression） 如果多个条件表达式返回同样的结果，建议试用&或||将它们合并，并将条件判断提取为独立的函数。但是如果这些条件表达式的检查彼此独立，不应该放到一起去检查，则不要试用本项重构。 合并重复的条件片段（Consolidate Duplicate Conditional Fragments） 如果在条件表达式的每个分支上都有相同的代码，则应该将重复代码移到条件表达式之外。 移除控制标记（Remove Control Flag） 控制标记：在一系列布尔表达式中，可能会根据不同的条件给布尔变量赋予不同的值。建议试用break或return语句替换控制标记，提前返回或退出。 以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses） 卫语句：单独检查条件表达式的某个分支，如果条件满足，则直接返回。如果条件表达式中，有些分支是特殊情况，建议试用卫语句提前返回。 以多态取代条件表达式（Replace Conditional with Polymorphism） 如果有个条件表达式（如switch语句）根据对象类型的不同执行不同的行为，建议使用多态替换：为每一个不同类型建立一个子类，将分支中的内容放到子类的覆写方法中。 引入Null对象（Introduce Null Object） 如果总是需要检查对象是否为null，可以考虑引入null对象。null对象是正常对象的一个子类，覆写的方法使用空实现，一般是单例，不可变。 引入断言（Introduce Assertion） 如果某一段代码需要对程序状态做出某种假设，以断言明确表明这种假设。断言应该总是为真，如果它失败，表明程序员犯了错误，应该抛出异常。断言的主要作用：一是帮助程序的读者更好地理解代码所做的假设；二是可以在距离bug最近的地方捕获之。不要滥用断言，断言只用于检查一定必须为真的条件，而不是用于检查你认为应该为真的条件。实际上，最后生产环境的代码应该将断言全部都删掉。 简化函数调用 函数改名（Rename Method） 将复杂的处理过程分解成小函数，可以增加程序的可读性，其中的关键是给函数命名。函数名应该准确表达它的用途，可以先考虑如何添加注释，然后将注释转换成函数名称。 添加参数（Add Parameter） 如果函数需要额外的信息，可以考虑给函数添加新的参数。添加新参数之前考虑：现有参数是否无法满足需要？是否可以通过其它函数调用获得需要的数据？ 移除参数（Remove Parameter） 如果函数不再需要某个参数，将其移除。 将查询函数和修改函数分离（Separate Query from Modifier） 如果某个函数既返回对象状态，又修改对象状态，建议分离成查询和修改两个独立的函数。任何有返回值的函数，都不应该有看得到的副作用。 令函数携带参数（Parameterize Method） 如果两个函数做着类似的工作，但因少数几个值导致行为略有不同，可以考虑合并为一个函数，通过参数处理变化的部分，这样可以去除重复的代码，提高灵活性。 以明确函数取代参数（Replace Parameter with Explicit Methods） 如果一个函数，根据参数的值不同采取不同的行为，建议针对每一个参数值，建立独立的函数，调用方可以直接调用对应的函数，就可以避免条件表达式。注意与令函数携带参数（Parameterize Method）区分开来。 保持对象完整（Preserve Whole Object） 如果将一个对象的若干数据作为参数传给一个函数，可以考虑直接将该对象作为参数传递。需要注意：1. 如果传递对象会导致依赖关系恶化，则不要使用本项重构。2. 如果调用函数使用了对象的很多项数据，需要考虑该函数是否应该被移到对象中去。 以函数取代参数（Replace Parameter with Methods） 如果函数可以通过其它途径（如调用其它的函数）获得参数值，就应该去掉参数值，缩短参数列的长度。 引入参数对象（Introduce Parameter Object） 如果特定的一组参数总是同时出现在不同的函数参数列表，建议使用一个对象将这些数据组织到一起，可以缩短参数列的长度，提高了代码的一致性。 移除设值函数（Remove Setting Method） 如果类中的某个字段在对象创建后不应该改变，去掉该字段的设值函数。 隐藏函数（Hide Method） 如果某个函数没有被外部类使用到，将该函数设置为private。 以工厂函数取代构造函数（Replace Constructor with Factory Method） 如果在创建对象时还需要执行一些额外的操作，建议将构造函数替换为工厂函数。 封装向下转型（Encapsulate Downcast） 如果函数的返回值需要调用者进行向下转型(downcast)，建议在该函数内执行向下转型，返回调用者需要的类型。 在某些情况下，函数的返回值是一个基类的对象，但调用者需要使用该对象的派生类的功能。这时，调用者需要将返回的基类对象向下转型为派生类对象。 以异常取代错误码（Replace Error Code with Exception） 如果某个函数返回特定的错误码表示某种异常情况，建议直接抛出异常。 以测试取代异常（Replace Exception with Test） 面对调用者可以预先检查的条件，调用者应该先检查该条件，不要通过捕获异常去处理可以预见的逻辑。不要滥用异常，异常应该只用于异常的、罕见的行为。 处理概括关系 字段上移（Pull Up Field） 两个子类有相同的字段，将该字段移到超类中去。 函数上移（Pull Up Method） 有些函数，在各个子类中产生完全相同的结果，将该函数移到超类。 构造函数本体上移（Pull Up Constructor Body） 如果各个子类中都有一些构造函数，它们的函数体几乎完全一致，应该在超类中新建一个构造函数，并在各个子类的构造函数中调用它。 函数下移（Push Down Method） 如果超类中的某个函数只是被部分子类用到，将这个函数移到需要它的子类中去。 字段下移（Push Down Field） 如果超类中的某个字段只是被部分子类用到，将这个字段移到需要它的子类中去。 提炼子类（Extract Subclass） 如果类的某些特性只被某些（不是全部）实例用到，新建一个子类，将特定的属性移到子类中去。 提炼超类（Extract Superclass） 如果两个类有相似特性，建立一个超类，将相同的特性移到超类。 折叠继承体系（Collapse Hierarchy） 如果子类和超类并无太大区别，将它们合并。 塑造模板函数（Form Template Method） 如果有一些子类，其中的某个函数以相同顺序执行大致相近的操作，但是各操作不完全相同。将这些操作分别放进独立函数中，并保持它们都有相同的签名，然后将原函数上移至超类，子类重写实现不同的逻辑。 以委托取代继承（Replace Inheritance with Delegation） 如果子类只使用了超类接口中的一部分，或者子类从超类继承了一大堆并不需要的数据，建议将继承改为委托。 以继承取代委托（Replace Delegation with Inheritance） Addison Wesley - Refactoring-Improving the Design of Existing Code.pdf No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Coding/【代码大全】阅读笔记.html":{"url":"07_项目管理/Coding/【代码大全】阅读笔记.html","title":"【代码大全】阅读笔记","keywords":"","body":"第一部分：奠定基础 前期准备 构建成本可以占到项目成本的65% 准备工作不充分的原因：程序员无法抗拒开始编码的冲动/领导催促尽快开始编码 前期准备的方向：逻辑、类比、数据 如果需求被污染，需求会污染架构，架构又会污染构建 定义开发方式： 序列式：预先确定约80%的需求，为以后再确定的额外需求预留时间，然后采用系统化的变更空值，以确保随着项目的进展只接受最有价值的新需求 迭代：预先确定最重要的20%需求，并计划以小的增量了开发软件的其他部分。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Coding/【设计模式-可复用面向对象软件的基础】阅读笔记.html":{"url":"07_项目管理/Coding/【设计模式-可复用面向对象软件的基础】阅读笔记.html","title":"【设计模式-可复用面向对象软件的基础】阅读笔记","keywords":"","body":"设计模式的三个分类 创建型模式 单例模式：某个类只能有一个实例，提供一个全局的访问点。 简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。 工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。 抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。 建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。 原型模式：通过复制现有的实例来创建新的实例。 结构性模式 适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。 组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。 装饰模式：动态的给对象添加新的功能。 代理模式：为其他对象提供一个代理以便控制这个对象的访问。 亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。 外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。 桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。 行为型模式 模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。 策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。 状态模式：允许一个对象在其对象内部状态改变时改变它的行为。 观察者模式：对象间的一对多的依赖关系。 备忘录模式：在不破坏封装的前提下，保持对象的内部状态。 中介者模式：用一个中介对象来封装一系列的对象交互。 命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。 访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。 责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。 迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。 设计模式详解 单例模式 所谓的单例设计指的是一个类只允许产生一个实例化对象。 最好理解的一种设计模式，分为懒汉式和饿汉式。 饿汉式 类产生时就实例化对象。 class Singleton { /** * 在类的内部可以访问私有结构，所以可以在类的内部产生实例化对象 */ private static Singleton instance = new Singleton(); /** * private 声明构造 */ private Singleton() { } /** * 返回对象实例 */ public static Singleton getInstance() { return instance; } } 懒汉式 当第一次去使用Singleton对象的时候才会为其产生实例化对象的操作。 class Singleton { /** * 声明变量 */ private static volatile Singleton singleton = null; /** * 私有构造方法 */ private Singleton() { } /** * 提供对外方法 * @return */ public static Singleton getInstance() { // 还未实例化 if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 工厂设计模式 工厂模式分为工厂方法模式和抽象工厂模式。 工厂方法模式 普通工厂模式：就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 多个工厂方法模式：是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。 静态工厂方法模式：将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 普通工厂模式 建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 interface Sender { void Send(); } class MailSender implements Sender { @Override public void Send() { System.out.println(\"This is mail sender...\"); } } class SmsSender implements Sender { @Override public void Send() { System.out.println(\"This is sms sender...\"); } } public class FactoryPattern { public static void main(String[] args) { Sender sender = produce(\"mail\"); sender.Send(); } public static Sender produce(String str) { if (\"mail\".equals(str)) { return new MailSender(); } else if (\"sms\".equals(str)) { return new SmsSender(); } else { System.out.println(\"输入错误...\"); return null; } } } 多个工厂方法模式 该模式是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。 interface Sender { void Send(); } class MailSender implements Sender { @Override public void Send() { System.out.println(\"This is mail sender...\"); } } class SmsSender implements Sender { @Override public void Send() { System.out.println(\"This is sms sender...\"); } } class SendFactory { public Sender produceMail() { return new MailSender(); } public Sender produceSms() { return new SmsSender(); } } public class FactoryPattern { public static void main(String[] args) { SendFactory factory = new SendFactory(); Sender sender = factory.produceMail(); sender.Send(); } } 静态工厂方法模式 将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 interface Sender { void Send(); } class MailSender implements Sender { @Override public void Send() { System.out.println(\"This is mail sender...\"); } } class SmsSender implements Sender { @Override public void Send() { System.out.println(\"This is sms sender...\"); } } class SendFactory { public static Sender produceMail() { return new MailSender(); } public static Sender produceSms() { return new SmsSender(); } } public class FactoryPattern { public static void main(String[] args) { Sender sender = SendFactory.produceMail(); sender.Send(); } } 抽象工厂模式 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要扩展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？ 那么这就用到了抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 interface Provider { Sender produce(); } interface Sender { void Send(); } class MailSender implements Sender { public void Send() { System.out.println(\"This is mail sender...\"); } } class SmsSender implements Sender { public void Send() { System.out.println(\"This is sms sender...\"); } } class SendMailFactory implements Provider { public Sender produce() { return new MailSender(); } } class SendSmsFactory implements Provider { public Sender produce() { return new SmsSender(); } } public class FactoryPattern { public static void main(String[] args) { Provider provider = new SendMailFactory(); Sender sender = provider.produce(); sender.Send(); } } 建造者模式 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性。 import java.util.ArrayList; import java.util.List; abstract class Builder { /** * 第一步：装CPU */ public abstract void buildCPU(); /** * 第二步：装主板 */ public abstract void buildMainBoard(); /** * 第三步：装硬盘 */ public abstract void buildHD(); /** * 获得组装好的电脑 * @return */ public abstract Computer getComputer(); } /** * 装机人员装机 */ class Director { public void Construct(Builder builder) { builder.buildCPU(); builder.buildMainBoard(); builder.buildHD(); } } /** * 具体的装机人员 */ class ConcreteBuilder extends Builder { Computer computer = new Computer(); @Override public void buildCPU() { computer.Add(\"装CPU\"); } @Override public void buildMainBoard() { computer.Add(\"装主板\"); } @Override public void buildHD() { computer.Add(\"装硬盘\"); } @Override public Computer getComputer() { return computer; } } class Computer { /** * 电脑组件集合 */ private List parts = new ArrayList(); public void Add(String part) { parts.add(part); } public void print() { for (int i = 0; i 适配器设计模式 适配器模式是将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的的类的兼容性问题。 主要分三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 类的适配器模式 class Source { public void method1() { System.out.println(\"This is original method...\"); } } interface Targetable { /** * 与原类中的方法相同 */ public void method1(); /** * 新类的方法 */ public void method2(); } class Adapter extends Source implements Targetable { @Override public void method2() { System.out.println(\"This is the targetable method...\"); } } public class AdapterPattern { public static void main(String[] args) { Targetable targetable = new Adapter(); targetable.method1(); targetable.method2(); } } 对象的适配器模式 基本思路和类的适配器模式相同，只是将Adapter 类作修改，这次不继承Source 类，而是持有Source 类的实例，以达到解决兼容性的问题。 class Source { public void method1() { System.out.println(\"This is original method...\"); } } interface Targetable { /** * 与原类中的方法相同 */ public void method1(); /** * 新类的方法 */ public void method2(); } class Wrapper implements Targetable { private Source source; public Wrapper(Source source) { super(); this.source = source; } @Override public void method1() { source.method1(); } @Override public void method2() { System.out.println(\"This is the targetable method...\"); } } public class AdapterPattern { public static void main(String[] args) { Source source = new Source(); Targetable targetable = new Wrapper(source); targetable.method1(); targetable.method2(); } } 接口的适配器模式 接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。 /** * 定义端口接口，提供通信服务 */ interface Port { /** * 远程SSH端口为22 */ void SSH(); /** * 网络端口为80 */ void NET(); /** * Tomcat容器端口为8080 */ void Tomcat(); /** * MySQL数据库端口为3306 */ void MySQL(); } /** * 定义抽象类实现端口接口，但是什么事情都不做 */ abstract class Wrapper implements Port { @Override public void SSH() { } @Override public void NET() { } @Override public void Tomcat() { } @Override public void MySQL() { } } /** * 提供聊天服务 * 需要网络功能 */ class Chat extends Wrapper { @Override public void NET() { System.out.println(\"Hello World...\"); } } /** * 网站服务器 * 需要Tomcat容器，Mysql数据库，网络服务，远程服务 */ class Server extends Wrapper { @Override public void SSH() { System.out.println(\"Connect success...\"); } @Override public void NET() { System.out.println(\"WWW...\"); } @Override public void Tomcat() { System.out.println(\"Tomcat is running...\"); } @Override public void MySQL() { System.out.println(\"MySQL is running...\"); } } public class AdapterPattern { private static Port chatPort = new Chat(); private static Port serverPort = new Server(); public static void main(String[] args) { // 聊天服务 chatPort.NET(); // 服务器 serverPort.SSH(); serverPort.NET(); serverPort.Tomcat(); serverPort.MySQL(); } } 装饰模式 顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。 interface Shape { void draw(); } /** * 实现接口的实体类 */ class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Shape: Rectangle...\"); } } class Circle implements Shape { @Override public void draw() { System.out.println(\"Shape: Circle...\"); } } /** * 创建实现了 Shape 接口的抽象装饰类。 */ abstract class ShapeDecorator implements Shape { protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape) { this.decoratedShape = decoratedShape; } @Override public void draw() { decoratedShape.draw(); } } /** * 创建扩展自 ShapeDecorator 类的实体装饰类。 */ class RedShapeDecorator extends ShapeDecorator { public RedShapeDecorator(Shape decoratedShape) { super(decoratedShape); } @Override public void draw() { decoratedShape.draw(); setRedBorder(decoratedShape); } private void setRedBorder(Shape decoratedShape) { System.out.println(\"Border Color: Red\"); } } /** * 使用 RedShapeDecorator 来装饰 Shape 对象。 */ public class DecoratorPattern { public static void main(String[] args) { Shape circle = new Circle(); Shape redCircle = new RedShapeDecorator(new Circle()); Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(\"Circle with normal border\"); circle.draw(); System.out.println(\"\\nCircle of red border\"); redCircle.draw(); System.out.println(\"\\nRectangle of red border\"); redRectangle.draw(); } } 策略模式 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数。策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。 /** * 抽象算法的策略类，定义所有支持的算法的公共接口 */ abstract class Strategy { /** * 算法方法 */ public abstract void AlgorithmInterface(); } /** * 具体算法A */ class ConcreteStrategyA extends Strategy { //算法A实现方法 @Override public void AlgorithmInterface() { System.out.println(\"算法A的实现\"); } } /** * 具体算法B */ class ConcreteStrategyB extends Strategy { /** * 算法B实现方法 */ @Override public void AlgorithmInterface() { System.out.println(\"算法B的实现\"); } } /** * 具体算法C */ class ConcreteStrategyC extends Strategy { @Override public void AlgorithmInterface() { System.out.println(\"算法C的实现\"); } } /** * 上下文，维护一个对策略类对象的引用 */ class Context { Strategy strategy; public Context(Strategy strategy) { this.strategy = strategy; } public void contextInterface(){ strategy.AlgorithmInterface(); } } /** * 客户端代码：实现不同的策略 */ public class StrategyPattern { public static void main(String[] args) { Context context; context = new Context(new ConcreteStrategyA()); context.contextInterface(); context = new Context(new ConcreteStrategyB()); context.contextInterface(); context = new Context(new ConcreteStrategyC()); context.contextInterface(); } } 代理模式 代理模式指给一个对象提供一个代理对象，并由代理对象控制对原对象的引用。代理可以分为静态代理和动态代理。通过代理模式，可以利用代理对象为被代理对象添加额外的功能，以此来拓展被代理对象的功能。可以用于计算某个方法执行时间，在某个方法执行前后记录日志等操作。 静态代理 静态代理需要我们写出代理类和被代理类，而且一个代理类和一个被代理类一一对应。代理类和被代理类需要实现同一个接口，通过聚合使得代理对象中有被代理对象的引用，以此实现代理对象控制被代理对象的目的。 /** * 代理类和被代理类共同实现的接口 */ interface IService { void service(); } /** * 被代理类 */ class Service implements IService{ @Override public void service() { System.out.println(\"被代理对象执行相关操作\"); } } /** * 代理类 */ class ProxyService implements IService{ /** * 持有被代理对象的引用 */ private IService service; /** * 默认代理Service类 */ public ProxyService() { this.service = new Service(); } /** * 也可以代理实现相同接口的其他类 * @param service */ public ProxyService(IService service) { this.service = service; } @Override public void service() { System.out.println(\"开始执行service()方法\"); service.service(); System.out.println(\"service()方法执行完毕\"); } } //测试类 public class ProxyPattern { public static void main(String[] args) { IService service = new Service(); //传入被代理类的对象 ProxyService proxyService = new ProxyService(service); proxyService.service(); } } 动态代理 JDK 1.3 之后，Java通过java.lang.reflect包中的三个类Proxy、InvocationHandler、Method来支持动态代理。动态代理常用于有若干个被代理的对象，且为每个被代理对象添加的功能是相同的（例如在每个方法运行前后记录日志）。动态代理的代理类不需要我们编写，由Java自动产生代理类源代码并进行编译最后生成代理对象。 创建动态代理对象的步骤： 1）指明一系列的接口来创建一个代理对象 2）创建一个调用处理器（InvocationHandler）对象 3）将这个代理指定为某个其他对象的代理对象 4） 在调用处理器的invoke（）方法中采取代理，一方面将调用传递给真实对象，另一方面执行各种需要的操作 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; /** * 代理类和被代理类共同实现的接口 */ interface IService { void service(); } class Service implements IService{ @Override public void service() { System.out.println(\"被代理对象执行相关操作\"); } } class ServiceInvocationHandler implements InvocationHandler { /** * 被代理的对象 */ private Object srcObject; public ServiceInvocationHandler(Object srcObject) { this.srcObject = srcObject; } @Override public Object invoke(Object proxyObj, Method method, Object[] args) throws Throwable { System.out.println(\"开始执行\"+method.getName()+\"方法\"); //执行原对象的相关操作，容易忘记 Object returnObj = method.invoke(srcObject,args); System.out.println(method.getName()+\"方法执行完毕\"); return returnObj; } } public class ProxyPattern { public static void main(String[] args) { IService service = new Service(); Class clazz = service.getClass(); IService proxyService = (IService) Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), new ServiceInvocationHandler(service)); proxyService.service(); } } 模板方法模式 定义：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。 需求：简单描述一下：本公司有程序猿、测试、HR、项目经理等人，下面使用模版方法模式，记录下所有人员的上班情况 模板方法模式中的三类角色： 1、具体方法(Concrete Method) 2、抽象方法(Abstract Method) 3、钩子方法(Hook Method) // 具体方法 public final void workOneDay() { Log.e(\"workOneDay\", \"-----------------work start----------------\"); enterCompany(); work(); exitCompany(); Log.e(\"workOneDay\", \"-----------------work end----------------\"); } // 工作 抽象方法 public abstract void work(); // 钩子方法 public boolean isNeedPrintDate() { return false; } private void exitCompany() { if (isNeedPrintDate()) { Log.e(\"exitCompany\", \"---\" + new Date().toLocaleString() + \"--->\"); } Log.e(\"exitCompany\", name + \"---离开公司\"); } /** * 重写父类的此方法,使可以查看离开公司时间 */ @Override public boolean isNeedPrintDate() { return true; } 查看所有人员的工作情况： QAWorker qaWorker = new QAWorker(\"测试人员\"); qaWorker(); HRWorker hrWorker = new HRWorker(\"莉莉姐\"); hrWorker.workOneDay(); ... 查看程序猿离开公司的时间: ITWorker itWorker = new ITWorker(\"jingbin\"); itWorker.workOneDay(); No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Coding/设计模式六大原则.html":{"url":"07_项目管理/Coding/设计模式六大原则.html","title":"设计模式六大原则","keywords":"","body":"1、单一职责原则（Single Responsibility Principle） 单一职责原则，也是说一个类或者模块应该只有一个引起它变化的原因。 一个类只负责一项职责：类或者模块应该专注于完成一项任务或者实现一个功能。如果一个类承担了过多的责任，那么它的职责就会变得模糊不清，难以理解和维护。 高内聚性：单一职责原则鼓励高内聚性，即将相关的功能组织在一起，而不是将不相关的功能混合在一起。这样可以使得代码更加清晰和易于理解。 低耦合性：通过将不同的职责分离到不同的类或者模块中，可以降低类之间的耦合度。这样一来，当一个职责发生变化时，不会影响到其他职责，提高了代码的灵活性和可维护性。 2、里氏替换原则（Liskov Substitution Principle） 里氏替换原则要求子类能够替换掉父类，并且程序行为保持一致。 子类必须完全实现父类的方法：子类可以扩展父类的方法，但不能改变父类方法的原有行为。 子类的方法签名应该与父类一致：子类重写的方法参数类型和返回类型应该与父类一致或更宽松。 子类不能违背父类的预期行为：子类实现的方法不能违背父类的逻辑约定，比如如果父类的某个方法不应该抛出异常，那么子类重写该方法时也不应抛出异常。 继承层次中的里氏替换：在继承层次中，任何可以使用基类实例的地方，都应该可以使用子类实例而不改变程序的功能和结果。 3、依赖倒转原则（Dependence Inversion Principle） 依赖倒置原则（Dependency Inversion Principle，DIP）是面向对象设计中的一个重要原则，它强调高层模块不应该依赖于低层模块，而是应该依赖于抽象。具体来说，依赖倒置原则包含以下两个核心概念： 高层模块不应该依赖于低层模块：高层模块通常是指应用程序的主要逻辑和业务逻辑，而低层模块通常是指与具体实现相关的类或者模块。依赖倒置原则要求高层模块不应该直接依赖于低层模块，而是应该依赖于抽象。换句话说，高层模块不应该直接调用具体实现的类，而应该通过接口或者抽象类来访问低层模块。 抽象不应该依赖于具体实现：抽象是指接口、抽象类或者抽象方法，它们定义了高层模块与低层模块之间的约束关系。依赖倒置原则要求抽象不应该依赖于具体实现，而是应该具有稳定的抽象性质，使得高层模块可以独立于具体实现进行变化和扩展。 4、开闭原则（Open Close Principle） 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。 对扩展开放（Open for Extension）：意味着软件实体应该允许在不修改现有代码的情况下进行扩展。当需求发生变化时，我们应该通过添加新的代码来实现新功能，而不是修改已有的代码。 对修改关闭（Closed for Modification）：意味着一旦软件实体已经完成设计和开发，并且通过测试和验证，就应该尽量避免对其进行修改。修改已有的代码可能会引入新的错误，导致系统不稳定。 5、接口隔离原则（Interface Segregation Principle） 客户端不应该被迫依赖于它们不使用的接口。 接口应该足够小：接口应该只包含客户端所需的方法，而不应该强迫客户端实现它们不需要的方法。一个接口应该只为一个特定的客户端或者使用场景服务。 客户端不应该依赖于它们不使用的接口：客户端不应该被迫依赖于它们不需要的接口。如果一个接口包含了太多的方法，而客户端只需要其中一部分，那么客户端就会受到接口的影响，导致代码的耦合度增加，不利于系统的扩展和维护。 接口隔离原则的核心思想是将庞大臃肿的接口拆分为更小更专用的接口，从而降低接口之间的耦合度，提高系统的灵活性和可维护性。具体来说，可以通过以下几种方式来实现接口隔离原则： 根据职责拆分接口：将一个大接口拆分为多个小接口，每个接口只包含相关的方法，从而确保接口的职责单一。 使用接口继承：使用接口继承来定义更小更专用的接口，客户端可以根据需要选择性地实现这些接口。 适配器模式：使用适配器模式来将一个大接口适配为多个小接口，从而实现接口隔离原则。 代理模式：使用代理模式来代理一个大接口，客户端可以通过代理对象来调用所需的方法，而不需要依赖于整个大接口。 6、迪米特法则（最少知道原则）（Demeter Principle） 迪米特法则的核心思想是：一个对象应该对其他对象有尽可能少的了解。换句话说，一个对象应该尽量减少对其他对象的直接交互，而是通过中介者、代理等方式来间接地与其他对象进行通信。这样可以降低系统的耦合度，提高系统的灵活性和可维护性。 只与直接的朋友通信：一个对象只应该与其直接的朋友进行通信，而不应该与陌生的对象进行通信。所谓直接的朋友是指以下几种情况： 该对象本身； 该对象的成员对象； 该对象所创建或者实例化的对象； 该对象的方法中的参数。 减少对象之间的依赖关系：对象之间的依赖关系应该尽量减少，避免出现过多的直接耦合。通过中介者、代理等方式来减少对象之间的直接关联，提高系统的灵活性和可维护性。 封装对象的行为：对象应该将自己的行为封装起来，暴露给外部的只是必要的接口，而不是将所有的行为都公开出去。这样可以降低对象之间的耦合度，提高系统的内聚性。 7、合成复用原则（Composite Reuse Principle） 合成复用原则的核心思想是：应该优先使用对象组合（Composition）或聚合（Aggregation）等弱关联关系来实现代码复用，而不是通过继承来实现。换句话说，尽量使用对象之间的合成关系来组织代码结构，而不是通过类之间的继承关系来实现代码的复用。 优先使用组合关系：将对象的部分功能封装在其他对象中，通过组合关系来实现复用。例如，将对象作为另一个对象的成员变量，从而实现对象之间的组合关系。 避免使用继承关系：尽量避免使用类之间的继承关系来实现代码复用。虽然继承可以实现代码的复用，但它会增加类之间的耦合度，使得系统更加脆弱和难以维护。 多使用抽象：在设计时，尽量使用抽象类或者接口来定义对象之间的关系，而不是依赖于具体的实现。这样可以使得代码更加灵活和易于扩展。 封装变化：将可能发生变化的部分封装起来，从而使得系统的变化对其他部分的影响最小化。通过合成复用原则，可以将对象的变化局部化，降低了系统的耦合度。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Git/":{"url":"07_项目管理/Git/","title":"Ebook","keywords":"","body":"Git No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Git/ebook/REFERS.html":{"url":"07_项目管理/Git/ebook/REFERS.html","title":"Refers","keywords":"","body":" GitHub入门与实践 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Git/Git-命令.html":{"url":"07_项目管理/Git/Git-命令.html","title":"Git-命令","keywords":"","body":"Repo 初始化 $ git init git init命令只做一件事，就是在项目根目录下创建一个.git子目录，用来保存版本信息。 $ ls .git branches/ config description HEAD hooks/ info/ objects/ refs/ 配置 查看版本 git --version 配置全局用户名和邮箱 git config —global user.name “name” git config —global user.email “email address” 配置当前仓库用户名和邮箱 git config user.name “name” git config user.email “email address” 找到.gitconfig文件 git config --list --show-origin 查看远程仓库 git remote -v 关联远程仓库 git remote add origin git@github.com:sony-netapp/SearchApp4China.git 删除远程仓库 git remote rm 修改远程 Git 仓库的地址 git remote set-url WorkZone 快照 放弃工作区中全部的修改 git checkout . 放弃工作区中某个文件的修改： git checkout -- filename 列出缓存区中文件与上一次提交的区别（新增、更改、删除） git status 生成快照 git commit -m \"commit message\" 切换快照 git checkout {snapchat-hash} 展示某个快照的所有代码改动 git show {snapchat-hash} 查看本地提交历史 git log 显示可引用的本地历史版本记录 git reflog 强制跳转回退到某个版本 git reset --hard 缓存区 add 会提交当前工作区中当前目录(包括子目录)下所有的文件改动。 注意：在Git Version 1.x中：会将当前工作区中当前目录(包括子目录)下的所有新文件和对已有文件的改动提交至暂存区，但不包括被删除的文件。 git add . 只会监控当前整个工作区中之前已被 add 的文件，即已被跟踪(tracked)的文件，也就是只会将当前整个工作区中被修改和被删除的文件提交至暂存区。而新文件因为未被跟踪(untracked)，所以不会被提交至暂存区。 git add -u git add --update 它会将当前整个工作区中所有的文件改动提交至暂存区，包括新增、修改和被删除的文件，不受当前所在目录限制 注意： git add -A 不属于 git add . 和 git add -u 。因为 git add . 只会提交当前目录(包括子目录)下的新文件和对已有文件的改动，而 git add -A 不受当前目录限制。也就是说，git add . 和 git add -u 功能的合集只能属于 git add -A 功能的子集。 git add -A git add --all 添加单个文件 git add 表示添加当前目录(包括子目录)下的所有文件改动，但不包括文件名以 . 符号开头的文件的改动 git add * reset 从暂存区中删除文件，相当于git add 的撤销操作 git reset . 回退到某次commit但不修改本地文件 git reset --soft rm 从缓存区中删除的意思是不再跟踪此文件的修改 不删除物理文件，仅将该文件从缓存中删除 git rm --cached 不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶） git rm --f clean 删除不在缓存区的文件 git clean -f #删除文件 git clean -fd #删除文件和目录 git clean -xfd #不会连 gitignore 的untrack 文件/目录也一起删掉 (慎用,一般这个是用来删掉编译出来的 .o之类的文件用的) git clean -nxfd # 在用上述 git clean 前,墙裂建议加上 -n 参数来先看看会删掉哪些文件,防止重要文件被误删 提交 将本地git记录添加到远程 git commit -m \"modify DownloadUri from PRD to DEV\" git commit 后在vim编辑提交说明，shift+zz保存退出 如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用git push git push -u 强制提交，回退版本时使用 git push -f Branch 本地 查看本地分支 git branch 在本地创建新分支 git branch creates a new branch from the current HEAD, and switches the working directory to the new branch git checkout -b 拉取远程分支并merge到本地 git pull origin : 删除本地分支 git branch -d 查看所有分支 git branch -a 修改分支名字 git branch -m 合并两个分支，处于哪个分支，就合并到哪个分支上 git merge A //将A分支合并到当前分支上 git merge A B //将A分支和B分支合并到当前分支上 远程 创建远程分支 git push origin origin_branch:local_branch 查看远程分支的提交 git log origin/branch-name git log HEAD...origin/branch-name 切换到远程分支 git checkout -b new-branch-name remote-branch-name git checkout -b sony/banko/s-develop-01 origin/sony/banko/s-develop-01 删除远程分支 git push origin --delete pullrequest_Valhalla2_dev 拉取远程仓库最新更新 git pull origin Commit 修改上一次的commit-msg，后面不要接新的message，进入vim修改 git commit --amend Tag 本地创建 git tag v0.1 本地删除（不会删除远程的标签） git tag -d v0.1 推送本地标签到远程 git push origin v0.1 一次性推送全部尚未推送到远程的本地标签 git push origin --tags 从远程删除标签 git push origin :refs/tags/v0.1 Merge 列出冲突的文件 git diff --name-only --diff-filter=U Patch的使用 打patch //将暂存区的文件与上一次Commit生成patch包 git diff --cached > changes.patch 使用补丁 git apply changes.patch Rebase的使用 1.可以修改Commit-msg和commit内的文件内容 git rebase -i HEAD~N 2.在弹出的界面中pick -- > edit修改commit消息 3.输入下面的命令开始修改 git commit --amend 4.输入下面的命令保存 git rebase --continue 5.回到第三步继续修改 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Git/Git-四个工作区原理及命令.html":{"url":"07_项目管理/Git/Git-四个工作区原理及命令.html","title":"Git-四个工作区原理及命令","keywords":"","body":"一、概念 1、四个工作区域 Git本地有四个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)、git仓库(Remote Directory)。文件在这四个区域之间的转换关系如下： Workspace： 工作区，就是你平时存放项目代码的地方 Index / Stage： 暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository： 仓库区（或版本库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 ​ Remote： 远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 2、工作流程 git的工作流程一般是这样的： １、在工作目录中添加、修改文件； ２、将需要进行版本管理的文件放入暂存区域； ３、将暂存区域的文件提交到git仓库。 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed) 3、文件的四种状态 版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 GIT不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用 SHA-1算法计算文件的校验和。 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. ​ 如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, ​ 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, ​ 文件状态为Modified 下面的图很好的解释了这四种状态的转变： 新建文件--->Untracked 使用add命令将新建的文件加入到暂存区--->Staged 使用commit命令将暂存区的文件提交到本地仓库--->Unmodified 如果对Unmodified状态的文件进行修改---> modified 如果对Unmodified状态的文件进行remove操作--->Untracked 二、四个区域常用命令 将工作区的文件添加到暂存区 # 添加指定文件到暂存区 git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 git add [dir] # 添加当前目录的所有文件到暂存区 git add . 从暂存区删除文件，不改变工作区状态 #当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 这个时候直接push那边这个文件就没有，如果push之前重新add那么还是会有。 git rm --cached file_path 从暂存区与工作区删除文件 #当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用（⚠️） git rm file_path 从暂存区将文件恢复到工作区 #直接加文件名 从暂存区将文件恢复到工作区，如果工作区已经有该文件，则会选择覆盖 #加了【分支名】 +文件名 则表示从分支名为所写的分支名中拉取文件 并覆盖工作区里的文件 git checkout 从版本库删除提交或文件 #移除不必要的添加到暂存区的文件 git reset HEAD 文件名 #去掉上一次的提交（会直接变成add之前状态） （暂存区清空） git reset HEAD^ #去掉上一次的提交（变成add之后，commit之前状态） （暂存区不变） git reset --soft HEAD^ 存储本地修改 git stash // 存储本地修改到暂存区 git stash pop // 将暂存区释放到本地工作目录 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Git/Git-操作原理.html":{"url":"07_项目管理/Git/Git-操作原理.html","title":"Git-操作原理","keywords":"","body":"Branch 一个快照构成的连续的单向链表称作分支，每个分支有一个指向该分支快照的指针 在git中路径也被当做文件夹处理 每次提交会创建一个子版本，子版本来自于上一个父版本 这一系列的版本称为branch/stream。在git中main stream称作HEAD 所谓分支（branch）就是指向某个快照的指针，分支名就是指针名。 分支会自动更新，如果当前分支有新的快照，指针就会自动指向它。 Git 有一个特殊指针HEAD， 总是指向当前分支的最近一次快照。Git 还提供简写方式，HEAD^指向 HEAD的前一个快照（父节点），HEAD~6则是HEAD之前的第6个快照。 每一个分支指针都是一个文本文件，保存在.git/refs/heads/目录，该文件的内容就是它所指向的快照的二进制对象名（哈希值）。 Merge 合并拥有同一父节点的分支 git merge –abort There are changes in both branches, but they conflict. In this case, the conflicting result is left in the working directory for the user to fix and commit, or to abort the merge with git merge –abort. Rebase 重定向分支指针 CherryPick 选一个分支中一个或者几个commit来应用提交到另外一个分支 Revert No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Git/Git-环境.html":{"url":"07_项目管理/Git/Git-环境.html","title":"Git-环境","keywords":"","body":"安装 Git https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496 Android Studio 中 Git的配置及协同开发 https://cloud.tencent.com/developer/article/1739792 git命令行 安装UbuntuGUI tasksel: a utility for installing multiple related packages at once. See the documentation for more details. slim: A display manager is an application that starts the display server, launches the desktop, and manages user authentication 搭建git服务器 https://zhuanlan.zhihu.com/p/40371444 mkdir COVID-19_Map.git root@iZt4n2r37at459efgntordZ:/home/git# git init --bare COVID-19_Map.git/ Initialized empty Git repository in /home/git/COVID-19_Map.git/ root@iZt4n2r37at459efgntordZ:/home/git# chown -R git COVID-19_Map.git/ No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Git/Git-问题及处理.html":{"url":"07_项目管理/Git/Git-问题及处理.html","title":"Git-问题及处理","keywords":"","body":"【同一个电脑上添加两个github仓库】 https://blog.csdn.net/qq_34634812/article/details/90168486 【windows下启动git bash每次启动自动添加ssh-agent和ssh-add密钥】 https://blog.csdn.net/wobofan2006/article/details/126505622 【Git: ‘LF will be replaced by CRLF the next time Git touches it‘ 问题解决与思考】 Git: ‘LF will be replaced by CRLF the next time Git touches it‘ 问题解决与思考-CSDN博客 【push 大文件时可能遇到的问题，网络缓存不够】 ## 设置http缓存为1000M（大小可以根据需要自行更改） git config --global http.postBuffer 1048576000 ## 设置https缓存为1000M git config --global https.postBuffer 1048576000 【修改了.gitignore文件中的规则，之前的commit有需要忽略的文件，可以清除缓存区后重新提交】 清空缓存区： git rm -r --cached . 【比较同一分支两个提交之间的差别】 https://github.com/sony-netapp/HomeAccount4China/compare/a90579c3f95667aff72cd0f630db42dd72d5ade3...bb95b720cbf7ef2acb7d14c8f816e7bd194c2c54 【删除本地不存在于远程的分支】 git fetch --prune git branch -vv | grep ': gone]' | awk '{print $1}' | xargs -r git branch -d 【修改Commit-msg】 git commit --amend //长消息 git commit --amend -m \"\" //短消息 git push --force 【怎样解决不小心将修改提交到本地的主分支无法触发PR的问题】 1.将本地的主分支重命名为PR分支名称 git branch -m Main PR 2.将本地的PR分支Push到远程的同时，重新设置upstream分支 原本upsteam分支应该设置为了主分支，如果不重新设置会push到主分支上 git push origin --set-upstream origin PR 3.重新从远程拉取开发分支 git checkout Main 4.创建PR 【怎样解决不小心将修改提交到远程的主分支无法触发PR的问题】 1.将本地的主分支重命名为PR分支名称 git branch -m Main PR 2.将本地的PR分支Push到远程的同时，重新设置upstream分支 原本upsteam分支应该设置为了主分支，如果不重新设置会push到主分支上 git push origin --set-upstream origin PR 3.重新从远程拉取开发分支 git checkout Main 4.将commit reset 到修改前的节点，并push --force到远程 git reset --hard 107d523a2fa7540421a65476c28313de44c3da4c 5.创建PR 【删除本地不存在于远程的分支】 git fetch --prune git branch -vv | grep ': gone]' | awk '{print $1}' | xargs -r git branch -d 【在Commit中删除新加入gitignore的文件】 git rm --cached 然后正常commit即可 【替换Commit历史记录中的AuthorEmail，删除Remote】 //可能要多次执行 git filter-branch --env-filter 'OLD_EMAIL=\"aki_98@163.com\"; CORRECT_NAME=\"5109U25854\"; CORRECT_EMAIL=\"qingqiu.li@sony.com\"; if [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ]; then export GIT_COMMITTER_NAME=\"$CORRECT_NAME\"; export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\"; fi; if [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ]; then export GIT_AUTHOR_NAME=\"$CORRECT_NAME\"; export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\"; fi;' --tag-name-filter cat -- --branches --tags 执行完后删除.git\\refs\\original 和 .git\\refs\\remote下的文件 【如何排除gitignore的文件后打包整个仓库？】 git clone D:\\\\temp\\\\Automation D:\\\\temp\\\\Automation_LQQ_OnTracked 打包temp仓库 【修改远程分支的名字】 要修改 Git 远程分支的名字，可以按照以下步骤进行： 重命名本地分支 首先，将本地的分支名称修改为新的名称。 # 切换到你想要重命名的分支 git checkout old-branch-name # 重命名本地分支 git branch -m new-branch-name 删除远程的旧分支 将旧的远程分支删除： # 删除远程的旧分支 git push origin --delete old-branch-name 推送新分支到远程仓库 将新命名的本地分支推送到远程仓库： git push origin new-branch-name 设置新的远程追踪分支（可选） 推送新分支后，Git 不会自动将它设置为追踪分支。你可以通过以下命令让本地分支追踪新的远程分支： git branch --set-upstream-to=origin/new-branch-name 清理旧的本地远程分支引用（可选） 最后，你可以清理掉对旧的远程分支的本地引用： git fetch --prune No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Git/git_submodule.html":{"url":"07_项目管理/Git/git_submodule.html","title":"Git submodule","keywords":"","body":"git submodule 是 Git 提供的一种机制，用于在一个 Git 仓库（称为主仓库或父仓库）中嵌入另一个 Git 仓库（称为子模块）。通过子模块，你可以在主项目中包含和管理独立的外部项目，同时保持它们各自的 Git 历史和版本控制。 主要特性和用途： 模块化管理代码：当你的项目依赖其他仓库（例如第三方库或共享组件）时，子模块可以将这些外部项目纳入到你的项目中，便于同步和维护。 独立版本控制：每个子模块有自己的 Git 仓库，保持与主仓库分离的提交历史和版本控制。这样即使子模块更新了，你的主项目不需要同时更新。 版本固定：子模块的引用保留在主仓库的特定版本上。因此，当你拉取或克隆主仓库时，子模块会固定在你指定的特定版本，而不会自动更新为子模块的最新版本。 使用场景： 当你的项目依赖于某个外部库时，你希望将这个外部库作为独立的 Git 仓库来管理。 需要在多个项目中共享某个代码模块，并希望所有项目都保持这个模块的历史和版本独立。 子模块的常见操作： 添加子模块： ``` bash Copy code git submodule add [path] 这会将外部项目作为子模块添加到当前项目中，并将子模块的引用保存在 `.gitmodules` 文件中。 2. **初始化和更新子模块**： 当你克隆一个包含子模块的仓库时，你需要使用以下命令来初始化和获取子模块的内容： bash Copy code git submodule update --init --recursive 这会下载并更新子模块到你当前仓库中记录的版本。 3. **更新子模块的版本**： 当你想要更新子模块到最新版本或特定的版本时，进入子模块目录并执行常规的 Git 命令： bashCopy codecd git fetch git checkout 4. **删除子模块**： 如果你不再需要某个子模块，可以使用以下步骤来删除它： - 删除 `.gitmodules` 文件中的相关条目。 - 从 Git 索引中删除子模块路径： bash Copy code git rm --cached ``` 删除子模块的目录文件。 子模块的优缺点： 优点： 让你能够将外部项目作为依赖项集成到项目中，同时保持它们的独立性。 适用于大型项目，能有效管理跨项目共享代码。 缺点： 操作相对复杂，尤其是在多人协作时，可能需要更多的手动步骤来保持子模块的同步和更新。 在克隆和拉取仓库时，可能需要额外的步骤来获取子模块的内容。 子模块为管理复杂项目提供了模块化的好方法，但也可能引入一些管理上的复杂性。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Git/imgs/REFERS.html":{"url":"07_项目管理/Git/imgs/REFERS.html","title":"Refers","keywords":"","body":" image-134546yt No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Git/REFERS.html":{"url":"07_项目管理/Git/REFERS.html","title":"Refers","keywords":"","body":" .gitignore No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Jira/Jira（一）核心概念.html":{"url":"07_项目管理/Jira/Jira（一）核心概念.html","title":"Jira（一）核心概念","keywords":"","body":"1.Project项目 项目的业务概念比较清晰，也容易理解。在JIRA系统中的项目概念是一组问题单（Issue）的集合，项目可以根据组织需求来定义，例如：软件研发项目，市场营销活动，服务台（helpdesk）系统，一个请假管理系统等等。每一个问题单属于一个项目。每个项目需要有一个名称（例如：Website Issues）和关键字（Key，例如WEB）。项目的关键字会成为项目问题单前缀，例如WEB-101, WEB-102等等。 组件是什么（Component） 组件是项目中对问题单的一种逻辑分组，例如上图中的UI，DB，Server和Bug，组件一个项目根据组织的需要可能会包括多种组件。 举例而言，一个软件开发项目可以包括如下组件：文档，后端，邮件子系统，界面。一个网站系统可能包括产品，联系方式等组件。在一个项目中，一个问题单可以归属于0到多个组件。 版本是什么（Version） 对于一些类型的项目，尤其是软件研发项目，把一个问题单关联到一个特定的项目版本（例如：1.0 beta, 1.0, 1.2, 2.0）会非常有用。 问题单（Issues）有两个跟版本有关的字段： 影响版本（Affects Version(s)） — 这个是要说明受问题单影响的版本.举例而言，一个软件Bug可能影响1.1和1.2版本。 修复版本（Fix Version(s)） — 这个是为了标明这个问题单在哪一个版本中被修复。继续上例，Bug的影响版本号是1.1和1.2，但是可能会在版本2.0中才被修复。 没有修复版本号的问题单会被归类为未规划（Unscheduled）。 版本可以是下面三种状态之一：发布（Released），未发布（Unreleased）和归档（Archived）。版本会有一个发布日期，并且如果在发布日期之后还没有按时发布，这个状态会自动变为过期状态（overdue）。 2.Workflow（工作流） JIRA中的工作流由一系列的状态（statuses）和变迁（transitions）构成，一个问题单在其生命周期中会经过这些状态和变迁。下图为例： 3.Issue（问题单） JIRA的问题单非常灵活，页面可以定制，字段也可以定义。这里介绍一些内置的基本概念。 Issue Type（问题单类型） JIRA可以用来跟踪不同类型的问题单。默认类型如下，JIRA的系统管理员也可能会定制这些类型。 Bug — 故障，功能失效 Improvement — 提升，既有功能增强 New Feature — 新功能 Task — 任务 Custom Issue — 根据需要客户化定制 Priority（优先级） 优先级也可以自定义，系统默认优先级如下： Highest — 最高级别，表明问题阻塞了业务流程正常进行 High — 高级，表明问题引发明显故障，需要紧急关注 Medium — 中级，表明问题有一个明显的影响 Low — 低级，表明问题有一个轻微的影响 Lowest — 最低级 Status（状态） 每一个问题单都会有一个当前的状态。一个问题单开始阶段可能是Open状态，然后可以转移到Resolved或者Closed，依赖于系统流程配置的方式。内置的常见状态如下： Open — 打开状态，表明问题单已经被创建，等待被分配到开始处理状态。 In Progress — 处理中状态，表明问题单已经被分配人激活，并处于被处理状态中. Resolved — 已解决状态，表明问题已经被处理完成，等待问题报告人的验证。从这个状态，问题单一般可以进一步变更为重新打开状态（Reopened）或关闭状态（Closed）。 Reopened — 重新打开状态，问题经过验证发现没有被解决，就可以变更到这个状态。 Closed — 关闭状态，问题被彻底解决就可以转为这个状态。 Resolution（决议） 一个问题可以有多种解决结果，其中只有一种方法是修复。一个解决结果通常会在状态变更时候被设置起来。系统默认的问题解决结果会有以下几种： Fixed — 修复。 Won't Fix — 不用修复。例如这个问题所描述的现象已不再有影响了。 Duplicate — 重复。同其它已经存在的问题重复了，推荐把相关的单子链接起来. Incomplete — 未完成。没有足够的信息继续完成这个问题。 Cannot Reproduce — 不能重现。如果以后有更多信息可以继续可以重新打开这张单子. Won't Do — 不做。类似于不用修复的方案，试用于软件项目的默认状态。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Jira/REFERS.html":{"url":"07_项目管理/Jira/REFERS.html","title":"Refers","keywords":"","body":" Jira（三）Xray - 基于JIRA的测试管理插件 Jira（二）配置和使用 Jira（四）高级搜索（JQL） No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Uml/UML.html":{"url":"07_项目管理/Uml/UML.html","title":"Uml","keywords":"","body":"一、UML简介 (一)UML (Unified Modeling Language)为面向对象软件设计提供统一的、标准的、可视化的建模语言。适用于 描述以用例为驱动，以体系结构为中心的软件设计的全过程。 (二)UML的定义包括UML语义和UML表示法两个部分。 1.UML语义:UML对语义的描述使开发者能在语义上取得一致认识，消除了因人而异的表达方法所造成的影响； 2.UML表示法:UML表示法定义UML符号的表示法，为开发者或开发工具使用这些图形符号和文本语法为系统建模提供了标准. 二、UML模型图的构成 （一）事物[Things] (4种)： UML模型中最基本的构成元素，是具有代表性的成分的抽象 1. 构件事物： UML模型的静态部分，描述概念或物理元素 类:具有相同属性相同操作相同关系相同语义的对象的描述 接口:描述元素的外部可见行为，即服务集合的定义说明 协作:描述了一组事物间的相互作用的集合 用例:代表一个系统或系统的一部分行为，是一组动作序列的集合 构件:系统中物理存在，可替换的部件 节点:运行时存在的物理元素 另外，参与者、信号应用、文档库、页表等都是上述基本事物的变体 2. 行为事物： UML模型图的动态部分，描述跨越空间和时间的行为 交互:实现某功能的一组构件事物之间的消息的集合，涉及消息、动作序列、链接 状态机:描述事物或交互在生命周期内响应事件所经历的状态序列 3. 分组事物： UML模型图的组织部分，描述事物的组织结构 包:把元素组织成组的机制 4. 注释事物： UML模型的解释部分，用来对模型中的元素进行说明、解释 注解:对元素进行约束或解释的简单符号 （二）关系[Relationships]： 关系把事物紧密联系在一起 依赖[dependency]是两个事物之间的语义关系，其中一个事物(独立事物)发生变化，会影响到另一个事物(依赖事物)的语义 关联[association]是一种结构关系，它指明一个事物的对象与另一个事物的对象间的联系 泛化[generalization]是一种特殊/一般的关系。也可以看作是常说的继承关系 实现[realization]是类元之间的语义关系，其中的一个类元指定了由另一个类元保证执行的契约 （三）图[Diagrams]： 图是事物和关系的可视化表示 1. 用例图[Use Case Diagram]: 用例图是从用户角度描述系统功能， 是用户所能观察到的系统功能的模型图，用例是系统中的一个功能单元 2. 类图[Class Diagram]: (1)类图描述系统中类的静态结构。不仅定义系统中的类，表示类之间的联系如关联、 依赖、聚合等，也包括类的内部结构(类的属性和操作); (2)类图是以类为中心类组织的，类图中的其他元素或属于某个类或与类相关联 3. 对象图[Object Diagram]: 对象图是类图的实例，几乎使用与类图完全相同的标识。 他们的不同点在于对象图显示类的多个对象实例，而不是实际的类 4. 顺序图[Sequence Diagram]: (1)顺序图显示对象之间的动态合作关系,他强调对象之间消息发送的顺序，同时显示对象之间的交互; (2)顺序图的一个用途是用来表示用例中的行为顺序。当执行一个用例行为时，顺序图中的每条消息对应了一个类操作或引起状态转换的触发事件 5. 协作图[Collaboration Diagram]: (1)协作图描述对象间的协作关系，协作图跟顺序图相似，显示对象间的动态合作关系。除显示信息交换外，协作图还显示对象以及他们之间的关系。 (2)协作图的一个用途是表示一个类操作的实现 6. 状态图[State Chart Diagram]: 状态图是一个类对象所可能经历的所有历程的模型图。状态图由对象的各个状态和连接这些状态的转换组成 7. 活动图[Activity Diagram]: (1)活动图是状态图的一个变体，用来描述执行算法的工作流程中涉及的活动 (2)活动图描述了一组顺序的或并发的活动 8. 构件图[Component Diagram]: 构件图为系统的构件建模型——构件即构造应用的软件单元——还包括各构件之间的依赖关系，以便通过这些依赖关系来估计对系统构件的修改给系统可能带来的影响 9. 部署图[Deployment Diagram]: 部署视图描述位于节点实例上的运行构件实例的安排。节点是一组运行资源，如计算机、设备或存储器。这个视图允许评估分配结果和资源分配 各UML图的关系 三、UML语法描述 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Uml/时序图.html":{"url":"07_项目管理/Uml/时序图.html","title":"时序图","keywords":"","body":"一、定义 UML时序图一般用于确认和丰富一个使用情境的逻辑。 一个使用情境的逻辑或是一个用例的一部分；或是一条扩展路径；或是一个贯穿单个用例的完整路径，例如动作基本过程的逻辑描述；或是动作的基本过程的一部分再加上一个或多个的备用情境的逻辑描述；或是包含在几个用例中的路径。 时序图将交互关系表现为一个二维图，纵向是时间轴，时间沿竖线向下延伸。横向轴代表了在协作中各独立对象的类元角色，类元角色的活动用生命线表示。 二、时序图示例 三、时序图的组成元素 生命线用一条纵向虚线表示。 在UML中，对象表示为一个矩形，其中对象名称标有下划线。 激活是过程的执行，包括等待过程执行的时间。在时序图中激活部分替换生命线，使用长条的矩形表示。 消息是对象之间的通信，是两个对象之间的单路通信，是从发送者到接收者之间的控制信息流。消息在时序图中由有标记的箭头表示，箭头从一个对象的生命线指向另一个对象的生命线，消息按时间顺序在图中从上到下排列。 在时序图中，对象安排在X轴。启动交互的对象放在最左边，随后放入消息的对象放在启动交互对象的右边。交互中对象发送和接收的消息沿着Y轴以时间增加的次序放置。在时序图中，有的消息对应于激活，表示它将会激活一个对象，这种消息称为调用消息(Call Message)；如果消息没有对应激活框，表示它不是一个调用消息，不会引发其他对象的活动，这种消息称为发送消息(Send Message)。 消息 调用消息&&返回消息&&自身消息 调用消息&&发送消息 创建消息&&销毁消息 同步消息：发送消息的对象要等到接收消息的对象执行完所有操作后，发送消息的对象才能继续执行自己的操作。 异步消息：发送消息的对象发送消息后，不用等待接收对象是否执行，继续执行自己的操作。 交互片段 一个复杂的时序图可以划分为几个小块，每一个小块称为一个交互片段。每个交互片段由一个大方框包围，其名称显示在方框左上角的间隔区内，表示该时序图的信息。常用操作符如下： alt:多条路径，条件为真时执行。 opt:任选，仅当条件为真时执行。 par:并行，每一片段都并发执行。 loop:循环，片段可多次执行。 critical:临界区，只能有一个线程对它立即执行。 四、时序图的作用 对于业务人员，时序图可显示不同的业务对象如何交互，对于交流当前业务如何进行很有用。除记录组织的当前事件外，一个业务级的时序图能被当作一个需求文件使用，为实现一个未来系统传递需求。 对于需求分析人员，时序图能通过提供一个深层次的表达，把用例带入下一层次。通常用例被细化为一个或者更多的时序图。时序图的主要用途之一，是把用例表达的需求，转化为进一步、更深层次的精细表达。 对于技术人员，时序图在记录一个未来系统的行为应该如何表现时非常有用。在设计阶段，架构师和开发者能使用时序图挖掘出系统对象间的交互，进一步完善整个系统的设计。 五、时序图绘制技巧 以用例为单位创建时序图，针对每个用例，考察为完成它所描述的功能需要哪些对象的操作参与执行，并且进一步考察这些操作的执行需要通过消息而引起其他哪些对象操作的执行。把这些对象以及参与交互的执行者组织到一个时序图中。 理论上需要为每一个用例创建一个时序图，但是如果一个用例的交互对象很简单可以不需要创建时序图。 时序图绘制步骤： 确定参与交互的执行者 确定与执行者直接交互的对象 确定与交互相关的全部对象（顺藤摸瓜） 如果需要考察单个用例内部多个对象的行为可以使用时序图； 如果需要考察单个对象的行为就需要使用状态图； 如果需要考察跨用例或者跨线程的行为就需要考虑使用活动图。 需求分析阶段的时序图：主要用于描述用例中对象之间的交互，可以使用自然语言来绘制，用于细化需求。从业务的角度进行建模，用描述性的文字叙述消息的内容。 系统设计阶段的时序图：确切表示系统设计中对象之间的交互，考虑到具体的系统实现，对象之间通过方法调用传递消息。 六、实例 绘制图书管理系统“借书”用例的时序图（业务模型）。 图书管理员打开借书界面，输入借书信息并提交借书请求；系统验证借书卡状态，如果借书卡未借书则记录借书信息且修改图书状态和借书卡状态，并提示借书成功；否则提示借书失败。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"07_项目管理/Uml/类图.html":{"url":"07_项目管理/Uml/类图.html","title":"类图","keywords":"","body":"注释 元素 类 类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示： 类的访范围： “+” Public “-” Private “#” Protected 不同参数的“方向”， “in” The parameter is an input parameter. “Inout” The parameter is capable of both input and output. “Out” The parameter is an output parameter. 类中不同类型的成员， 1) Static members are represented as underlined. 静态函数带下划线表示 2) Pure virtual functions are represented as italics. 虚函数用斜体表示 类的属性的完整表示方式： 可见性 名称：类型[ = 缺省值] //中括号中的内容表示是可选的 类的方法的完整表示方式: 可见性 名称(参数列表) [ ： 返回类型] //中括号中的内容是可选的。 接口 接口是一种特殊的类，具有类的结构但不可被实例化，只可以被实现（继承）。 两种表示方法： 类与类之间的关系 依赖 (Dependency) (uses a) 使用：虚线箭头 只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没 有对方，编绎通过不了。 排除其他关系后再使用这个关系 public class PersonDao{} //类中用到了对方： public class IDCard{} //如果是类的成员属性 public class Person{} //如果是方法的返回类型 public class Department{} //是方法接收的参数类型 public class PersonServiceBean { //方法中使用到 private PersonDao personDao; public IDCard getIDCard(Integer personid) {} public void save(Person person){} public void modify(){Department department = new Department();} } 关联（Association) (knows a) 使用：实线 关联关系实际上就是类与类之间的联系，是依赖关系的特例。 关联具有导航性：即双向关系或单向关系 单向一对一关系 //一个人一个身份证号一对一单向的 一对一 public class Person { private IDCard card; } public class IDCard{} 双向一对一关系 //一个人对应一个身份证号 一对一 //一个身份证号也对应一个人 public class Person { private IDCard card; } public class IDCard{ private Person person; } 关系具有多重性： “1”（表示有且仅有一个）， “0…”（表示0个或者多个）， “0，1”（表示0个或者1个）， “n…m”(表示n到 m个都可以), “m…*”（表示至少m 个）。 继承（Inheritance）(is a) 使用：空心三角形+实线 继承关系也称泛化关系，是依赖关系的特例。 A类继承了B类也相当于A类用到了B类。 //PersonServiceBean继承了DaoSupport public abstract class DaoSupport{ public void save(Object entity){ } public void delete(Object id){ } } public class PersonServiceBean extends DaoSupport{ } 实现（Realization） 使用：空心三角形+虚线 实现关系实际上就是A类实现B接口，是依赖关系的特例，依赖关系更强。 //PersonServiceBean实现了PersonService这个接口-实现关系 public interface PersonService { public void delete(Interger id); } public class PersonServiceBean implements PersonService { public void delete(Interger id){} } 聚合（Aggregation）(has a) 使用：带空心菱形的实线，菱形指向整体 聚合关系表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。 导航性：谁聚合谁? A聚合到B: 多重性： B聚合一个A——单聚合 B里面可以聚合多个A——多重聚合 public class Computer { private Mouse mouse; // 鼠标可以和computer分离 private Monitor monitor; //显示器可以和Computer分离 public void setMouse(Mouse mouse) {this.mouse = mouse; } public void setMonitor (Monitor monitor) {this.monitor = monitor;} } 组合 (Composition) (has a) 使用：带实心菱形的实线，菱形指向整体 认为不可以分开，是组合关系 public class Person{ private IDCard card; //聚合 private Head head = new Head(); //组合 } public class IDCard{} public class Head{} 如何判断类关系 是子类继承父类？-->继承关系-->空心三角形+实线 是实现接口？-->实现关系-->空心三角形+虚线 是成员变量并且不可分割？-->组合关系-->实心菱形+实线，菱形指向整体 是成员变量并且可以分割？-->聚合关系-->空心菱形+实线，菱形指向整体 具有方向或者数量关系？-->关联关系-->实线+方向+数字 其他的都是依赖关系-->虚线+方向 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/":{"url":"08_Others/","title":"Backend","keywords":"","body":"08_others No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/BackEnd/backEnd.html":{"url":"08_Others/BackEnd/backEnd.html","title":"Backend","keywords":"","body":"HTTP请求 功能 后端与前端交互数据通过http请求 类型 GET 数据放在query里面 POST 数据放在body里面 PUT 数据放在put里面 DELETE 数据放在param里面 格式 query body param api/ui/id Restful 数据库 RDMS Mysql progresgl Non-Relational mongs 用户验证 Session/cookie CORS JWT 数据格式 JSON XML No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/BackEnd/后端相关.html":{"url":"08_Others/BackEnd/后端相关.html","title":"后端相关","keywords":"","body":"现在大部分的家用IP其实都是NAT分配的内网IP，通过一个网关形成的局域网，在外部看来是同一个公网IP。 现在国内只有台湾地区的家庭网络服务才有公网IP。 Apache和Nginx都是服务器代理，Nginx很擅长处理高并发高负担的任务，一般用作反向代理。 Apache系组件化，有很多有用的组件。 反向代理即将客户端的请求发送到后端服务器，隐藏后端细节。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/Hardware/HDMI的逻辑输入和物理输入.html":{"url":"08_Others/Hardware/HDMI的逻辑输入和物理输入.html","title":"Hdmi的逻辑输入和物理输入","keywords":"","body":"在HDMI（High-Definition Multimedia Interface）技术中，逻辑输入和物理输入是两个不同的概念，分别涉及信号的传输方式和物理连接方式。 物理输入 物理输入是指HDMI接口的实际物理连接端口。一个设备（如电视、显示器或AV接收器）上可以有多个HDMI物理输入端口，每个端口都能接收来自不同HDMI源设备（如DVD播放器、游戏机、机顶盒等）的信号。物理输入的数量和位置是固定的，可以通过查看设备的背面或侧面的HDMI端口来确定。 逻辑输入 逻辑输入是指设备在软件或固件中如何处理和识别来自不同HDMI物理输入端口的信号。逻辑输入涉及设备内部的信号处理路径和逻辑通道，通常与物理端口一一对应，但在某些情况下可以进行重新映射或配置。 具体例子 假设你有一台电视机，有三个HDMI物理输入端口，标记为HDMI 1、HDMI 2和HDMI 3。你可以将这些物理端口连接到不同的设备，如下所示： HDMI 1：连接到蓝光播放器 HDMI 2：连接到游戏机 HDMI 3：连接到机顶盒 在电视机的设置菜单中，这些物理端口可以被逻辑映射到不同的输入源。例如，你可以在电视机的输入源菜单中看到如下选项： HDMI 1: Blu-ray Player HDMI 2: Game Console HDMI 3: Set-top Box 这里，“HDMI 1”、“HDMI 2”和“HDMI 3”是物理输入，而“Blu-ray Player”、“Game Console”和“Set-top Box”则是逻辑输入的描述。 物理输入和逻辑输入的关系 直接对应：在大多数情况下，每个物理输入直接对应一个逻辑输入。用户通过选择逻辑输入来切换到相应的物理端口。 重新映射：有些设备允许用户重新配置或重命名逻辑输入，使其更容易识别和管理。例如，你可以将物理输入HDMI 1重新命名为“PlayStation 5”，这样在选择输入源时就更直观了。 实际应用 在实际应用中，了解物理输入和逻辑输入的区别可以帮助用户更有效地管理和配置他们的设备。例如，在家庭影院设置中，用户可以通过逻辑输入的重新命名来简化设备切换过程，提高使用体验。同时，技术人员在进行故障排除或安装时，也需要知道这些概念以便正确连接和配置设备。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/Hardware/REFERS.html":{"url":"08_Others/Hardware/REFERS.html","title":"Refers","keywords":"","body":" USB口分类 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/Hardware/U盘相关.html":{"url":"08_Others/Hardware/U盘相关.html","title":"U盘相关","keywords":"","body":"Q1：能刷和不能刷的U盘有什么区别？ 无关：文件系统，已测：exFAT、FAT32、NTFS 无关：柱面头也没有关系，1或者0都可能能刷也可能刷不了。 未知：和每个扇区的大小有没有关系？ 无关：完全没有坏道的U盘也可能刷不了。 无关：u盘里的system volume information文件夹，这只是个backup的缓存文件。 https://zhidao.baidu.com/question/1049972701400525059.html 未知：Model，VendorCoProductCode（Val&Amaebi可刷）、KingstonDataTraveler3.0（Amaebi可刷）、SanDiskCruzerGlide3.0（Val可刷） 可能有关：USB2.0端口供电不足。 Q2：怎么格式化写保护的U盘？ 无效：修改注册表项目https://zhidao.baidu.com/question/23062716.html?si=1 无效：用diskpart 输入attributes disk clear readonly 无效：DiskGenius、系统修改U盘属性 无效：利用cmd将U盘格式转换为NTFS convert L: /fs:ntfs /nosecurity/x 其它： 1.U盘的Attribute A代表All，可读可写 R代表Read，只可读 2.不要整理U盘的碎片，会影响U盘寿命。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/Know/REFERS.html":{"url":"08_Others/Know/REFERS.html","title":"Refers","keywords":"","body":" InfoQ技术交流大会 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/Know/大语言模型简介和前景预估.html":{"url":"08_Others/Know/大语言模型简介和前景预估.html","title":"大语言模型简介和前景预估","keywords":"","body":"主要概念 LM（Language Model） 定义：语言模型是指一种统计模型或机器学习模型，用于捕捉和生成自然语言文本。它通过学习大量文本数据中的模式和概率分布来理解和生成语言。 功能：语言模型可以预测一个句子中的下一个单词，或生成与给定上下文相关的文本。 示例： N-gram模型：这是早期的一种语言模型，通过计算连续N个词的联合概率来进行语言生成和预测。例如，二元组（Bigram）模型和三元组（Trigram）模型。 基于神经网络的模型：如Word2Vec、GloVe、RNN（递归神经网络）、LSTM（长短期记忆网络）等。这些模型利用神经网络来捕捉更复杂的语言模式。 LLM（Large Language Model） 定义：大语言模型是指具有大量参数和复杂架构的语言模型，通常基于深度学习技术。这些模型在大量的文本数据上进行训练，能够理解和生成更复杂、更人类化的语言。 特点： 大规模：LLM通常具有数亿到数千亿的参数，使得它们能够捕捉非常复杂和细微的语言模式。 深度学习：使用深度学习技术，如Transformer架构，这些模型能够处理长距离的语言依赖关系。 预训练和微调：LLM通常采用预训练和微调的训练策略。首先在大量通用文本数据上进行预训练，然后在特定任务上进行微调。 示例： GPT-3（由OpenAI开发）：具有1750亿参数，是当前最大和最先进的语言模型之一，能够执行各种NLP任务，如文本生成、翻译、问答等。 BERT（由Google开发）：专注于自然语言理解任务，如问答和句子分类，使用了双向Transformer架构。 T5（由Google开发）：一种统一的文本到文本的模型，能够处理多种NLP任务。 NLP（Natural Language Processing） 定义：自然语言处理（NLP）是计算机科学、人工智能和语言学的一个子领域，致力于使计算机能够理解、解释、生成和操作人类语言。NLP 技术用于处理和分析大量自然语言数据。 主要任务： 文本分类：将文本数据分类到预定义的类别中，例如垃圾邮件检测、情感分析等。 命名实体识别（NER）：识别并分类文本中的实体，如人名、地名、组织等。 机器翻译：将一种语言的文本自动翻译成另一种语言，例如谷歌翻译。 问答系统：根据问题在给定的文本中找到答案，例如智能客服、Siri 等。 语音识别：将语音转换为文本。 文本生成：根据给定的输入生成合适的文本，例如自动摘要、文本补全。 技术： 统计方法：如 n-gram 模型、隐马尔可夫模型（HMM）。 机器学习：如支持向量机（SVM）、朴素贝叶斯。 深度学习：如递归神经网络（RNN）、长短期记忆网络（LSTM）、Transformer（如 BERT、GPT）。 AIGC（AI-Generated Content） 定义：AI-Generated Content（AIGC）指的是使用人工智能技术生成的内容。AIGC 涉及使用机器学习和深度学习算法自动生成各种形式的内容，包括但不限于文本、图像、视频和音频。 应用领域： 文本生成：生成文章、新闻、故事等，例如 GPT-3。 图像生成：生成图像、艺术作品等，例如 GAN（生成对抗网络）生成的图像。 视频生成：生成动画、视频剪辑等。 音频生成：生成音乐、语音等，例如深度学习模型生成的语音合成。 技术： 生成对抗网络（GAN）：用于生成逼真的图像和视频。 变分自编码器（VAE）：用于生成图像和其他数据类型。 Transformer 模型：如 GPT-3，用于文本生成和其他任务。 强化学习：用于生成策略和优化生成过程。 前景预估 刘劼 背景：哈工大AI院长，偏理论。 项目：国家级项目千亩产田无人自动化、农作物知识数据库检索(LLM+RAG)、仿真数据生成？（AIGC） 观点：应用场景和价值不明确 陈亦伦 背景：清华大学AIR专家主任，偏实践、 项目：操持自动驾驶基于大模型的对象识别（人物、路标、塑料袋、自行车、建筑）、对比亚迪汽车制造工厂的每一个环节进行分析是否能用大模型优化、根据医疗检验数据（CT、血液分析等）推测疾病概率的智慧医疗、机动车生成式仿真碰撞实验。 观点：非常乐观 综合观点和考虑 大模型和之前的互联网一样过热，但覆盖范围更广，所有产业都在推进。 有算力瓶颈。 目前投入成本很大，担忧投入产出比，这点个人认为取决于应用方向，现在大语言模型在生物制药、化工实验领域应用得很好， 其他 LLM的应用成果 生物制药领域 药物发现和设计： 分子生成：LLM可以生成新颖的化学结构或分子，这些分子可能具有药物活性。通过学习已有化合物的结构，模型可以设计出可能具有特定生物活性的候选药物。 虚拟筛选：通过语言模型对大量化合物进行筛选，预测其与目标蛋白或生物靶点的相互作用，以加速药物发现过程。 蛋白质结构预测： 蛋白质折叠：如AlphaFold这样的模型已经展示了预测蛋白质三维结构的强大能力，这对于理解疾病机制和设计针对特定靶点的药物具有重要意义。 文献分析和知识提取： 自然语言处理：LLM可以从海量的科学文献中提取关键信息，帮助研究人员快速获取最新的研究成果、理解复杂的生物机制，并生成有意义的研究假设。 数据挖掘：分析临床试验数据和患者记录，识别潜在的药物副作用或新的适应症。 个性化医疗： 基因组学数据分析：通过分析患者的基因组数据，LLM可以帮助识别个体化治疗方案，提高治疗的精准性。 化工实验领域 化学反应预测： 反应生成：LLM可以预测化学反应的产物，帮助化学家设计新的合成路径和反应方案。 反应优化：通过学习已有的反应数据，模型可以推荐最佳的反应条件（如温度、压力、催化剂等），提高实验效率和产率。 材料设计： 新材料生成：通过生成新的化学结构，LLM可以帮助设计出具有特定性质的新材料，如高强度材料、导电材料等。 性能预测：预测新材料的物理和化学性能，指导实验研究的方向。 实验自动化： 实验规划和优化：LLM可以基于已有的数据和文献，自动生成实验方案，并优化实验参数，提高实验效率。 机器人实验室：结合机器人技术，LLM可以自动执行化学实验，实时调整实验条件，提高研究和开发的速度。 安全性评估： 风险预测：通过分析化学反应和材料的性质，模型可以预测潜在的安全风险，指导实验室安全管理。 环境影响评估：预测化学物质对环境的影响，帮助制定更环保的实验和生产方案。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/script/REFERS.html":{"url":"08_Others/script/REFERS.html","title":"Refers","keywords":"","body":" newFileType_markdown newFileType_txt No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:14 "},"08_Others/ShortcutKey/Cmd.html":{"url":"08_Others/ShortcutKey/Cmd.html","title":"Cmd","keywords":"","body":"输入cls 清空页面 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/ShortcutKey/VsCode.html":{"url":"08_Others/ShortcutKey/VsCode.html","title":"Vscode","keywords":"","body":"Ctrl + Shift + L 同时选中多个相同字符 Alt + 鼠标左键单个选择 同时选中多行不同位置 Alt + Shift + 鼠标左键竖拉 同时选中多行同一位置 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/ShortcutKey/Windows.html":{"url":"08_Others/ShortcutKey/Windows.html","title":"Windows","keywords":"","body":"Win + D 显示桌面 Ctrl + F 查找 Ctrl + H 查找和替换 Ctrl + E 选择搜索框 Ctrl + N 打开一个新窗口 Win + Prtscn 保存全屏截图 Win + Shift + S 局部截图 Win + R 打开Windows系统的运行窗口 Ctrl + Shift + Esc 弹出任务管理器 Alt + Tab： 切换屏幕/标签 Win + Tab（+ Shift） 切换任务视图 Alt + F4 关闭当前窗口 Win + L 锁定屏幕 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/Ui_Ux/点石成金-Web设计原则.html":{"url":"08_Others/Ui_Ux/点石成金-Web设计原则.html","title":"点石成金-web设计原则","keywords":"","body":"(来自网络) 可用性原则（重点） 可用性第一原则：别让我思考。 可用性第二原则：点击多少次都没有太多关系，只要每次点击都是无需思考、明确无误的选择。 可用性第三原则：省略多余的文字，去掉每个页面上一半的文字，然后把剩下的文字再去掉一半。 如果你不能做到让一个页面不言而喻，那么至少应该让它自我解释。 我们实际上是如何使用Web的：我们不是阅读，而是浏览、我们不作最佳选择，而是满意即可、我们不是追根究底，而是勉强应付。 为浏览设计，不为阅读设计。 某个东西越需要投入大量时间，或者看起来会这样，它将来就会用得越少。 可用性的定义：让一个有着平均能力和经验的人（甚至稍低于平均水平）能明白如何使用它——不必付出过度的努力，或者遇到不必要的麻烦。 可用性的定义可分为：有用，可学习，可记忆，有效，合乎期望。 最小化干扰：即降低视觉噪点。 用户喜欢无需思考的选择。 必要的帮助和支持：简短、及时、不会错过。 主要省去欢迎文字和精简指示文字。 好的促销文案：不会一个劲地说自己有多好，而是描述什么东西让我们感觉更好。 第一章 别让我思考 别让用户思考，让每一个页面不言而喻。用户处于忙碌之，知道自己不必阅读所有内容。 善于扫描（注意力在自己感兴趣的部分），用户只要看它一眼就知道是什么内容，知道怎么用它。如果不能，至少也应该一目了然。 第二章 我们实际上是如何使用web 用户不是阅读，而是浏览。 ①第一个事实：我们不是阅读，而是扫描——人们总是处于忙碌中； 知道自己不需要阅读所有内容；善于扫描（浏览）。 ②第二个事实：我们不做最佳选择，而是满意即可——忙碌；猜错了， 后果也不严重；对选择进行权衡不会改善我们的机会；猜测更有意思。 ③第三个事实：我们不是追根究底，而是勉强应付——根源对我们来说 不重要；若发现某个事物能用，就会一直用它。 抓住用户内心需求，用户不做最佳选择（难、时间长）而是满意即可（效率更高）；我们不会是追根揭底，而是勉强应付。 第三章 广告牌设计101法则 在每个页面上建立清楚的视觉层次：越重要的部分月突出；逻辑上相关的部分在视觉上也相关，逻辑上包含的部分在视觉上进行嵌套。 2、 尽量利用习惯用法：习惯用法非常有用，设计师为了新颖通常不愿意利用习惯用法。 3、把页面划分成明确定义的区域。 4、明确标识可以点击的区域。 5、最大限度降低干扰：眼花缭乱；背景噪声（间隔线尽量虚化） 第四章 动物、植物、无机物 “三次无需思考明确无误点击相当于一次需要思考的点击” 点击次数不是重点，用户在使用网页中如果页面上信息过于繁琐，那么用户就要产生一个思考的过程，因此给用户点击（选择）体验尽可能直白。 点击多少次都没关系，只要每次点击都是无须思考，明确无误的选择——可用性第二定律。 如果我们需要一直在网络上进行选择，那么让这些选择变得无须思考是让一个网站容易使用的主要因素。 第五章 省略多余的文字 去掉页面上一半的文字，然后把剩下的的文字再去掉一半。——可用性第三定律 有力的文字都很简练。句子里不应该有多余的文字，段落里不应该有多余的句子。 去掉没人会看的文字的好处：可以降低页面噪音;让有用的内容更突出;让界面更简短，让用户在每个页面一眼就能看到更多内容。 实际上必需去掉的两种特别的文字：欢迎词和指示说明。 第六章 街头指示牌和面包屑 记住：如果在网站上找不到方向，人们不会使用你的网站。 Web上的体验缺少空间感：感觉不到大小、方向、位置。 若我们想再次访问网站的某个内容，我们记住的是它在概念层次上的位置，而不是依靠它在哪里的物理感觉，让后顺着以往的链接过去，这是书签重要的原因，也是后退按钮点击率极高的原因。 导航有两个显而易见的用途：帮助我们找到任何东西以及告诉我们现在身在何处。 导航的其他功能：它给了我们一个固定的感觉；告诉我们当前的位置；告诉我们如何使用网站；给了我们对网站建造者的信心。 设计得当的持久导航应该是平静,令人舒服的。 让导航部分每一页以一致的外观出现在同样的位置，会让你立即确认自己仍然在这个网站上——这比你想象中更加重要同时意味着你只需要了解它一次。 （Microsoft软件导航栏基础部分一样只有颜色的区别） 持久导航应该包括5个元素：站点ID(LOGO);回主页的方式；探索的方式；实用工具；栏目。 提供搜索——由于搜索的潜在威力和喜欢搜索的用户比喜欢浏览的用户更多，因此每个页面都应该有一个搜索框或一个搜索页面的连接，除非你的网站真的不太需要搜索。 大多数用户登录新站点，第一件事是扫描页面，看看有没有搜索。 搜索框要坚持简约原则：一个输入框、一个按钮、还有搜索字样，切记复杂。 要抵消网络固有的空间迷失感，其中的一种导航方式是告诉我当前在什么位置。在Web中，可以用突出当前位置来实现，不管是在页面的导航条、列表还是菜单上。 面包屑导航不会占用太多空间，提供一种方便的方式让你：退回上一个层次或去主页，它用来补充固定导航机制最有价值。 标签是极少几个将物理隐喻有效应用到用户界面的例子之一。将原来的物体分成了不同的部分，打开不同的部分很容易，通过突出的标签可以翻到对应位置。 标签是大型网站导航的上佳选择：它们不言而喻；它们很难错过；他们很灵活；它们暗示了一个物理空间。 如果想要使用标签，认真参考Amazon经典的标签设计，并且务必模仿其中的三个要点： 正确绘制：激活的标签页位于其他标签页之前——这是让他和标签相像的最大要点——比与众不同的标签外形更重要。——想营造出这样的效果，激活的标签页必须有一种不同的颜色或外形做对比，并且必须与它下面的空间在物理上链接起来，这是把激活的标签页“弹到”最前方的方法。 颜色编码：为网站的每个栏目使用不同的标签颜色。并把这种颜色用在页面其他导航元素上，让他们浑然一体。——运用颜色对比，饱和与中性对比 当你进入网站时，有一个标签已经选中。 进入网站一般会遵循的流程： 你通常是为了寻找某个目标 你会决定先询问还是先浏览 如果选择浏览，你将通过标识的引导在层次结构中穿行 最后，如果找不到想要的东西，就会离开。 第七章 首先要承认，主页不由你控制 主页要完成的任务： 站点的标识和使命：是什么网站，是做什么的，为什么我应该在这里而不是其他网站 站点层次：主页要给出网站提供服务的概貌，既有内容，又有功能还有这些服务是如何组织的——通常由持久导航来处理。 搜索：大多数网站需要在主页上设置一个突出显示的搜索框 导读：用暗示吸引用户——内容推荐应突出最新、最好、最流行的内容片段：功能推荐部分应邀请访问或试用一些个性化功能 内容片段：功能推荐部分应邀请访问或试用一些个性化功能 内容更新：主页要经常更新内容 友情链接：预留空间放置广告、交叉推广、合作品牌的链接 快捷方式：最常访问的内容片段（如软件升级）值得在主页上放置链接 注册：登录注册链接，并让用户知道已经登录了（欢迎回到……） 设计主页不可避免的要做一些折中。 设计网页必要传达整体形象——当进入新的网页时，主页应该尽可能快速清晰的回答四个问题：这是什么网站？我能在这里做什么？网站上有些什么？为什么我应该在这里而不是在别的地方？ 网页设计中整体形象如何传达？ 口号：最有价值的位置之一是靠近LOGO的地方 欢迎广告：是网站的简要描述，在主页的首要位置显示，不需要滚动屏幕就能看到。 信息传达的指导原则 需要多大空间就用多大空间，但也不要使用过多空间 不要把使命陈述当作欢迎广告 最重要的是进行测试 没有什么比得上一个好口号 口号是一条精炼的短句，刻画了整个企业，总结它是什么，什么让它如此卓越。它是用户最希望能找到关于网站目标具体描述的地方。 选择口号时要考虑的几点： 好的口号要清晰、言之有物 不好的口号含混不清 好的口号长度适中，6-8个英文单词足以表达思想，而且容易让人领会 好的口号能表达出网站的特点和显而易见的好处 不好的口号听起来太笼统 好的口号应该有个性、生动、有时候还很调皮 当进入一个新网站，快速扫描主页之后，我应该能明白无误的知道：如果我想要搜索、扫描及扫描网站最精彩的内容，都可以从这里开始 在那些针对包含一系列步骤的过程所建立的网站上，过程的起点应该很显眼；在需要新用户注册的／老用户登录的网站，应该突出显示注册和登录的位置 主页导航可以不一样。由于主页独特的职责，通常不必使用持久导航，常见差别包括： 栏目描述：由于主页要尽可能多的表现网站内容，因此可能想为每个栏目名称增加一些描述性短语，甚至列出下一级栏目——这些内容不可能放置在每个页面上。 不同的方向：主页可能有必要使用垂直导航栏而不是水平导航栏 不同的方向：主页可能有必要使用垂直导航栏而不是水平导航栏 最重要的是，让栏目的名称保持不变：同样的顺序、文字、分组；尽可能多的保持相同的视觉提示也很有用：同样的字体、颜色和大小。 下拉框可以节约空间，但它存在几个问题： 你必须把他们找出来：列表中但项目扫描页面时看不到 他们难以扫描：标准但HTML下拉菜单，他们无法控制字体、间隔和列表格式 他们不好控制：列表显示和收缩很快，会影响查看效果 下拉框对于组织按字母顺序排列但项目最有效，例如国家，省份或产品 。但当不知道自己在找什么名称时，下拉框的效率就很低了，特别是下拉清单不是按字母顺序或者清单长到需要滚动的情况。 任何共享的资源都会因为过度使用而遭到破坏，避免在首页过度推销过多项目 第八章 农场主和牧牛人应该是朋友 为什么Web设计团队讨论可用性实在浪费时间，如何避免这种情况。 1、Web团队的成员对于好的网站设计由什么组成有着不同的看法，但其实所有的Web用户都是独一无二的，所有的Web使用都是不一样的。好的设计会把这种复杂性考虑进去。 2、争论，浪费时间，消耗团队精力。 第九章 一天10美分的可用性测试 让测试简单——这样你能进行充分的测试 1、争论的解药——测试。（尽早测试） ①在项目中，早一点测试以为用户好过最后测试50位用户。 ②人们对招募用户代表的重要性估计过高。 ③测试的关键不是要证明什么或反驳什么，而是了解你的判断力。 ④测试是一个迭代的过程。 ⑤没有什么比现场用户的反应更重要。 2、跳楼大减价的建议可用性测试，3-4位用户，招募方式比较随便地点比较随意，主导人具有相对耐心的人即可，成本低。 3、应该测试多少用户，很多情况下每轮测试的理想用户数量应该是3-4个。 4、宽松招募，曲线上升，利用你能够寻找到的任何人（满足最低要求——懂网上的基本知识），然后曲线上升。 5、在哪里测试XXXXX（感觉没用），通过视频电缆把摄像机的信号传到附近的另一个办公室以便团队的每个人都能观察而不干扰测试用户。 6、应道测试的人，冷静、耐心、由同理心、善于倾听、天性公正的人。不要选完全不是人类的人或者办公室狂人。 7、立刻回顾测试结果，给问题分类、解决问题。 8、常见问题，用户不清楚概念、他们找不到自己要找的字眼、内容太多 9、解决办法，忽略“Kayak”（划皮艇）问题、抵制添加的冲动、不要太看重人们对新功能的要求、抓住够得着的果子。 10、别把孩子也泼出去了，和任何好的设计一样，成功的网页往往要进行巧妙的平衡，哪怕是一个微小的改动也会带来不晓得影响。 11、每个月一个上午的测试。 第十章 可用性是基本礼貌 为什么你的网站应该让人尊敬 1.好感储存器是什么 好感储存器是用户对该网站用户体验的感知，以及用户体验的好坏程度的一个反馈。 2.影响用户的好感储存期的因素 ①每个用户的特质，用户的性格，个性，耐心程度 ②用户在使用该网站时的环境以及用户当时的心情 ③网站是否真正关心用户的利益等因素 3.降低好感度的方式 ①为提供用户应该知道，了解的比较信息。例如产品价格，客服联系方式等信息 ②不符合用户的行为习惯 ③获取过多用户不必要的个人信息 ④过多虚伪的真诚，例如上一章讲到的欢迎语不宜过多 ⑤设置一些不必要的信息障碍使用户的用户体验不自由，浪费时间 网站设计凌乱不专业给用户一种你并没有认真做网站的态度 4.提高好感度的方法 ①了解使用该网站的用户的需求并简单明了的呈现给用户 ②让用户尽可能的了解他想要的信息即便这个星期并不是用户的期望 ③尽量使网站的操作简单，以此来提升用户体验 ④尽最大能力为用户解决一切疑问 ⑤为用户提供更加方便，简捷优质的服务 ⑥解决不可避免的bug,及时优化网站的不足 ⑦如果不能为用户解决问题但必须让用户了解,坦诚面对用户 第十一章 可访问性级联样式表和你 将可访问性做到更好,即用户体验更好才会让残疾人士用着更方便 测试是改进网站的可访问性的方法 只有将网站操作步骤做到更简单才能更好的改进网站的可访问性 级联样式就是将每一层级的页面同上下层级的逻辑关系以文件夹同文件的形式梳理清晰，也可认为同一页面中的各个元素的主次关系，使其更有逻辑形成一种可循的规律，同时也是其更加智能化更加灵活是用户体验更加美好 很多网站都没有通过三秒可问性测试——增大字体 第十二章 救命，老板我想要······ 当好人遇到不好的设计决策 询问不必要的用户信息会令用户感到不安，减少用户对该网站的信任感。并且会得不到真实的数据信息，并且网站形象会有所下降以及得到完整的信息表更少。 制作网站的原则 只让用户提供此次操作所必需的信息 不要过多要求填写可选信息 明确告诉用户注册后会得到什么 制作网站不需要视觉很炫酷，但要有表现力，专业，吸引人，在不妨碍网站正常运行的情况下，来做网站的视觉来吸引用户，但要适度。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/Utils_Know&Use.html":{"url":"08_Others/Utils_Know&Use.html","title":"Utils know&use","keywords":"","body":"redius 一种非关系型数据库 .ini文件 ini 文件是Initialization File的缩写，即初始化文件，是windows的系统配置文件所采用的存储格式，统管windows的各项配置，一般用户就用windows提供的各项图形化管理界面就可实现相同的配置了。但在某些情况，还是要直接编辑ini才方便，一般只有很熟悉windows才能去直接编辑。 RAM\\DRAM\\SRAM RAM，Random-Access Memory，即随机存取存储器，其实就是内存，断电会丢失数据。主要分为SRAM（static）和DRAM（dynamic)。主要的区别在于存储单元，DRAM使用电容电荷进行存储。需要一直刷新充电。SRAM是用锁存器锁住信息，不需要刷新。但也需要充电保持。 TLS TLS是Transport Layer Security（传输层安全性）的缩写，是一种网络通信协议，用于确保在两个通信应用程序之间的隐私和数据完整性。它是SSL（Secure Sockets Layer，安全套接层）协议的继任者，用于加密和保护在计算机网络上传输的数据。 TLS常用于保护网站的敏感数据传输，例如登录信息、支付信息等。 窥孔优化PeepHole https://blog.csdn.net/weixin_43844521/article/details/132258450 应用于编译后期，去除无效指令、冗长指令替换为简单的、折叠常量、替换使用寄存器的指令以避免不必要的内存访问。 PGO（Profile-Guided Optimization） 是一种编译器优化技术，旨在通过程序运行时收集的性能数据（profile）来优化生成的机器码，以提高程序的性能和效率。 具体来说，PGO 的工作流程通常包括以下几个步骤： 收集性能数据：首先，程序被运行时收集性能数据，例如函数调用频率、代码块执行次数、分支预测成功率等。这些数据反映了程序在实际运行中的行为和热点。 生成优化建议：收集到的性能数据被用来生成优化的建议。例如，哪些函数调用频率高、哪些代码路径经常执行等。 重新编译优化：基于收集到的性能数据，编译器重新生成优化后的代码。这可能包括内联频繁调用的函数、优化热点代码路径的布局以减少分支预测失败等。 重新链接生成的代码：最后，重新优化的代码被链接成最终的可执行文件或者库。 PGO 的优势在于，它能够根据实际程序运行的行为模式来优化代码，而不是依赖于编译器对代码结构的静态分析。因此，PGO 可以更精确地针对特定的使用情况和环境进行优化，提升程序的运行效率和性能。 在实际应用中，PGO 可以用于优化各种类型的程序，包括桌面应用程序、服务器软件、甚至是嵌入式系统中的代码，以提升整体系统的性能和响应速度。 GLES / OpenGL ES（OpenGL for Embedded Systems） 它是一种用于嵌入式系统的图形库和API。OpenGL ES 是 OpenGL 的一个子集，专门设计用于在移动设备、游戏机、嵌入式系统和其他资源受限的平台上进行图形渲染和加速。 关键特点和用途包括： 跨平台性：OpenGL ES 提供了跨多种平台的标准图形渲染接口，使得开发人员可以在不同的硬件和操作系统上实现一致的图形渲染效果。 低功耗和高性能：针对嵌入式设备和移动平台的需求，OpenGL ES 优化了图形渲染过程，使得能够在有限的资源下实现高效的图形处理和渲染。 功能子集：相较于桌面版本的 OpenGL，OpenGL ES 是一个功能上的子集，移除了一些桌面环境中不太适用或者性能开销较大的部分，以适应嵌入式和移动设备的特性和限制。 支持多种版本：OpenGL ES 有多个版本，例如 OpenGL ES 1.x、2.x 和 3.x 等，每个版本对硬件和功能的要求不同，允许开发者根据设备的能力选择合适的版本进行开发。 总体来说，OpenGL ES 提供了一个标准的图形渲染API，使得开发者能够利用硬件加速功能，实现复杂的图形和视觉效果，同时在嵌入式和移动设备上保持良好的性能和功耗平衡。 Vulkan 是一种现代的、跨平台的图形和计算API。它设计用于高性能的3D图形应用程序，例如游戏和交互式模拟，同时也支持通用计算任务。以下是关于Vulkan的一些关键特点和信息： 跨平台性：Vulkan被设计为跨多种操作系统（如Windows、Linux、Android等）和硬件平台（包括PC、手机、游戏机等）的通用图形和计算API。这种跨平台性使得开发者能够在不同设备上实现一致的图形效果。 高性能：Vulkan的设计目标之一是提供更好的性能和更低的CPU开销。它通过减少API调用的开销、显式管理资源和并行命令提交等方式，提高了图形渲染和通用计算的效率。 低级别接口：与传统的图形API（如OpenGL）相比，Vulkan提供了更低级别的访问，需要开发者更多地管理细节（如内存分配、同步等），但也赋予了更多的控制力和优化的空间。 并行处理：Vulkan充分利用现代多核处理器的优势，支持并行提交多个渲染或计算任务，从而提升整体性能。 通用计算：除了图形渲染，Vulkan还支持通用计算任务，例如GPU加速的物理模拟、数据处理和深度学习等应用。 后继者和关系：Vulkan可以看作是OpenGL的后继者之一，但它更加现代化和面向未来。OpenGL依然广泛使用，特别是在传统的桌面应用和一些低要求的应用场景中，而Vulkan则更适合需要更高性能和更多控制的场合。 总之，Vulkan作为一个现代的、跨平台的图形和计算API，旨在提供更高性能、更低开销的图形渲染和通用计算解决方案，适用于各种类型的应用程序和设备。 WSL WSL 是 Windows Subsystem for Linux 的缩写，翻译过来就是 适用于 Linux 的 Windows 子系统。它是一个让大家可以在 Windows 系统上直接运行 Linux 应用的兼容层。 WSL 的作用： 在 Windows 上使用 Linux 工具： 你可以在 Windows 上直接使用熟悉的 Linux 命令行工具、开发环境，而不需要虚拟机或者双系统。 开发跨平台应用： 开发者可以在 Windows 上开发 Linux 应用，或者在 Linux 环境下调试 Windows 应用。 运行 Linux 应用程序： 如果有特定的 Linux 应用程序，可以在 WSL 中运行，而不需要在虚拟机中安装整个 Linux 系统。 WSL 的原理： WSL 并不是一个完整的 Linux 系统，而是在 Windows 内核上提供了一个兼容层，让 Linux 应用程序可以运行在 Windows 上。它通过虚拟化技术，模拟了一个 Linux 环境，让 Linux 应用程序认为自己是在一个真正的 Linux 系统上运行。 Annaconda 用powershell安装WSL https://docs.microsoft.com/en-us/windows/wsl/install 进入annaconda source ~/anaconda3/bin/activate r 查看当前所有环境 conda info --envs 创建环境 conda create -n 环境名 激活环境 Conda activate 环境名 Source activate 环境名 activate + 环境名 删除环境 conda remove -n 环境名 --all 教程 https://zhuanlan.zhihu.com/p/348120084 C++ For Jupyter Notebook https://www.pranav.ai/cplusplus-for-jupyter condaHTTPERROR问题 https://zhuanlan.zhihu.com/p/260034241 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/WebApp/":{"url":"08_Others/WebApp/","title":"Css","keywords":"","body":"Webapp No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/WebApp/css/":{"url":"08_Others/WebApp/css/","title":"Css3","keywords":"","body":"Css No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/WebApp/css/css3/REFERS.html":{"url":"08_Others/WebApp/css/css3/REFERS.html","title":"Refers","keywords":"","body":" 1-css选择器-1-基本选择器 1-css选择器-2-属性选择器 1-css选择器-3-伪类选择器 1-css选择器-4-伪元素 1-css选择器-5-权重 2-边框与圆角-圆角 2-边框与圆角-盒阴影 3-css3背景与渐变-IE渐变-IE10- 3-css3背景与渐变-径向渐变 3-css3背景与渐变-线性渐变 3-css3背景与渐变-背景 3-css3背景与渐变-重复渐变 4-css3转换-2D转换-矩阵 4-css3转换-2D转换 4-css3转换-3D转换 4-css3转换-Transform与坐标系统 4-css3转换-transition 需要触发事件 4-css3转换-转换-拓展属性 5-css3过渡 6-css3动画-@keyframes 6-css3动画-will-change 6-css3动画-动画原理+animation属性详解 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/WebApp/css/Float设计的初衷.html":{"url":"08_Others/WebApp/css/Float设计的初衷.html","title":"Float设计的初衷","keywords":"","body":"Float设计的初衷：实现文字环绕效果 包裹： 收缩 坚挺 隔绝（BFC-块级格式化上下文） 具有包裹性的： display:inline-block/table-cell/... position:absolute(近亲)/fixed/sticky overflow:hidden/scroll 具有破坏性，浮动后使父元素高度塌陷： display:none position:absolute(近亲)/fixed/sticky 浮动使父元素高度塌陷是标准，当父元素高度塌陷后，置于父元素下的元素没有限制会在空间允许的条件下浮动上来，这就是文字环绕图片的原因； 或者是图片位于文字之间，图片的浮动会使其突破父元素向左或右浮动后文字拼接呈环绕效果（浮动的破坏性只是为了实现文字环绕效果 清除浮动（带来的影响）： 法1：脚底插入clear:both; 法2：父元素BEC（IE8+)或haslayout（IE6/IE7） Clear常用形式： HTML block水平元素底部走起 CSS after伪元素底部生成 .clearfix:after{}(不兼容IE6/IE7) 父元素BFC(IE8+)或haslayout(IE6/IE7) float:left/right position:absolute/fixed overflow:hidden/scroll(IE7+) display:inline-block/table-cell(IE8+) width/height/zoom:1/...(IE7/IE7) 权衡后的策略 .clearfix:after{content:\";display:block;height:0;overflow:hidden;clear:both;} .clearfix{*zoom:1;} .fix:after{} .fix{} 更好的方法： .clearfix:after{content:\";display:table;clear:both;} .clearfix{*zoom:1;} .clearfix应用在包含浮动子元素的父级元素上 haslayout（浮动也会触发）在IE6/IE7下不合适 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/WebApp/html/":{"url":"08_Others/WebApp/html/","title":"Html&css","keywords":"","body":"Html No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/WebApp/html/html&css/REFERS.html":{"url":"08_Others/WebApp/html/html&css/REFERS.html","title":"Refers","keywords":"","body":" C10 文字排版 C11 CSS 盒模型 C12 CSS布局模型 C13 代码缩写 C14 单位和值 C15 CSS样式设置技巧 C1C2C3C4 标签(imooc HTML&CSS基础).pdf) C5 表单 C7 CSS的三种方法及优先级 C8 CSS选择器 C9 CSS继承 权值 特殊性 层叠 重要性 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/WebApp/html/html5/REFERS.html":{"url":"08_Others/WebApp/html/html5/REFERS.html","title":"Refers","keywords":"","body":" HTML5展望-Canvas HTML5展望-移动端应用 HTML5属性-Input类型 HTML5属性-script ol HTML5属性-表单类型 HTML5属性-链接属性 HTML5标签变化-HTML5简介 HTML5标签变化-删除标签 HTML5标签变化-文档类型定义 HTML5标签变化-新增标签-Menu标签 HTML5标签变化-新增标签-Web应用标签 HTML5标签变化-新增标签-其他标签 HTML5标签变化-新增标签-多媒体标签 HTML5标签变化-新增标签-注释标签 HTML5标签变化-新增标签-结构标签 HTML5标签变化-重定义标签 HTML5网页布局 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/WebApp/html/html_w3c/REFERS.html":{"url":"08_Others/WebApp/html/html_w3c/REFERS.html","title":"Refers","keywords":"","body":" HTML Attributes HTML Block and HTML Colors HTML Comments HTML Display HTML Elements HTML File Paths HTML Head HTML Headings HTML Iframes HTML Images HTML JavaScript HTML Links HTML Lists HTML Quotation and Citation Element HTML Styles -CSS HTML Styles HTML Tables HTML Text Formatting HTML The class Attribute HTML The id Attribute HTML结构 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/WebApp/layout/REFERS.html":{"url":"08_Others/WebApp/layout/REFERS.html","title":"Refers","keywords":"","body":" C1 W3C标准 盒子模型 C2 标准文档流 C3 浮动 C4 清除浮动的方法 C5 横向两列布局 C6 绝对定位 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/WindowsApp/C_hashtag_Winform.html":{"url":"08_Others/WindowsApp/C_hashtag_Winform.html","title":"C hashtag winform","keywords":"","body":"C# winform从零开始玩转计算器 一、作品展示 文件夹地址 Github repo \\Calculator\\bin\\Release\\net6.0-windows\\publish 项目启动文件： Calculator.exe 或者 通过命令启动Calculator.dll dotnet Calculator.dll 二、.NET平台和C#语言的介绍 C#是一种面向对象的编程语言，主要用于开发可以运行在.NET平台上的应用程序。C#的语言体系都构建在.NET框架上，近几年，C#语言的简单、现代、面向对象和类型安全等特点正在被越来越多的人认同。 C#语言及其特点 C#是微软公司设计的一种编程语言，是从C和C++派生来的一种简单、现代、面向对象和类型安全的编程语言，并且能够与.NET框架完美结合。C#具有以下突出的特点: (1)语法简洁。不允许直接操作内存，去掉了指针操作。 (2)彻底的面向对象设计。C#具有面向对象语言所应有的一切特性:封装、继承和多态。 (3)与Web紧密结合。C#支持绝大多数的Web标准，例如HTML、XML、SOAP等。 (4)强大的安全性机制。可以消除软件开发中常见的错误(如语法错误)，.NET提供的垃圾回收器能够帮助开发者有效地管理内存资源。 (5)兼容性。因为C#遵循.NET的公共语言规范(CLS)，从而保证能够与其他语言开发的组件 兼容。 (6)灵活的版本处理技术。因为C#语言本身内置了版本控制功能，使开发人员更加容易地开发和维护。 (7)完善的错误、异常处理机制。C#提供了完善的错误和异常处理机制，使程序在交付应用时能够更加健壮。 认识.NET Framework/.NET Core .NET Framework是微软公司推出的完全面向对象的软件开发与运行平台。.NET Framework具有两个主要组件:公共语言运行时(Common Language Runtime, CLR)和类库。 公共语言运行时:公共语言运行时(CLR) 负责管理和执行由.NET编译器编译产生的中间语言代码( .NET程序执行原理如图1.1 所示)。由于共语言运行库的存在，解决了很多传统编译语言的一些致命缺点，如垃圾内存回收、安全性检查等。 类库:类库我们比较好理解，就好比一一个大仓库里装满了工具。类库里有很多现成的类，可以拿来直接使用。例如，文件操作时，可以直接使用类库里的IO类。 .NET Core是适用于 Windows、Linux 和 macOS 的免费、开源托管的计算机软件框架,两者最直接的不同点便是他们的运行环境，.NET Framework只能在Windows环境下运行，但.NET Core是跨平台的 C#的应用领域 游戏软件开发 桌面应用系统开发 智能手机程序开发 Web应用开发 云开发 物联网IOT 人工智能AI 三、创建第一个winform程序 1.下载和安装 vs2022的下载和安装教程 2、选择winform模板（注意是.NET Core） 3、配置新项目 4、选择框架 .NET6.0 5、点击创建出现这个界面就表示创建成功！ 四、项目文件讲解 解决方案：一个大文件夹，里面可以包含多个项目 项目：每个程序的名字和功能集合 依赖项：项目引用的各种类库 Form1.cs：窗体界面 Form1.Designer.cs：界面对应的后台设计 Form1.resx：窗体引用的资源文件 Program.cs：程序的入口 五、文件结构讲解 namespace Calculator { internal static class Program { /// /// The main entry point for the application. /// [STAThread] static void Main() { ApplicationConfiguration.Initialize(); Application.Run(new Form1()); } } } 命名空间 C#程序是利用命名空间组织起来的。命名空间既用作程序的“内部”组织系统，也用作向“外部”公开的组织系统(即一种向其他程序公开自已拥有的程序元素的方法)。如果要调用某个命名空间中的类或者方法，首先需要使用using指令引入命名空间，using指令将命名空间名所标识的命名空间内的类型成员导入当前编译单元中，从而可以直接使用每个被导入的类型的标识符，而不必加上它们的完全限定名。 C#中的各命名空间就好像是一个存储了不同类型的仓库，而using 指令就好比是一把钥匙， 命名空间的名称就好比仓库的名称，可以通过钥匙打开指定名称的仓库,从而在仓库中获取所需的物品。 类 类是一种数据结构，它可以封装数据成员、函数成员和其他的类。类是创建对象的模板。C#中所有的语句都必须位于类内。因此，类是C#语言的核心和基本构成模块。C#支持自定义类，使用C#编程就是编写自己的类来描述实际需要解决的问题。 类就好比医院的各个部门，如内科、骨科、泌尿科、眼科等，在各科室中都有自己的工作方法，相当于在类中定义的变量、方法等。如果要救治车祸重伤的病人，仅一一个部门是不行的，可能要内科、骨科、脑科等多个部门一起治疗才行，这时可以让这几个部门临时组成-一个小组， 对病人进行治疗，这个小组就相当于类的继承，也就是该小组可以动用这几个部门中的所有资源和设备。 Main()方法 Main()方法是程序的入口点，C#程序中必须包含一一个Main(方法，在该方法中可以创建对象和调用其他方法，一一个C#程序中只能有一个Main()方法，并且在C#中所有的Main()方法都必须是静态的。 C#是一种面向对象的编程语言，即使是程序的启动入口点，它也是一个类的成员。由于程序启动时还没有创建类的对象，因此，必须将入口点Main()方法定义为静态方法，使它可以不依赖于类的实例对象而执行。 Main()方法就相当于汽车的电瓶，在生产汽车时，将各个零件进行组装，相当于程序的编写。当汽车组装完成后，就要检测汽车是否可用，如果想启动汽车，就必须通过电瓶来启动汽车的各个部件，如发动机、车灯等，电瓶就相当于启动汽车的入口点。 标识符 可以简单理解为一个名字，用来标识类名、变量名、方法名、数组名、文件名的有效字符序列 关键字 是C#语言中已经被赋予特定意义的一些单词，不可以把这些单词当作标识符来使用 在我们的vs中，蓝色表示该单词是我们的关键字 语句 语句是构造所有C#程序的基本单位。语句可以声明局部变量或常数、调用方法、创建对象或将值赋给变量、属性、字段，通常以分号终止。 注释 对某行或者某段代码进行说明，方便对代码进行理解与维护。 六、注释的使用 在我们的vs中，绿色表示该单词是我们的注释 单行注释 //初始化程序 多行注释 /*这是我们程序的一个入口 这里写我们的核心代码*/ 文档注释 /// /// 主函数入口 /// 七、变量和数据类型 int 整数类型 int number=10; float 单精度浮点型 float f =3.5f; double 双精度浮点型 double d =3.1415; char 字符类型 char c ='a'; string 字符串类型 string str=\"abcdefg\"; bool 布尔类型 bool b =true; ... 小作业：手动写一遍各个数据类型的变量，并且输出。 八、常量的使用 const const int number=10; 九、运算符（加减乘除取余） 加+ 两数相加 减- 两数相减 乘* 两数相乘 除/ 两数相除 取余% 获取余数 ++ -- 自身加1 自身减1 前++ 后++ 前-- 后-- 单独使用无差异，和表达式配合使用，前++，先给变量加1，再进行运算，后++，先用变量的值进行运算，再加1 += -= *= /= 十、比较运算符（大于小余等于不等于） 大于 小于 > = 一个等号是赋值，两个是等号是判断 十一、表达式 什么是表达式：各种数据类型的变量+运算符的组合 十二、隐式转换 直接转换，自动的、隐式的转换，不需要做别的操作，就完成了转换 源类型 目标类型 sbyte short、int、long、float、double、decimal byte short 、ushort、 int 、uint、 long、 ulong、 float、 double、 decimal short int、 float、 long、 double、 decimal ushort int、 uint、 long、 ulong、 float、 double、 decimal int long、 float、 double、 decimal uint long、 ulong、 float、 double、 decimal char ushort、 int、 uint、 long、 ulong、 float、 double、 decimal float double ulong float、 double、 decimal long float、 double、 decimal 不能隐式转换的，vs会有智能提示，这个时候是无法编译项目的。 十三、显式转换 不能直接转换的，要通过方法来进行转换 源类型 目标类型 sbyte byte、 ushort、 uint、 ulong、 char byte sbyte、 char short sbyte 、byte、 ushort 、uint 、ulong 、char ushort sbyte 、byte、 short、 char int sbyte、byte、 short、 ushort、 uint、 ulong、 char uint sbyte、byte、 short、 ushort、int、char char sbyte、byte、 short float sbyte、byte、 short、 ushort、int、uint 、long 、ulong 、char 、decimal ulong sbyte、byte、 short、 ushort、int、uint 、long 、char long sbyte、byte、 short、 ushort、int、uint 、ulong 、char double sbyte、byte、 short、 ushort、int、uint 、ulong 、long、float、char、decimal decimal sbyte、byte、 short、 ushort、int、uint 、ulong 、long、float、char、double 十四、分支结构if-else if if(判断条件){ 需要执行的代码; } if-else if(判断条件){ 需要执行的代码; } else{ 需要执行的代码; } if---- else if ----else if(判断条件){ 需要执行的代码; } else if(判断条件){ } else{ 需要执行的代码; } 程序执行到 if 处，首先判断 if 所带的小括号中的判断条件是否成立，如果成立，就回一个 true，则执行 if 所带的大括号中的代码，执行完毕后，跳出 if-else 结构；如果不成立，返回一个 false，则跳过 if 语句后的大括号，执行 else 所带的大括号中的代码，执行完毕后，跳出 if-else 结构。 十五、分支结构switch switch(结合enum) switch（变量或者表达式的值） { case 值 1： 要执行的代码； break； case 值 2： 要执行的代码； break； ... case 值 N： 要执行的代码； break； default： 要执行的代码； break； } 练习 用switch做一个星期的判断 十六、循环结构-for for for（初始表达式；条件表达式；增量表达式） { 循环体代码； } for(int i = 0;i初始表达式：声明循环变量，记录循环的次数；[ int i = 1 ] 条件表达式：循环的条件；[ i 小作业：从0到100，循环输出每个数字 十七、循环结构-while while while（循环条件） { 循环体； } 首先判断 while 所带的小括号内的循环条件是否成立， 如果成立的话，也就是返回 true，则执行循环体； 执行完一遍循环体后，再次回到循环条件进行判断，如果依然成立，则继续执行循环体，如果不成立，则跳出 while 循环。 十八、循环结构-do-while do-whlie do { 循环体； }while（循环条件） 首先会执行 do 中的循环体，执行完毕后，去判断 do-while 的循环条件， 如果成立则继续执行 do 中的循环体，如果不成立，则跳出 do-while 的循环体。 循环体中的代码最少会执行一次。 先斩后奏 十九、break和continue break 作用：立刻结束当前循环（不再进行这个循环）。 continue 作用：立刻结束本次循环（进行下一次循环）。 for (int i = 0; i 二十、数组、集合 概念：数组是一个存储相同类型元素的固定大小的顺序集合。 作用：一次性存储多个相同类型的变量。 //定义一个数组，然后初始化数组的元素 int[] arr = new int[] { 1, 2, 3, 4, 5 }; ////取数组第一个元素 //Console.WriteLine(arr[0]); for (int i = 0; i 二一、遍历 foreach（数组数据类型 临时变量 in 数组名） { Console.WriteLine(临时变量); } int[] arr = new int[] { 1, 2, 3, 4, 5 }; foreach (int item in arr) { Console.WriteLine(item); } 二二、函数及其基本语法 函数的概念 一段特定功能的代码，有自己的名字，通过名字可以重复调用这段代码来帮我们完成特定的事情。 函数的声明(语法) static 返回值类型 函数名（[形式参数]） { 函数代码体； } static int Test(int a) { //执行一段计算逻辑 a+=1; return a; } int b=1; int result = Test(b)//调用这个函数得到的结果是2 形参： 形式参数，在定义函数的时候，在参数列表中定义的参数。 实参： 实际参数，在调用函数的时候，传递给函数的具体参数。 返回值 关键字 return ①在函数中返回要返回的值； ②立即结束函数； 二三、Label控件的使用 控件的名称和文案 按住鼠标左键，从工具箱拖动控件到我们的窗体设计页面上 通过右键属性，我们可以修改控件的文案（Text）和名称（Name） 二四、Button控件的使用 按住鼠标左键，从工具箱拖动控件到我们的窗体设计页面上 通过右键属性，我们可以修改控件的文案（Text）和名称（Name） 二五、计算器页面的布局 需要删除控件的时候，选中按住delete进行删除即可 二六、窗体属性的设置 启动后居中：StartPostion=CenterParent 禁止放大：MaximizeBox=false 二七、代码层面查看属性以及修改属性 ​ ​ Form1.Designer.cs this.Surplus.Location = new System.Drawing.Point(97, 61); this.Surplus.Name = \"Surplus\"; this.Surplus.Size = new System.Drawing.Size(78, 50); this.Surplus.TabIndex = 21; this.Surplus.Text = \"取余\"; this.Surplus.UseVisualStyleBackColor = true; this.Surplus.Click += new System.EventHandler(this.Surplus_Click); 二八、控件的点击事件 ​ 什么是事件，如何添加事件。双击控件，生成事件 二九、通过事件来触发一些操作，比如修改label的值 ​ 在事件中，给控件赋值 ​ label1.Text = \"张三\"; 三十、定义一个变量，记录每次点击按钮的值 ​ 分析当前环境， 定义合适的变量类型 ​ public static string GlobalExpression = \"\"; ​ GlobalExpression += \"8\"; ​ Expression.Text = GlobalExpression; 三一、定义追加表达式的公共方法，传参以及调用 /// /// 追加表达式 /// /// public void AppendNumber(string num) { //全局表达式变量累计赋值 GlobalExpression += num; Expression.Text = GlobalExpression; } 三二、通过if-else，判断输入的是数字还是计算符号 ​ //判断输入的是不是数字或者小数点 string vaildStr = \".,0,1,2,3,4,5,6,7,8,9\"; //IndexOf返回当前字符在字符串中的位置（索引） if (vaildStr.IndexOf(num) > -1) { //索引大大于-1表示存在，说明是数字 } else { //说明是符号 } 三三、字符串的追加操作 GlobalExpression += num; 三四、字符串的为空判断，以及多种方式 //如果默认没有输入数字，点击加减乘除则不走解析逻辑 if (GlobalExpression != \"\") { //不为空的时候走解析逻辑 } //通过string自带的函数来判断字符串是否为空字符串或者null if (!string.IsNullOrEmpty(GlobalExpression)) { //不为空的时候走解析逻辑 } 三五、取最后一位字符，并判断是否存在 ​ 1+1 + 2+ ​ 1++ Substring函数 Substring（截取的开始位置，截取长度） string lastStr = GlobalExpression.Substring(GlobalExpression.Length - 1, 1); 三六、定义运算方法，入参，和返回结果 /// /// 运算 /// /// /// public string Operation(string num) { //运算逻辑 return GlobalExpression; } 三七、通过if-else-if，判断是什么符号 1+1、1-1、 1*1 、 1/1 、1%1 if (GlobalExpression.Contains(\"+\")) { //加法 } else if (GlobalExpression.Contains(\"-\")) { //减法 } else if (GlobalExpression.Contains(\"*\")) { //乘法 } else if (GlobalExpression.Contains(\"/\")) { //除法 } else if (GlobalExpression.Contains(\"%\")) { //取余 } 三八、字符串的切割以及字符串数组的讲解 string[] temps = GlobalExpression.Split(new char[] { '+' }, StringSplitOptions.RemoveEmptyEntries); //举个栗子 string[] temps = new string[]{\"张三\",\"李四\",\"王五\",\"赵六\",\"田七\"} string[] temps = new string[]{\"1\",\"1\"} string[] temps = new string[]{\"2\",\"3\"} 三九、取值，以及类型转换和赋值 //加法 //通过Split方法切割字符串，得到一个字符串数组 string[] temps = GlobalExpression.Split(new char[] { '+' }, StringSplitOptions.RemoveEmptyEntries); //如果是字符串1+字符串1，得到的将会是11，只有数值类型相加才会执行数学计算 GlobalExpression = (Convert.ToDecimal(temps[0]) + Convert.ToDecimal(temps[1])).ToString(); 四十、优化之方法的提炼 /// /// 子方法 /// /// +-*/% public void OperationTool(char Symbol) { if (GlobalExpression.Contains(Symbol)) { string[] temps = GlobalExpression.Split(new char[] { Symbol }, StringSplitOptions.RemoveEmptyEntries); if (temps.Length > 1) { switch (Symbol) { case '+': GlobalExpression = (Convert.ToDecimal(temps[0]) + Convert.ToDecimal(temps[1])).ToString(); break; case '-': GlobalExpression = (Convert.ToDecimal(temps[0]) - Convert.ToDecimal(temps[1])).ToString(); break; case '*': GlobalExpression = (Convert.ToDecimal(temps[0]) * Convert.ToDecimal(temps[1])).ToString(); break; case '/': GlobalExpression = (Convert.ToDecimal(temps[0]) / Convert.ToDecimal(temps[1])).ToString(); break; case '%': GlobalExpression = (Convert.ToDecimal(temps[0]) % Convert.ToDecimal(temps[1])).ToString(); break; } } } } 四十一、写在最后，细节的完善 //清零+图标和窗体的文案 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/WindowsApp/WindowsMFC.html":{"url":"08_Others/WindowsApp/WindowsMFC.html","title":"Windowsmfc","keywords":"","body":"windows程序内部运行原理 Windows API 操作系统能完成的功能的函数集合 位置：Windows/System32/Kernel32.dll、 USER32.dll、GDI32.dll 使用：C和Windows SDK开发包( API函数是用纯C写的，都在windows.h中有声明) MFC MFC > Microsoft Foundation Classes > 微软基础类库 一个对Windows API进行封装后产生的类库，提供了一个面向对象的编程方式。 MFC使Windows程序员能够利用C++面象对象的特性进行编程 为什么要使用MFC？ 可重用性 封装后使方法和属性更紧密的捆绑 常用的功能自动化，减少编写代码的数量 提供应用程序的框架结构 框架结构提供了抽象功能，它远远超出了Windows API的功能。例如:MFC的文档/视图体系结构在API上建造了一个功能强大的基础结构,它把程序中数据的图形表示(或成为视图)与数据本身分开。这种抽象对API而言完全是陌生的，而且在MFC框架结构之外或类似的类库中也不存在。 Windows编程模型 编写windows应用程序的要素 入口函数 创建窗口 发送消息与消息循环 窗口过程与消息响应 句柄 操作系统通过句柄来找到对应的资源进行管理和操作。 按资源的类型，又可将句柄细分成图标句柄(HICON)，光标句柄(HCURSOR)，窗口句柄(HWND)，应用程序实例句柄(HINSTANCE)等等各种类型的句柄。 操作系统给每一个窗口指定的一个唯一的标识号即窗口句柄。 创建窗口 API中对数据的宏定义 int x, y; x = 30; y = 30; //x和y既可以用来表示坐标点，也可以用来表示宽度和高度，还可以用来表示身高和体重。 typedef int WIDTH typedef int HEIGHT WIDTH x; HEIGHT y; //我们从变量的类型上就可以知道x和y是用来表示宽度和高度。 char str[255]; sprintf (str, \"%s\"，lpCmdLine); //参数1：父窗口，默认为桌面 //参数2：显示的内容 //参数3：窗口标题 //参数4：窗口布局 //返回值：整型数，告诉程序用户按了哪个按钮 MessageBox (NULL, str,\"命令行\",O); sprintf(str,\"%d\", nCmdShow) ; MessageBox (NULL,str,\"窗口状态\", 0); 代码 #include #include //声明窗口过程函数 LRESULT CALLBACK MyWndProc( HWND hwnd,//handle to window UINT uMsg,//message identifier WPARAM wParam,//first message parameter LPARAM lParam,// second message parameter ) //1 入口函数 int WINAPI WinMain( HINSTANCE hInstance,//应用程序的实例句柄 HINSTANCE hPrevInstance,//老版本需要，传入空 LPSTR lpCmdLine,//命令行 int nCmdShow,// 窗口显示时的状态 ) { //2 创建窗口 //2.1 设计一个窗口类 WNDCLASS MyWnd; MyWnd.cbClsExtra = NULL;//窗口类附加内存，用不到，设置为空就好 MyWnd.cbWndExtra = NULL;//窗口附加内存，用不到，设置为空就好 MyWnd.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);//背景颜色，getStockObject还可以获得画刷、画笔、字体、调色板，句柄类型不一样，c语言特性需要对这些资源进行强转 MyWnd.hCursor = LoadCursor (NULL，IDC_ARROW);//鼠标形状 MyWnd.hIcon = LoadIcon (NULL，IDI_APPLICATION );//窗口图标，LoadIcon的第一个参数为空代表图标资源由操作系统提供，不为空时只能传入hInstance，代表图标自己绘制 MyWnd.hInstance = hISnstance;//应用程序实例句柄 MyWnd.lpfnWndProc = MyWndProc;//指向窗口过程函数的指针 MyWnd.lpszClassName = \"Hello\";//窗口型号名称 MyWnd.lpszMenuName = NULL;//窗口没有菜单 MyWnd.style = CS_HREDRAW | cS_VREDRAW;//样式，当水平尺寸或垂直尺寸变化时，窗口要重新绘制 //2.2 对设计好的窗口类进行注册 RegisterClass(&MyWnd) ; //2.3 创建窗口 HWND hWnd;//定义了一个句柄，不代表窗口已经生成 hWnd = CreateWindow(\"Hello\",\"Windows编程\", WS_OVERLAPPEDWINDOW & ~WS_MAXIMIZEBOX, //~WS_MAXIMIZEBOX代表去掉最大化按钮 0,0,800,600, //CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT //代表不指定具体的位置和尺寸，使用默认的，操作系统会根据分辨率、窗口布局等显示窗口 NULL,NULL,hInstance, \"欢迎来到Windows编程!\" //CREATE消息携带的信息，打开窗口前显示 ); /** //API函数，创建窗口，调用时会发送消息W_CREATE HWND CreateWindow( LPCTSTR lpClassName,//已注册的窗口类名称 LPCTSTR ipWindowName,//窗口标题栏中显示的文本 DWORD dwStyle,//窗口类样式，代表共同都拥有的样式 int x,//水平坐标,坐标原点是屏幕的左上角 int y,//垂直坐标 int nWidth,//宽度 int nHeight,//高度 HWND hWndParent,//父窗口句柄,桌面是操作系统原始的父窗口 HMENU hMenu,//菜单句柄 HINSTANCE hInstance,//应用程序实例句柄 LPVOID lpParam//用于多文档程序的附加参数,单文档为NULL ); **/ /** //消息结构体 **/ //2.4 显示及其更新窗口 ShowWindow (hWnd,SW_SHOW); UpdateWindow (hWnd) ; //如果有无效区，则马上发送WM_PAINT到窗口处理过程， //不进消息队列进行排队等待，立即刷新窗口，否则，什么都不做。 //3.消息循环 //如果没有消息循环，窗口会一闪而过 MSG msg; while (GetMessage (&msg, NULL,0,0))//从消息队列中获取消息,拿到QUIT消息则返回0，当程序异常时返回-1 { TranslateMessage (&msg);//消息解释 /** TranslateMessage函数用于将虚拟键消息转换为字符消息。当我们敲击键盘上的某个字符键时，系统将产生WM_KEYDOWN和WM_KEYUP消息。这两个消息的附加参数(wParam和lParam）包含的是虚拟键代码和扫描码等信息，而我们在程序中往往需要得到某个字符的ASCII码，TranslateMessage这个函数就可以将WM_KEYDOWN和WM_KEYUP消息的组合转换为一条WM_CHAR消息，该消息的WParam附加参数包含了字符的ASCII码），并将转换后的新消息投递到调用线程的消息队列中。注意，Translate函数并不会修改原有的信息，他只是产生新的消息并投递到消息队列中。 **/ DispatchMessage (&msg) ;//将消息发送到“窗口过程” } return 0; /** BOOL GetMessage( LPMSG lpMsg, // 消息结构体指针，返回消息信息 HWND hWnd, // 窗口句柄 ，通常设为NULL UINT wMsgFilterMin, // 消息过滤最小值 UINT wMsgFilterMax // 消息过滤最大值 ); //GetMessage从线程的消息队列中取出消息，取出的消息保存在事先定义好的消息的结构体对象中。 **/ //4.“窗口过程函数”(编写消息响应代码) typedef struct _WNDCLASS { UINT style;//窗口类样式 WNDPROC lpfnWndProc;//窗口过程函数指针 int cbClsExtra;//窗口类附加内存字节数，通常为0 int cbWndExtra;//窗口附加内存字节数，通常为0 HANDLE hInstance;//应用程序实例句柄 HICON hIcon;//标题栏图标 HCURSOR hCursor;//光标 HBRUSH hbrBackground;//窗口背景颜色 LPCTSTR lpszMenuName;//菜单资源名称 LPCTSTR lpszClassName;//窗口类名称 } WNDCLASS; WNDCLASS MyWnd; MyWnd.cbClsExtra = NULL; MyWnd.cbWnd Extra = NULL; MyWnd.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); MyWnd.hCursor = LoadCursor (NULL, IDC_ARROW); MyWnd.hIcon = LoadIcon (NULL,IDI_QUESTION); MyWnd.hInstance = hInstance; MyWnd.lpfnWndProc = MyWndProc; MyWnd.lpszClassName = \"He1lo\"; MyWnd.lpszMenuName = NULL; MyWnd.style = CS_HREDRAW | CS_VREDRAW; LRESULT CALLBACK MyWndProc ( HWND hwnd,//handle to window UINT uMsg，//message identifier WPARAM wParam,//first message parameter LPARAM lParam//second message parameter } switch (uMsg){ case WM_CREATE: //查看CreateWindow函数的最后一个参数 MessageBox(hwnd,(char*) (((LPCREATESTRUCT)1Param)->lpCreateParams),\"启动窗口\",0); return 0;//返回值不能是-1，否则CreateWindow函数返回0 case WM_CLOSE: if (IDYES == MessageBox (hwnd,\"真的要退出吗?\",\"退出\",MB_YI) DestroyWindow (hwnd); break; case WM_DESTROY: PostQuitMessage(0); break; case WM_CHAR: char str[255]; sprintf (str,\"char is %d\", wParam); MessageBox (hwnd,str,\"按键响应\",0);。 break; case WM_LBUTTONDOWN: HDC hDC; hDC = GetDC(hwnd); TextOut(hDC,255,100,\"Hello World!\",strlen(\"Hello World!\")); ReleaseDC(hwnd,hDC); break; case WM_PAINT://窗口无效-->重绘-->窗口重新变成有效状态 HDC hpaintDC; PAINTSTRUCT ps; hpaintDC = BeginPaint(hwnd,&ps);//不能用getDC TextOut(hpaintDC,255,150,\"Hello World!\",strlen(\"Hello World\"));//文本输出，应该在beginpaint下面 EndPaint(hwnd,&ps); case WM_RBUTTONDOWN: sendMessage(hwnd,WM_SETTEXT,0,(LPARAM)\"right button down\");//改变当前窗口的标题 sendMessage(FindWindow(\"CalcFrame\",NULL),WM_SETTEXT,0,(LPARAM)\"right button down\");//改变其他窗口的标题，CalcFrame是系统计算器的窗口类名称 break; default: return DefwindowProc(hwnd, uMsg, wParam，lParam); } return 0; /** 大多数消息是由操作系统产生和发送，此外我们也可以人为调用SendMessage和PostMessage函数来自行发送消息。 SendMessage将消息直接发送给窗口，并调用该窗口过程进行处理。在窗口过程对消息处理完毕后,该函数才返回。 PostMessage函数将消息放入与创建窗口的线程相关联的消息队列后立即返回。 **/ 编写Windows应用程序 要素 1.入口函数WinMain 2.创建窗口 3.消息循环与发送消息 4.窗口过程与消息响应 1.入口函数WinMain int WINAPI WinMain( HINSTANCE hInstance,//当前应用程序实例句炳 HINSTANCE hPrevInstance,//永远为NULL LPSTR lpCmdLine,//命令行参数 int nCmdShow//窗口显示时的状态 ); 2.创建窗口 设计一个窗口类 注册窗口类 创建窗口 显示及更新窗口 设计窗口类 typedef struct _WNDCLASS { UINT style;//窗口类样式 WNDPROC lpfnWndProc;//窗口过程函数指针 int cbClsExtra;//窗口类附加内存字节数，通常为0 int cbWndExtra;//窗口附加内存字节数，通常为0 HANDLE hInstance;//应用程序实例句柄 HICON hIcon;//标题栏图标 HCURSOR hCursor;//光标 HBRUSH hbrBackground;//窗口背景颜色 LPCTSTR lpszMenuName;//菜单资源名称 LPCTSTR lpszClassName;//窗口类名称 } WNDCLASS; 创建窗口 HWND CreateWindow( LPCTSTR lpClassName,//己注册的窗口类名称 LPCTSTR lpWindowName,//窗口标题栏中显示的文本 DWORD dwStyle,//窗口样式 int x,//水平坐标 int y,//垂直坐标 int nWidth,//宽度 int nHeight,//高度 HWND hWndParent,//父窗口句柄 HMENU hMenu,//菜单句柄 HINSTANCE hInstance,//应用程序实例句柄 LPVOID lpParam//用于多文档程序的附加参数,单文栏为NULL ); 3.消息循环与发送消息 MSG msg; while (GetMessage(&msg,NULL,0,0))// 从消息队列获取消息 { TranslateMessage(&msg);//消息解释 DispatchMessage(&msg);//将消息发送到“窗口过程” } GetMessage BOOL GetMessage( LPMSG IpMsg,//消息结构体指针,返回消息信息 HWND hWnd,//窗口句柄,通常设为NULL UINT wMsgFilterMin,//消息过滤最小值 UINT wMsgFilterMax//消息过滤最大值 ); GetMessage从线程的消息队列中取出消息，取出的消息保存在事先定义好的消息的结构体对象中。 GetMessage函数取到除WM_QUIT外的消息均返回非零值,只有在接收到WM_QUIT消息时，才返回0。 什么时候才会收到WM_QUIT呢?(见窗口过程) TranslateMessage TranslateMessage函数用于将虚拟键消息转换为字符消息。当我们敲击键盘上的某个字符键时,系统将产生WM_KEYDOWN和WM_KEYUP消息。这两个消息的附加参数(wParam和IParam)包含的是虚拟键代码和扫描码等信息,而我们在程序中往往需要得到某个字符的ASCII码，TranslateMessage这个函数就可以将WM KEYDOWN和WM_KEYUP消息的组合转换为一条WM_CHAR消息，该消息的WParam附加参数包含了字符的ASClI码),并将转换后的新消息投递到调用线程的消息队列中。注意, Translate函数并不会修改原有的信息，他只是产生新的消息并投递到消息队列中。 DispatchMessage DispatchMessage分派一个消息到窗口过程。由窗口过程函数对消息进行处理。 DispatchMessage实际上是将消息回传给操作系统,再由操作系统调用窗口过程函数对消息进行处理。 4.窗口过程与响应消息 窗口过程函数 窗口类第二个成员变量lpfnWndProc指定了这一类型的窗口过程函数，也称回调函数。 当应用程序收到给某一窗口的消息时，操作系统调用回调函数来处理这条消息。回调函数本身的代码必须由应用程序自己完成。 回调函数 凡是由你设计而却由Windows系统调用的函数,统称为Callback函数。这些函数都有一定的类型,以配合Windows的调用操作。 除了窗口过程函数,Windows API还有一些其它的回调函数，例如SetTimer、LineDDA、 EnumObject。这种函数会在进行某种行为之后或满足某种状态之时，操作系统自动调用该函数。 响应消息实例 LRESULT CALLBACK MyWndProc( HWND hwnd,//handle to window UINT uMsg,//message identifier WPARAM wParam,//first message parameter LPARAM lParam//second message parameter ) { switch (uMsg){ case WM PAINT://响应消息 case WM KEYDOWN://响应消息 case WM LBUTTONDOWN://响应消息 default: return DefWindowProc(hwnd,uMsg,wParam,lParam); } return 0; } DefWindowProc 我们的程序无论多大都不可能将所有的消息都处理,所以我们必须有一个机制让不感兴趣的、不需要我们处理的消息，交还给Windows操作系统为我们处理,这个过程就是由DefWindowProc函数来实现的，也是每个程序所必备的。 掌握C++ 虚函数与多态 当C++编译器在编译的时候,发现基类的函数是虚函数,这个时候C++就会采用迟绑定(late binding）的技术，在运行时，依据对象的类型(在示例程序中，我们传递的派生类对象的地址)来确认调用的哪一个函数,这种能力就做C++的多态性。 在基类的函数前加上virtual关键字，该函数则为虚函数。虚函数派生下去仍为虚函数,而且可以省略virtual关键字。 在派生类中重写该函数,运行时将会根据指针实际所指的对象的类型来调用相应的函数。如果对象类型是派生类,就调用派生类的函数;如果对象类型是基类，就调用基类的函数。 纯虚函数是指被标明为不具体实现的虚函数。纯虚函数可以让类先具有一个操作名称,而没有操作内容,让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种可不能实例化对象，只能作为基类为派生类服务。 注意:派生类中必须实现基类的纯虚函数,否则，派生类也变成了抽象类，不能实例化对象。 纯虚函数多用在一些方法行为的实际上。在设计基类时,不太好确定或将来的行为多种多样，而此行为又是必需的，我们就可以在基类的设计中，以纯虚函数来声明次中行为，而不具体实现它。 关于“相同名称之成员函数” 1.如果你以一个“基类之指针”指向“派生类之对象”那么经由该指针你只能够调用基类所定义的函数。 2.如果基类和派生类都定义了“相同名称之成员函数”，那么通过对象指针调用成员函数时，到底调用哪一个函数,必须视该指针的原始类型而定,而不是指针实际所指的对象的类型而定,这一点与第1点其实意义相同。 C++中虚函数与纯虚函数的区别 定义一个函数为虚函数，不代表函数为不被实现的函数。 定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。 定义一个函数为纯虚函数，才代表函数没有被实现。 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。 引用 引用的使用规则及其与指针的比较 (1)引用被创建的同时必须被初始化;指针则可以在任何时候被初始化。 (2)不能有NULL引用,引用必须与合法的存储单元关联;指针则可以是NULL。 (3)一旦引用被初始化，就不能改变引用的关系;指针则可以随时改变所指的对象。 const 任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时,不慎修改了数据成员,或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。 静态与非静态 静态成员函数和静态成员变量属于类本身，在类加载的时候(编译阶段)，即为它们分配了空间，因此可以通过类名::函数名或类名::变量名来访问。 而非静态函数和非静态成员属于对象的方法和数据，也就是应该首先产生类的对象,然后通过类的对象去引用。 静态函数不属于某个具体的对象，也就是说，在还没有产生类的任何一个具体对象时，静态函数就已经存在于程序的代码区了。但这是类的非静态成员还没有分配内存空间，这样，在静态成员函数中是没有办法对类非静态成员进行操作的。因此，在静态成员函数中只能访问静态成员变量，不能访问非静态成员函数和非静态成员变量。非静态成员函数中可以调用静态成员函数。 四种不同对象的生与死 在C++中,产生一个对象有四种方法： void MyFunc(){ CObject ob; //1.一般局部对象，在栈(Stack)之中产生 } void MyFunc(){ CObject* pOb = new CObject; //2.new局部对象，在堆(Heap)中产生 } //3.全局对象（必然也是个静态对象) CObject ob ;//在任何函数范围之外做此操作 void MyFunc(){ static CObject ob;//4.局部静态对象，在函数范围内的一个静态对象 } 对于一般局部对象(栈Stack中产生):当对象产生时，构造函数被执行;当函数结束时(以至于对象将毁灭)，析构函数被执行。 对于new操作局部对象(堆Heap中产生):当对象产生时(执行new操作)，构造函数被执行;当delete对象语句被执行时，析构函数被执行。 对于全局对象:程序一开始，其构造函数就先被执行（比入口函数main、WinMain更早);程序结束前，析构函数被执行。 对于局部静态(static）对象:只会有一个实例产生，而且在固定的内存上(既不是stack也不是heap)，执行到第一次声明处（也就是在MyFunc第一次调用)时，构造函数被调用;当程序结束时(对象因此遭致毁灭)，析构函数被执行，但比全局对象的析构函数先一步执行。 函数的重载 两个函数的函数名一样,参数的类型和个数不同，这在C语言中不允许,而在C++中是合法的,这就是C++中函数的重载。 (overload)。C++编译器将根据参数的类型和参数的个数来确定执行哪一个函数。 重载的条件:函数的参数类型、参数个数不同，才能构成函数的重载。分析: (1) void output( 与int output( (2) void output(int a, int b=5)与void output(int a) 注意: 只有函数的返回类型不同是不能构成函数的重载的。 要注意函数带有默认参数的这种情况,也不能构成函数重载。 MFC框架程序剖析 test.h、 test.cpp 应用程序类:CTestApp（由CWinApp继承而来），每一个MFC程序有且仅有一个主应用程序类对象 theApp，它代表一个程序本体,用于管理和维护主应用程序 MainFrm.h、 MainFrm.cpp 主框架类CMainFrame（由CWnd继承而来)，主框架是应用程序的主体窗口，其他的窗口（如视类窗口、工具条、状态条）都依附于主框架窗口(覆盖在它上面）。 testView.h、 testView.cpp 视图类:CTestView（由CWnd继承而来），负责管理和维护图形显示操作。 testDoc.h、 testDoc.cpp 文档类:CTestDoc（由CDocumet继承而来），负责显示数据的后台管理和维护。 MFC中的全局对象theApp 初始化CTestAPP对象，应用程序内存获得配置 调用基类CWinApp构造函数（在MFC源码目录的文件中AppCore.cpp），初始化完成程序运行时的一些初始化工作。 注意:由于theApp是个全局对象，所以CWinApp构造函数会在入口函数WinMain之前运行。 消息映射 消息是Windows程序的血液，Windows程序靠消息的流动而维护生命。 在Windows API程序当中，消息的处理方法是在窗口函数中借助一个大大的switch/case比较操作,判别消息，再执行对应的处理代码。 在MFC中,为了让大大的switch/case比较操作简化,也让程序代码模块化,MFC采用了一种“Message Mapping”(消息映射表)的做法，把消息和其处理程序关联起来。 Message Mapping的基本原理 首先定义一个MSCMAP ENTRY结构 struct MSGMAP_ENTRY { UNIT nMessage; LONG (*pfn) (HWND, UNIT,WPARAM, LPARAM); }; 注意：pfn是一个函数指针,而该指针所指的函数处理nMessage消息。这正是面向对象观念中把“数据”和“处理数据的方法”封装起来的一种具体实现。 接下来,组织一个MSGMAP_RNTRY结构的数组_messageEntries[]把程序终欲处理的若干消息以及消息处理函数的关联性建立起来: struct MSGMAP ENTRY_messageEntries[] = { //消息,消息处理函数 WM_CREATE, OnCreate, WM_PAINT, OnPaint, WM_COMMAND, OnCommand WM_CLOSE, OnClose }; 于是窗口函数可以这么写: LRESULT CALLBACK MyWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM IParam) { for (int i=0; i 这么一来,窗口过程函数WndProc永远不必改变,每当有新的要处理的消息,只要在_messageEntries[]数组中加上新的数组元素，并针对新消息写新的处理函数就OK了。 MFC框架程序中是如何实现消息映射操作的呢? 在MFC框架程序中,消息映射通过消息映射宏来实现消息映射的操作。 举例:在MFC框架程序中为视类增加一个鼠标左键按卞消息。在源文件中会增加兰处代码: (1)消息响应函数原型(作为类成员函数，在类h头文件中声明) (2)消息映射宏(CPP源文件) (3)消息响应函数定义(在类CPP源文件实现该消息响应函数) 消息映射宏 其中BEGIN_MESSAGE_MAP和END_MESSAGE_MAP这两个宏之间定义了CTestView类的消息映射表，即前面所讲的_messageEntries[]数组;而ON_WM_LBUTTONDOWNO这个宏的作用是在_messageEntries[]数组中添加一个消息映射元素，把WM_LBUTTONDOWN消息与 OnButtonDown函数关联起来。 通过这种机制，一旦有消息产生,程序就会调用相应的消息响应函数来进行处理。 MFC类层次结构 设备描述表DC 在Windows平台下，窗口的所有图形操作都是利用DC来完成的。 如果使用GetDC来得到DC的句柄，在完成图形操作后，必须调用ReleaseDC来释放DC所占用的资源,以避免内存泄漏。 利用计算机作图，窗口相当于画布,因此，在获取DC的句柄时，总是和一个指定的窗口相关联。 绘图 1.利用API全局函数实现画线功能 void CDrawView::OnLButtonDown(UINT nFlags,CPoint point){ //TODO: Add your message handler code here and/or call default m_ptOxigin = point; CView::OnLButtonDown(nFlags, point); } void CDrawView::OnLButtonUp(UINT nFlags,CPoint point){ HDC hdc; hdc =::GetDC(m_hWnd); ::MoxeToEx(hdc, m_ptOrigin.x, m_ptOrigin.y, NUL); ::LineTo(hdc, point.x, point.y); ::ReleaseDC(m_hWnd,hdc); CView::OnLButtonUp(nFlags, point); } 2.利用CDC类实现画线功能 void CDraw.View::OnLButtonUp(UINT nFlags, CPoint point){ CDC* pDC = GetDC(); pDC->MoveTo(m_ptOrigin); pDC->LineTo(point); ReleaseDC(pDC); CView::OnLButtonUp(mFlags, point); } 3.利用CClientDC、CWindowDC类绘图 CClientDC派生于CDC类,并且在构造时调用GetDC函数，在析构时调用ReleaseDC函数。它与CDC一样,都是实现在窗口的客户区绘图。 void CDrawView::OnLButtonUp(UINT nFlags,CPoint point){ CClientDC dc(this); dc.MoveTo(m_ptOrigin); dc.LineTo(point); CView::OnLButtonUp(nFlags, point); } CWindowDC派生于CDC类,并且在构造时调用GetWindowDC函数,在析构时调用ReleaseDC函数。该对象可以访问整个窗口区域，包括客户区与非客户区。 void CDrawView::OnLButtonUp(UINT nFlags, CPoint point){ CWindowDC dc(this); dc.MoveTo(m_ptOrigin); dc.LineTo(point); CView::OnLButtonUp(nFlags, point); } CClientDC和CWindowDC的区别 CClientDC派生于CDC类，并且在构造时调用GetDC函数，在析构时调用ReleaseDC函数。它与CDC一样，都是实现在窗口的客户区绘图。 CWindowDC派生于CDC类，并且在构造时调用GetWindowDC函数，在析构时调用ReleaseDC函数。该对象可以访问整个窗口区域,包括客户区与非客户区。 客户区与非客户区 这种类型的窗口叫做应用程序窗口（application window）或者主窗口（ main window）。典型的主窗口框架通常包括标题栏、最小化按钮和最大化按钮以及一些其它的 UI 组件。这个框架本身叫做窗口的非客户区（non-client area）。 Windows 操作系统负责管理非客户区的响应操作，例如拖拽，改变大小，最大化最小化等等。框架之外剩余的区域，叫做客户区（client area），这部分是由程序自身负责管理的。 MFC框架程序界面中，整个程序窗口就是框架窗口,工具栏以下白色区域才是视类窗口。 视类窗口只有客户区(即视类窗口本身) 框架窗口既有客户区(菜单栏以下部分)，还有非客户区(标题栏和菜单栏)。 绘图操作一般都是在窗口的客户区进行的（(使用CDC或CClientDC);要在非客户区绘图,则要使用CWindowDC. 4.绘制彩色线条—使用CPen类 CPen pen(PS_SOLID,5,RGB(255,0,0));//声明一个Cpen对象 CClientDC dc(this);//声明一个CClientDC对象 CPen* pOldPen = dc.SelectObject(&pen); dc.MoveTo(m_ptOrigin); dc.LineTo(point); dc.SelectObject(pOldPen); 注意:当构造一个GDI对象后，该对象并不会立即生效，必须通过SelectObject函数选入设备描述表,它才会在以后的绘制操作中生效。在完成绘图操作之后，都要利用SelectObject把先前的GDI对象选入设备描述表，以便使其恢复到先前的状态。 5.使用画刷CBrush类绘图 //绘制矩形填充块 CBrush brush(RGB(255,0,0)); CClientDC dc(this); dc.FillRect(CRect(m ptOrigin,point), &brush); //绘制位图填充块 CBitmap bmp; bmp.LoadBitmap(IDB_BITMAP1); CBrush brush(&bmp); CClientDC dc(this); dc.FillRect(CRect(m_ptOrigin,point), &brush); 6.绘制矩形框 CPen pen(PS_SOLID,5,RGB(255,0,0));CClientDC dc(this); CPen* pOldPen = dc.SelectObject(&pen); dc.Rectangle(CRect(m_ptOrigin,point)); dc.SelectObject(pOldPen); //若要绘制空心的矩形框,需要在设备描述表中将默认画刷(填充白色)换成透明画刷 CBrush* pOldBrush =(CBrush*)dc.SelectStockObject(HOLLOW_BRUSH);dc.SelectObject(pOldBrush); 7.绘制连续线条 m_ptOrigin = point; //OnLButtionDown //OnMouseMove CClientDC dc(this); if (nFlags ==MK_LBUTTON ){ dc.MoveTo(m_ptOrigin); dc.LineTo(point); m_ptOrigin = point; } 8.橡皮筋技术 //OnLButtionDown m_ptOrigin = m_ptEnd = point; //OnMouseMove CClientDC dc(this); if (nFlags== MK_LBUTTON){ //通过取反的模式擦除旧线条 dc.SetROP2(R2_NOT); dc.MoveTo(m ptOrigin); dc.LineTo(m_ptEnd); //绘制新线条 m_ptEnd = point; dc.MoveTo(m_ptOrigin); dc.LineTo(m_ptEnd); } 文本编程 1.在窗口输入文字——视类OnDraw函数 MFC中专门为视类提供了响应WM_PAINT消息的响应函数OnDraw(CDC* pDC) 如果要防止窗口重绘时显示的文字或图形被刷新,文字输出和图形绘制的操作都应该在OnDraw函数里完成。 void CTextView::OnDraw(CDC* pDC){ CTextDoc* pDoc-GetDocument(); ASSERTVALID(pDoc); pDC->TextOut(100,100,\"第四讲文本编程\"); } 2.在窗口输入文字——CString类 MFC中提供了一个字符串类:CString,这个类没有基类。一个CString对象由一串可变长度的字符组成。 利用CString操作字符串时，无论存储多少个字符,我们都不需要对它进行内存分配,因为这些操作在CString类的内部都已经替我们完成了。 void CTextView::OnDraw(cDC* pDC){ CTextDoc* pDoc = GetDocumentO; ASSERT VALID(pDoc); //TODO: add draw code for native data here CString str(\"第四讲文本编程\"); pDC->TextOut(100,100, str); } 3.添加字符串资源 CString提供了一个成员函数:LoadString 该函数可以装载一个由nID标识的字符串资源。其好处是,在需要使用的时候将其装载到字符串变量中，这样就不需要在程序中对字符串变量直接赋值。 在VC开发界面左边的Resource View中，通过StringTable可添加字符串资源 void CTextView::OnDraw(CDC* pDC){ CString str; str.LoadString(1DS_MYSTRING); pDC->TextOut(100,100,str); } 4.创建文本插入符 int CDrawView::OnCreate(LPCREATESTRUCT lpCreateStruct){ if (CView::OnCreate(lpCreateStruct)==-1) return -1; //TODO: Add your specialized creation code here CreateSolidCaret(20,200); ShowCaret(); return 0; } 通常，插入符的大小应当根据当前所选的字号来变化。 调用CDC类的GetTextMetrics成员函数可以得到设备描述表中当前字体的度量信息。 BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const//详见MSDN 5.根据当前所选字号设置插入符大小 int CTextView::OnCreate(LPCREATESTRUCT lpCreateStruct){ if (CView::OnCreate(lpCreateStruct)==-1) return -1; //TODO: Add your specialized creation code here CClientDC dc(this); TEXTMETRIC tm; dc.GetTextMetrics(&tm); CreateSolidCaret(tm.tmAveCharWidth/8, tm.tmHeight); ShowCaret(); return 0; } 6.创建图形插入符 int CTextView::OnCreate(LPCREATESTRUCT lpCreateStruct){ if (CView::onCreate(lpCreateStruct)==-1) return-1; //TODO: Add your specialized creation code here CBitmap bmp; bmp.LoadBitmap(IDB_ BITMAP1); CreateCaret(&bmp); ShowCaret(); return 0; } 注意:以上代码的结果并非如我们所愿。因为这bmp对象是一个局部变量,当onCreate函数执行完成后，bmp对象就被销毁。有两种方法可以解决这一问题: ①将这个CBitmap对象修改为视类的成员变量。 ②如果CBitmap对象是一个临时对象,则在加载完成之后必须加上bmp.Detach()。Detach会把位图句柄与这个位图对象分离，这样,当这个局部对象的生命周期结束时，它不会去销毁一个它不再具有拥有权的位图资源。 7.插入符位置随鼠标单击而移动 void CTextView::OnLButtonDown(UINT nFlags, CPoint point){ //TODO: Add your message handler code here and/or call default SetCaretPos(point); CView::OnLButtonDown(nFlags, point); } 8.字符输入 首先让CTextView类捕获WM_CHAR消息,接着为该类定义一个CString类型的成员变量:m_strLine,用来存储输入的字符串。 输入的字符从插入符位置开始输出,因此当鼠标左键单击时,需要把m_strLine清空，同时保存左键单击点的坐标，确定字符串显示的位置。 void CTextView::OnLButtonDown(UINT nFlags,CPoint point){ SetCaretPos(point); m_strLine.Empty(); m_ptOrigin = point; CView::OnLButtonDown(nFlags, point); } void CTextView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags){ //TODO: Add your message handler code here and/or call default CClientDC dc(this); mstrLine += nChar; dc.TextOut(m_ptOrigin.x, m_ptOrigin.y, m_strLine); CView::OnChar(nChar,nRepCnt,nFlags); } 9.字符输入——回车键的处理 按下回车键后，插入符应换到下一行，随后的输入也应从这一新行开始·输出。因此需要清空上一行保存的字符，并计算插入下一行的新位置。 void CTextView::OnChar(UINT nChar,UINT nRepCnt, UINT nFlags){ if (13==nChar){//回车键的ASCI码为13i TEXTMETRIC tm; dc.GetTextMetrics(&tm); m_strLine.Empty(); m_ptOrigin.y += tm.tmHeight; } CView::OnChar(nChar, nRepCnt, nFlags); } 10.字符输入——退格键的处理 按下退格键后,应该删除屏幕上位于插入符前面的字符，同时,插入符的位置应回退一个字符。 先把文本的颜色设置为背景色,在窗口中把该文本输出一次(相当于从屏幕中抹去文本);再把文本的颜色设置为原来的颜色,把删除最后一个字符的字符串在窗口中输出一次。 CDC类中,获取背景色成员函数为GetBkColor;设置文本颜色的函数为SetTextColor。 从字符串中删除最右边的字符,可以利用CString类的Left函数。 else if (8== nChar)//退格键的ASCII码为8 { COLORREF clr= dc.SetTextColor(dc.GetBkColor()); dc.TextOut(m_ptOrigin.x, m_ptOrigin.y, m_strLine); m_strLine = m_strLine.Left(m_strLine.GetLength() - 1); dc.SetTextColor(clr); } else m_strLine+= nChar; dc.TextOut(m_ptOrigin.x, mptOrigin.y,m_strLine); 11.字符输入——调整插入符的位置 插入符应该随着字符的输入而移动。插入符横向移动的距离就是输入字符的宽度，其纵坐标不变。 GetTextExtent函数可以得到字符串在屏幕上显示的宽度。 CSize sz = dc.GetTextExtent(m_strLine); CPoint pt; pt.x = mptOrigin.x +Sz.cx; pt.y = m_ptOrigin.y; SetCaretPos(pt); 12.设置字体——CFont CFont的初始化函数有“CreateFont”、\"CreateFontIndirect”、\"CreatePointFont”、\"CreatePointFontIndirect\"。 CClientDC dc(this); CFont font; font.CreatePointFont(200,\"华文琥珀\"); CFont* pOldFont = dc.SelectObject(&font); dc.SelectObject(pOldFont); 消息 Windows消息的分类 标准消息 除WMCOMMAND之外，所有以WM开头的消息。从cWnd派生的类，都可以接收到这类消息。 命令消息 来自菜单、加速键或工具栏按钮的消息。这类消息都以WM_COMMAND呈现。在MFC中，通过菜单项的标识（ID)来区分不同的命令消息;在SDK中,通过消息的wParam参数识别。 从CCmdTarget派生的类，都可以接收到这类消息。 通告消息 由控件产生的消息，例如，按钮的单击，列表框的选择等均产生此类消息为的是向其父窗口(通常是对话框）通知事件的发生。这类消息也是以WM_COMMAND形式呈现。 从CCmdTarget派生的类，都可以接收到这类消息。 MSG结构体 操作系统将每个事件都包装成一个称为消息的结构体MSG来传递给应用程序。 MSG结构定义如下： typedef struct tagMSG { HWND hwnd; UINT message; WPARAM wParam; LPARAM lParam; DWORD time; POINT pt; } MSG; WM_PAINT Windows把一个最小的需要重绘的正方形区域叫做“无效区域”。当Windows发现了一个“无效区域“后，它就会向该应用程序发送一个WM_PAINT消息，通知应用程序重新绘制窗口。 当窗口从无到有、改变尺寸、最小化后再恢复、被其他窗口遮盖后再显示时,窗口的客户区都将变为无效。 WM_DESTROY 当窗口被销毁时会产生这个消息(通常也是准备退出应用程序的时候),对于这个消息的响应是每个程序所必备的。怎样响应呢? 响应方式就是调用PostQuitMessage函数，该函数会在消息队列中添加一个WM _QUIT消息,准备让由消息循环中的GetMessage取得。当消息循环中的收到wM QUIT消息时，GetMessage会传回0，从而结束消息循环,进而结束整个程序。 PostQuitMessage会发送WM_QUIT给消息队列。注意，WM_QUIT永远不会到达窗口过程,因为GetMessage得到WM_QUIT后就会返回0，从而结束消息循环,程序退出。 强烈建议PostQuitMessage放在WM_DESTROY消息响应里面调用，让程序正常有序的结束，因为通常销毁窗口是程序运行的最后一步。 当然, PostQuitMessage可以放在窗口过程的任何一个地方，让程序随时结束,但是这种做法就像采用拔电源的野蛮方式来关机,不可取~! WM_CLOSE 当我们按下窗口右上角的叉号或者按下左上角系统菜单中的“关闭”命令时,系统会送出WM_CLOSE消息。通常程序的窗口过程函数不拦截此消息，而是交由DefWindowProc函数来处理。 DefWindowProc函数在收到WM_CLOSE消息后，会自动调用DestroyWindow把窗口销毁。(调用DestroyWindow会产生WM_DESTROY消息) 当然，你可以不让DefWindowProc处理,而是自己处理WM_CLOSE消息。例如询问用户是否真的退出程序:如果用户选择“取消”,你忽略此消息,那么程序照常运行;如果用户确认要退出,必须手工调用DestroyWindow. 自行发送消息的两种方式 发送消息可以使用SendMessage和PostMessage函数。 SendMessage将消息直接发送给窗口，并调用该窗口过程进行处理。在窗口过程对消息处理完毕后，该函数才返回。 PostMessage函数将消息放入与创建窗口的线程相关联的消息队列后立即返回。 菜单 MFC中，设置为Pop-up类型的菜单称为弹出式菜单,VC++默认顶层菜单为弹出式菜单,这种菜单不能响应命令。 将菜单的属性对话框中的Pop-up选项去掉，该菜单成为一个菜单项，对应有一个ID号,可以响应命令。 菜单命令消息路由的过程(简答题) ①当点击某菜单项时，最先接收到这个菜单命令消息的是框架类。 ②框架类把接收到的这个消息传给它的子窗口，即视类。视类根据命令消息映射机制查找自身是否对这个消息进行了响应，如果响应了，则调用自身相应响应函数。 ③如果视类没有对此命令消息作出响应，就交由文档类，文档类同 样查找自身是否这个消息进行了响应，如果响应了，则调用自身相应响应函数。 ④如果文档类也未做出响应，就把这个命令消息交还给视类，后者 再交还给框架类。 ⑤框架类查看自己是否对这个命令消息进行了响应，如果它也没有 相应，就把这个菜单命令消息交给应用程序类,由后者来处理。 菜单的结构 标记菜单 UNIT CheckMenultem(UINT nIDCheckltem, UINT nCheck) 实例一: GetMenu0->GetSubMenu(0)->CheckMenuItem(0,MF_BYPOSITION |MF_CHECKED); 实例二: GetMenu(->GetSubMenu(0)-> CheckMenuItem(ID FILE_NEW,MF_CHECKED); 图形标记菜单（在菜单项签名加上位图） UNIT SetMenuItemBitmaps(UINT nPosition, UINTnFlag, const CBitmap pBmpUnchecked, constCBitmap pBmpChecked) 实例: bmp1.LoadBitmap(IDB_ BITMAP1); bmp2.LoadBitmap(IDB_BITMAP2); GetMenu(->GetSubMenu(0)->SetMenuItemBitmaps(0, MF BYPOSITION, &bmp1, &bmp2); 注意: 位图大小必须为13 x 13。 bmp1、bmp2为主框类的成员对象; 若为局部变量,菜单标记后要加上bmp.Detach() 移除和加载菜单 BOOL SetMenu(CMenu* pMenu) 移除菜单: SetMenu(NULL); 加载菜单: CMenu menu; menu.LoadMenu(IDR_MAINFRAME); SetMenu(&menu); 注意:如果CMenu对象是一个临时对象，则在加载完成之后必须加 上menu.Detach(。Detach会把菜单句柄与这个菜单对象分离,这样,当这个局部对象的生命周期结束时，它不会去销毁一个它不再具有拥有权的菜单资源。 MFC菜单命令更新机制 菜单项状态的维护是依赖于CN_UPDATE_COMMAND_UI消息，谁捕获CN_UPDATE_COMMAND_UI消息，MFC就在其中创建一个CCmdUI对象。我们可以通过ClassWizard在消息映射中添加ON_UPDATE_COMMAND_UI宏来捕获CN UPDATE_COMMAND_UI消息。 在后台所做的工作是:当显示菜单的时候,操作系统发出WM_INITMENUPOPUP消息,然后由MFC的基类如CFrameWnd接管。它创建一个CCmdUI对象,并与第一个菜单项相关联,调用对象的一个成员函数DoUpdate()。这个函数发出CN_UPDATE_COMMAND_UI消息,这条消息带有指向CCmdUI对象的指针。同一个CCmdUI对象就设置为与第二个菜单项相关联，这样顺序进行，直到完成所有菜单项。 更新命令UI处理程序仅应用于弹出式菜单项上的项目(有ID号)，不能应用于顶层菜单项目(无ID号)。 void CMainFrame::OnUpdateEditCopy(CCmdUI* pCmdUD){ //TODO: Add your command update UI handler code here pCmdUI->Enable(TRUE); pCmdUI->SetCheckO; pCmdUI->SetText(\"123\"); } 制作快捷菜单 Step1:为Menu程序增加一个新的菜单资源 在ResouceView上的Menu分支上单击鼠标右件,选择\"Insert Menu”命令，为这个菜单资源添加菜单项。 由于在显示快捷菜单时顶级菜单不出现,所以可以给它设置任意的文本。 Step2:给视类添加WM_RBUTTONDOWN消息响应函数 加载菜单资源到CMenu对象 void CMenuView::OnRButtonDown(UINT nFlags, CPointpoint){ CMenu menu; menu.LoadMenu(IDR_MENU1); CView::OnRButtonDown(nFlags, point); } Step3:调用TrackPopupMenu函数 void CMenuiew:: OnRButtonDown(UINT nElags,CPoint point){ CMenu menu; menu.LoadMenu(IDR_MENU1); CMenu* pPopup = menu.GetSubMenu(0); pPopuP->TrackPopupMenu(TPM_LEFTALIGN,point.x,point.y, this); CView::OnRButtonDown(nFlags,point); } 将鼠标点的客户去坐标转换为屏幕坐标 void CMenu View::onRButtonDown(UINT nFlags,CPoint point) { CMenu menu; menu.LoadMenu(IDR_MENU1); ClientToScreen(&point); CMenu* pPopup = menu.GetSubMenu(O); pPopup->TrackPopupMenu(TPM_LEFTALIGN,point.x,point.y, this); CView::OnRButtonDown(nFlags, point); } Step4:添加响应函数 利用ClassWizard添加。 void CMenu View::OnTest1(){ //TODO: Add your command handler code here MessageBox(\"View Test1\"); } void CMenuView::OnTest2(){ //TODO: Add your command handler code here MessageBox(\"View Test2\"); } 关于快捷菜单中的菜单项的命令响应的说明 对于快捷菜单,如果将其拥有者窗口设置为框架类窗口,则框架类窗口才能有机会获得对该快捷菜单中的菜单项的命令响应,否则，就只能有视类窗口作出响应。 动态菜单操作 添加菜单项目（AppendMenu) 添加顶层菜单: CMenu my_menu; my_menu.CreateMenu(); GetMenu()->AppendMenu(MF_POPUP, (UINT)my_menu.m_hMenu, \"my_menu\"); my_menu.Detach(); 添加顶层菜单下的菜单项: GetMenu()->GetSubMenu(0)->AppendMenu(MF_STRING, 777, \"Hello\"); 插入菜单项目（InsertMenu) 插入顶级菜单: CMenu my menu; my_menu.CreateMenu(); GetMenu()->InsertMenu(2, MF_BYPOSITION | MF_POPUP, (UINT)my_menu.m_hMenu,\"my_menu\"); my_menu.Detach(); 插入顶级菜单下的菜单项 GetMenu)->GetSubMenu(O)->InsertMenu (0, MF_STRINGI MF_BYPOSITION, 777,\"Hello\"); GetMenu()->GetSubMenu(O)->InsertMenu (ID_FILE_OPEN, MF_STRING, 777, \"Hello\"); 删除菜单项目（DeleteMenu) 删除顶级菜单: GetMenu(->DeleteMenu(1, MF_ BYPOSITION); 删除顶级菜单下的菜单项: GetMenu(->GetSubMenu(O)->DeleteMenu (o, MF BYPOSITION); GetMenu()->GetSubMenu(0)->DeleteMenu (D_FILE_NEW, MF BYCOMMAND);\\ 动态添加的菜单项的命令响应 遵循MFC的消息映射机制，需要手动添加三处代码来实现命令消息的响应。 可先利用ClassWizard对程序中某个已有的静态菜单项添加命令消息响应，然后参照ClassWizard在程序中为其添加的内容,来完成动态菜单添加命令响应。 工具栏编程 工具栏是把常用的菜单命令集合起来,以按钮的形式提供给用户使用,目的是方便用户的操作。 工具按钮的添加、删除都在资源编辑器窗口中的工具栏编辑窗口中完成。 添加按钮响应命令的方法与菜单相同。通常工具栏与其对应的菜单项ID相同，这样,在程序运行时。可以通过单击工具栏上的按钮来调用相应菜单项的命令。 创建工具栏——4个步骤 Step1:创建工具栏资源; Step2:构造CToolBar对象; Step3:调用Create或CreateEx函数创建Window工具栏(工具栏也是窗口) Step4:调用LoadToolBar函数加载工具栏资源。 状态栏编程 状态栏的提示行与指示器 状态栏分为两部分:提示行与指示器。 左边最长的部分为提示行，通常用于显示菜单项或工具按钮的提示信息。右边由若干窗格组成的部分为状态栏指示器,通常用来显示大小写键、数字锁定键等信息。 框架程序专门提供了一个indicators数组来管理提示行与指示器。如果要修改状态栏的外观,则只需在 indicators数组中添加或减少相应的字符串资源ID即可。 对话框 对话框是一个窗口,与对话框资源相关的类为CDialog,由CWnd类派生而来。 可以将对话框看成是一个大容器，在它上面能够放置各种标准和扩展控件，是用户与程序进行交互的重要手段。 在MFC中，所有的控件都是由CWnd派生而来,因此，控件实际上也是窗口。 对话框的种类 模式对话框: 当其显示时,程序会暂停执行，直到关闭这个对话框后,才能继续执行程序中其他任务。例如“文件/打开”对话框。 无模式对话框: 当其显示时，允许转而执行程序中其他任务，而不用关闭这个对话框。该类型对话框不会垄断用户的操作，用户仍可以与其他界面对象进行交互。例如“查找”对话框。 创建模式对话框 DoModal()函数 创建模式对话框需要调用CDialog类的成员函数:DoModal，该函数的功能就是创建并显示一个模式对话框。 void CMainFrame::OnTest(){ //TODO: Add your command handler code here CMyDialog dlg; dlg.DoModal(); } 创建无模式对话框 Create()函数 创建非模式对话框需要调用CDialog类的成员函数: BOOL Create(UINT nIDTemplate,CWnd*pParentWnd = NULL); void CMainFrame::OnTest(){ //TODO: Add your command handler code here CMyDialog dlg; dlg.Create(IDD_DIALOG1, this); } 注意:运行程序，对话框并未显示~! ShowWindow()函数 当利用Create函数创建非模式对话框时,还需要调用Show Window函数将这个对话框显示出来。 void CMainFrame::OnTest(){ CMyDialog dlg; dlg.Create(IDD_DIALOG1,this); dlg.ShowWindow(SW_SHOW); } 注意:运行程序，对话框仍未显示~! 对话框未显示之原因分析 这里创建的非模式对话框对象（dlg）是一个局部对象，当OnTest函数结束时，dlg这个对象的生命周期也就结束了，它会销毁与之相关联的对话框资源,因此对话框不会显示。 为什么模式对话框不会出现这样的问题? 在创建模式对话框时，当执行到DoModal函数显示这个对话框时，程序会暂停执行，直到关闭模式对话框之后，程序才继续执行。也就是说，当模态对话框显示时，dlg这个对象的生命周期并未结束。 结论:在创建非模式对话框时，不能把对话框对象定义为局部对象。 解决方法1———使用成员变量 把对话框对象定义为视类的成员变量。 注意:在销毁对话框之前，Create函数只能调用一次，否则会出错。 void CMainFrame::OnTest() { static BOOL bFlag = TRUE; if (TRUE == bFlag){ dlg.Create(IDD_DIALOG1, this); bFlag = FALSE; } dlg.ShowWindow(SW_SHOW); } 销毁无模式对话框 若要在程序中主动销毁无模式对话框（例如在没有“确定”和“取消”按钮的情况下销毁对话框),需调用函数DestroyWindow。 void CTestView::OnTest(){ static BOOL bFlag = FALSE; if (FALSE == bFlag){ dlg.Create(IDD_DIALOG1,this); dlg.ShowWindow(SW_SHOW); bFlag =TRUE; }else{ dlg.DestroyWindow(); bFlag = FALSE; } } 解决方法2——使用堆内存 把对话框对象定义为指针,在堆上分配内存。 void CMainFrame ::OnTest(){ CMyDialog* pDlg = new CMyDialog; pDlg->Create(IDD_DIALOG1, this); pDlg->ShowWindow(SW_SHOW); } 注意:该程序存在问题。由于没有办法释放这个指针变量所指向的那块内存，会出现内存泄漏~! 消除内存泄漏的办法:1.指针变量定义成全局变量;或者⒉重载对话框的PostNcDestroy函数，添加代码delete this. 利用GetDlgltem改变控件文本内容 void CMyDialog::OnNumber1() { CString str; GetDIgItem(IDC_NUMBER1)->GetWindowText(str); if (str ==\"Number1:\") GetDlgItem(IDC_NUMBER1)->SetWindowText(\"数值1:\"); else GetDlgItem(IDC_NUMBER1)->SetWindowText(\"Number1:\"); } 注意:静态文本框在默认状态下是不发送通告消息的。 改变这一默认状态,必须在属性窗口选中Notify这个选项。 访问控件的七种方法 1.MFC的DDX数据交换—控件和整型变量关联 最简单的访问控件的方式:通过类向导，在对话框函数 DoDataExchange内部实现对话框控件与对话框类的成员变量相关联。 重要函数:BOOL UpdateData(BOOL bSaveAndValidate= TRUE) void CMyDialog::OnButton1(){ UpdateData();//成员变量从对话框控件中获取数据 m_num3 = m_num1 + m_num2; UpdateData(FALSE); //以成员变量的值初始化对话框控件 } 2.MFC的DDX数据交换——控件和控件变量关联 重要函数: Get/SetWindowText void CMyDialog::OnButton2(){ int num1, num2, num3; char c1[10], c2[10],c3[10]; m_edit1.GetWindowText(c1, 10); m_edit2.GetWindowText(c2, 10); num1 = atoi(c1); num2 = atoi(c2); num3 = num1 + num2; itoa(num3,c3,10); m_edit3.SetWindowText(c3); } 3.GetDIgltem + Get/SetWindowText 重要函数:cWnd * GetDlgltem( int nID) const; 该函数返回一个指向由参数nID指定的控件对象的指针。 void CMyDialog::OnButton3() { int num1, num2, num3; char c1[10], c2[10], c3[10]; GetDlgltem(IDC EDIT1)->GetWindowText(c1, 10); GetDlgltem(IDC EDIT2)->GetWindowText(c2, 10); num1 = atoi(c1); num2 = atoi(c2); num3 = num1 + num2; itoa(num3,c3,10); GetDlgItem(IDC_EDIT3)->SetWindowText(c3); } 利用GetDlgltem改变控件文本内容 void CMyDialog::OnNumber1() { CString str; GetDlgltem(IDC_ NUMBER1)->GetWindowText(str); if (str--\"Number1:\") GetDlgItem(IDC NUMBER1)->SetWindowText(\"数值1:\"); else GetDlgItem(IDC_NUMBER1)->SetWindowText(\"Number1:\"); } 注意:静态文本框在默认状态下是不发送通告消息的。改变这一默认状态,必须在属性窗口选中Notify这个选项。 利用GetDlgltem在控件中绘图 void CMyDialog::OnNumber(){ CWnd* pWnd = GetDlgItem(IDC_NUMBER2); CRect rc; pWnd->GetClientRect(&rc); CBrush brush(RGB(255,0,0)); CDC* pDC- pWnd->GetDC(); pDC->FillRect(&rc,&brush); pDC->SetBkMode(TRANSPARENT); pDC->TextOut(13,5,\"刘晓翔\"); ReleaseDC(pDC); } 4.Get/SetDlgltemText 该函数返回对话框中指定nID的控件上的文本。也就是说:GetDlgItemText函数把方法③中介绍的GetDlgItem和GetWindowText这两个函数的功能组合起来了。 void CMyDialog::OnButton4(){ int num1, num2, num3; char c1[10], c2[10], c3[10]; GetDlgItemText(IDC_EDIT1, c1, 10); GetDlgItemText(IDC_EDIT2, c2,10); num1 = atoi(c1); num2 = atoi(c2); num3 = num1 + num2; itoa(num3,c3,10); SetDlgItemText(IDC_EDIT3, c3); } 5.Get/SetDlgltemlnt 该函数首先获得对话框中指定nID的控件上的文本，然后将其转换为一个整型数值返回 void CMyDialog::OnButton5(){ int num1, num2, num3; num1 = GetDlgItemInt(IDC_EDIT1); num2 = GetDlgltemInt(IDC_ EDIT2); num3 - num1 +num2; SetDlgItemInt(IDC_EDIT3, num3); } 6.发送消息——SendMessage Windows程序是基于消息的系统，因此,只要获取设置窗口文本的消息，就可以通过SendMessage来发送这条消息，从而获取/设置窗口的文本。 void CMyDialog::OnButton6(){ int num1, num2, num3; char c1[10], c2[10], c3[10]; ::SendMessage(GetDIgltem(IDC_EDIT1)->m_hWnd, WM_ GETTEXT,10, (LPARAM)c1); ::SendMessage(m_edit2.m_hWnd, WM_GETTEXT, 10, (LPARAMI)c2); num1 = atoi(c1); num2 = atoi(c2); num3 = num1 + num2; itoa(num3, c3, 10); m_edit3.SendMessage(WM_SETTEXT, 0, (LPARAM)c3); } 7.发送消息——SendDlgltemMessage 直接给对话框的子控件发送消息: LRESULT SendDIgItemMessage(int nID, UINT message,WPARA wParam -0, LPARAM lParam=0) 该函数功能相当于把上面GetDlgltem和SendMessage这两个函数的组合。 void CMyDialog:onButton7(){ int num1, num2, num3; char c1[10], c2[10], c3[10]; SendDIgltemMessage(IDC_EDIT1,WM_GETTEXT, 10, (LPARAMI)c1); SendDIgltemMessage(IDC_EDIT2, WM_GETTEXT, 10, (LPARAM)c2); num1 = atoi(c1); num2 = atoi(c2); num3 = num1 + num2; itoa(num3, c3, 10); sendDIgItemMessage(DC_EDIT3,WM_SETTEXT, 0, (LPARAMI)c3); } 改变对话框/窗口外观 设置窗口的位置与大小 BOOL SetWindowPos(const CWnd* pWndInsertAfter, int x, int y, int cx, int cy,UINT nFlags); pWndInsertAfter:在以Z次序排序的窗口中位于当前窗口前面的那个窗口对象，通常可忽略该参数,置为NULL。 x,y:窗口左上角的x和y坐标(相对于屏幕左上角的原点)。 cx, cy:窗口的宽度和高度。 nFlags:设定窗口位置与大小的相关参数。 设置窗口的形状 int SetWindowRgn(HRGN hRgn, BOOL bRedraw) hRgn: CRgn对象的资源句炳。 bRedraw:通常设为TRUE,表示设置窗口的形状后立即重绘窗口。 CRgn:与CFont、CPen、CBrush、CBitmap一样,属于Windows GDI对象,用来描述自定义形状的区域。 例如，将窗口形状设置为椭圆形的代码: CRect rc; GetClientRect(rc); CRgn rgn; rgn.CreateEllipticRgn(0, 0, rc.Width(),rc.Height()); SetWindowRgn((HRGN) rgn.m_hObject, TRUE); 窗口 在窗口创建之前更改 如果希望在应用程序窗口创建之前修改它的大小、标题和风格应该在CMainFrame类的PreCreateWindow成员函数进行。 该函数有个类型是CREATESTRUCT结构的参数，如果在修改了这个参数中的成员变量的值，那么这种改变会反映到MFC底层代码中，当MFC底层代码调用CreateWindowEx函数去创建窗口时，它就会使用改变后的参数值去创建这个窗口。 更改窗口大小 BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs){ if( !CFrameWnd::PreCreateWindow(cs) ) return FALSE; cs.cx = 300; cs.cy = 200; return TRUE; } 更改应用程序标题 BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs){ if( !CFrameWnd::PreCreateWindow(cs) ) return FALSE; cs.lpszName =\"暨南大学\"; return TRUE; } 注意:此时应用程序的标题并未改变，原因及解决方法见下页。 在MFC框架程序中更改标题栏文字应注意 框架的默认窗口样式是wS_OVERLAPPEDWINDOW和FWS_ADDTOTITLE样式的组合。其中FWS_ADDTOTITLE是MFC特定的一种样式,指示框架将文档标题添加到窗口标题上。因此,如果想让窗口显示自己的标题,只需将窗口的 FWS_ADDTOTITLE样式去掉即可。设置窗口标题的代码之前加上: cs.style = cs.style&~FWS_ADDTOTITLE; 或者: cs.style = WS_OVERLAPPEDWINDOW; 修改光标、图标、背景 之前对于窗口的大小、标题和风格是在创建窗口时设定的。而光标、图标和背景是在设计窗口类时指定的。 窗口类的设计与注册是由MFC底层代码自动完成的,我们不可能、也不应该去修改MFC底层代码。但是我们可以编写自己的窗口类注册,然后让随后的窗口按照我们编写的窗口类去创建。 BOOL CMaimExam::PreCeateWwimdow(CREATESTRUCT& cs) { WNDCLASS MvWnd; MyWnd.cbClsExtra=NULL; MyWnd.cbWndExtra=NULL; MyWnd.hbrBackground = (HBRUSH)GetStockObiect(BLACK_BRUSH); MyWnd.hCursor= LoadCursor(NULL, IDC_CROSS); MyWnd.hIcon = LoadIcon(NULL,IDI_WARNING); MyWnd.hInstance- AfxGetInstanceHandle(); MyWnd.lpfnwWndProc = ::DeindowProc; MyWnd.lpszClassName =\"Hello\"; Mywnd.lpszMenuName=NULL; MyWnd.style =CS_HREDRAW| CS_VREDRAW; RegisterClass(&MyWnd); cs.IpszClass=\"hello\"; return TRUE; } 以上代码存在的问题、原因及解决方法 上述代码的运行结果是:仅仅是程序的标题栏图标发生了改变，但窗口的背景和光标没有改变。 原因是:视类窗口覆盖在主窗口上面,我们看到的窗口实际上是视类窗口，而上述代码修改的是框架类窗口的背景和光标。应用程序的图标属于框架窗口,因此上述程序运行后,图标发生了改变。 结论:在MFC中，如果要修改应用程序窗口的图标,则应该框架类中进行，因为框架窗口才有标题栏;如果要修改程序窗口的背景和光标,则应该在视类中进行。 解决方法:在视类的PreCreateWindow函数中添加代码: cs.lpszClass = \"hello\"; 一个简单的修改函数 BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs){ if( !CErameWnd;:PreCreateWindow(cs)) return FALSE; cs.lpszClass= AfxRegisterndClass(CS_HREDRAW |CS_VREDRAW,0,0,LoadIcon(NULL, IDI_ WARNING)); return TRUE; } BOOL CUIView::PreCreateWindow(CREATESTRUCT& cs){ cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW CS_VREDRAW,LoadCursor(NULL,IDC_CROSS),(HBRUSH)GetStockObject(BLACK_BRUSH),0); return CView::PreCreateWindow(cs); } 在窗口创建之后更改 更改风格 在应用程序窗口创建之后修改它的风格属性,可在 CMainFrame类的OnCreate函数中调用SetWindowLong函数实现。 SetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong) 该函数的作用是改变制定窗口的属性（包括设置新的窗口风格设置新的窗口过程、设置新的应用程序实例局柄等）。要改变窗口的风格，则将该函数的第二个参数指定为GWL_STYLE，然后由第三个参数指定新的窗口风格。 int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) { if (CFrameWnd::OnCreate(lpCreateStruct)==-1) return -1; SetWindowLong(m_hWnd, GWL_STYLE, WS_OVERLAPPEDWINDOW); return 0; } 更改标题与大小 在应用程序窗口创建之后修改标题,可在CMainFrame类的OnCreate函数中调用SetWindowText函数实现。 在应用程序窗口创建之后修改大小,可在CMainFrame类的OnCreate函数中调用SetWindowPos函数实现。 如果是在已有类型的基础上进行修改的话，那么可以利用GetWindowLong这个函数获得这个窗口的现有类型，然后修改。 例如: SetWindowLong(m hWnd, GWL STYLE, GetWindowLong(m_hWnd,GWL_STYLE) &~WS_MAXIMIIZEBOX); 更改光标、标题栏图标、窗口背景 要在应用程序窗口创建之后修改它的光标、图标和背景，可在OnCreate函数中调用SetClassLong函数实现。 SetClassLong(HWND hWnd, int nIndex, LONG dwNewLong) 该函数的作用是:重新设置指定窗口所属窗口类的 WNDCLASS结构体中指定数据成员的属性（包括设置新的窗口背景画刷、光标、图标和窗口类样式）。 注意:在MFC中，如果要修改应用程序窗口的图标，则应该框架类中进行因为框架窗口才有标题栏;如果要修改程序窗口的背景和光标，则应该在视类中进行。 int CMainErame::OnCreate(LPCREATESTRUCT IDCreateStruct){ SetClassIong(m_hWnd,GCL_HICON,(LONG)LoadIcon(NULL,IDI_WARNING)); return 0; } int CUIView::OnCreate(LPCREATESTRUCT lpCreateStruct){ SetClassLong(m_hWnd,GCL_HBRBACKGROUND,(LONG)GetStockObject(BLACK BRUSH)); SetClassLong(m_hWnd,GCL_HCURSOR,(LONG)LoadCursor(NULL,IDC_CROSs)); return 0; } 动画图标 加载图标资源、设置定时器、添加定时器消息响应函数 HICoN m hlcon[41; //MainErm.h文件 int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct){ m_hIcon[0]=::LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI ICON1)); m_hIcon[1]=::LoadIcon(theApp.m_hInstance,MAKEINTRESOURCE(IDI_ ICON2)); m_hIcon[2]=::LoadIcon(AfxGetAppO->m_hInstance,MAKEINTRESOURCE(IDI ICON3)); m_hIcon[3]=AfxGetApp()->LoadIcon(IDI_ICON4); SetClassLong(m_hWnd, GCL_HICON,(LONG)m_hlcon[0]); SetTimer(1,1000, NULL); return 0; } void CMainFrame::OnTimer(UINT nIDEvent){ static int index=1; SetClassLong(m_hWnd, GCL_HICON,(LONG)m_hIcon[index]); index = ++index % 4; CFrameWnd:: OnTimer(nIDEvent); } 进程与线程 内核对象 Windows操作系统和应用程序使用内核对象来管理各种各样的重要资源。比如进程、线程和文件。 内核对象是Windows内核分配的一个内存块,该内存块是一种数据结构,它的成员负责维护该对象的各种信息。 内核对象的数据结构只能被内核访问,因此应用程序无法在内存中找到这些数据结构并直接改变它们的内容。Windows提供了一组函数来对内核对象进行操作和访问。 内核对象的创建函数都有一个设定安全属性的参数,这一点可与Windows中的用户对象或GDI对象(窗口、菜单、光标、字体、画刷等)区分开。 程序与进程 程序:计算机指令的集合，它以文件的形式存储在磁盘上。 进程:通常被定义为一个正在运行的程序的实例，是一个程序在其自身的地址空间中的一次执行活动。 进程是活的，是资源申请、调度和独立运行的单位，因此，它使用系统中的运行资源;而程序是死的,它不占用系统的运行资源。 进程由两个部分组成: 1、操作系统用来管理进程的内核对象。内核对象也是系统用来存放关于进程的统计信息的地方。(注意:内核对象不是进程本身) 2、地址空间。它包含所有可执行模块或DLL模块的代码和数据。它还包含动态内存分配的空间。如线程堆栈和堆分配空间。 进程与线程 进程是不活泼的。进程从来不执行任何东西,它只是线程的容器。若要使进程完成某项操作，它必须拥有一个在它的环境中运行的线程,此线程负责执行包含在进程的地址空间中的代码。 单个进程可能包含若干个线程，这些线程都“同时”执行进程地址空间中的代码。 每个进程至少拥有一个线程，来执行进程的地址空间中的代码。当创建一个进程时，操作系统会自动创建这个进程的第一个线程,称为主线程。此后，该线程可以创建其他的线程。 线程 线程由两个部分组成: 1、线程的内核对象,操作系统用它来对线程实施管理。内核对象也是系统用来存放线程统计信息的地方。 2、线程堆栈,它用于维护线程在执行代码时需要的所有参数和局部变量。 当创建线程时，系统创建一个线程内核对象。该线程内核对象不是线程本身，而是操作系统用来管理线程的较小的数据结构。可以将线程内核对象视为由关于线程的统计信息组成的一个小型数据结构。 线程总是在某个进程环境中创建。系统从进程的地址空间中分配内存,供线程的堆栈使用。新线程运行的进程环境与创建线程的环境相同。因此,新线程可以访问进程的内核对象的所有句柄、进程中的所有内存和在这个相同的进程中的所有其他线程的堆栈。这使得单个进程中的多个线程确实能够非常容易地互相通信。 线程只有一个内核对象和一个堆栈，保留的记录很少，因此所需要的内存也很少。 因为线程需要的开销比进程少,因此在编程中经常采用多线程来解决编程问题,而尽量避免创建新的进程。 线程的运行 对于多线程程序，操作系统会为每一个运行线程安排一定的CPU时间——时间片。系统通过一种循环的方式为线程提供时间片,线程在自己的时间内运行,因时间片相当短，因此,给用户的感觉,就好像线程是同时运行的一样。 如果计算机拥有多个CPU,线程就能真正意义上同时运行了。 简单多线程实例 注意1: Main函数中调用CloseHandle语句没有终止新创建的线程，只是表示在主线程中对新创建的线程的引用不感兴趣，因此将其句柄关闭。 另一方面,当关闭该句柄时，系统会递减该线程内核对象的使用计数。当实用计数为0时,系统就会释放该线程内核对象。如果没有关闭线程句柄，系统就会一直保持着对线程内核对象的引用,这样，即使该线程执行完毕,它的引用计数仍不会为0。这样该线程内核对象也就不会被释放,只有等到进程终止时,系统才会清理这些残留的对象。 因此,在程序中,当不再需要线程句柄时，应将其关闭，让这个线程内核对象的引用计数减1。 注意2: 上述程序只运行了主线程,新建的线程并没有运行。为什么会出现这样的结果?线程创建失败了吗? 实际情况并非如此,对于主线程来说，操作系统为它分配了时间片,因此它能够运行。当主线程创建新的线程后，会接着执行下一行代码，然后该线程结束，也就是说主线程执行完成了。此时,进程也就退出了，进呈中的所有资源,包括还没有执行的线程都要退出。所以,不是新的线程创建失败，而是没有机会执行，进程就退出了。 Sleep函数 通过调用API函数 Sleep,线程可以让自己睡眠指定的一段时间。正在睡眠的线程将暂停自己的运行，放弃执行的权利,而且睡眠的时候不占用处理器时间。一旦放弃了执行权力,操作系统就会从等待运行的其他线程队列中选择一个线程来执行。 因此,可以在上述程序的main函数最后添加:Sleep(10); 让主线程睡眠10ms,使其放弃执行的权利,操作系统就会选择新创建的线程让其运行。当10ms时间一过,主线程睡醒恢复运行，main函数退出，进程结束。 利用互斥对象实现线程同步 互斥对象 获得互斥对象的所有权 线程必须主动请求共享对象的使用权才能获得该所有权，这可以通过调用WaitForSingleObject函数实现。 DWORD WatiForSingleObject(HANDLE hHandle, DWORD dwMillisecond; HANDLE hHandle 所请求对象的句柄。本例为互斥对象句柄:hMutex。一旦互斥对象处于有信号状态,则该函数返回，接着，操作系统会将这个互斥对象设为未通知状态。如果该互斥对象处于无信号状态，则该函数会一直等待，这样会暂停线程的执行。 DWORD dwMillisecond 指定等待的时间，如果指定的时间间隔已过，即使所请求的对象处于无信号状态，该函数也返回。如果该参数为0，该函数立即返回。如果该参数为INFINTE,则该函数永远等待，直到互斥对象处于由信号状态才返回。 释放互斥对象的所有权 当线程对共享资源访问结束后,应释放互斥对象的所有权，让该对象处于有信号状态。这时需要调用函数:ReleaseMutex BOOL ReleaseMutex(HANDLE hMutex); 火车站售票系统模拟程序 #include #include DwORD WINAPI ThreadProc1( LPVOID lpParameter); DWORD WINAPI ThreadProc2( LPVOID IpParameter); int tickets = 1; HANDLE hMutex; void main(){ HANDLE hThread1; HANDLE hThread2; hThread1 = CreateThread(NULL,0,ThreadProc1,NULL,0,NULL); hThread2 = CreateThread(NULL,0,ThreadProc2,NULL,0,NULL); CloseHandle(hThread1); CloseHandle(hThread2); //创建互斥对象 hMutex = CreateMutex(NULL, FALSE, NULL); Sleep(5000); } //线程1的入口函数（售票窗口1) DWORD WINAPI ThreadProc1(LPVOID IpParameter){ while (TRUE){ //等待互斥对象的所有权 WaitForSingleObject(hMutex,INFINITE); if (tickets （没用互斥对象前）上述程序的隐患 事实上,上述程序存在隐患,比如以下情况: 当tickets为100时，线程1函数进入if语句块后,正好该线程的时间片到了，操作系统就会选择线程2让其进行,而这时变量tickets的值还没有加1,因此这时变量tickets的值仍是100，线程2进入它的if语句块中，于是线程2执行卖票操作,打印票号100,然后tickets变量加1，其值变为101。如果当线程2执行完成上述操作之后,正好又轮到线程1开始运行了。而这时线程1将从原先的if语句块开始执行,于是它输出当前的票号,而此时tickets变量的值已经是101了，也就是说,我们会看到线程1卖了号码为101的票。显然这种情况时不允许的。 上述情况再现:在两个if语句内的第一行加入Sleep(1);再看运行结果 利用临界区实现线程同步 临界区对象 临界区,也称关键代码段,它是指一个小代码段,在代码能够执行前，它必须独占对某些资源的访问权。 通常把多线程中访问统一资源的那部分代码当作临界区，从而达到线程同步的目的。 相关API函数 初始化临界区对象: void InitializeCriticalSection(LPCRITICAL_SECTIONlpCriticalSetion); 获得临界区对象所有权: void EnterCriticalSection(LPCRITICAL_SECTIONlpCriticalSetion); 释放临界区对象所有权: void LeaveCriticalSection(LPCRITICALSECTIONlpCriticalSetion); 释放临界区对象: void DeleteCriticalSection(LPCRITICAL_SECTIONlpCriticalSetion); 实例 互斥对象与临界区的比较 互斥对象属于内核对象，利用内核对象进行线程同步，速度较慢，但利用互斥对象这样的内核对象,可以在多个进程中的各个线程间进行同步。 临界区只能在同一进程内的线程间进行同步，但使用最简单，同步速度较快，因此是实现同步化的首选方法。在使用临界区时，由于在等待进入关键代码段时无法设定超时值,容易进入死锁状态。 动态链接库DLL DDL概述 微软任何一个版本的Windows操作系统，动态链接库（DLL)都是其核心和基础。 动态链接库不能直接运行。它们是一些独立的文件，其中包含能被可执行程序或其它DLL调用来完成某项工作的函数。只有在其它模块调用动态链接库中的函数时，它才发挥作用。 Windows API中的所有函数都包含在DLL中。其中有3个最重要的DLL， Kernel32.dll，它包含用于管理内存、进程和线程的各个函数;User32.dll，它包含用于执行用户界面任务（如窗口的创建和消息的传送)的各个函数; GDI32.dll，它包含用于画图和显示文本的各个函数。 静态库（LIB）和动态库（DLL） 静态库: 函数和数据被编译进一个二进制文件(通常扩展名为.LIB)。在使用静态库的情况下，在编译链接可执行文件时,链接器从库中复制这些函数和数据，并把它们和应用程序的其它模块组合起来创建最终的可执行文件(.EXE文件)。 动态库： 在使用动态库的时候,往往提供两个文件:一个引入库和一个DLL。引入库包含被DLL导出的函数和变量的符号名,DLL包含实际的函数和数据。在编译链接可执行文件时，只需要链接引入库,DLL中的函数代码和数据并不复制到可执行文件中,在运行的时候,再去加载DLL，访问DLL中导出的函数。 使用动态链接库的好处(简答) 增强程序的扩展性 可以采用多种编程语言来写 提供二次开发的平台 简化项目管理 节省磁盘空间和内存 有助于资源共享 创建DLL文件 导出DLL中的函数 注意:应用程序如果想要访问DLL中的函数,那么该函数必须是已经被导出的函数。 为了让DLL导出函数，需要在每一个将要被导出的函数前添加标识符:_declspec (dllexport)。 _declspec (dllexport) int add(int a, int b){ return a + b; } _declspec (dllexport) int subtract(int a, int b){ return a - b; } Build后，在Debug目录下会产生一个动态库DII1.dIl文件和一个引入库文件DIl1.lib。 导出DLL中的类 在动态链接库中，除了函数能被导出，C++类同样也能够被导出。 为了让DLL导出类,在DLL中定义类时，需要在class关键字和类名之间加入标识符:_declspec (dllexport)。 另外，在实现动态链接库时,可以不导出整个类,而只导出该类中的某些成员函数。具体做法是将标识符添加到成员函数前。 注意:在访问导出类的函数时,仍受限于函数自身的访问权限。也就是说，如果该类的某个函数访问权限不是Pubilc，那么外部程序仍无法访问这个函数。 使用引入库文件 以上程序能够成功通过编译，但在程序链接时会产生三个错误，因为此时链接器不知道这两个函数是在哪个地方实现的。 为了解决这个问题，就需要利用动态链接库的引入库文件。引入库文件并没有包含实际的代码，它是用来为链接程序提供必要的信息，以便在可执行文件中建立动态链接时需要用到的重定位表。 加载引入库文件的两种方法（加载之前先把dll1.lib复制到dlltest工程目录中) : 选择“project\\Settings”命令，选择link选项卡，在“Object/librarymodules”选项编辑框中输入:dll1.lib 通过“add files to project..”直接将dll1.lib加入到工程中。 隐式链接方式加载DLL 显式加载方式加载DLL 实例 名字改编问题 如果希望动态链接库在编译时，导出函数的名称不要发生改变，在定义导出函数时，需要加上限定符:extern“C\" extern \"C\"_declspec (dllexport) int add(int a, int b){ return a + b; } extern \"C\"_declspec (dllexport) int subtract(int a, int b){ return a - b; } extern \"C”可以解决C++对C语言之间的函数名改编问题，但这种方法有一个缺陷，就是不能用于导出一个类的成员函数，只能用于导出全局函数这种情况。 DlIMain函数介绍 一个Win32程序，对可执行模块来说，其入口函数是WinMain;而对DLL来说，其入口函数是DIlMain，该函数是可选的。也就是说，在编写DLL程序时，可以提供也可以不提供DIIMain函数。 注意:如果提供了DIIMain函数，那么在此函数中不要进行太复杂的调用。因为在加载该动态链接库时，user32.dll或GDI32.dll等一些Windows核心DLL还没有加载，这时会导致程序终止。 MFC AppWizard(dll) VC++集成开发工具提供了一个向导: MFC App Wizard(dl),它可以帮助我们创建一个支持MFC类库的DLL。 编写支持MFC的DLL与前面编写Win32 DLL的方法是类似的，只是前者对MFC提供了很好的支持。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:13 "},"08_Others/正则表达式.html":{"url":"08_Others/正则表达式.html","title":"正则表达式","keywords":"","body":"【特殊字符】 .（点）：匹配除换行符 \\n 之外的任何单个字符。 *：匹配前一个元素零次或多次。 +：匹配前一个元素一次或多次。 ?：匹配前一个元素零次或一次。 |（竖线）：用于表示或操作，匹配多个模式中的一个。 []（方括号）：用于定义字符集，匹配其中任何一个字符。 （反向方括号）：用于定义反向字符集，匹配除括号内定义的字符之外的任何字符。 ()（小括号）：用于分组模式，可以用来应用量词、进行捕获和构建子表达式。(P|p)ython可以匹配'Python'或者'python' {}（大括号）：用于指定前一个元素重复的次数，例如 {3} 匹配前一个元素恰好 3 次。 \\（反斜杠）：用于转义下一个字符，以匹配特殊字符本身。 ^：在字符集中使用时，表示匹配字符串的开头。在字符集外使用时，表示非。 $：表示匹配字符串的结尾。 \\s：匹配空白字符，包括空格、制表符、换行符等。 \\d：匹配数字字符，等同于 [0-9]。 \\w：匹配单词字符，包括字母、数字和下划线，等同于 [a-zA-Z0-9_]。 \\b：匹配单词边界，用于确保匹配的是整个单词。 \\W：与 \\w 相反，匹配非单词字符。 \\D：与 \\d 相反，匹配非数字字符。 \\S：与 \\s 相反，匹配非空白字符。 【量词】 *：零次或多次 +：一次或多次 ?：零次或一次 {n}：精确重复n次 {n,m}：重复n~m次 【反向引用】 （反向方括号）：用于定义反向字符集，匹配除括号内定义的字符之外的任何字符。例如，正则表达式\"0-9\"匹配非数字字符。 【特殊字符转义】 如果要匹配正则表达式中的特殊字符本身，需要使用反斜杠\\来转义它们。 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:14 "},"08_Others/远程连接主机方案.html":{"url":"08_Others/远程连接主机方案.html","title":"远程连接主机方案","keywords":"","body":"1.内网局域网（同一网关下） XRDP（图形界面） XRDP是一个开源的远程桌面协议，使得用户可以从Windows、Linux或者macOS设备上远程访问和控制Linux桌面。 缺点：很慢，不清楚原因 Step1 Ubuntu主机安装xrdp服务 sudo apt-get intall xrdp Step2 Windows系统运行mstsc Win+R打开运行窗口输入mstsc，输入Ubuntu主机的局域网ip和账号密码即可连接 速度优化方式 如下，虽然优化了还是很卡 Step1 调整XRDP Buffer配置 # 用文本编辑器打开配置 gedit /etc/xrdp/xrdp.ini # 编辑注释起来的两行 tcp_send_buffer_bytes=4294304 tcp_recv_buffer_bytes=6291456 Step2 调整系统网络内存配置 # 用文本编辑器打开配置 gedit /etc/systcl.conf # 最后加上两行 net.core.rmem_max = 12582912 net.core.wmem_max = 8388608 # 保存修改后时系统配置生效 sudo sysctl -p Step3 重新xrdp服务生效 sudo systemctl restart xrdp SSH（命令行） Ubuntu 电脑安装ssh服务 # 更新源 sudo apt-get update # 安装ssh服务端 sudo apt-get install openssh-service # 启动ssh服务 sudo service ssh start VNC（图形界面） 缺点：安全性差 2.内网非局域网 3.公网 No Copyright all right reserved，powered by Gitbookmodified time: 2025-02-08 05:03:14 "}}